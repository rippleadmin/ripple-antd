(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[5],{

/***/ "./node_modules/@antv/data-set/build/data-set.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/data-set/build/data-set.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/_@antv_hierarchy@0.6.2@@antv/hierarchy/build/hierarchy.js\":\n/*!********************************************************************************!*\\\n  !*** ./node_modules/_@antv_hierarchy@0.6.2@@antv/hierarchy/build/hierarchy.js ***!\n  \\********************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assign = __webpack_require__(7);\n\nmodule.exports = {\n  assign: assign\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar hierarchy = __webpack_require__(3);\n\nvar Layout = /*#__PURE__*/function () {\n  function Layout(root, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var me = this;\n    me.options = options;\n    me.rootNode = hierarchy(root, options);\n  }\n\n  var _proto = Layout.prototype;\n\n  _proto.execute = function execute() {\n    throw new Error('please override this method');\n  };\n\n  return Layout;\n}();\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar separateTree = __webpack_require__(4);\n\nvar VALID_DIRECTIONS = ['LR', // left to right\n'RL', // right to left\n'TB', // top to bottom\n'BT', // bottom to top\n'H', // horizontal\n'V' // vertical\n];\nvar HORIZONTAL_DIRECTIONS = ['LR', 'RL', 'H'];\n\nvar isHorizontal = function isHorizontal(direction) {\n  return HORIZONTAL_DIRECTIONS.indexOf(direction) > -1;\n};\n\nvar DEFAULT_DIRECTION = VALID_DIRECTIONS[0];\n\nmodule.exports = function (root, options, layoutAlgrithm) {\n  var direction = options.direction || DEFAULT_DIRECTION;\n  options.isHorizontal = isHorizontal(direction);\n\n  if (direction && VALID_DIRECTIONS.indexOf(direction) === -1) {\n    throw new TypeError(\"Invalid direction: \" + direction);\n  }\n\n  if (direction === VALID_DIRECTIONS[0]) {\n    // LR\n    layoutAlgrithm(root, options);\n  } else if (direction === VALID_DIRECTIONS[1]) {\n    // RL\n    layoutAlgrithm(root, options);\n    root.right2left();\n  } else if (direction === VALID_DIRECTIONS[2]) {\n    // TB\n    layoutAlgrithm(root, options);\n  } else if (direction === VALID_DIRECTIONS[3]) {\n    // BT\n    layoutAlgrithm(root, options);\n    root.bottom2top();\n  } else if (direction === VALID_DIRECTIONS[4] || direction === VALID_DIRECTIONS[5]) {\n    // H or V\n    // separate into left and right trees\n    var _separateTree = separateTree(root, options),\n        left = _separateTree.left,\n        right = _separateTree.right; // do layout for left and right trees\n\n\n    layoutAlgrithm(left, options);\n    layoutAlgrithm(right, options);\n    options.isHorizontal ? left.right2left() : left.bottom2top(); // combine left and right trees\n\n    right.translate(left.x - right.x, left.y - right.y); // translate root\n\n    root.x = left.x;\n    root.y = right.y;\n    var bb = root.getBoundingBox();\n\n    if (options.isHorizontal) {\n      if (bb.top < 0) {\n        root.translate(0, -bb.top);\n      }\n    } else {\n      if (bb.left < 0) {\n        root.translate(-bb.left, 0);\n      }\n    }\n  } // fixed root position, default value is true\n\n\n  var fixedRoot = options.fixedRoot;\n  if (fixedRoot === undefined) fixedRoot = true;\n\n  if (fixedRoot) {\n    root.translate(-(root.x + root.width / 2 + root.hgap), -(root.y + root.height / 2 + root.vgap));\n  }\n\n  return root;\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* eslint-disable no-cond-assign */\nvar util = __webpack_require__(0);\n\nvar PEM = 18;\nvar DEFAULT_HEIGHT = PEM * 2;\nvar DEFAULT_GAP = PEM;\nvar DEFAULT_OPTIONS = {\n  getId: function getId(d) {\n    return d.id || d.name;\n  },\n  getHGap: function getHGap(d) {\n    return d.hgap || DEFAULT_GAP;\n  },\n  getVGap: function getVGap(d) {\n    return d.vgap || DEFAULT_GAP;\n  },\n  getChildren: function getChildren(d) {\n    return d.children;\n  },\n  getHeight: function getHeight(d) {\n    return d.height || DEFAULT_HEIGHT;\n  },\n  getWidth: function getWidth(d) {\n    var name = d.name || ' ';\n    return d.width || name.split('').length * PEM; // FIXME DO NOT get width like this\n  }\n};\n\nfunction Node(data, options) {\n  var me = this;\n  me.vgap = me.hgap = 0;\n  if (data instanceof Node) return data;\n  me.data = data;\n  /*\n   * Gaps: filling space between nodes\n   * (x, y) ----------------------\n   * |            vgap            |\n   * |    --------------------    h\n   * | h |                    |   e\n   * | g |                    |   i\n   * | a |                    |   g\n   * | p |                    |   h\n   * |   ---------------------    t\n   * |                            |\n   *  -----------width------------\n   */\n\n  var hgap = options.getHGap(data);\n  var vgap = options.getVGap(data);\n  me.width = options.getWidth(data);\n  me.height = options.getHeight(data);\n  me.id = options.getId(data);\n  me.x = me.y = 0;\n  me.depth = 0;\n\n  if (!me.children) {\n    me.children = [];\n  }\n\n  me.addGap(hgap, vgap);\n  return me;\n}\n\nutil.assign(Node.prototype, {\n  isRoot: function isRoot() {\n    return this.depth === 0;\n  },\n  isLeaf: function isLeaf() {\n    return this.children.length === 0;\n  },\n  addGap: function addGap(hgap, vgap) {\n    var me = this;\n    me.hgap += hgap;\n    me.vgap += vgap;\n    me.width += 2 * hgap;\n    me.height += 2 * vgap;\n  },\n  eachNode: function eachNode(callback) {\n    // Depth First traverse\n    var me = this;\n    var nodes = [me];\n    var current;\n\n    while (current = nodes.pop()) {\n      callback(current);\n      nodes = nodes.concat(current.children);\n    }\n  },\n  DFTraverse: function DFTraverse(callback) {\n    // Depth First traverse\n    this.eachNode(callback);\n  },\n  BFTraverse: function BFTraverse(callback) {\n    // Breadth First traverse\n    var me = this;\n    var nodes = [me];\n    var current;\n\n    while (current = nodes.shift()) {\n      callback(current);\n      nodes = nodes.concat(current.children);\n    }\n  },\n  getBoundingBox: function getBoundingBox() {\n    // BBox for just one tree node\n    var bb = {\n      left: Number.MAX_VALUE,\n      top: Number.MAX_VALUE,\n      width: 0,\n      height: 0\n    };\n    this.eachNode(function (node) {\n      bb.left = Math.min(bb.left, node.x);\n      bb.top = Math.min(bb.top, node.y);\n      bb.width = Math.max(bb.width, node.x + node.width);\n      bb.height = Math.max(bb.height, node.y + node.height);\n    });\n    return bb;\n  },\n  // translate\n  translate: function translate(tx, ty) {\n    if (tx === void 0) {\n      tx = 0;\n    }\n\n    if (ty === void 0) {\n      ty = 0;\n    }\n\n    this.eachNode(function (node) {\n      node.x += tx;\n      node.y += ty;\n    });\n  },\n  right2left: function right2left() {\n    var me = this;\n    var bb = me.getBoundingBox();\n    me.eachNode(function (node) {\n      node.x = node.x - (node.x - bb.left) * 2 - node.width; // node.x = - node.x;\n    });\n    me.translate(bb.width, 0);\n  },\n  bottom2top: function bottom2top() {\n    var me = this;\n    var bb = me.getBoundingBox();\n    me.eachNode(function (node) {\n      node.y = node.y - (node.y - bb.top) * 2 - node.height; // node.y = - node.y;\n    });\n    me.translate(0, bb.height);\n  }\n});\n\nfunction hierarchy(data, options, isolated) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  var root = new Node(data, options);\n  var nodes = [root];\n  var node;\n\n  if (!isolated && !data.collapsed) {\n    while (node = nodes.pop()) {\n      if (!node.data.collapsed) {\n        var children = options.getChildren(node.data);\n        var length = children ? children.length : 0;\n        node.children = new Array(length);\n\n        if (children && length) {\n          for (var i = 0; i < length; i++) {\n            var child = new Node(children[i], options);\n            node.children[i] = child;\n            nodes.push(child);\n            child.parent = node;\n            child.depth = node.depth + 1;\n          }\n        }\n      }\n    }\n  }\n\n  return root;\n}\n\nmodule.exports = hierarchy;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar hierarchy = __webpack_require__(3);\n\nmodule.exports = function (root, options) {\n  // separate into left and right trees\n  var left = hierarchy(root.data, options, true); // root only\n\n  var right = hierarchy(root.data, options, true); // root only\n  // automatically\n\n  var treeSize = root.children.length;\n  var rightTreeSize = Math.round(treeSize / 2); // separate left and right tree by meta data\n\n  var getSide = options.getSide || function (child, index) {\n    if (index < rightTreeSize) {\n      return 'right';\n    }\n\n    return 'left';\n  };\n\n  for (var i = 0; i < treeSize; i++) {\n    var child = root.children[i];\n    var side = getSide(child, i);\n\n    if (side === 'right') {\n      right.children.push(child);\n    } else {\n      left.children.push(child);\n    }\n  }\n\n  left.eachNode(function (node) {\n    if (!node.isRoot()) {\n      node.side = 'left';\n    }\n  });\n  right.eachNode(function (node) {\n    if (!node.isRoot()) {\n      node.side = 'right';\n    }\n  });\n  return {\n    left: left,\n    right: right\n  };\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar hierarchy = {\n  compactBox: __webpack_require__(6),\n  dendrogram: __webpack_require__(9),\n  indented: __webpack_require__(11),\n  mindmap: __webpack_require__(13)\n};\nmodule.exports = hierarchy;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar TreeLayout = __webpack_require__(1);\n\nvar nonLayeredTidyTree = __webpack_require__(8);\n\nvar doTreeLayout = __webpack_require__(2);\n\nvar util = __webpack_require__(0);\n\nvar CompactBoxTreeLayout = /*#__PURE__*/function (_TreeLayout) {\n  _inheritsLoose(CompactBoxTreeLayout, _TreeLayout);\n\n  function CompactBoxTreeLayout() {\n    return _TreeLayout.apply(this, arguments) || this;\n  }\n\n  var _proto = CompactBoxTreeLayout.prototype;\n\n  _proto.execute = function execute() {\n    var me = this;\n    return doTreeLayout(me.rootNode, me.options, nonLayeredTidyTree);\n  };\n\n  return CompactBoxTreeLayout;\n}(TreeLayout);\n\nvar DEFAULT_OPTIONS = {};\n\nfunction compactBoxLayout(root, options) {\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  return new CompactBoxTreeLayout(root, options).execute();\n}\n\nmodule.exports = compactBoxLayout;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nfunction _mix(dist, obj) {\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {\n      dist[key] = obj[key];\n    }\n  }\n}\n\nvar mix = function mix(dist, src1, src2, src3) {\n  if (src1) _mix(dist, src1);\n  if (src2) _mix(dist, src2);\n  if (src3) _mix(dist, src3);\n  return dist;\n};\n\nmodule.exports = mix;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n// wrap tree node\nfunction WrappedTree(w, h, y, c) {\n  if (c === void 0) {\n    c = [];\n  }\n\n  var me = this; // size\n\n  me.w = w || 0;\n  me.h = h || 0; // position\n\n  me.y = y || 0;\n  me.x = 0; // children\n\n  me.c = c || [];\n  me.cs = c.length; // modified\n\n  me.prelim = 0;\n  me.mod = 0;\n  me.shift = 0;\n  me.change = 0; // left/right tree\n\n  me.tl = null;\n  me.tr = null; // extreme left/right tree\n\n  me.el = null;\n  me.er = null; // modified left/right tree\n\n  me.msel = 0;\n  me.mser = 0;\n}\n\nWrappedTree.fromNode = function (root, isHorizontal) {\n  if (!root) return null;\n  var children = [];\n  root.children.forEach(function (child) {\n    children.push(WrappedTree.fromNode(child, isHorizontal));\n  });\n  if (isHorizontal) return new WrappedTree(root.height, root.width, root.x, children);\n  return new WrappedTree(root.width, root.height, root.y, children);\n}; // node utils\n\n\nfunction moveRight(node, move, isHorizontal) {\n  if (isHorizontal) {\n    node.y += move;\n  } else {\n    node.x += move;\n  }\n\n  node.children.forEach(function (child) {\n    moveRight(child, move, isHorizontal);\n  });\n}\n\nfunction getMin(node, isHorizontal) {\n  var res = isHorizontal ? node.y : node.x;\n  node.children.forEach(function (child) {\n    res = Math.min(getMin(child, isHorizontal), res);\n  });\n  return res;\n}\n\nfunction normalize(node, isHorizontal) {\n  var min = getMin(node, isHorizontal);\n  moveRight(node, -min, isHorizontal);\n}\n\nfunction convertBack(converted\n/* WrappedTree */\n, root\n/* TreeNode */\n, isHorizontal) {\n  if (isHorizontal) {\n    root.y = converted.x;\n  } else {\n    root.x = converted.x;\n  }\n\n  converted.c.forEach(function (child, i) {\n    convertBack(child, root.children[i], isHorizontal);\n  });\n}\n\nfunction layer(node, isHorizontal, d) {\n  if (d === void 0) {\n    d = 0;\n  }\n\n  if (isHorizontal) {\n    node.x = d;\n    d += node.width;\n  } else {\n    node.y = d;\n    d += node.height;\n  }\n\n  node.children.forEach(function (child) {\n    layer(child, isHorizontal, d);\n  });\n}\n\nmodule.exports = function (root, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var isHorizontal = options.isHorizontal;\n\n  function firstWalk(t) {\n    if (t.cs === 0) {\n      setExtremes(t);\n      return;\n    }\n\n    firstWalk(t.c[0]);\n    var ih = updateIYL(bottom(t.c[0].el), 0, null);\n\n    for (var i = 1; i < t.cs; ++i) {\n      firstWalk(t.c[i]);\n      var min = bottom(t.c[i].er);\n      separate(t, i, ih);\n      ih = updateIYL(min, i, ih);\n    }\n\n    positionRoot(t);\n    setExtremes(t);\n  }\n\n  function setExtremes(t) {\n    if (t.cs === 0) {\n      t.el = t;\n      t.er = t;\n      t.msel = t.mser = 0;\n    } else {\n      t.el = t.c[0].el;\n      t.msel = t.c[0].msel;\n      t.er = t.c[t.cs - 1].er;\n      t.mser = t.c[t.cs - 1].mser;\n    }\n  }\n\n  function separate(t, i, ih) {\n    var sr = t.c[i - 1];\n    var mssr = sr.mod;\n    var cl = t.c[i];\n    var mscl = cl.mod;\n\n    while (sr !== null && cl !== null) {\n      if (bottom(sr) > ih.low) ih = ih.nxt;\n      var dist = mssr + sr.prelim + sr.w - (mscl + cl.prelim);\n\n      if (dist > 0) {\n        mscl += dist;\n        moveSubtree(t, i, ih.index, dist);\n      }\n\n      var sy = bottom(sr);\n      var cy = bottom(cl);\n\n      if (sy <= cy) {\n        sr = nextRightContour(sr);\n        if (sr !== null) mssr += sr.mod;\n      }\n\n      if (sy >= cy) {\n        cl = nextLeftContour(cl);\n        if (cl !== null) mscl += cl.mod;\n      }\n    }\n\n    if (!sr && !!cl) {\n      setLeftThread(t, i, cl, mscl);\n    } else if (!!sr && !cl) {\n      setRightThread(t, i, sr, mssr);\n    }\n  }\n\n  function moveSubtree(t, i, si, dist) {\n    t.c[i].mod += dist;\n    t.c[i].msel += dist;\n    t.c[i].mser += dist;\n    distributeExtra(t, i, si, dist);\n  }\n\n  function nextLeftContour(t) {\n    return t.cs === 0 ? t.tl : t.c[0];\n  }\n\n  function nextRightContour(t) {\n    return t.cs === 0 ? t.tr : t.c[t.cs - 1];\n  }\n\n  function bottom(t) {\n    return t.y + t.h;\n  }\n\n  function setLeftThread(t, i, cl, modsumcl) {\n    var li = t.c[0].el;\n    li.tl = cl;\n    var diff = modsumcl - cl.mod - t.c[0].msel;\n    li.mod += diff;\n    li.prelim -= diff;\n    t.c[0].el = t.c[i].el;\n    t.c[0].msel = t.c[i].msel;\n  }\n\n  function setRightThread(t, i, sr, modsumsr) {\n    var ri = t.c[i].er;\n    ri.tr = sr;\n    var diff = modsumsr - sr.mod - t.c[i].mser;\n    ri.mod += diff;\n    ri.prelim -= diff;\n    t.c[i].er = t.c[i - 1].er;\n    t.c[i].mser = t.c[i - 1].mser;\n  }\n\n  function positionRoot(t) {\n    t.prelim = (t.c[0].prelim + t.c[0].mod + t.c[t.cs - 1].mod + t.c[t.cs - 1].prelim + t.c[t.cs - 1].w) / 2 - t.w / 2;\n  }\n\n  function secondWalk(t, modsum) {\n    modsum += t.mod;\n    t.x = t.prelim + modsum;\n    addChildSpacing(t);\n\n    for (var i = 0; i < t.cs; i++) {\n      secondWalk(t.c[i], modsum);\n    }\n  }\n\n  function distributeExtra(t, i, si, dist) {\n    if (si !== i - 1) {\n      var nr = i - si;\n      t.c[si + 1].shift += dist / nr;\n      t.c[i].shift -= dist / nr;\n      t.c[i].change -= dist - dist / nr;\n    }\n  }\n\n  function addChildSpacing(t) {\n    var d = 0;\n    var modsumdelta = 0;\n\n    for (var i = 0; i < t.cs; i++) {\n      d += t.c[i].shift;\n      modsumdelta += d + t.c[i].change;\n      t.c[i].mod += modsumdelta;\n    }\n  }\n\n  function updateIYL(low, index, ih) {\n    while (ih !== null && low >= ih.low) {\n      ih = ih.nxt;\n    }\n\n    return {\n      low: low,\n      index: index,\n      nxt: ih\n    };\n  } // do layout\n\n\n  layer(root, isHorizontal);\n  var wt = WrappedTree.fromNode(root, isHorizontal);\n  firstWalk(wt);\n  secondWalk(wt, 0);\n  convertBack(wt, root, isHorizontal);\n  normalize(root, isHorizontal);\n  return root;\n};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar TreeLayout = __webpack_require__(1);\n\nvar dendrogram = __webpack_require__(10);\n\nvar doTreeLayout = __webpack_require__(2);\n\nvar util = __webpack_require__(0);\n\nvar DendrogramLayout = /*#__PURE__*/function (_TreeLayout) {\n  _inheritsLoose(DendrogramLayout, _TreeLayout);\n\n  function DendrogramLayout() {\n    return _TreeLayout.apply(this, arguments) || this;\n  }\n\n  var _proto = DendrogramLayout.prototype;\n\n  _proto.execute = function execute() {\n    var me = this;\n    me.rootNode.width = 0;\n    return doTreeLayout(me.rootNode, me.options, dendrogram);\n  };\n\n  return DendrogramLayout;\n}(TreeLayout);\n\nvar DEFAULT_OPTIONS = {};\n\nfunction dendrogramLayout(root, options) {\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  return new DendrogramLayout(root, options).execute();\n}\n\nmodule.exports = dendrogramLayout;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// wrap tree node\n// TODO considering size\nvar util = __webpack_require__(0);\n\nfunction WrappedTree(height, children) {\n  if (height === void 0) {\n    height = 0;\n  }\n\n  if (children === void 0) {\n    children = [];\n  }\n\n  var me = this;\n  me.x = me.y = 0;\n  me.leftChild = me.rightChild = null;\n  me.height = 0;\n  me.children = children;\n}\n\nvar DEFAULT_OPTIONS = {\n  isHorizontal: true,\n  nodeSep: 20,\n  nodeSize: 20,\n  rankSep: 200,\n  subTreeSep: 10\n};\n\nfunction convertBack(converted\n/* WrappedTree */\n, root\n/* TreeNode */\n, isHorizontal) {\n  if (isHorizontal) {\n    root.x = converted.x;\n    root.y = converted.y;\n  } else {\n    root.x = converted.y;\n    root.y = converted.x;\n  }\n\n  converted.children.forEach(function (child, i) {\n    convertBack(child, root.children[i], isHorizontal);\n  });\n}\n\nmodule.exports = function (root, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  var maxDepth = 0;\n\n  function wrappedTreeFromNode(n) {\n    if (!n) return null;\n    n.width = 0;\n\n    if (n.depth && n.depth > maxDepth) {\n      maxDepth = n.depth; // get the max depth\n    }\n\n    var children = n.children;\n    var childrenCount = children.length;\n    var t = new WrappedTree(n.height, []);\n    children.forEach(function (child, i) {\n      var childWT = wrappedTreeFromNode(child);\n      t.children.push(childWT);\n\n      if (i === 0) {\n        // t.leftChild = childWT.leftChild ? childWT.leftChild : childWT\n        t.leftChild = childWT;\n      }\n\n      if (i === childrenCount - 1) {\n        // t.rightChild = childWT.rightChild ? childWT.rightChild : childWT\n        t.rightChild = childWT;\n      }\n    });\n    t.originNode = n;\n    t.isLeaf = n.isLeaf();\n    return t;\n  }\n\n  function getDrawingDepth(t) {\n    if (t.isLeaf || t.children.length === 0) {\n      t.drawingDepth = maxDepth;\n    } else {\n      var depths = t.children.map(function (child) {\n        return getDrawingDepth(child);\n      });\n      var minChildDepth = Math.min.apply(null, depths);\n      t.drawingDepth = minChildDepth - 1;\n    }\n\n    return t.drawingDepth;\n  }\n\n  var prevLeaf;\n\n  function position(t) {\n    t.x = t.drawingDepth * options.rankSep;\n\n    if (t.isLeaf) {\n      t.y = 0;\n\n      if (prevLeaf) {\n        t.y = prevLeaf.y + prevLeaf.height + options.nodeSep;\n\n        if (t.originNode.parent !== prevLeaf.originNode.parent) {\n          t.y += options.subTreeSep;\n        }\n      }\n\n      prevLeaf = t;\n    } else {\n      t.children.forEach(function (child) {\n        position(child);\n      });\n      t.y = (t.leftChild.y + t.rightChild.y) / 2;\n    }\n  } // wrap node\n\n\n  var wt = wrappedTreeFromNode(root); // get depth for drawing\n\n  getDrawingDepth(wt); // get position\n\n  position(wt); // get x, y\n\n  convertBack(wt, root, options.isHorizontal);\n  return root;\n};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar TreeLayout = __webpack_require__(1);\n\nvar indentedTree = __webpack_require__(12);\n\nvar separateTree = __webpack_require__(4);\n\nvar util = __webpack_require__(0);\n\nvar VALID_DIRECTIONS = ['LR', // left to right\n'RL', // right to left\n'H' // horizontal\n];\nvar DEFAULT_DIRECTION = VALID_DIRECTIONS[0];\n\nvar IndentedLayout = /*#__PURE__*/function (_TreeLayout) {\n  _inheritsLoose(IndentedLayout, _TreeLayout);\n\n  function IndentedLayout() {\n    return _TreeLayout.apply(this, arguments) || this;\n  }\n\n  var _proto = IndentedLayout.prototype;\n\n  _proto.execute = function execute() {\n    var me = this;\n    var options = me.options;\n    var root = me.rootNode;\n    options.isHorizontal = true;\n    var indent = options.indent;\n    var direction = options.direction || DEFAULT_DIRECTION;\n\n    if (direction && VALID_DIRECTIONS.indexOf(direction) === -1) {\n      throw new TypeError(\"Invalid direction: \" + direction);\n    }\n\n    if (direction === VALID_DIRECTIONS[0]) {\n      // LR\n      indentedTree(root, indent);\n    } else if (direction === VALID_DIRECTIONS[1]) {\n      // RL\n      indentedTree(root, indent);\n      root.right2left();\n    } else if (direction === VALID_DIRECTIONS[2]) {\n      // H\n      // separate into left and right trees\n      var _separateTree = separateTree(root, options),\n          left = _separateTree.left,\n          right = _separateTree.right;\n\n      indentedTree(left, indent);\n      left.right2left();\n      indentedTree(right, indent);\n      var bbox = left.getBoundingBox();\n      right.translate(bbox.width, 0);\n      root.x = right.x - root.width / 2;\n    }\n\n    return root;\n  };\n\n  return IndentedLayout;\n}(TreeLayout);\n\nvar DEFAULT_OPTIONS = {};\n\nfunction indentedLayout(root, options) {\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  return new IndentedLayout(root, options).execute();\n}\n\nmodule.exports = indentedLayout;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\nvar DEFAULT_INDENT = 20;\n\nfunction positionNode(node, previousNode, dx) {\n  node.x += dx * node.depth;\n  node.y = previousNode ? previousNode.y + previousNode.height : 0;\n}\n\nmodule.exports = function (root, indent) {\n  if (indent === void 0) {\n    indent = DEFAULT_INDENT;\n  }\n\n  var previousNode = null;\n  root.eachNode(function (node) {\n    positionNode(node, previousNode, indent);\n    previousNode = node;\n  });\n};\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar TreeLayout = __webpack_require__(1);\n\nvar mindmap = __webpack_require__(14);\n\nvar doTreeLayout = __webpack_require__(2);\n\nvar util = __webpack_require__(0);\n\nvar MindmapLayout = /*#__PURE__*/function (_TreeLayout) {\n  _inheritsLoose(MindmapLayout, _TreeLayout);\n\n  function MindmapLayout() {\n    return _TreeLayout.apply(this, arguments) || this;\n  }\n\n  var _proto = MindmapLayout.prototype;\n\n  _proto.execute = function execute() {\n    var me = this;\n    return doTreeLayout(me.rootNode, me.options, mindmap);\n  };\n\n  return MindmapLayout;\n}(TreeLayout);\n\nvar DEFAULT_OPTIONS = {};\n\nfunction mindmapLayout(root, options) {\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  return new MindmapLayout(root, options).execute();\n}\n\nmodule.exports = mindmapLayout;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar util = __webpack_require__(0);\n\nfunction secondWalk(node, options) {\n  var totalHeight = 0;\n\n  if (!node.children.length) {\n    totalHeight = node.height;\n  } else {\n    node.children.forEach(function (c) {\n      totalHeight += secondWalk(c, options);\n    });\n  }\n\n  node._subTreeSep = options.getSubTreeSep(node.data);\n  node.totalHeight = Math.max(node.height, totalHeight) + 2 * node._subTreeSep;\n  return node.totalHeight;\n}\n\nfunction thirdWalk(node) {\n  var children = node.children;\n  var len = children.length;\n\n  if (len) {\n    children.forEach(function (c) {\n      thirdWalk(c);\n    });\n    var first = children[0];\n    var last = children[len - 1];\n    var childrenHeight = last.y - first.y + last.height;\n    var childrenTotalHeight = 0;\n    children.forEach(function (child) {\n      childrenTotalHeight += child.totalHeight;\n    });\n\n    if (childrenHeight > node.height) {\n      // 当子节点总高度大于父节点高度\n      node.y = first.y + childrenHeight / 2 - node.height / 2;\n    } else if (children.length !== 1 || node.height > childrenTotalHeight) {\n      // 多于一个子节点或者父节点大于所有子节点的总高度\n      var offset = node.y + (node.height - childrenHeight) / 2 - first.y;\n      children.forEach(function (c) {\n        c.translate(0, offset);\n      });\n    } else {\n      // 只有一个子节点\n      node.y = (first.y + first.height / 2 + last.y + last.height / 2) / 2 - node.height / 2;\n    }\n  }\n}\n\nvar DEFAULT_OPTIONS = {\n  getSubTreeSep: function getSubTreeSep() {\n    return 0;\n  }\n};\n\nmodule.exports = function (root, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  root.parent = {\n    x: 0,\n    width: 0,\n    height: 0,\n    y: 0\n  }; // first walk\n\n  root.BFTraverse(function (node) {\n    node.x = node.parent.x + node.parent.width; // simply get x\n  });\n  root.parent = null; // second walk\n\n  secondWalk(root, options); // assign sub tree totalHeight\n  // adjusting\n  // separating nodes\n\n  root.startY = 0;\n  root.y = root.totalHeight / 2 - root.height / 2;\n  root.eachNode(function (node) {\n    var children = node.children;\n    var len = children.length;\n\n    if (len) {\n      var first = children[0];\n      first.startY = node.startY + node._subTreeSep;\n\n      if (len === 1) {\n        first.y = node.y + node.height / 2 - first.height / 2;\n      } else {\n        first.y = first.startY + first.totalHeight / 2 - first.height / 2;\n\n        for (var i = 1; i < len; i++) {\n          var c = children[i];\n          c.startY = children[i - 1].startY + children[i - 1].totalHeight;\n          c.y = c.startY + c.totalHeight / 2 - c.height / 2;\n        }\n      }\n    }\n  }); // third walk\n\n  thirdWalk(root);\n};\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=hierarchy.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/augment.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/augment.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mix_1 = __webpack_require__(/*! ./mix */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/mix.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nvar augment = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var c = args[0];\n    for (var i = 1; i < args.length; i++) {\n        var obj = args[i];\n        if (is_function_1.default(obj)) {\n            obj = obj.prototype;\n        }\n        mix_1.default(c.prototype, obj);\n    }\n};\nexports.default = augment;\n//# sourceMappingURL=augment.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/cache.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/cache.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * k-v 存储\n */\nvar default_1 = /** @class */ (function () {\n    function default_1() {\n        this.map = {};\n    }\n    default_1.prototype.has = function (key) {\n        return this.map[key] !== undefined;\n    };\n    default_1.prototype.get = function (key, def) {\n        var v = this.map[key];\n        return v === undefined ? def : v;\n    };\n    default_1.prototype.set = function (key, value) {\n        this.map[key] = value;\n    };\n    default_1.prototype.clear = function () {\n        this.map = {};\n    };\n    default_1.prototype.delete = function (key) {\n        delete this.map[key];\n    };\n    default_1.prototype.size = function () {\n        return Object.keys(this.map).length;\n    };\n    return default_1;\n}());\nexports.default = default_1;\n//# sourceMappingURL=cache.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/clamp.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/clamp.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar clamp = function (a, min, max) {\n    if (a < min) {\n        return min;\n    }\n    else if (a > max) {\n        return max;\n    }\n    return a;\n};\nexports.default = clamp;\n//# sourceMappingURL=clamp.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/clear-animation-frame.js\":\n/*!********************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/clear-animation-frame.js ***!\n  \\********************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction cancelAnimationFrame(handler) {\n    var method = window.cancelAnimationFrame ||\n        window.webkitCancelAnimationFrame ||\n        // @ts-ignore\n        window.mozCancelAnimationFrame ||\n        // @ts-ignore\n        window.msCancelAnimationFrame ||\n        clearTimeout;\n    method(handler);\n}\nexports.default = cancelAnimationFrame;\n;\n//# sourceMappingURL=clear-animation-frame.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/clone.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/clone.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar clone = function (obj) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n    var rst;\n    if (is_array_1.default(obj)) {\n        rst = [];\n        for (var i = 0, l = obj.length; i < l; i++) {\n            if (typeof obj[i] === 'object' && obj[i] != null) {\n                rst[i] = clone(obj[i]);\n            }\n            else {\n                rst[i] = obj[i];\n            }\n        }\n    }\n    else {\n        rst = {};\n        for (var k in obj) {\n            if (typeof obj[k] === 'object' && obj[k] != null) {\n                rst[k] = clone(obj[k]);\n            }\n            else {\n                rst[k] = obj[k];\n            }\n        }\n    }\n    return rst;\n};\nexports.default = clone;\n//# sourceMappingURL=clone.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/contains.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/contains.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar contains = function (arr, value) {\n    if (!is_array_like_1.default(arr)) {\n        return false;\n    }\n    return arr.indexOf(value) > -1;\n};\nexports.default = contains;\n//# sourceMappingURL=contains.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/debounce.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/debounce.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction debounce(func, wait, immediate) {\n    var timeout;\n    return function () {\n        var context = this, args = arguments;\n        var later = function () {\n            timeout = null;\n            if (!immediate) {\n                func.apply(context, args);\n            }\n        };\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n}\nexports.default = debounce;\n//# sourceMappingURL=debounce.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/deep-mix.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/deep-mix.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_plain_object_1 = __webpack_require__(/*! ./is-plain-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-plain-object.js\");\nvar MAX_MIX_LEVEL = 5;\nfunction _deepMix(dist, src, level, maxLevel) {\n    level = level || 0;\n    maxLevel = maxLevel || MAX_MIX_LEVEL;\n    for (var key in src) {\n        if (src.hasOwnProperty(key)) {\n            var value = src[key];\n            if (value !== null && is_plain_object_1.default(value)) {\n                if (!is_plain_object_1.default(dist[key])) {\n                    dist[key] = {};\n                }\n                if (level < maxLevel) {\n                    _deepMix(dist[key], value, level + 1, maxLevel);\n                }\n                else {\n                    dist[key] = src[key];\n                }\n            }\n            else if (is_array_1.default(value)) {\n                dist[key] = [];\n                dist[key] = dist[key].concat(value);\n            }\n            else if (value !== undefined) {\n                dist[key] = value;\n            }\n        }\n    }\n}\n// todo 重写\nvar deepMix = function (rst) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < args.length; i += 1) {\n        _deepMix(rst, args[i]);\n    }\n    return rst;\n};\nexports.default = deepMix;\n//# sourceMappingURL=deep-mix.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/difference.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/difference.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar filter_1 = __webpack_require__(/*! ./filter */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/filter.js\");\nvar contains_1 = __webpack_require__(/*! ./contains */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/contains.js\");\n/**\n * Flattens `array` a single level deep.\n *\n * @param {Array} arr The array to inspect.\n * @param {Array} values The values to exclude.\n * @return {Array} Returns the new array of filtered values.\n * @example\n * difference([2, 1], [2, 3]);  // => [1]\n */\nvar difference = function (arr, values) {\n    if (values === void 0) { values = []; }\n    return filter_1.default(arr, function (value) { return !contains_1.default(values, value); });\n};\nexports.default = difference;\n//# sourceMappingURL=difference.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_object_1 = __webpack_require__(/*! ./is-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object.js\");\nfunction each(elements, func) {\n    if (!elements) {\n        return;\n    }\n    var rst;\n    if (is_array_1.default(elements)) {\n        for (var i = 0, len = elements.length; i < len; i++) {\n            rst = func(elements[i], i);\n            if (rst === false) {\n                break;\n            }\n        }\n    }\n    else if (is_object_1.default(elements)) {\n        for (var k in elements) {\n            if (elements.hasOwnProperty(k)) {\n                rst = func(elements[k], k);\n                if (rst === false) {\n                    break;\n                }\n            }\n        }\n    }\n}\nexports.default = each;\n//# sourceMappingURL=each.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/ends-with.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/ends-with.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_string_1 = __webpack_require__(/*! ./is-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\");\nfunction endsWith(arr, e) {\n    return (is_array_1.default(arr) || is_string_1.default(arr)) ? arr[arr.length - 1] === e : false;\n}\nexports.default = endsWith;\n//# sourceMappingURL=ends-with.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/every.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/every.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 只要有一个不满足条件就返回 false\n * @param arr\n * @param func\n */\nvar every = function (arr, func) {\n    for (var i = 0; i < arr.length; i++) {\n        if (!func(arr[i], i))\n            return false;\n    }\n    return true;\n};\nexports.default = every;\n//# sourceMappingURL=every.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/extend.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/extend.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mix_1 = __webpack_require__(/*! ./mix */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/mix.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nvar extend = function (subclass, superclass, overrides, staticOverrides) {\n    // 如果只提供父类构造函数，则自动生成子类构造函数\n    if (!is_function_1.default(superclass)) {\n        overrides = superclass;\n        superclass = subclass;\n        subclass = function () { };\n    }\n    var create = Object.create ?\n        function (proto, c) {\n            return Object.create(proto, {\n                constructor: {\n                    value: c\n                }\n            });\n        } :\n        function (proto, c) {\n            function Tmp() { }\n            Tmp.prototype = proto;\n            var o = new Tmp();\n            o.constructor = c;\n            return o;\n        };\n    var superObj = create(superclass.prototype, subclass); // new superclass(),//实例化父类作为子类的prototype\n    subclass.prototype = mix_1.default(superObj, subclass.prototype); // 指定子类的prototype\n    subclass.superclass = create(superclass.prototype, superclass);\n    mix_1.default(superObj, overrides);\n    mix_1.default(subclass, staticOverrides);\n    return subclass;\n};\nexports.default = extend;\n//# sourceMappingURL=extend.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/filter.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/filter.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar filter = function (arr, func) {\n    if (!is_array_like_1.default(arr)) {\n        return arr;\n    }\n    var result = [];\n    each_1.default(arr, function (value, index) {\n        if (func(value, index)) {\n            result.push(value);\n        }\n    });\n    return result;\n};\nexports.default = filter;\n//# sourceMappingURL=filter.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/find-index.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/find-index.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction findIndex(arr, predicate, fromIndex) {\n    if (fromIndex === void 0) { fromIndex = 0; }\n    for (var i = fromIndex; i < arr.length; i++) {\n        if (predicate(arr[i], i)) {\n            // 找到终止循环\n            return i;\n        }\n    }\n    return -1;\n}\nexports.default = findIndex;\n//# sourceMappingURL=find-index.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/find.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/find.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nvar is_match_1 = __webpack_require__(/*! ./is-match */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-match.js\");\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_plain_object_1 = __webpack_require__(/*! ./is-plain-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-plain-object.js\");\nfunction find(arr, predicate) {\n    if (!is_array_1.default(arr))\n        return null;\n    var _predicate;\n    if (is_function_1.default(predicate)) {\n        _predicate = predicate;\n    }\n    if (is_plain_object_1.default(predicate)) {\n        _predicate = function (a) { return is_match_1.default(a, predicate); };\n    }\n    if (_predicate) {\n        for (var i = 0; i < arr.length; i += 1) {\n            if (_predicate(arr[i])) {\n                return arr[i];\n            }\n        }\n    }\n    return null;\n}\nexports.default = find;\n//# sourceMappingURL=find.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/first-value.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/first-value.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar firstValue = function (data, name) {\n    var rst = null;\n    for (var i = 0; i < data.length; i++) {\n        var obj = data[i];\n        var value = obj[name];\n        if (!is_nil_1.default(value)) {\n            if (is_array_1.default(value)) {\n                rst = value[0]; // todo 这里是否应该使用递归，调用 firstValue @绝云\n            }\n            else {\n                rst = value;\n            }\n            break;\n        }\n    }\n    return rst;\n};\nexports.default = firstValue;\n//# sourceMappingURL=first-value.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/fixed-base.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/fixed-base.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar fixedBase = function (v, base) {\n    var str = base.toString();\n    var index = str.indexOf('.');\n    if (index === -1) {\n        return Math.round(v);\n    }\n    var length = str.substr(index + 1).length;\n    if (length > 20) {\n        length = 20;\n    }\n    return parseFloat(v.toFixed(length));\n};\nexports.default = fixedBase;\n//# sourceMappingURL=fixed-base.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/flatten-deep.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/flatten-deep.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\n/**\n * Flattens `array` a single level deep.\n *\n * @param {Array} arr The array to flatten.\n * @param {Array} result The array to return.\n * @return {Array} Returns the new flattened array.\n * @example\n *\n * flattenDeep([1, [2, [3, [4]], 5]]);  // => [1, 2, 3, 4, 5]\n */\nvar flattenDeep = function (arr, result) {\n    if (result === void 0) { result = []; }\n    if (!is_array_1.default(arr)) {\n        result.push(arr);\n    }\n    else {\n        for (var i = 0; i < arr.length; i += 1) {\n            flattenDeep(arr[i], result);\n        }\n    }\n    return result;\n};\nexports.default = flattenDeep;\n//# sourceMappingURL=flatten-deep.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/flatten.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/flatten.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\n/**\n * Flattens `array` a single level deep.\n *\n * @param {Array} arr The array to flatten.\n * @return {Array} Returns the new flattened array.\n * @example\n *\n * flatten([1, [2, [3, [4]], 5]]);  // => [1, 2, [3, [4]], 5]\n */\nvar flatten = function (arr) {\n    if (!is_array_1.default(arr)) {\n        return [];\n    }\n    var rst = [];\n    for (var i = 0; i < arr.length; i++) {\n        rst = rst.concat(arr[i]);\n    }\n    return rst;\n};\nexports.default = flatten;\n//# sourceMappingURL=flatten.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/for-in.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/for-in.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nexports.default = each_1.default;\n//# sourceMappingURL=for-in.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-range.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-range.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar filter_1 = __webpack_require__(/*! ./filter */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/filter.js\");\nvar getRange = function (values) {\n    // 存在 NaN 时，min,max 判定会出问题\n    values = filter_1.default(values, function (v) {\n        return !isNaN(v);\n    });\n    if (!values.length) { // 如果没有数值则直接返回0\n        return {\n            min: 0,\n            max: 0\n        };\n    }\n    if (is_array_1.default(values[0])) {\n        var tmp = [];\n        for (var i = 0; i < values.length; i++) {\n            tmp = tmp.concat(values[i]);\n        }\n        values = tmp;\n    }\n    var max = Math.max.apply(null, values);\n    var min = Math.min.apply(null, values);\n    return {\n        min: min,\n        max: max\n    };\n};\nexports.default = getRange;\n//# sourceMappingURL=get-range.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-type.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-type.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar toString = {}.toString;\nvar getType = function (value) {\n    return toString.call(value).replace(/^\\[object /, '').replace(/]$/, '');\n};\nexports.default = getType;\n//# sourceMappingURL=get-type.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-wrap-behavior.js\":\n/*!****************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-wrap-behavior.js ***!\n  \\****************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 获取封装的事件\n * @protected\n * @param  {Object} obj   对象\n * @param  {String} action 事件名称\n * @return {Function}        返回事件处理函数\n */\nfunction getWrapBehavior(obj, action) {\n    return obj['_wrap_' + action];\n}\nexports.default = getWrapBehavior;\n//# sourceMappingURL=get-wrap-behavior.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/get.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_string_1 = __webpack_require__(/*! ./is-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\");\n/**\n * https://github.com/developit/dlv/blob/master/index.js\n * @param obj\n * @param key\n * @param defaultValue\n */\nexports.default = (function (obj, key, defaultValue) {\n    var p = 0;\n    var keyArr = is_string_1.default(key) ? key.split('.') : key;\n    while (obj && p < keyArr.length) {\n        obj = obj[keyArr[p++]];\n    }\n    return (obj === undefined || p < keyArr.length) ? defaultValue : obj;\n});\n//# sourceMappingURL=get.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-by.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-by.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction groupBy(data, condition) {\n    if (!condition || !is_array_1.default(data)) {\n        return {};\n    }\n    var result = {};\n    // 兼容方法和 字符串的写法\n    var predicate = is_function_1.default(condition) ? condition : function (item) { return item[condition]; };\n    var key;\n    each_1.default(data, function (item) {\n        key = predicate(item);\n        if (hasOwnProperty.call(result, key)) {\n            result[key].push(item);\n        }\n        else {\n            result[key] = [item];\n        }\n    });\n    return result;\n}\nexports.default = groupBy;\n//# sourceMappingURL=group-by.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-to-map.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-to-map.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nvar group_by_1 = __webpack_require__(/*! ./group-by */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-by.js\");\nvar groupToMap = function (data, condition) {\n    if (!condition) {\n        return {\n            0: data\n        };\n    }\n    if (!is_function_1.default(condition)) {\n        var paramsCondition_1 = is_array_1.default(condition) ? condition : condition.replace(/\\s+/g, '').split('*');\n        condition = function (row) {\n            var unique = '_'; // 避免出现数字作为Key的情况，会进行按照数字的排序\n            for (var i = 0, l = paramsCondition_1.length; i < l; i++) {\n                unique += row[paramsCondition_1[i]] && row[paramsCondition_1[i]].toString();\n            }\n            return unique;\n        };\n    }\n    var groups = group_by_1.default(data, condition);\n    return groups;\n};\nexports.default = groupToMap;\n//# sourceMappingURL=group-to-map.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/group.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar group_to_map_1 = __webpack_require__(/*! ./group-to-map */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-to-map.js\");\nexports.default = (function (data, condition) {\n    if (!condition) {\n        // 没有条件，则自身改成数组\n        return [data];\n    }\n    var groups = group_to_map_1.default(data, condition);\n    var array = [];\n    for (var i in groups) {\n        array.push(groups[i]);\n    }\n    return array;\n});\n//# sourceMappingURL=group.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/has-key.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/has-key.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar has_1 = __webpack_require__(/*! ./has */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/has.js\");\nexports.default = has_1.default;\n//# sourceMappingURL=has-key.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/has-value.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/has-value.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar contains_1 = __webpack_require__(/*! ./contains */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/contains.js\");\nvar values_1 = __webpack_require__(/*! ./values */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/values.js\");\nexports.default = (function (obj, value) { return contains_1.default(values_1.default(obj), value); });\n//# sourceMappingURL=has-value.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/has.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/has.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (function (obj, key) { return obj.hasOwnProperty(key); });\n//# sourceMappingURL=has.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/head.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/head.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nfunction head(o) {\n    if (is_array_like_1.default(o)) {\n        return o[0];\n    }\n    return undefined;\n}\nexports.default = head;\n//# sourceMappingURL=head.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/identity.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/identity.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (function (v) { return v; });\n//# sourceMappingURL=identity.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index-of.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/index-of.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar indexOf = function (arr, obj) {\n    if (!is_array_like_1.default(arr)) {\n        return -1;\n    }\n    var m = Array.prototype.indexOf;\n    if (m) {\n        return m.call(arr, obj);\n    }\n    var index = -1;\n    for (var i = 0; i < arr.length; i++) {\n        if (arr[i] === obj) {\n            index = i;\n            break;\n        }\n    }\n    return index;\n};\nexports.default = indexOf;\n//# sourceMappingURL=index-of.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// array\nvar contains_1 = __webpack_require__(/*! ./contains */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/contains.js\");\nexports.contains = contains_1.default;\nexports.includes = contains_1.default;\nvar difference_1 = __webpack_require__(/*! ./difference */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/difference.js\");\nexports.difference = difference_1.default;\nvar find_1 = __webpack_require__(/*! ./find */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/find.js\");\nexports.find = find_1.default;\nvar find_index_1 = __webpack_require__(/*! ./find-index */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/find-index.js\");\nexports.findIndex = find_index_1.default;\nvar first_value_1 = __webpack_require__(/*! ./first-value */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/first-value.js\");\nexports.firstValue = first_value_1.default;\nvar flatten_1 = __webpack_require__(/*! ./flatten */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/flatten.js\");\nexports.flatten = flatten_1.default;\nvar flatten_deep_1 = __webpack_require__(/*! ./flatten-deep */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/flatten-deep.js\");\nexports.flattenDeep = flatten_deep_1.default;\nvar get_range_1 = __webpack_require__(/*! ./get-range */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-range.js\");\nexports.getRange = get_range_1.default;\nvar pull_1 = __webpack_require__(/*! ./pull */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/pull.js\");\nexports.pull = pull_1.default;\nvar pull_at_1 = __webpack_require__(/*! ./pull-at */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/pull-at.js\");\nexports.pullAt = pull_at_1.default;\nvar reduce_1 = __webpack_require__(/*! ./reduce */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/reduce.js\");\nexports.reduce = reduce_1.default;\nvar remove_1 = __webpack_require__(/*! ./remove */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/remove.js\");\nexports.remove = remove_1.default;\nvar sort_by_1 = __webpack_require__(/*! ./sort-by */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/sort-by.js\");\nexports.sortBy = sort_by_1.default;\nvar union_1 = __webpack_require__(/*! ./union */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/union.js\");\nexports.union = union_1.default;\nvar uniq_1 = __webpack_require__(/*! ./uniq */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/uniq.js\");\nexports.uniq = uniq_1.default;\nvar values_of_key_1 = __webpack_require__(/*! ./values-of-key */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/values-of-key.js\");\nexports.valuesOfKey = values_of_key_1.default;\nvar head_1 = __webpack_require__(/*! ./head */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/head.js\");\nexports.head = head_1.default;\nvar last_1 = __webpack_require__(/*! ./last */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/last.js\");\nexports.last = last_1.default;\nvar starts_with_1 = __webpack_require__(/*! ./starts-with */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/starts-with.js\");\nexports.startsWith = starts_with_1.default;\nvar ends_with_1 = __webpack_require__(/*! ./ends-with */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/ends-with.js\");\nexports.endsWith = ends_with_1.default;\nvar filter_1 = __webpack_require__(/*! ./filter */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/filter.js\");\nexports.filter = filter_1.default;\nvar every_1 = __webpack_require__(/*! ./every */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/every.js\");\nexports.every = every_1.default;\nvar some_1 = __webpack_require__(/*! ./some */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/some.js\");\nexports.some = some_1.default;\nvar group_1 = __webpack_require__(/*! ./group */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group.js\");\nexports.group = group_1.default;\nvar group_by_1 = __webpack_require__(/*! ./group-by */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-by.js\");\nexports.groupBy = group_by_1.default;\nvar group_to_map_1 = __webpack_require__(/*! ./group-to-map */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/group-to-map.js\");\nexports.groupToMap = group_to_map_1.default;\n// event\nvar get_wrap_behavior_1 = __webpack_require__(/*! ./get-wrap-behavior */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-wrap-behavior.js\");\nexports.getWrapBehavior = get_wrap_behavior_1.default;\nvar wrap_behavior_1 = __webpack_require__(/*! ./wrap-behavior */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/wrap-behavior.js\");\nexports.wrapBehavior = wrap_behavior_1.default;\n// format\nvar number2color_1 = __webpack_require__(/*! ./number2color */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/number2color.js\");\nexports.number2color = number2color_1.default;\nvar parse_radius_1 = __webpack_require__(/*! ./parse-radius */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/parse-radius.js\");\nexports.parseRadius = parse_radius_1.default;\n// math\nvar clamp_1 = __webpack_require__(/*! ./clamp */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/clamp.js\");\nexports.clamp = clamp_1.default;\nvar fixed_base_1 = __webpack_require__(/*! ./fixed-base */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/fixed-base.js\");\nexports.fixedBase = fixed_base_1.default;\nvar is_decimal_1 = __webpack_require__(/*! ./is-decimal */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-decimal.js\");\nexports.isDecimal = is_decimal_1.default;\nvar is_even_1 = __webpack_require__(/*! ./is-even */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-even.js\");\nexports.isEven = is_even_1.default;\nvar is_integer_1 = __webpack_require__(/*! ./is-integer */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-integer.js\");\nexports.isInteger = is_integer_1.default;\nvar is_negative_1 = __webpack_require__(/*! ./is-negative */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-negative.js\");\nexports.isNegative = is_negative_1.default;\nvar is_number_equal_1 = __webpack_require__(/*! ./is-number-equal */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number-equal.js\");\nexports.isNumberEqual = is_number_equal_1.default;\nvar is_odd_1 = __webpack_require__(/*! ./is-odd */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-odd.js\");\nexports.isOdd = is_odd_1.default;\nvar is_positive_1 = __webpack_require__(/*! ./is-positive */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-positive.js\");\nexports.isPositive = is_positive_1.default;\nvar max_by_1 = __webpack_require__(/*! ./max-by */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/max-by.js\");\nexports.maxBy = max_by_1.default;\nvar min_by_1 = __webpack_require__(/*! ./min-by */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/min-by.js\");\nexports.minBy = min_by_1.default;\nvar mod_1 = __webpack_require__(/*! ./mod */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/mod.js\");\nexports.mod = mod_1.default;\nvar to_degree_1 = __webpack_require__(/*! ./to-degree */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-degree.js\");\nexports.toDegree = to_degree_1.default;\nvar to_integer_1 = __webpack_require__(/*! ./to-integer */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-integer.js\");\nexports.toInteger = to_integer_1.default;\nvar to_radian_1 = __webpack_require__(/*! ./to-radian */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-radian.js\");\nexports.toRadian = to_radian_1.default;\n// object\nvar for_in_1 = __webpack_require__(/*! ./for-in */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/for-in.js\");\nexports.forIn = for_in_1.default;\nvar has_1 = __webpack_require__(/*! ./has */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/has.js\");\nexports.has = has_1.default;\nvar has_key_1 = __webpack_require__(/*! ./has-key */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/has-key.js\");\nexports.hasKey = has_key_1.default;\nvar has_value_1 = __webpack_require__(/*! ./has-value */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/has-value.js\");\nexports.hasValue = has_value_1.default;\nvar keys_1 = __webpack_require__(/*! ./keys */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/keys.js\");\nexports.keys = keys_1.default;\nvar is_match_1 = __webpack_require__(/*! ./is-match */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-match.js\");\nexports.isMatch = is_match_1.default;\nvar values_1 = __webpack_require__(/*! ./values */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/values.js\");\nexports.values = values_1.default;\n// string\nvar lower_case_1 = __webpack_require__(/*! ./lower-case */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/lower-case.js\");\nexports.lowerCase = lower_case_1.default;\nvar lower_first_1 = __webpack_require__(/*! ./lower-first */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/lower-first.js\");\nexports.lowerFirst = lower_first_1.default;\nvar substitute_1 = __webpack_require__(/*! ./substitute */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/substitute.js\");\nexports.substitute = substitute_1.default;\nvar upper_case_1 = __webpack_require__(/*! ./upper-case */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/upper-case.js\");\nexports.upperCase = upper_case_1.default;\nvar upper_first_1 = __webpack_require__(/*! ./upper-first */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/upper-first.js\");\nexports.upperFirst = upper_first_1.default;\n// type\nvar get_type_1 = __webpack_require__(/*! ./get-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-type.js\");\nexports.getType = get_type_1.default;\nvar is_arguments_1 = __webpack_require__(/*! ./is-arguments */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-arguments.js\");\nexports.isArguments = is_arguments_1.default;\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nexports.isArray = is_array_1.default;\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nexports.isArrayLike = is_array_like_1.default;\nvar is_boolean_1 = __webpack_require__(/*! ./is-boolean */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-boolean.js\");\nexports.isBoolean = is_boolean_1.default;\nvar is_date_1 = __webpack_require__(/*! ./is-date */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-date.js\");\nexports.isDate = is_date_1.default;\nvar is_error_1 = __webpack_require__(/*! ./is-error */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-error.js\");\nexports.isError = is_error_1.default;\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nexports.isFunction = is_function_1.default;\nvar is_finite_1 = __webpack_require__(/*! ./is-finite */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-finite.js\");\nexports.isFinite = is_finite_1.default;\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nexports.isNil = is_nil_1.default;\nvar is_null_1 = __webpack_require__(/*! ./is-null */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-null.js\");\nexports.isNull = is_null_1.default;\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nexports.isNumber = is_number_1.default;\nvar is_object_1 = __webpack_require__(/*! ./is-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object.js\");\nexports.isObject = is_object_1.default;\nvar is_object_like_1 = __webpack_require__(/*! ./is-object-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object-like.js\");\nexports.isObjectLike = is_object_like_1.default;\nvar is_plain_object_1 = __webpack_require__(/*! ./is-plain-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-plain-object.js\");\nexports.isPlainObject = is_plain_object_1.default;\nvar is_prototype_1 = __webpack_require__(/*! ./is-prototype */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-prototype.js\");\nexports.isPrototype = is_prototype_1.default;\nvar is_reg_exp_1 = __webpack_require__(/*! ./is-reg-exp */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-reg-exp.js\");\nexports.isRegExp = is_reg_exp_1.default;\nvar is_string_1 = __webpack_require__(/*! ./is-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\");\nexports.isString = is_string_1.default;\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nexports.isType = is_type_1.default;\nvar is_undefined_1 = __webpack_require__(/*! ./is-undefined */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-undefined.js\");\nexports.isUndefined = is_undefined_1.default;\nvar is_element_1 = __webpack_require__(/*! ./is-element */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-element.js\");\nexports.isElement = is_element_1.default;\nvar request_animation_frame_1 = __webpack_require__(/*! ./request-animation-frame */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/request-animation-frame.js\");\nexports.requestAnimationFrame = request_animation_frame_1.default;\nvar clear_animation_frame_1 = __webpack_require__(/*! ./clear-animation-frame */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/clear-animation-frame.js\");\nexports.clearAnimationFrame = clear_animation_frame_1.default;\n// other\nvar augment_1 = __webpack_require__(/*! ./augment */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/augment.js\");\nexports.augment = augment_1.default;\nvar clone_1 = __webpack_require__(/*! ./clone */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/clone.js\");\nexports.clone = clone_1.default;\nvar debounce_1 = __webpack_require__(/*! ./debounce */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/debounce.js\");\nexports.debounce = debounce_1.default;\nvar memoize_1 = __webpack_require__(/*! ./memoize */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/memoize.js\");\nexports.memoize = memoize_1.default;\nvar deep_mix_1 = __webpack_require__(/*! ./deep-mix */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/deep-mix.js\");\nexports.deepMix = deep_mix_1.default;\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nexports.each = each_1.default;\nvar extend_1 = __webpack_require__(/*! ./extend */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/extend.js\");\nexports.extend = extend_1.default;\nvar index_of_1 = __webpack_require__(/*! ./index-of */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index-of.js\");\nexports.indexOf = index_of_1.default;\nvar is_empty_1 = __webpack_require__(/*! ./is-empty */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-empty.js\");\nexports.isEmpty = is_empty_1.default;\nvar is_equal_1 = __webpack_require__(/*! ./is-equal */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-equal.js\");\nexports.isEqual = is_equal_1.default;\nvar is_equal_with_1 = __webpack_require__(/*! ./is-equal-with */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-equal-with.js\");\nexports.isEqualWith = is_equal_with_1.default;\nvar map_1 = __webpack_require__(/*! ./map */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/map.js\");\nexports.map = map_1.default;\nvar map_values_1 = __webpack_require__(/*! ./map-values */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/map-values.js\");\nexports.mapValues = map_values_1.default;\nvar mix_1 = __webpack_require__(/*! ./mix */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/mix.js\");\nexports.mix = mix_1.default;\nexports.assign = mix_1.default;\nvar get_1 = __webpack_require__(/*! ./get */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get.js\");\nexports.get = get_1.default;\nvar set_1 = __webpack_require__(/*! ./set */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/set.js\");\nexports.set = set_1.default;\nvar pick_1 = __webpack_require__(/*! ./pick */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/pick.js\");\nexports.pick = pick_1.default;\nvar throttle_1 = __webpack_require__(/*! ./throttle */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/throttle.js\");\nexports.throttle = throttle_1.default;\nvar to_array_1 = __webpack_require__(/*! ./to-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-array.js\");\nexports.toArray = to_array_1.default;\nvar to_string_1 = __webpack_require__(/*! ./to-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-string.js\");\nexports.toString = to_string_1.default;\nvar unique_id_1 = __webpack_require__(/*! ./unique-id */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/unique-id.js\");\nexports.uniqueId = unique_id_1.default;\nvar noop_1 = __webpack_require__(/*! ./noop */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/noop.js\");\nexports.noop = noop_1.default;\nvar identity_1 = __webpack_require__(/*! ./identity */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/identity.js\");\nexports.identity = identity_1.default;\nvar size_1 = __webpack_require__(/*! ./size */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/size.js\");\nexports.size = size_1.default;\n// 不知道为什么，需要把这个 export，不然 ts 会报类型错误\nvar cache_1 = __webpack_require__(/*! ./cache */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/cache.js\");\nexports.Cache = cache_1.default;\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-arguments.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-arguments.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 是否是参数类型\n *\n * @param {Object} value 测试的值\n * @return {Boolean}\n */\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nvar isArguments = function (value) {\n    return is_type_1.default(value, 'Arguments');\n};\nexports.default = isArguments;\n//# sourceMappingURL=is-arguments.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js ***!\n  \\************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isArrayLike = function (value) {\n    /**\n     * isArrayLike([1, 2, 3]) => true\n     * isArrayLike(document.body.children) => true\n     * isArrayLike('abc') => true\n     * isArrayLike(Function) => false\n     */\n    return value !== null && typeof value !== 'function' && isFinite(value.length);\n};\nexports.default = isArrayLike;\n//# sourceMappingURL=is-array-like.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nexports.default = (function (value) {\n    return Array.isArray ?\n        Array.isArray(value) :\n        is_type_1.default(value, 'Array');\n});\n//# sourceMappingURL=is-array.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-boolean.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-boolean.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 是否是布尔类型\n *\n * @param {Object} value 测试的值\n * @return {Boolean}\n */\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nvar isBoolean = function (value) {\n    return is_type_1.default(value, 'Boolean');\n};\nexports.default = isBoolean;\n//# sourceMappingURL=is-boolean.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-date.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-date.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nvar isDate = function (value) {\n    return is_type_1.default(value, 'Date');\n};\nexports.default = isDate;\n//# sourceMappingURL=is-date.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-decimal.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-decimal.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nvar isDecimal = function (num) {\n    return is_number_1.default(num) && num % 1 !== 0;\n};\nexports.default = isDecimal;\n//# sourceMappingURL=is-decimal.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-element.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-element.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 判断是否HTML元素\n * @return {Boolean} 是否HTML元素\n */\nvar isElement = function (o) {\n    return o instanceof Element || o instanceof HTMLDocument;\n};\nexports.default = isElement;\n//# sourceMappingURL=is-element.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-empty.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-empty.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar get_type_1 = __webpack_require__(/*! ./get-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/get-type.js\");\nvar is_prototype_1 = __webpack_require__(/*! ./is-prototype */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-prototype.js\");\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction isEmpty(value) {\n    /**\n     * isEmpty(null) => true\n     * isEmpty() => true\n     * isEmpty(true) => true\n     * isEmpty(1) => true\n     * isEmpty([1, 2, 3]) => false\n     * isEmpty('abc') => false\n     * isEmpty({ a: 1 }) => false\n     */\n    if (is_nil_1.default(value)) {\n        return true;\n    }\n    if (is_array_like_1.default(value)) {\n        return !value.length;\n    }\n    var type = get_type_1.default(value);\n    if (type === 'Map' || type === 'Set') {\n        return !value.size;\n    }\n    if (is_prototype_1.default(value)) {\n        return !Object.keys(value).length;\n    }\n    for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.default = isEmpty;\n//# sourceMappingURL=is-empty.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-equal-with.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-equal-with.js ***!\n  \\************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nvar is_equal_1 = __webpack_require__(/*! ./is-equal */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-equal.js\");\n/**\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [fn] The function to customize comparisons.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * function isGreeting(value) {\n *   return /^h(?:i|ello)$/.test(value);\n * }\n *\n * function customizer(objValue, othValue) {\n *   if (isGreeting(objValue) && isGreeting(othValue)) {\n *     return true;\n *   }\n * }\n *\n * var array = ['hello', 'goodbye'];\n * var other = ['hi', 'goodbye'];\n *\n * isEqualWith(array, other, customizer);  // => true\n */\nexports.default = (function (value, other, fn) {\n    if (!is_function_1.default(fn)) {\n        return is_equal_1.default(value, other);\n    }\n    return !!fn(value, other);\n});\n//# sourceMappingURL=is-equal-with.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-equal.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-equal.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_object_like_1 = __webpack_require__(/*! ./is-object-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object-like.js\");\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar is_string_1 = __webpack_require__(/*! ./is-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\");\nvar isEqual = function (value, other) {\n    if (value === other) {\n        return true;\n    }\n    if (!value || !other) {\n        return false;\n    }\n    if (is_string_1.default(value) || is_string_1.default(other)) {\n        return false;\n    }\n    if (is_array_like_1.default(value) || is_array_like_1.default(other)) {\n        if (value.length !== other.length) {\n            return false;\n        }\n        var rst = true;\n        for (var i = 0; i < value.length; i++) {\n            rst = isEqual(value[i], other[i]);\n            if (!rst) {\n                break;\n            }\n        }\n        return rst;\n    }\n    if (is_object_like_1.default(value) || is_object_like_1.default(other)) {\n        var valueKeys = Object.keys(value);\n        var otherKeys = Object.keys(other);\n        if (valueKeys.length !== otherKeys.length) {\n            return false;\n        }\n        var rst = true;\n        for (var i = 0; i < valueKeys.length; i++) {\n            rst = isEqual(value[valueKeys[i]], other[valueKeys[i]]);\n            if (!rst) {\n                break;\n            }\n        }\n        return rst;\n    }\n    return false;\n};\nexports.default = isEqual;\n//# sourceMappingURL=is-equal.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-error.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-error.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 是否是参数类型\n *\n * @param {Object} value 测试的值\n * @return {Boolean}\n */\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nvar isError = function (value) {\n    return is_type_1.default(value, 'Error');\n};\nexports.default = isError;\n//# sourceMappingURL=is-error.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-even.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-even.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nvar isEven = function (num) {\n    return is_number_1.default(num) && num % 2 === 0;\n};\nexports.default = isEven;\n//# sourceMappingURL=is-even.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-finite.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-finite.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 判断是否为有限数\n * @return {Boolean}\n */\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nfunction default_1(value) {\n    return is_number_1.default(value) && isFinite(value);\n}\nexports.default = default_1;\n//# sourceMappingURL=is-finite.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 是否为函数\n * @param  {*} fn 对象\n * @return {Boolean}  是否函数\n */\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nexports.default = (function (value) {\n    return is_type_1.default(value, 'Function');\n});\n//# sourceMappingURL=is-function.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-integer.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-integer.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nvar isInteger = Number.isInteger ? Number.isInteger : function (num) {\n    return is_number_1.default(num) && num % 1 === 0;\n};\nexports.default = isInteger;\n//# sourceMappingURL=is-integer.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-match.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-match.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nvar keys_1 = __webpack_require__(/*! ./keys */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/keys.js\");\nfunction isMatch(obj, attrs) {\n    var _keys = keys_1.default(attrs);\n    var length = _keys.length;\n    if (is_nil_1.default(obj))\n        return !length;\n    for (var i = 0; i < length; i += 1) {\n        var key = _keys[i];\n        if (attrs[key] !== obj[key] || !(key in obj)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.default = isMatch;\n//# sourceMappingURL=is-match.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-negative.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-negative.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nvar isNegative = function (num) {\n    return is_number_1.default(num) && num < 0;\n};\nexports.default = isNegative;\n//# sourceMappingURL=is-negative.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// isFinite,\nvar isNil = function (value) {\n    /**\n     * isNil(null) => true\n     * isNil() => true\n     */\n    return value === null || value === undefined;\n};\nexports.default = isNil;\n//# sourceMappingURL=is-nil.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-null.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-null.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isNull = function (value) {\n    return value === null;\n};\nexports.default = isNull;\n//# sourceMappingURL=is-null.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number-equal.js\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number-equal.js ***!\n  \\**************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar PRECISION = 0.00001; // numbers less than this is considered as 0\nfunction isNumberEqual(a, b, precision) {\n    if (precision === void 0) { precision = PRECISION; }\n    return Math.abs((a - b)) < precision;\n}\nexports.default = isNumberEqual;\n;\n//# sourceMappingURL=is-number-equal.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 判断是否数字\n * @return {Boolean} 是否数字\n */\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nvar isNumber = function (value) {\n    return is_type_1.default(value, 'Number');\n};\nexports.default = isNumber;\n//# sourceMappingURL=is-number.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object-like.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object-like.js ***!\n  \\*************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isObjectLike = function (value) {\n    /**\n     * isObjectLike({}) => true\n     * isObjectLike([1, 2, 3]) => true\n     * isObjectLike(Function) => false\n     * isObjectLike(null) => false\n     */\n    return typeof value === 'object' && value !== null;\n};\nexports.default = isObjectLike;\n//# sourceMappingURL=is-object-like.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (function (value) {\n    /**\n     * isObject({}) => true\n     * isObject([1, 2, 3]) => true\n     * isObject(Function) => true\n     * isObject(null) => false\n     */\n    var type = typeof value;\n    return value !== null && type === 'object' || type === 'function';\n});\n//# sourceMappingURL=is-object.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-odd.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-odd.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nvar isOdd = function (num) {\n    return is_number_1.default(num) && num % 2 !== 0;\n};\nexports.default = isOdd;\n//# sourceMappingURL=is-odd.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-plain-object.js\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-plain-object.js ***!\n  \\**************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_object_like_1 = __webpack_require__(/*! ./is-object-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object-like.js\");\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nvar isPlainObject = function (value) {\n    /**\n     * isObjectLike(new Foo) => false\n     * isObjectLike([1, 2, 3]) => false\n     * isObjectLike({ x: 0, y: 0 }) => true\n     * isObjectLike(Object.create(null)) => true\n     */\n    if (!is_object_like_1.default(value) || !is_type_1.default(value, 'Object')) {\n        return false;\n    }\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n    var proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n};\nexports.default = isPlainObject;\n//# sourceMappingURL=is-plain-object.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-positive.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-positive.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\nvar isPositive = function (num) {\n    return is_number_1.default(num) && num > 0;\n};\nexports.default = isPositive;\n//# sourceMappingURL=is-positive.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-prototype.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-prototype.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar objectProto = Object.prototype;\nvar isPrototype = function (value) {\n    var Ctor = value && value.constructor;\n    var proto = (typeof Ctor === 'function' && Ctor.prototype) || objectProto;\n    return value === proto;\n};\nexports.default = isPrototype;\n//# sourceMappingURL=is-prototype.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-reg-exp.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-reg-exp.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nvar isRegExp = function (str) {\n    return is_type_1.default(str, 'RegExp');\n};\nexports.default = isRegExp;\n//# sourceMappingURL=is-reg-exp.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_type_1 = __webpack_require__(/*! ./is-type */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\");\nexports.default = (function (str) {\n    return is_type_1.default(str, 'String');\n});\n//# sourceMappingURL=is-string.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-type.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar toString = {}.toString;\nvar isType = function (value, type) { return toString.call(value) === '[object ' + type + ']'; };\nexports.default = isType;\n//# sourceMappingURL=is-type.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-undefined.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-undefined.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isUndefined = function (value) {\n    return value === undefined;\n};\nexports.default = isUndefined;\n//# sourceMappingURL=is-undefined.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/keys.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/keys.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nvar keys = Object.keys ? function (obj) { return Object.keys(obj); } : function (obj) {\n    var result = [];\n    each_1.default(obj, function (value, key) {\n        if (!(is_function_1.default(obj) && key === 'prototype')) {\n            result.push(key);\n        }\n    });\n    return result;\n};\nexports.default = keys;\n//# sourceMappingURL=keys.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/last.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/last.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nfunction last(o) {\n    if (is_array_like_1.default(o)) {\n        var arr = o;\n        return arr[arr.length - 1];\n    }\n    return undefined;\n}\nexports.default = last;\n//# sourceMappingURL=last.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/lower-case.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/lower-case.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar to_string_1 = __webpack_require__(/*! ./to-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-string.js\");\nvar lowerCase = function (str) {\n    return to_string_1.default(str).toLowerCase();\n};\nexports.default = lowerCase;\n//# sourceMappingURL=lower-case.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/lower-first.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/lower-first.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar to_string_1 = __webpack_require__(/*! ./to-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-string.js\");\nvar lowerFirst = function (value) {\n    var str = to_string_1.default(value);\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\nexports.default = lowerFirst;\n//# sourceMappingURL=lower-first.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/map-values.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/map-values.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nvar is_object_1 = __webpack_require__(/*! ./is-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object.js\");\nvar identity = function (v) { return v; };\nexports.default = (function (object, func) {\n    if (func === void 0) { func = identity; }\n    var r = {};\n    if (is_object_1.default(object) && !is_nil_1.default(object)) {\n        Object.keys(object).forEach(function (key) {\n            // @ts-ignore\n            r[key] = func(object[key], key);\n        });\n    }\n    return r;\n});\n//# sourceMappingURL=map-values.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/map.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/map.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar map = function (arr, func) {\n    if (!is_array_like_1.default(arr)) {\n        // @ts-ignore\n        return arr;\n    }\n    var result = [];\n    each_1.default(arr, function (value, index) {\n        result.push(func(value, index));\n    });\n    return result;\n};\nexports.default = map;\n//# sourceMappingURL=map.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/max-by.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/max-by.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\n/**\n * @param {Array} arr The array to iterate over.\n * @param {Function} [fn] The iteratee invoked per element.\n * @return {*} Returns the maximum value.\n * @example\n *\n * var objects = [{ 'n': 1 }, { 'n': 2 }];\n *\n * maxBy(objects, function(o) { return o.n; });\n * // => { 'n': 2 }\n *\n * maxBy(objects, 'n');\n * // => { 'n': 2 }\n */\nexports.default = (function (arr, fn) {\n    if (!is_array_1.default(arr)) {\n        return undefined;\n    }\n    var max = arr[0];\n    var maxData;\n    if (is_function_1.default(fn)) {\n        maxData = fn(arr[0]);\n    }\n    else {\n        maxData = arr[0][fn];\n    }\n    var data;\n    each_1.default(arr, function (val) {\n        if (is_function_1.default(fn)) {\n            data = fn(val);\n        }\n        else {\n            data = val[fn];\n        }\n        if (data > maxData) {\n            max = val;\n            maxData = data;\n        }\n    });\n    return max;\n});\n//# sourceMappingURL=max-by.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/memoize.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/memoize.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\n/**\n * _.memoize(calColor);\n * _.memoize(calColor, (...args) => args[0]);\n * @param f\n * @param resolver\n */\nexports.default = (function (f, resolver) {\n    if (!is_function_1.default(f)) {\n        throw new TypeError('Expected a function');\n    }\n    var memoized = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // 使用方法构造 key，如果不存在 resolver，则直接取第一个参数作为 key\n        var key = resolver ? resolver.apply(this, args) : args[0];\n        var cache = memoized.cache;\n        if (cache.has(key)) {\n            return cache.get(key);\n        }\n        var result = f.apply(this, args);\n        // 缓存起来\n        cache.set(key, result);\n        return result;\n    };\n    memoized.cache = new Map();\n    return memoized;\n});\n//# sourceMappingURL=memoize.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/min-by.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/min-by.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\n/**\n * @param {Array} arr The array to iterate over.\n * @param {Function} [fn] The iteratee invoked per element.\n * @return {*} Returns the minimum value.\n * @example\n *\n * var objects = [{ 'n': 1 }, { 'n': 2 }];\n *\n * minBy(objects, function(o) { return o.n; });\n * // => { 'n': 1 }\n *\n * minBy(objects, 'n');\n * // => { 'n': 1 }\n */\nexports.default = (function (arr, fn) {\n    if (!is_array_1.default(arr)) {\n        return undefined;\n    }\n    var min = arr[0];\n    var minData;\n    if (is_function_1.default(fn)) {\n        minData = fn(arr[0]);\n    }\n    else {\n        minData = arr[0][fn];\n    }\n    var data;\n    each_1.default(arr, function (val) {\n        if (is_function_1.default(fn)) {\n            data = fn(val);\n        }\n        else {\n            data = val[fn];\n        }\n        if (data < minData) {\n            min = val;\n            minData = data;\n        }\n    });\n    return min;\n});\n//# sourceMappingURL=min-by.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/mix.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/mix.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// FIXME: Mutable param should be forbidden in static lang.\nfunction _mix(dist, obj) {\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {\n            dist[key] = obj[key];\n        }\n    }\n}\nfunction mix(dist, src1, src2, src3) {\n    if (src1)\n        _mix(dist, src1);\n    if (src2)\n        _mix(dist, src2);\n    if (src3)\n        _mix(dist, src3);\n    return dist;\n}\nexports.default = mix;\n//# sourceMappingURL=mix.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/mod.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/mod.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar mod = function (n, m) {\n    return ((n % m) + m) % m;\n};\nexports.default = mod;\n//# sourceMappingURL=mod.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/noop.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/noop.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (function () { });\n//# sourceMappingURL=noop.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/number2color.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/number2color.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar numColorCache = {};\nfunction numberToColor(num) {\n    // 增加缓存\n    var color = numColorCache[num];\n    if (!color) {\n        var str = num.toString(16);\n        for (var i = str.length; i < 6; i++) {\n            str = '0' + str;\n        }\n        color = '#' + str;\n        numColorCache[num] = color;\n    }\n    return color;\n}\nexports.default = numberToColor;\n//# sourceMappingURL=number2color.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/parse-radius.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/parse-radius.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nfunction parseRadius(radius) {\n    var r1 = 0, r2 = 0, r3 = 0, r4 = 0;\n    if (is_array_1.default(radius)) {\n        if (radius.length === 1) {\n            r1 = r2 = r3 = r4 = radius[0];\n        }\n        else if (radius.length === 2) {\n            r1 = r3 = radius[0];\n            r2 = r4 = radius[1];\n        }\n        else if (radius.length === 3) {\n            r1 = radius[0];\n            r2 = r4 = radius[1];\n            r3 = radius[2];\n        }\n        else {\n            r1 = radius[0];\n            r2 = radius[1];\n            r3 = radius[2];\n            r4 = radius[3];\n        }\n    }\n    else {\n        r1 = r2 = r3 = r4 = radius;\n    }\n    return {\n        r1: r1,\n        r2: r2,\n        r3: r3,\n        r4: r4\n    };\n}\nexports.default = parseRadius;\n//# sourceMappingURL=parse-radius.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/pick.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/pick.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_plain_object_1 = __webpack_require__(/*! ./is-plain-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-plain-object.js\");\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexports.default = (function (object, keys) {\n    if (object === null || !is_plain_object_1.default(object)) {\n        return {};\n    }\n    var result = {};\n    each_1.default(keys, function (key) {\n        if (hasOwnProperty.call(object, key)) {\n            result[key] = object[key];\n        }\n    });\n    return result;\n});\n//# sourceMappingURL=pick.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/pull-at.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/pull-at.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar splice = Array.prototype.splice;\nvar pullAt = function pullAt(arr, indexes) {\n    if (!is_array_like_1.default(arr)) {\n        return [];\n    }\n    var length = arr ? indexes.length : 0;\n    var last = length - 1;\n    while (length--) {\n        var previous = void 0;\n        var index = indexes[length];\n        if (length === last || index !== previous) {\n            previous = index;\n            splice.call(arr, index, 1);\n        }\n    }\n    return arr;\n};\nexports.default = pullAt;\n//# sourceMappingURL=pull-at.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/pull.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/pull.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar arrPrototype = Array.prototype;\nvar splice = arrPrototype.splice;\nvar indexOf = arrPrototype.indexOf;\nvar pull = function (arr) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        values[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        var fromIndex = -1;\n        while ((fromIndex = indexOf.call(arr, value)) > -1) {\n            splice.call(arr, fromIndex, 1);\n        }\n    }\n    return arr;\n};\nexports.default = pull;\n//# sourceMappingURL=pull.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/reduce.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/reduce.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_plain_object_1 = __webpack_require__(/*! ./is-plain-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-plain-object.js\");\nvar reduce = function (arr, fn, init) {\n    if (!is_array_1.default(arr) && !is_plain_object_1.default(arr)) {\n        return arr;\n    }\n    var result = init;\n    each_1.default(arr, function (data, i) {\n        result = fn(result, data, i);\n    });\n    return result;\n};\nexports.default = reduce;\n//# sourceMappingURL=reduce.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/remove.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/remove.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nvar pull_at_1 = __webpack_require__(/*! ./pull-at */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/pull-at.js\");\nvar remove = function (arr, predicate) {\n    /**\n     * const arr = [1, 2, 3, 4]\n     * const evens = remove(arr, n => n % 2 == 0)\n     * console.log(arr) // => [1, 3]\n     * console.log(evens) // => [2, 4]\n     */\n    var result = [];\n    if (!is_array_like_1.default(arr)) {\n        return result;\n    }\n    var i = -1;\n    var indexes = [];\n    var length = arr.length;\n    while (++i < length) {\n        var value = arr[i];\n        if (predicate(value, i, arr)) {\n            result.push(value);\n            indexes.push(i);\n        }\n    }\n    pull_at_1.default(arr, indexes);\n    return result;\n};\nexports.default = remove;\n//# sourceMappingURL=remove.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/request-animation-frame.js\":\n/*!**********************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/request-animation-frame.js ***!\n  \\**********************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction requestAnimationFrame(fn) {\n    var method = window.requestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        // @ts-ignore\n        window.mozRequestAnimationFrame ||\n        // @ts-ignore\n        window.msRequestAnimationFrame ||\n        function (f) {\n            return setTimeout(f, 16);\n        };\n    return method(fn);\n}\nexports.default = requestAnimationFrame;\n;\n//# sourceMappingURL=request-animation-frame.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/set.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/set.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_object_1 = __webpack_require__(/*! ./is-object */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-object.js\");\nvar is_string_1 = __webpack_require__(/*! ./is-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\");\nvar is_number_1 = __webpack_require__(/*! ./is-number */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-number.js\");\n/**\n * https://github.com/developit/dlv/blob/master/index.js\n * @param obj\n * @param path\n * @param value\n */\nexports.default = (function (obj, path, value) {\n    var o = obj;\n    var keyArr = is_string_1.default(path) ? path.split('.') : path;\n    keyArr.forEach(function (key, idx) {\n        // 不是最后一个\n        if (idx < keyArr.length - 1) {\n            if (!is_object_1.default(o[key])) {\n                o[key] = is_number_1.default(keyArr[idx + 1]) ? [] : {};\n            }\n            o = o[key];\n        }\n        else {\n            o[key] = value;\n        }\n    });\n    return obj;\n});\n//# sourceMappingURL=set.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/size.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/size.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nfunction size(o) {\n    if (is_nil_1.default(o)) {\n        return 0;\n    }\n    if (is_array_like_1.default(o)) {\n        return o.length;\n    }\n    return Object.keys(o).length;\n}\nexports.default = size;\n//# sourceMappingURL=size.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/some.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/some.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 只要有一个满足条件就返回 true\n * @param arr\n * @param func\n */\nvar some = function (arr, func) {\n    for (var i = 0; i < arr.length; i++) {\n        if (func(arr[i], i))\n            return true;\n    }\n    return false;\n};\nexports.default = some;\n//# sourceMappingURL=some.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/sort-by.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/sort-by.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_string_1 = __webpack_require__(/*! ./is-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\nfunction sortBy(arr, key) {\n    var comparer;\n    if (is_function_1.default(key)) {\n        comparer = function (a, b) { return key(a) - key(b); };\n    }\n    else {\n        var keys_1 = [];\n        if (is_string_1.default(key)) {\n            keys_1.push(key);\n        }\n        else if (is_array_1.default(key)) {\n            keys_1 = key;\n        }\n        comparer = function (a, b) {\n            for (var i = 0; i < keys_1.length; i += 1) {\n                var prop = keys_1[i];\n                if (a[prop] > b[prop]) {\n                    return 1;\n                }\n                if (a[prop] < b[prop]) {\n                    return -1;\n                }\n            }\n            return 0;\n        };\n    }\n    arr.sort(comparer);\n    return arr;\n}\nexports.default = sortBy;\n//# sourceMappingURL=sort-by.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/starts-with.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/starts-with.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_string_1 = __webpack_require__(/*! ./is-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-string.js\");\nfunction startsWith(arr, e) {\n    return (is_array_1.default(arr) || is_string_1.default(arr)) ? arr[0] === e : false;\n}\nexports.default = startsWith;\n//# sourceMappingURL=starts-with.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/substitute.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/substitute.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction substitute(str, o) {\n    if (!str || !o) {\n        return str;\n    }\n    return str.replace(/\\\\?\\{([^{}]+)\\}/g, function (match, name) {\n        if (match.charAt(0) === '\\\\') {\n            return match.slice(1);\n        }\n        return (o[name] === undefined) ? '' : o[name];\n    });\n}\nexports.default = substitute;\n//# sourceMappingURL=substitute.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/throttle.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/throttle.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (function (func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options)\n        options = {};\n    var later = function () {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout)\n            context = args = null;\n    };\n    var throttled = function () {\n        var now = Date.now();\n        if (!previous && options.leading === false)\n            previous = now;\n        var remaining = wait - (now - previous);\n        context = this;\n        args = arguments;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            result = func.apply(context, args);\n            if (!timeout)\n                context = args = null;\n        }\n        else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(later, remaining);\n        }\n        return result;\n    };\n    throttled.cancel = function () {\n        clearTimeout(timeout);\n        previous = 0;\n        timeout = context = args = null;\n    };\n    return throttled;\n});\n//# sourceMappingURL=throttle.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-array.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-array.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_array_like_1 = __webpack_require__(/*! ./is-array-like */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array-like.js\");\nexports.default = (function (value) {\n    return is_array_like_1.default(value) ? Array.prototype.slice.call(value) : [];\n});\n//# sourceMappingURL=to-array.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-degree.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-degree.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar DEGREE = 180 / Math.PI;\nvar toDegree = function (radian) {\n    return DEGREE * radian;\n};\nexports.default = toDegree;\n//# sourceMappingURL=to-degree.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-integer.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-integer.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = parseInt;\n//# sourceMappingURL=to-integer.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-radian.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-radian.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar RADIAN = Math.PI / 180;\nvar toRadian = function (degree) {\n    return RADIAN * degree;\n};\nexports.default = toRadian;\n//# sourceMappingURL=to-radian.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-string.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-string.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nexports.default = (function (value) {\n    if (is_nil_1.default(value))\n        return '';\n    return value.toString();\n});\n//# sourceMappingURL=to-string.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/union.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/union.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar uniq_1 = __webpack_require__(/*! ./uniq */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/uniq.js\");\nvar union = function () {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    return uniq_1.default([].concat.apply([], sources));\n};\nexports.default = union;\n//# sourceMappingURL=union.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/uniq.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/uniq.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar contains_1 = __webpack_require__(/*! ./contains */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/contains.js\");\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar uniq = function (arr) {\n    var resultArr = [];\n    each_1.default(arr, function (item) {\n        if (!contains_1.default(resultArr, item)) {\n            resultArr.push(item);\n        }\n    });\n    return resultArr;\n};\nexports.default = uniq;\n//# sourceMappingURL=uniq.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/unique-id.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/unique-id.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar map = {};\nexports.default = (function (prefix) {\n    prefix = prefix || 'g';\n    if (!map[prefix]) {\n        map[prefix] = 1;\n    }\n    else {\n        map[prefix] += 1;\n    }\n    return prefix + map[prefix];\n});\n//# sourceMappingURL=unique-id.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/upper-case.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/upper-case.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar to_string_1 = __webpack_require__(/*! ./to-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-string.js\");\nvar upperCase = function (str) {\n    return to_string_1.default(str).toUpperCase();\n};\nexports.default = upperCase;\n//# sourceMappingURL=upper-case.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/upper-first.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/upper-first.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar to_string_1 = __webpack_require__(/*! ./to-string */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/to-string.js\");\nvar upperFirst = function (value) {\n    var str = to_string_1.default(value);\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\nexports.default = upperFirst;\n//# sourceMappingURL=upper-first.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/values-of-key.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/values-of-key.js ***!\n  \\************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_array_1 = __webpack_require__(/*! ./is-array */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-array.js\");\nvar is_nil_1 = __webpack_require__(/*! ./is-nil */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-nil.js\");\nexports.default = (function (data, name) {\n    var rst = [];\n    var tmpMap = {};\n    data.forEach(function (obj) {\n        var value = obj[name];\n        if (!is_nil_1.default(value)) {\n            // flatten\n            if (!is_array_1.default(value)) {\n                value = [value];\n            }\n            each_1.default(value, function (val) {\n                // unique\n                if (!tmpMap[val]) {\n                    rst.push(val);\n                    tmpMap[val] = true;\n                }\n            });\n        }\n    });\n    return rst;\n});\n//# sourceMappingURL=values-of-key.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/values.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/values.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar each_1 = __webpack_require__(/*! ./each */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/each.js\");\nvar is_function_1 = __webpack_require__(/*! ./is-function */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/is-function.js\");\n// @ts-ignore\nvar values = Object.values ? function (obj) { return Object.values(obj); } : function (obj) {\n    var result = [];\n    each_1.default(obj, function (value, key) {\n        if (!(is_function_1.default(obj) && key === 'prototype')) {\n            result.push(value);\n        }\n    });\n    return result;\n};\nexports.default = values;\n//# sourceMappingURL=values.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/wrap-behavior.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/_@antv_util@2.0.7@@antv/util/lib/wrap-behavior.js ***!\n  \\************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * 封装事件，便于使用上下文this,和便于解除事件时使用\n * @protected\n * @param  {Object} obj   对象\n * @param  {String} action 事件名称\n * @return {Function}        返回事件处理函数\n */\nfunction wrapBehavior(obj, action) {\n    if (obj['_wrap_' + action]) {\n        return obj['_wrap_' + action];\n    }\n    var method = function (e) {\n        obj[action](e);\n    };\n    obj['_wrap_' + action] = method;\n    return method;\n}\nexports.default = wrapBehavior;\n//# sourceMappingURL=wrap-behavior.js.map\n\n/***/ }),\n\n/***/ \"./node_modules/_abs-svg-path@0.1.1@abs-svg-path/index.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_abs-svg-path@0.1.1@abs-svg-path/index.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n\nmodule.exports = absolutize\n\n/**\n * redefine `path` with absolute coordinates\n *\n * @param {Array} path\n * @return {Array}\n */\n\nfunction absolutize(path){\n\tvar startX = 0\n\tvar startY = 0\n\tvar x = 0\n\tvar y = 0\n\n\treturn path.map(function(seg){\n\t\tseg = seg.slice()\n\t\tvar type = seg[0]\n\t\tvar command = type.toUpperCase()\n\n\t\t// is relative\n\t\tif (type != command) {\n\t\t\tseg[0] = command\n\t\t\tswitch (type) {\n\t\t\t\tcase 'a':\n\t\t\t\t\tseg[6] += x\n\t\t\t\t\tseg[7] += y\n\t\t\t\t\tbreak\n\t\t\t\tcase 'v':\n\t\t\t\t\tseg[1] += y\n\t\t\t\t\tbreak\n\t\t\t\tcase 'h':\n\t\t\t\t\tseg[1] += x\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tfor (var i = 1; i < seg.length;) {\n\t\t\t\t\t\tseg[i++] += x\n\t\t\t\t\t\tseg[i++] += y\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update cursor state\n\t\tswitch (command) {\n\t\t\tcase 'Z':\n\t\t\t\tx = startX\n\t\t\t\ty = startY\n\t\t\t\tbreak\n\t\t\tcase 'H':\n\t\t\t\tx = seg[1]\n\t\t\t\tbreak\n\t\t\tcase 'V':\n\t\t\t\ty = seg[1]\n\t\t\t\tbreak\n\t\t\tcase 'M':\n\t\t\t\tx = startX = seg[1]\n\t\t\t\ty = startY = seg[2]\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tx = seg[seg.length - 2]\n\t\t\t\ty = seg[seg.length - 1]\n\t\t}\n\n\t\treturn seg\n\t})\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-array/ v1.2.4 Copyright 2018 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports) :\n        undefined;\n}(this, (function (exports) {\n    'use strict';\n    function ascending(a, b) {\n        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n    }\n    function bisector(compare) {\n        if (compare.length === 1)\n            compare = ascendingComparator(compare);\n        return {\n            left: function (a, x, lo, hi) {\n                if (lo == null)\n                    lo = 0;\n                if (hi == null)\n                    hi = a.length;\n                while (lo < hi) {\n                    var mid = lo + hi >>> 1;\n                    if (compare(a[mid], x) < 0)\n                        lo = mid + 1;\n                    else\n                        hi = mid;\n                }\n                return lo;\n            },\n            right: function (a, x, lo, hi) {\n                if (lo == null)\n                    lo = 0;\n                if (hi == null)\n                    hi = a.length;\n                while (lo < hi) {\n                    var mid = lo + hi >>> 1;\n                    if (compare(a[mid], x) > 0)\n                        hi = mid;\n                    else\n                        lo = mid + 1;\n                }\n                return lo;\n            }\n        };\n    }\n    function ascendingComparator(f) {\n        return function (d, x) {\n            return ascending(f(d), x);\n        };\n    }\n    var ascendingBisect = bisector(ascending);\n    var bisectRight = ascendingBisect.right;\n    var bisectLeft = ascendingBisect.left;\n    function pairs(array, f) {\n        if (f == null)\n            f = pair;\n        var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);\n        while (i < n)\n            pairs[i] = f(p, p = array[++i]);\n        return pairs;\n    }\n    function pair(a, b) {\n        return [a, b];\n    }\n    function cross(values0, values1, reduce) {\n        var n0 = values0.length, n1 = values1.length, values = new Array(n0 * n1), i0, i1, i, value0;\n        if (reduce == null)\n            reduce = pair;\n        for (i0 = i = 0; i0 < n0; ++i0) {\n            for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {\n                values[i] = reduce(value0, values1[i1]);\n            }\n        }\n        return values;\n    }\n    function descending(a, b) {\n        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n    }\n    function number(x) {\n        return x === null ? NaN : +x;\n    }\n    function variance(values, valueof) {\n        var n = values.length, m = 0, i = -1, mean = 0, value, delta, sum = 0;\n        if (valueof == null) {\n            while (++i < n) {\n                if (!isNaN(value = number(values[i]))) {\n                    delta = value - mean;\n                    mean += delta / ++m;\n                    sum += delta * (value - mean);\n                }\n            }\n        }\n        else {\n            while (++i < n) {\n                if (!isNaN(value = number(valueof(values[i], i, values)))) {\n                    delta = value - mean;\n                    mean += delta / ++m;\n                    sum += delta * (value - mean);\n                }\n            }\n        }\n        if (m > 1)\n            return sum / (m - 1);\n    }\n    function deviation(array, f) {\n        var v = variance(array, f);\n        return v ? Math.sqrt(v) : v;\n    }\n    function extent(values, valueof) {\n        var n = values.length, i = -1, value, min, max;\n        if (valueof == null) {\n            while (++i < n) { // Find the first comparable value.\n                if ((value = values[i]) != null && value >= value) {\n                    min = max = value;\n                    while (++i < n) { // Compare the remaining values.\n                        if ((value = values[i]) != null) {\n                            if (min > value)\n                                min = value;\n                            if (max < value)\n                                max = value;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            while (++i < n) { // Find the first comparable value.\n                if ((value = valueof(values[i], i, values)) != null && value >= value) {\n                    min = max = value;\n                    while (++i < n) { // Compare the remaining values.\n                        if ((value = valueof(values[i], i, values)) != null) {\n                            if (min > value)\n                                min = value;\n                            if (max < value)\n                                max = value;\n                        }\n                    }\n                }\n            }\n        }\n        return [min, max];\n    }\n    var array = Array.prototype;\n    var slice = array.slice;\n    var map = array.map;\n    function constant(x) {\n        return function () {\n            return x;\n        };\n    }\n    function identity(x) {\n        return x;\n    }\n    function range(start, stop, step) {\n        start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n        var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = new Array(n);\n        while (++i < n) {\n            range[i] = start + i * step;\n        }\n        return range;\n    }\n    var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);\n    function ticks(start, stop, count) {\n        var reverse, i = -1, n, ticks, step;\n        stop = +stop, start = +start, count = +count;\n        if (start === stop && count > 0)\n            return [start];\n        if (reverse = stop < start)\n            n = start, start = stop, stop = n;\n        if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step))\n            return [];\n        if (step > 0) {\n            start = Math.ceil(start / step);\n            stop = Math.floor(stop / step);\n            ticks = new Array(n = Math.ceil(stop - start + 1));\n            while (++i < n)\n                ticks[i] = (start + i) * step;\n        }\n        else {\n            start = Math.floor(start * step);\n            stop = Math.ceil(stop * step);\n            ticks = new Array(n = Math.ceil(start - stop + 1));\n            while (++i < n)\n                ticks[i] = (start - i) / step;\n        }\n        if (reverse)\n            ticks.reverse();\n        return ticks;\n    }\n    function tickIncrement(start, stop, count) {\n        var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);\n        return power >= 0\n            ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n            : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n    }\n    function tickStep(start, stop, count) {\n        var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;\n        if (error >= e10)\n            step1 *= 10;\n        else if (error >= e5)\n            step1 *= 5;\n        else if (error >= e2)\n            step1 *= 2;\n        return stop < start ? -step1 : step1;\n    }\n    function sturges(values) {\n        return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n    }\n    function histogram() {\n        var value = identity, domain = extent, threshold = sturges;\n        function histogram(data) {\n            var i, n = data.length, x, values = new Array(n);\n            for (i = 0; i < n; ++i) {\n                values[i] = value(data[i], i, data);\n            }\n            var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);\n            // Convert number of thresholds into uniform thresholds.\n            if (!Array.isArray(tz)) {\n                tz = tickStep(x0, x1, tz);\n                tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive\n            }\n            // Remove any thresholds outside the domain.\n            var m = tz.length;\n            while (tz[0] <= x0)\n                tz.shift(), --m;\n            while (tz[m - 1] > x1)\n                tz.pop(), --m;\n            var bins = new Array(m + 1), bin;\n            // Initialize bins.\n            for (i = 0; i <= m; ++i) {\n                bin = bins[i] = [];\n                bin.x0 = i > 0 ? tz[i - 1] : x0;\n                bin.x1 = i < m ? tz[i] : x1;\n            }\n            // Assign data to bins by value, ignoring any outside the domain.\n            for (i = 0; i < n; ++i) {\n                x = values[i];\n                if (x0 <= x && x <= x1) {\n                    bins[bisectRight(tz, x, 0, m)].push(data[i]);\n                }\n            }\n            return bins;\n        }\n        histogram.value = function (_) {\n            return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n        };\n        histogram.domain = function (_) {\n            return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n        };\n        histogram.thresholds = function (_) {\n            return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;\n        };\n        return histogram;\n    }\n    function quantile(values, p, valueof) {\n        if (valueof == null)\n            valueof = number;\n        if (!(n = values.length))\n            return;\n        if ((p = +p) <= 0 || n < 2)\n            return +valueof(values[0], 0, values);\n        if (p >= 1)\n            return +valueof(values[n - 1], n - 1, values);\n        var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);\n        return value0 + (value1 - value0) * (i - i0);\n    }\n    function freedmanDiaconis(values, min, max) {\n        values = map.call(values, number).sort(ascending);\n        return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));\n    }\n    function scott(values, min, max) {\n        return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));\n    }\n    function max(values, valueof) {\n        var n = values.length, i = -1, value, max;\n        if (valueof == null) {\n            while (++i < n) { // Find the first comparable value.\n                if ((value = values[i]) != null && value >= value) {\n                    max = value;\n                    while (++i < n) { // Compare the remaining values.\n                        if ((value = values[i]) != null && value > max) {\n                            max = value;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            while (++i < n) { // Find the first comparable value.\n                if ((value = valueof(values[i], i, values)) != null && value >= value) {\n                    max = value;\n                    while (++i < n) { // Compare the remaining values.\n                        if ((value = valueof(values[i], i, values)) != null && value > max) {\n                            max = value;\n                        }\n                    }\n                }\n            }\n        }\n        return max;\n    }\n    function mean(values, valueof) {\n        var n = values.length, m = n, i = -1, value, sum = 0;\n        if (valueof == null) {\n            while (++i < n) {\n                if (!isNaN(value = number(values[i])))\n                    sum += value;\n                else\n                    --m;\n            }\n        }\n        else {\n            while (++i < n) {\n                if (!isNaN(value = number(valueof(values[i], i, values))))\n                    sum += value;\n                else\n                    --m;\n            }\n        }\n        if (m)\n            return sum / m;\n    }\n    function median(values, valueof) {\n        var n = values.length, i = -1, value, numbers = [];\n        if (valueof == null) {\n            while (++i < n) {\n                if (!isNaN(value = number(values[i]))) {\n                    numbers.push(value);\n                }\n            }\n        }\n        else {\n            while (++i < n) {\n                if (!isNaN(value = number(valueof(values[i], i, values)))) {\n                    numbers.push(value);\n                }\n            }\n        }\n        return quantile(numbers.sort(ascending), 0.5);\n    }\n    function merge(arrays) {\n        var n = arrays.length, m, i = -1, j = 0, merged, array;\n        while (++i < n)\n            j += arrays[i].length;\n        merged = new Array(j);\n        while (--n >= 0) {\n            array = arrays[n];\n            m = array.length;\n            while (--m >= 0) {\n                merged[--j] = array[m];\n            }\n        }\n        return merged;\n    }\n    function min(values, valueof) {\n        var n = values.length, i = -1, value, min;\n        if (valueof == null) {\n            while (++i < n) { // Find the first comparable value.\n                if ((value = values[i]) != null && value >= value) {\n                    min = value;\n                    while (++i < n) { // Compare the remaining values.\n                        if ((value = values[i]) != null && min > value) {\n                            min = value;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            while (++i < n) { // Find the first comparable value.\n                if ((value = valueof(values[i], i, values)) != null && value >= value) {\n                    min = value;\n                    while (++i < n) { // Compare the remaining values.\n                        if ((value = valueof(values[i], i, values)) != null && min > value) {\n                            min = value;\n                        }\n                    }\n                }\n            }\n        }\n        return min;\n    }\n    function permute(array, indexes) {\n        var i = indexes.length, permutes = new Array(i);\n        while (i--)\n            permutes[i] = array[indexes[i]];\n        return permutes;\n    }\n    function scan(values, compare) {\n        if (!(n = values.length))\n            return;\n        var n, i = 0, j = 0, xi, xj = values[j];\n        if (compare == null)\n            compare = ascending;\n        while (++i < n) {\n            if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {\n                xj = xi, j = i;\n            }\n        }\n        if (compare(xj, xj) === 0)\n            return j;\n    }\n    function shuffle(array, i0, i1) {\n        var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0), t, i;\n        while (m) {\n            i = Math.random() * m-- | 0;\n            t = array[m + i0];\n            array[m + i0] = array[i + i0];\n            array[i + i0] = t;\n        }\n        return array;\n    }\n    function sum(values, valueof) {\n        var n = values.length, i = -1, value, sum = 0;\n        if (valueof == null) {\n            while (++i < n) {\n                if (value = +values[i])\n                    sum += value; // Note: zero and null are equivalent.\n            }\n        }\n        else {\n            while (++i < n) {\n                if (value = +valueof(values[i], i, values))\n                    sum += value;\n            }\n        }\n        return sum;\n    }\n    function transpose(matrix) {\n        if (!(n = matrix.length))\n            return [];\n        for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n            for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n                row[j] = matrix[j][i];\n            }\n        }\n        return transpose;\n    }\n    function length(d) {\n        return d.length;\n    }\n    function zip() {\n        return transpose(arguments);\n    }\n    exports.bisect = bisectRight;\n    exports.bisectRight = bisectRight;\n    exports.bisectLeft = bisectLeft;\n    exports.ascending = ascending;\n    exports.bisector = bisector;\n    exports.cross = cross;\n    exports.descending = descending;\n    exports.deviation = deviation;\n    exports.extent = extent;\n    exports.histogram = histogram;\n    exports.thresholdFreedmanDiaconis = freedmanDiaconis;\n    exports.thresholdScott = scott;\n    exports.thresholdSturges = sturges;\n    exports.max = max;\n    exports.mean = mean;\n    exports.median = median;\n    exports.merge = merge;\n    exports.min = min;\n    exports.pairs = pairs;\n    exports.permute = permute;\n    exports.quantile = quantile;\n    exports.range = range;\n    exports.scan = scan;\n    exports.shuffle = shuffle;\n    exports.sum = sum;\n    exports.ticks = ticks;\n    exports.tickIncrement = tickIncrement;\n    exports.tickStep = tickStep;\n    exports.transpose = transpose;\n    exports.variance = variance;\n    exports.zip = zip;\n    Object.defineProperty(exports, '__esModule', { value: true });\n})));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-collection@1.0.7@d3-collection/dist/d3-collection.js\":\n/*!*******************************************************************************!*\\\n  !*** ./node_modules/_d3-collection@1.0.7@d3-collection/dist/d3-collection.js ***!\n  \\*******************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-collection/ v1.0.7 Copyright 2018 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports) :\n        undefined;\n}(this, (function (exports) {\n    'use strict';\n    var prefix = \"$\";\n    function Map() { }\n    Map.prototype = map.prototype = {\n        constructor: Map,\n        has: function (key) {\n            return (prefix + key) in this;\n        },\n        get: function (key) {\n            return this[prefix + key];\n        },\n        set: function (key, value) {\n            this[prefix + key] = value;\n            return this;\n        },\n        remove: function (key) {\n            var property = prefix + key;\n            return property in this && delete this[property];\n        },\n        clear: function () {\n            for (var property in this)\n                if (property[0] === prefix)\n                    delete this[property];\n        },\n        keys: function () {\n            var keys = [];\n            for (var property in this)\n                if (property[0] === prefix)\n                    keys.push(property.slice(1));\n            return keys;\n        },\n        values: function () {\n            var values = [];\n            for (var property in this)\n                if (property[0] === prefix)\n                    values.push(this[property]);\n            return values;\n        },\n        entries: function () {\n            var entries = [];\n            for (var property in this)\n                if (property[0] === prefix)\n                    entries.push({ key: property.slice(1), value: this[property] });\n            return entries;\n        },\n        size: function () {\n            var size = 0;\n            for (var property in this)\n                if (property[0] === prefix)\n                    ++size;\n            return size;\n        },\n        empty: function () {\n            for (var property in this)\n                if (property[0] === prefix)\n                    return false;\n            return true;\n        },\n        each: function (f) {\n            for (var property in this)\n                if (property[0] === prefix)\n                    f(this[property], property.slice(1), this);\n        }\n    };\n    function map(object, f) {\n        var map = new Map;\n        // Copy constructor.\n        if (object instanceof Map)\n            object.each(function (value, key) { map.set(key, value); });\n        // Index array by numeric index or specified key function.\n        else if (Array.isArray(object)) {\n            var i = -1, n = object.length, o;\n            if (f == null)\n                while (++i < n)\n                    map.set(i, object[i]);\n            else\n                while (++i < n)\n                    map.set(f(o = object[i], i, object), o);\n        }\n        // Convert object to map.\n        else if (object)\n            for (var key in object)\n                map.set(key, object[key]);\n        return map;\n    }\n    function nest() {\n        var keys = [], sortKeys = [], sortValues, rollup, nest;\n        function apply(array, depth, createResult, setResult) {\n            if (depth >= keys.length) {\n                if (sortValues != null)\n                    array.sort(sortValues);\n                return rollup != null ? rollup(array) : array;\n            }\n            var i = -1, n = array.length, key = keys[depth++], keyValue, value, valuesByKey = map(), values, result = createResult();\n            while (++i < n) {\n                if (values = valuesByKey.get(keyValue = key(value = array[i]) + \"\")) {\n                    values.push(value);\n                }\n                else {\n                    valuesByKey.set(keyValue, [value]);\n                }\n            }\n            valuesByKey.each(function (values, key) {\n                setResult(result, key, apply(values, depth, createResult, setResult));\n            });\n            return result;\n        }\n        function entries(map$$1, depth) {\n            if (++depth > keys.length)\n                return map$$1;\n            var array, sortKey = sortKeys[depth - 1];\n            if (rollup != null && depth >= keys.length)\n                array = map$$1.entries();\n            else\n                array = [], map$$1.each(function (v, k) { array.push({ key: k, values: entries(v, depth) }); });\n            return sortKey != null ? array.sort(function (a, b) { return sortKey(a.key, b.key); }) : array;\n        }\n        return nest = {\n            object: function (array) { return apply(array, 0, createObject, setObject); },\n            map: function (array) { return apply(array, 0, createMap, setMap); },\n            entries: function (array) { return entries(apply(array, 0, createMap, setMap), 0); },\n            key: function (d) { keys.push(d); return nest; },\n            sortKeys: function (order) { sortKeys[keys.length - 1] = order; return nest; },\n            sortValues: function (order) { sortValues = order; return nest; },\n            rollup: function (f) { rollup = f; return nest; }\n        };\n    }\n    function createObject() {\n        return {};\n    }\n    function setObject(object, key, value) {\n        object[key] = value;\n    }\n    function createMap() {\n        return map();\n    }\n    function setMap(map$$1, key, value) {\n        map$$1.set(key, value);\n    }\n    function Set() { }\n    var proto = map.prototype;\n    Set.prototype = set.prototype = {\n        constructor: Set,\n        has: proto.has,\n        add: function (value) {\n            value += \"\";\n            this[prefix + value] = value;\n            return this;\n        },\n        remove: proto.remove,\n        clear: proto.clear,\n        values: proto.keys,\n        size: proto.size,\n        empty: proto.empty,\n        each: proto.each\n    };\n    function set(object, f) {\n        var set = new Set;\n        // Copy constructor.\n        if (object instanceof Set)\n            object.each(function (value) { set.add(value); });\n        // Otherwise, assume it’s an array.\n        else if (object) {\n            var i = -1, n = object.length;\n            if (f == null)\n                while (++i < n)\n                    set.add(object[i]);\n            else\n                while (++i < n)\n                    set.add(f(object[i], i, object));\n        }\n        return set;\n    }\n    function keys(map) {\n        var keys = [];\n        for (var key in map)\n            keys.push(key);\n        return keys;\n    }\n    function values(map) {\n        var values = [];\n        for (var key in map)\n            values.push(map[key]);\n        return values;\n    }\n    function entries(map) {\n        var entries = [];\n        for (var key in map)\n            entries.push({ key: key, value: map[key] });\n        return entries;\n    }\n    exports.nest = nest;\n    exports.set = set;\n    exports.map = map;\n    exports.keys = keys;\n    exports.values = values;\n    exports.entries = entries;\n    Object.defineProperty(exports, '__esModule', { value: true });\n})));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-composite-projections@1.3.2@d3-composite-projections/d3-composite-projections.js\":\n/*!***********************************************************************************************************!*\\\n  !*** ./node_modules/_d3-composite-projections@1.3.2@d3-composite-projections/d3-composite-projections.js ***!\n  \\***********************************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// http://geoexamples.com/d3-composite-projections/ v1.3.2 Copyright 2019 Roger Veciana i Rovira\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! d3-geo */ \"./node_modules/_d3-geo@1.11.9@d3-geo/dist/d3-geo.js\"), __webpack_require__(/*! d3-path */ \"./node_modules/_d3-path@1.0.9@d3-path/dist/d3-path.js\")) :\n        undefined;\n}(this, (function (exports, d3Geo, d3Path) {\n    'use strict';\n    var epsilon = 1e-6;\n    function noop() { }\n    var x0 = Infinity, y0 = x0, x1 = -x0, y1 = x1;\n    var boundsStream = {\n        point: boundsPoint,\n        lineStart: noop,\n        lineEnd: noop,\n        polygonStart: noop,\n        polygonEnd: noop,\n        result: function () {\n            var bounds = [[x0, y0], [x1, y1]];\n            x1 = y1 = -(y0 = x0 = Infinity);\n            return bounds;\n        }\n    };\n    function boundsPoint(x, y) {\n        if (x < x0)\n            x0 = x;\n        if (x > x1)\n            x1 = x;\n        if (y < y0)\n            y0 = y;\n        if (y > y1)\n            y1 = y;\n    }\n    function fitExtent(projection, extent, object) {\n        var w = extent[1][0] - extent[0][0], h = extent[1][1] - extent[0][1], clip = projection.clipExtent && projection.clipExtent();\n        projection\n            .scale(150)\n            .translate([0, 0]);\n        if (clip != null)\n            projection.clipExtent(null);\n        d3Geo.geoStream(object, projection.stream(boundsStream));\n        var b = boundsStream.result(), k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n        if (clip != null)\n            projection.clipExtent(clip);\n        return projection\n            .scale(k * 150)\n            .translate([x, y]);\n    }\n    function fitSize(projection, size, object) {\n        return fitExtent(projection, [[0, 0], size], object);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n)\n                streams[i].point(x, y); },\n            sphere: function () { var i = -1; while (++i < n)\n                streams[i].sphere(); },\n            lineStart: function () { var i = -1; while (++i < n)\n                streams[i].lineStart(); },\n            lineEnd: function () { var i = -1; while (++i < n)\n                streams[i].lineEnd(); },\n            polygonStart: function () { var i = -1; while (++i < n)\n                streams[i].polygonStart(); },\n            polygonEnd: function () { var i = -1; while (++i < n)\n                streams[i].polygonEnd(); }\n        };\n    }\n    // A composite projection for the United States, configured by default for\n    // 960×500. The projection also works quite well at 960×600 if you change the\n    // scale to 1285 and adjust the translate accordingly. The set of standard\n    // parallels for each region comes from USGS, which is published here:\n    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\n    function albersUsa() {\n        var cache, cacheStream, lower48 = d3Geo.geoAlbers(), lower48Point, alaska = d3Geo.geoConicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n        hawaii = d3Geo.geoConicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n        point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        function albersUsa(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (lower48Point.point(x, y), point)\n                    || (alaskaPoint.point(x, y), point)\n                    || (hawaiiPoint.point(x, y), point);\n        }\n        albersUsa.invert = function (coordinates) {\n            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n                : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n                    : lower48).invert(coordinates);\n        };\n        albersUsa.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n        };\n        albersUsa.precision = function (_) {\n            if (!arguments.length)\n                return lower48.precision();\n            lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n            return reset();\n        };\n        albersUsa.scale = function (_) {\n            if (!arguments.length)\n                return lower48.scale();\n            lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n            return albersUsa.translate(lower48.translate());\n        };\n        albersUsa.translate = function (_) {\n            if (!arguments.length)\n                return lower48.translate();\n            var k = lower48.scale(), x = +_[0], y = +_[1];\n            lower48Point = lower48\n                .translate(_)\n                .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n                .stream(pointStream);\n            alaskaPoint = alaska\n                .translate([x - 0.307 * k, y + 0.201 * k])\n                .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])\n                .stream(pointStream);\n            hawaiiPoint = hawaii\n                .translate([x - 0.205 * k, y + 0.212 * k])\n                .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        albersUsa.fitExtent = function (extent, object) {\n            return fitExtent(albersUsa, extent, object);\n        };\n        albersUsa.fitSize = function (size, object) {\n            return fitSize(albersUsa, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return albersUsa;\n        }\n        albersUsa.drawCompositionBorders = function (context) {\n            var hawaii1 = lower48([-102.91, 26.3]);\n            var hawaii2 = lower48([-104.0, 27.5]);\n            var hawaii3 = lower48([-108.0, 29.1]);\n            var hawaii4 = lower48([-110.0, 29.1]);\n            var alaska1 = lower48([-110.0, 26.7]);\n            var alaska2 = lower48([-112.8, 27.6]);\n            var alaska3 = lower48([-114.3, 30.6]);\n            var alaska4 = lower48([-119.3, 30.1]);\n            context.moveTo(hawaii1[0], hawaii1[1]);\n            context.lineTo(hawaii2[0], hawaii2[1]);\n            context.lineTo(hawaii3[0], hawaii3[1]);\n            context.lineTo(hawaii4[0], hawaii4[1]);\n            context.moveTo(alaska1[0], alaska1[1]);\n            context.lineTo(alaska2[0], alaska2[1]);\n            context.lineTo(alaska3[0], alaska3[1]);\n            context.lineTo(alaska4[0], alaska4[1]);\n        };\n        albersUsa.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return albersUsa.scale(1070);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$1(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n)\n                streams[i].point(x, y); },\n            sphere: function () { var i = -1; while (++i < n)\n                streams[i].sphere(); },\n            lineStart: function () { var i = -1; while (++i < n)\n                streams[i].lineStart(); },\n            lineEnd: function () { var i = -1; while (++i < n)\n                streams[i].lineEnd(); },\n            polygonStart: function () { var i = -1; while (++i < n)\n                streams[i].polygonStart(); },\n            polygonEnd: function () { var i = -1; while (++i < n)\n                streams[i].polygonEnd(); }\n        };\n    }\n    // A composite projection for the United States, configured by default for\n    // 960×500. Also works quite well at 960×600 with scale 1285. The set of\n    // standard parallels for each region comes from USGS, which is published here:\n    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\n    function albersUsaTerritories() {\n        var cache, cacheStream, lower48 = d3Geo.geoAlbers(), lower48Point, alaska = d3Geo.geoConicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n        hawaii = d3Geo.geoConicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n        puertoRico = d3Geo.geoConicEqualArea().rotate([66, 0]).center([0, 18]).parallels([8, 18]), puertoRicoPoint, //Taken from https://bl.ocks.org/mbostock/5629120\n        samoa = d3Geo.geoEquirectangular().rotate([173, 14]), samoaPoint, // EPSG:4169\n        guam = d3Geo.geoEquirectangular().rotate([-145, -16.8]), guamPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var puertoRicoBbox = [[-68.3, 19], [-63.9, 17]];\n        var samoaBbox = [[-171, -14], [-168, -14.8]];\n        var guamBbox = [[144, 20.8], [146.5, 12.7]];\n        */\n        function albersUsa(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (lower48Point.point(x, y), point) ||\n                    (alaskaPoint.point(x, y), point) ||\n                    (hawaiiPoint.point(x, y), point) ||\n                    (puertoRicoPoint.point(x, y), point) ||\n                    (samoaPoint.point(x, y), point) ||\n                    (guamPoint.point(x, y), point);\n        }\n        albersUsa.invert = function (coordinates) {\n            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            /*\n            //How are the return values calculated:\n            console.info(\"******\");\n            var c0 = puertoRico(puertoRicoBbox[0]);\n            var x0 = (c0[0] - t[0]) / k;\n            var y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 puertoRico\", x0 + ' - ' + y0);\n    \n            var c1 = puertoRico(puertoRicoBbox[1]);\n            var x1 = (c1[0] - t[0]) / k;\n            var y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 puertoRico\", x1 + ' - ' + y1);\n    \n            c0 = samoa(samoaBbox[0]);\n            x0 = (c0[0] - t[0]) / k;\n            y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 samoa\", x0 + ' - ' + y0);\n    \n            c1 = samoa(samoaBbox[1]);\n            x1 = (c1[0] - t[0]) / k;\n            y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 samoa\", x1 + ' - ' + y1);\n    \n            c0 = guam(guamBbox[0]);\n            x0 = (c0[0] - t[0]) / k;\n            y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 guam\", x0 + ' - ' + y0);\n    \n            c1 = guam(guamBbox[1]);\n            x1 = (c1[0] - t[0]) / k;\n            y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 guam\", x1 + ' - ' + y1);\n            */\n            return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n                : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n                    : y >= 0.2064 && y < 0.2413 && x >= 0.312 && x < 0.385 ? puertoRico\n                        : y >= 0.09 && y < 0.1197 && x >= -0.4243 && x < -0.3232 ? samoa\n                            : y >= -0.0518 && y < 0.0895 && x >= -0.4243 && x < -0.3824 ? guam\n                                : lower48).invert(coordinates);\n        };\n        albersUsa.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$1([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream), puertoRico.stream(stream), samoa.stream(stream), guam.stream(stream)]);\n        };\n        albersUsa.precision = function (_) {\n            if (!arguments.length) {\n                return lower48.precision();\n            }\n            lower48.precision(_);\n            alaska.precision(_);\n            hawaii.precision(_);\n            puertoRico.precision(_);\n            samoa.precision(_);\n            guam.precision(_);\n            return reset();\n        };\n        albersUsa.scale = function (_) {\n            if (!arguments.length) {\n                return lower48.scale();\n            }\n            lower48.scale(_);\n            alaska.scale(_ * 0.35);\n            hawaii.scale(_);\n            puertoRico.scale(_);\n            samoa.scale(_ * 2);\n            guam.scale(_);\n            return albersUsa.translate(lower48.translate());\n        };\n        albersUsa.translate = function (_) {\n            if (!arguments.length) {\n                return lower48.translate();\n            }\n            var k = lower48.scale(), x = +_[0], y = +_[1];\n            /*\n            var c0 = puertoRico.translate([x + 0.350 * k, y + 0.224 * k])(puertoRicoBbox[0]);\n            var x0 = (x - c0[0]) / k;\n            var y0 = (y - c0[1]) / k;\n        \n            var c1 = puertoRico.translate([x + 0.350 * k, y + 0.224 * k])(puertoRicoBbox[1]);\n            var x1 = (x - c1[0]) / k;\n            var y1 = (y - c1[1]) / k;\n        \n            console.info('puertoRico: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n            console.info('.clipExtent([[x '+\n             (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n             ' * k + epsilon, y '+\n             (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n             ' * k + epsilon],[x '+\n             (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n             ' * k - epsilon, y '+\n             (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n             ' * k - epsilon]])');\n        \n              c0 = samoa.translate([x - 0.492 * k, y + 0.09 * k])(samoaBbox[0]);\n              x0 = (x - c0[0]) / k;\n              y0 = (y - c0[1]) / k;\n        \n              c1 = samoa.translate([x - 0.492 * k, y + 0.09 * k])(samoaBbox[1]);\n              x1 = (x - c1[0]) / k;\n              y1 = (y - c1[1]) / k;\n        \n             console.info('samoa: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n             console.info('.clipExtent([[x '+\n              (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n              ' * k + epsilon, y '+\n              (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n              ' * k + epsilon],[x '+\n              (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n              ' * k - epsilon, y '+\n              (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n              ' * k - epsilon]])');\n        \n              c0 = guam.translate([x - 0.408 * k, y + 0.018 * k])(guamBbox[0]);\n              x0 = (x - c0[0]) / k;\n              y0 = (y - c0[1]) / k;\n        \n              c1 = guam.translate([x - 0.408 * k, y + 0.018 * k])(guamBbox[1]);\n              x1 = (x - c1[0]) / k;\n              y1 = (y - c1[1]) / k;\n        \n             console.info('guam: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n             console.info('.clipExtent([[x '+\n              (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n              ' * k + epsilon, y '+\n              (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n              ' * k + epsilon],[x '+\n              (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n              ' * k - epsilon, y '+\n              (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n              ' * k - epsilon]])');\n              */\n            lower48Point = lower48\n                .translate(_)\n                .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n                .stream(pointStream);\n            alaskaPoint = alaska\n                .translate([x - 0.307 * k, y + 0.201 * k])\n                .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.233 * k - epsilon]])\n                .stream(pointStream);\n            hawaiiPoint = hawaii\n                .translate([x - 0.205 * k, y + 0.212 * k])\n                .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.233 * k - epsilon]])\n                .stream(pointStream);\n            puertoRicoPoint = puertoRico\n                .translate([x + 0.350 * k, y + 0.224 * k])\n                .clipExtent([[x + 0.312 * k + epsilon, y + 0.2064 * k + epsilon], [x + 0.385 * k - epsilon, y + 0.233 * k - epsilon]])\n                .stream(pointStream);\n            samoaPoint = samoa\n                .translate([x - 0.492 * k, y + 0.09 * k])\n                .clipExtent([[x - 0.4243 * k + epsilon, y + 0.0903 * k + epsilon], [x - 0.3233 * k - epsilon, y + 0.1197 * k - epsilon]])\n                .stream(pointStream);\n            guamPoint = guam\n                .translate([x - 0.408 * k, y + 0.018 * k])\n                .clipExtent([[x - 0.4244 * k + epsilon, y - 0.0519 * k + epsilon], [x - 0.3824 * k - epsilon, y + 0.0895 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        albersUsa.fitExtent = function (extent, object) {\n            return fitExtent(albersUsa, extent, object);\n        };\n        albersUsa.fitSize = function (size, object) {\n            return fitSize(albersUsa, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return albersUsa;\n        }\n        albersUsa.drawCompositionBorders = function (context) {\n            /*\n            console.info(\"CLIP EXTENT hawaii: \", hawaii.clipExtent());\n            console.info(\"UL BBOX:\", lower48.invert([hawaii.clipExtent()[0][0], hawaii.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", lower48.invert([hawaii.clipExtent()[1][0], hawaii.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", lower48.invert([hawaii.clipExtent()[1][0], hawaii.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", lower48.invert([hawaii.clipExtent()[0][0], hawaii.clipExtent()[1][1]]));\n        \n            console.info(\"CLIP EXTENT alaska: \", alaska.clipExtent());\n            console.info(\"UL BBOX:\", lower48.invert([alaska.clipExtent()[0][0], alaska.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", lower48.invert([alaska.clipExtent()[1][0], alaska.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", lower48.invert([alaska.clipExtent()[1][0], alaska.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", lower48.invert([alaska.clipExtent()[0][0], alaska.clipExtent()[1][1]]));\n        \n            console.info(\"CLIP EXTENT puertoRico: \", puertoRico.clipExtent());\n            console.info(\"UL BBOX:\", lower48.invert([puertoRico.clipExtent()[0][0], puertoRico.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", lower48.invert([puertoRico.clipExtent()[1][0], puertoRico.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", lower48.invert([puertoRico.clipExtent()[1][0], puertoRico.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", lower48.invert([puertoRico.clipExtent()[0][0], puertoRico.clipExtent()[1][1]]));\n        \n            console.info(\"CLIP EXTENT samoa: \", samoa.clipExtent());\n            console.info(\"UL BBOX:\", lower48.invert([samoa.clipExtent()[0][0], samoa.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", lower48.invert([samoa.clipExtent()[1][0], samoa.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", lower48.invert([samoa.clipExtent()[1][0], samoa.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", lower48.invert([samoa.clipExtent()[0][0], samoa.clipExtent()[1][1]]));\n        \n        \n            console.info(\"CLIP EXTENT guam: \", guam.clipExtent());\n            console.info(\"UL BBOX:\", lower48.invert([guam.clipExtent()[0][0], guam.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", lower48.invert([guam.clipExtent()[1][0], guam.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", lower48.invert([guam.clipExtent()[1][0], guam.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", lower48.invert([guam.clipExtent()[0][0], guam.clipExtent()[1][1]]));\n            */\n            var ulhawaii = lower48([-110.4641, 28.2805]);\n            var urhawaii = lower48([-104.0597, 28.9528]);\n            var ldhawaii = lower48([-103.7049, 25.1031]);\n            var llhawaii = lower48([-109.8337, 24.4531]);\n            var ulalaska = lower48([-124.4745, 28.1407]);\n            var uralaska = lower48([-110.931, 30.8844]);\n            var ldalaska = lower48([-109.8337, 24.4531]);\n            var llalaska = lower48([-122.4628, 21.8562]);\n            var ulpuertoRico = lower48([-76.8579, 25.1544]);\n            var urpuertoRico = lower48([-72.429, 24.2097]);\n            var ldpuertoRico = lower48([-72.8265, 22.7056]);\n            var llpuertoRico = lower48([-77.1852, 23.6392]);\n            var ulsamoa = lower48([-125.0093, 29.7791]);\n            var ursamoa = lower48([-118.5193, 31.3262]);\n            var ldsamoa = lower48([-118.064, 29.6912]);\n            var llsamoa = lower48([-124.4369, 28.169]);\n            var ulguam = lower48([-128.1314, 37.4582]);\n            var urguam = lower48([-125.2132, 38.214]);\n            var ldguam = lower48([-122.3616, 30.5115]);\n            var llguam = lower48([-125.0315, 29.8211]);\n            context.moveTo(ulhawaii[0], ulhawaii[1]);\n            context.lineTo(urhawaii[0], urhawaii[1]);\n            context.lineTo(ldhawaii[0], ldhawaii[1]);\n            context.lineTo(ldhawaii[0], ldhawaii[1]);\n            context.lineTo(llhawaii[0], llhawaii[1]);\n            context.closePath();\n            context.moveTo(ulalaska[0], ulalaska[1]);\n            context.lineTo(uralaska[0], uralaska[1]);\n            context.lineTo(ldalaska[0], ldalaska[1]);\n            context.lineTo(ldalaska[0], ldalaska[1]);\n            context.lineTo(llalaska[0], llalaska[1]);\n            context.closePath();\n            context.moveTo(ulpuertoRico[0], ulpuertoRico[1]);\n            context.lineTo(urpuertoRico[0], urpuertoRico[1]);\n            context.lineTo(ldpuertoRico[0], ldpuertoRico[1]);\n            context.lineTo(ldpuertoRico[0], ldpuertoRico[1]);\n            context.lineTo(llpuertoRico[0], llpuertoRico[1]);\n            context.closePath();\n            context.moveTo(ulsamoa[0], ulsamoa[1]);\n            context.lineTo(ursamoa[0], ursamoa[1]);\n            context.lineTo(ldsamoa[0], ldsamoa[1]);\n            context.lineTo(ldsamoa[0], ldsamoa[1]);\n            context.lineTo(llsamoa[0], llsamoa[1]);\n            context.closePath();\n            context.moveTo(ulguam[0], ulguam[1]);\n            context.lineTo(urguam[0], urguam[1]);\n            context.lineTo(ldguam[0], ldguam[1]);\n            context.lineTo(ldguam[0], ldguam[1]);\n            context.lineTo(llguam[0], llguam[1]);\n            context.closePath();\n        };\n        albersUsa.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return albersUsa.scale(1070);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$2(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Spain, configured by default for 960×500.\n    function conicConformalSpain() {\n        var cache, cacheStream, iberianPeninsule = d3Geo.geoConicConformal().rotate([5, -38.6]).parallels([0, 60]), iberianPeninsulePoint, canaryIslands = d3Geo.geoConicConformal().rotate([5, -38.6]).parallels([0, 60]), canaryIslandsPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var iberianPeninsuleBbox = [[-11, 46], [4, 35]];\n        var canaryIslandsBbox = [[-19.0, 28.85], [-12.7, 28.1]];\n        */\n        function conicConformalSpain(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (iberianPeninsulePoint.point(x, y), point) ||\n                    (canaryIslandsPoint.point(x, y), point);\n        }\n        conicConformalSpain.invert = function (coordinates) {\n            var k = iberianPeninsule.scale(), t = iberianPeninsule.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= 0.05346 && y < 0.0897 && x >= -0.13388 && x < -0.0322 ? canaryIslands\n                : iberianPeninsule).invert(coordinates);\n        };\n        conicConformalSpain.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$2([iberianPeninsule.stream(cacheStream = stream), canaryIslands.stream(stream)]);\n        };\n        conicConformalSpain.precision = function (_) {\n            if (!arguments.length) {\n                return iberianPeninsule.precision();\n            }\n            iberianPeninsule.precision(_);\n            canaryIslands.precision(_);\n            return reset();\n        };\n        conicConformalSpain.scale = function (_) {\n            if (!arguments.length) {\n                return iberianPeninsule.scale();\n            }\n            iberianPeninsule.scale(_);\n            canaryIslands.scale(_);\n            return conicConformalSpain.translate(iberianPeninsule.translate());\n        };\n        conicConformalSpain.translate = function (_) {\n            if (!arguments.length) {\n                return iberianPeninsule.translate();\n            }\n            var k = iberianPeninsule.scale(), x = +_[0], y = +_[1];\n            /*\n            var c0 = iberianPeninsule(iberianPeninsuleBbox[0]);\n           var x0 = (x - c0[0]) / k;\n           var y0 = (y - c0[1]) / k;\n        \n           var c1 = iberianPeninsule(iberianPeninsuleBbox[1]);\n           var x1 = (x - c1[0]) / k;\n           var y1 = (y - c1[1]) / k;\n        \n           console.info('Iberian Peninsula: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n        \n           c0 = canaryIslands.translate([x + 0.1 * k, y - 0.094 * k])(canaryIslandsBbox[0]);\n           x0 = (x - c0[0]) / k;\n           y0 = (y - c0[1]) / k;\n        \n           c1 = canaryIslands.translate([x + 0.1 * k, y - 0.094 * k])(canaryIslandsBbox[1]);\n           x1 = (x - c1[0]) / k;\n           y1 = (y - c1[1]) / k;\n        \n           console.info('Canry Islands: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           */\n            iberianPeninsulePoint = iberianPeninsule\n                .translate(_)\n                .clipExtent([[x - 0.06857 * k, y - 0.1288 * k], [x + 0.13249 * k, y + 0.06 * k]])\n                .stream(pointStream);\n            canaryIslandsPoint = canaryIslands\n                .translate([x + 0.1 * k, y - 0.094 * k])\n                .clipExtent([[x - 0.1331 * k + epsilon, y + 0.053457 * k + epsilon], [x - 0.0354 * k - epsilon, y + 0.08969 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        conicConformalSpain.fitExtent = function (extent, object) {\n            return fitExtent(conicConformalSpain, extent, object);\n        };\n        conicConformalSpain.fitSize = function (size, object) {\n            return fitSize(conicConformalSpain, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return conicConformalSpain;\n        }\n        conicConformalSpain.drawCompositionBorders = function (context) {\n            /*\n            console.info(\"CLIP EXTENT: \", canaryIslands.clipExtent());\n            console.info(\"UL BBOX:\", iberianPeninsule.invert([canaryIslands.clipExtent()[0][0], canaryIslands.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", iberianPeninsule.invert([canaryIslands.clipExtent()[1][0], canaryIslands.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", iberianPeninsule.invert([canaryIslands.clipExtent()[1][0], canaryIslands.clipExtent()[1][1]]));\n            */\n            var ulCanaryIslands = iberianPeninsule([-14.0346750, 34.965007]);\n            var urCanaryIslands = iberianPeninsule([-7.4208899, 35.536988]);\n            var ldCanaryIslands = iberianPeninsule([-7.3148275, 33.54359]);\n            context.moveTo(ulCanaryIslands[0], ulCanaryIslands[1]);\n            context.lineTo(urCanaryIslands[0], urCanaryIslands[1]);\n            context.lineTo(ldCanaryIslands[0], ldCanaryIslands[1]);\n        };\n        conicConformalSpain.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return conicConformalSpain.scale(2700);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$3(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Portugal, configured by default for 960×500.\n    function conicConformalPortugal() {\n        var cache, cacheStream, iberianPeninsule = d3Geo.geoConicConformal().rotate([10, -39.3]).parallels([0, 60]), iberianPeninsulePoint, madeira = d3Geo.geoConicConformal().rotate([17, -32.7]).parallels([0, 60]), madeiraPoint, azores = d3Geo.geoConicConformal().rotate([27.8, -38.6]).parallels([0, 60]), azoresPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var iberianPeninsuleBbox = [[-11, 46], [4, 34]];\n        var madeiraBbox = [[-17.85, 33.6], [-16, 32.02]];\n        var azoresBbox = [[-32, 40.529], [-23.98, 35.75]];\n        */\n        function conicConformalPortugal(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (iberianPeninsulePoint.point(x, y), point) ||\n                    (madeiraPoint.point(x, y), point) ||\n                    (azoresPoint.point(x, y), point);\n        }\n        conicConformalPortugal.invert = function (coordinates) {\n            var k = iberianPeninsule.scale(), t = iberianPeninsule.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            /*\n            //How are the return values calculated:\n            console.info(\"******\");\n            var c0 = madeira(madeiraBbox[0]);\n            var x0 = (c0[0] - t[0]) / k;\n            var y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 madeira\", x0 + ' - ' + y0);\n    \n            var c1 = madeira(madeiraBbox[1]);\n            var x1 = (c1[0] - t[0]) / k;\n            var y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 madeira\", x1 + ' - ' + y1);\n    \n            c0 = azores(azoresBbox[0]);\n            x0 = (c0[0] - t[0]) / k;\n            y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 azores\", x0 + ' - ' + y0);\n    \n            c1 = azores(azoresBbox[1]);\n            x1 = (c1[0] - t[0]) / k;\n            y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 azores\", x1 + ' - ' + y1);\n            */\n            return (y >= 0.0093 && y < 0.03678 && x >= -0.03875 && x < -0.0116 ? madeira\n                : y >= -0.0412 && y < 0.0091 && x >= -0.07782 && x < -0.01166 ? azores\n                    : iberianPeninsule).invert(coordinates);\n        };\n        conicConformalPortugal.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$3([iberianPeninsule.stream(cacheStream = stream), madeira.stream(stream), azores.stream(stream)]);\n        };\n        conicConformalPortugal.precision = function (_) {\n            if (!arguments.length) {\n                return iberianPeninsule.precision();\n            }\n            iberianPeninsule.precision(_);\n            madeira.precision(_);\n            azores.precision(_);\n            return reset();\n        };\n        conicConformalPortugal.scale = function (_) {\n            if (!arguments.length) {\n                return iberianPeninsule.scale();\n            }\n            iberianPeninsule.scale(_);\n            madeira.scale(_);\n            azores.scale(_ * 0.6);\n            return conicConformalPortugal.translate(iberianPeninsule.translate());\n        };\n        conicConformalPortugal.translate = function (_) {\n            if (!arguments.length) {\n                return iberianPeninsule.translate();\n            }\n            var k = iberianPeninsule.scale(), x = +_[0], y = +_[1];\n            /*\n            var c0 = iberianPeninsule(iberianPeninsuleBbox[0]);\n           var x0 = (x - c0[0]) / k;\n           var y0 = (y - c0[1]) / k;\n        \n           var c1 = iberianPeninsule(iberianPeninsuleBbox[1]);\n           var x1 = (x - c1[0]) / k;\n           var y1 = (y - c1[1]) / k;\n        \n           console.info('Iberian Peninsula: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k]])');\n        \n           c0 = madeira.translate([x - 0.0265 * k, y + 0.025 * k])(madeiraBbox[0]);\n           x0 = (x - c0[0]) / k;\n           y0 = (y - c0[1]) / k;\n        \n           c1 = madeira.translate([x - 0.0265 * k, y + 0.025 * k])(madeiraBbox[1]);\n           x1 = (x - c1[0]) / k;\n           y1 = (y - c1[1]) / k;\n        \n           console.info('Madeira: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k + epsilon, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k + epsilon],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k - epsilon, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k - epsilon]])');\n        \n            c0 = azores.translate([x - 0.045 * k, y + -0.02 * k])(azoresBbox[0]);\n            x0 = (x - c0[0]) / k;\n            y0 = (y - c0[1]) / k;\n        \n            c1 = azores.translate([x - 0.045 * k, y + -0.02 * k])(azoresBbox[1]);\n            x1 = (x - c1[0]) / k;\n            y1 = (y - c1[1]) / k;\n        \n            console.info('Azores: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n            console.info('.clipExtent([[x '+\n             (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n             ' * k + epsilon, y '+\n             (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n             ' * k + epsilon],[x '+\n             (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n             ' * k - epsilon, y '+\n             (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n             ' * k - epsilon]])');\n             */\n            iberianPeninsulePoint = iberianPeninsule\n                .translate(_)\n                .clipExtent([[x - 0.0115 * k, y - 0.1138 * k], [x + 0.2105 * k, y + 0.0673 * k]])\n                .stream(pointStream);\n            madeiraPoint = madeira\n                .translate([x - 0.0265 * k, y + 0.025 * k])\n                .clipExtent([[x - 0.0388 * k + epsilon, y + 0.0093 * k + epsilon], [x - 0.0116 * k - epsilon, y + 0.0368 * k - epsilon]])\n                .stream(pointStream);\n            azoresPoint = azores\n                .translate([x - 0.045 * k, y + -0.02 * k])\n                .clipExtent([[x - 0.0778 * k + epsilon, y - 0.0413 * k + epsilon], [x - 0.0117 * k - epsilon, y + 0.0091 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        conicConformalPortugal.fitExtent = function (extent, object) {\n            return fitExtent(conicConformalPortugal, extent, object);\n        };\n        conicConformalPortugal.fitSize = function (size, object) {\n            return fitSize(conicConformalPortugal, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return conicConformalPortugal;\n        }\n        conicConformalPortugal.drawCompositionBorders = function (context) {\n            /*\n            console.info(\"CLIP EXTENT MADEIRA: \", madeira.clipExtent());\n            console.info(\"UL BBOX:\", iberianPeninsule.invert([madeira.clipExtent()[0][0], madeira.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", iberianPeninsule.invert([madeira.clipExtent()[1][0], madeira.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", iberianPeninsule.invert([madeira.clipExtent()[1][0], madeira.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", iberianPeninsule.invert([madeira.clipExtent()[0][0], madeira.clipExtent()[1][1]]));\n        \n            console.info(\"CLIP EXTENT AZORES: \", azores.clipExtent());\n            console.info(\"UL BBOX:\", iberianPeninsule.invert([azores.clipExtent()[0][0], azores.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", iberianPeninsule.invert([azores.clipExtent()[1][0], azores.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", iberianPeninsule.invert([azores.clipExtent()[1][0], azores.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", iberianPeninsule.invert([azores.clipExtent()[0][0], azores.clipExtent()[1][1]]));\n            */\n            var ulmadeira = iberianPeninsule([-12.8351, 38.7113]);\n            var urmadeira = iberianPeninsule([-10.8482, 38.7633]);\n            var ldmadeira = iberianPeninsule([-10.8181, 37.2072]);\n            var llmadeira = iberianPeninsule([-12.7345, 37.1573]);\n            var ulazores = iberianPeninsule([-16.0753, 41.4436]);\n            var urazores = iberianPeninsule([-10.9168, 41.6861]);\n            var ldazores = iberianPeninsule([-10.8557, 38.7747]);\n            var llazores = iberianPeninsule([-15.6728, 38.5505]);\n            context.moveTo(ulmadeira[0], ulmadeira[1]);\n            context.lineTo(urmadeira[0], urmadeira[1]);\n            context.lineTo(ldmadeira[0], ldmadeira[1]);\n            context.lineTo(ldmadeira[0], ldmadeira[1]);\n            context.lineTo(llmadeira[0], llmadeira[1]);\n            context.closePath();\n            context.moveTo(ulazores[0], ulazores[1]);\n            context.lineTo(urazores[0], urazores[1]);\n            context.lineTo(ldazores[0], ldazores[1]);\n            context.lineTo(ldazores[0], ldazores[1]);\n            context.lineTo(llazores[0], llazores[1]);\n            context.closePath();\n        };\n        conicConformalPortugal.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return conicConformalPortugal.scale(4200);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$4(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Ecuador, configured by default for 960×500.\n    function mercatorEcuador() {\n        var cache, cacheStream, mainland = d3Geo.geoMercator().rotate([80, 1.5]), mainlandPoint, galapagos = d3Geo.geoMercator().rotate([90.73, 1]), galapagosPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var mainlandBbox = [[-81.5, 2.7], [-70.0, -6.0]];\n        var galapagosBbox = [[-92.2, 0.58], [-88.8, -1.8]];\n        */\n        function mercatorEcuador(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (mainlandPoint.point(x, y), point) ||\n                    (galapagosPoint.point(x, y), point);\n        }\n        mercatorEcuador.invert = function (coordinates) {\n            var k = mainland.scale(), t = mainland.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            /*\n            //How are the return values calculated:\n            var c0 = galapagos(galapagosBbox[0]);\n            var x0 = (c0[0] - t[0]) / k;\n            var y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 galapagos\", x0 + ' - ' + y0);\n    \n    \n            var c1 = galapagos(galapagosBbox[1]);\n            var x1 = (c1[0] - t[0]) / k;\n            var y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 galapagos\", x1 + ' - ' + y1);\n            */\n            return (y >= -0.0676 && y < -0.026 && x >= -0.0857 && x < -0.0263 ? galapagos\n                : mainland).invert(coordinates);\n        };\n        mercatorEcuador.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$4([mainland.stream(cacheStream = stream), galapagos.stream(stream)]);\n        };\n        mercatorEcuador.precision = function (_) {\n            if (!arguments.length) {\n                return mainland.precision();\n            }\n            mainland.precision(_);\n            galapagos.precision(_);\n            return reset();\n        };\n        mercatorEcuador.scale = function (_) {\n            if (!arguments.length) {\n                return mainland.scale();\n            }\n            mainland.scale(_);\n            galapagos.scale(_);\n            return mercatorEcuador.translate(mainland.translate());\n        };\n        mercatorEcuador.translate = function (_) {\n            if (!arguments.length) {\n                return mainland.translate();\n            }\n            var k = mainland.scale(), x = +_[0], y = +_[1];\n            /*\n            var c0 = mainland(mainlandBbox[0]);\n           var x0 = (x - c0[0]) / k;\n           var y0 = (y - c0[1]) / k;\n        \n           var c1 = mainland(mainlandBbox[1]);\n           var x1 = (x - c1[0]) / k;\n           var y1 = (y - c1[1]) / k;\n        \n           console.info('mainland: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k]])');\n        \n           c0 = galapagos.translate([x - 0.06 * k, y - 0.04 * k])(galapagosBbox[0]);\n           x0 = (x - c0[0]) / k;\n           y0 = (y - c0[1]) / k;\n        \n           c1 = galapagos.translate([x - 0.06 * k, y - 0.04 * k])(galapagosBbox[1]);\n           x1 = (x - c1[0]) / k;\n           y1 = (y - c1[1]) / k;\n        \n           console.info('galapagos: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k + epsilon, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k + epsilon],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k - epsilon, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k - epsilon]])');*/\n            mainlandPoint = mainland\n                .translate(_)\n                .clipExtent([[x - 0.0262 * k, y - 0.0734 * k], [x + 0.1741 * k, y + 0.079 * k]])\n                .stream(pointStream);\n            galapagosPoint = galapagos\n                .translate([x - 0.06 * k, y - 0.04 * k])\n                .clipExtent([[x - 0.0857 * k + epsilon, y - 0.0676 * k + epsilon], [x - 0.0263 * k - epsilon, y - 0.026 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        mercatorEcuador.fitExtent = function (extent, object) {\n            return fitExtent(mercatorEcuador, extent, object);\n        };\n        mercatorEcuador.fitSize = function (size, object) {\n            return fitSize(mercatorEcuador, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return mercatorEcuador;\n        }\n        mercatorEcuador.drawCompositionBorders = function (context) {\n            /*\n            console.info(\"CLIP EXTENT: \", galapagos.clipExtent());\n            console.info(\"UL BBOX:\", mainland.invert([galapagos.clipExtent()[0][0], galapagos.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", mainland.invert([galapagos.clipExtent()[1][0], galapagos.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", mainland.invert([galapagos.clipExtent()[1][0], galapagos.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", mainland.invert([galapagos.clipExtent()[0][0], galapagos.clipExtent()[1][1]]));\n            */\n            var ulgalapagos = mainland([-84.9032, 2.3757]);\n            var urgalapagos = mainland([-81.5047, 2.3708]);\n            var ldgalapagos = mainland([-81.5063, -0.01]);\n            var llgalapagos = mainland([-84.9086, -0.005]);\n            context.moveTo(ulgalapagos[0], ulgalapagos[1]);\n            context.lineTo(urgalapagos[0], urgalapagos[1]);\n            context.lineTo(ldgalapagos[0], ldgalapagos[1]);\n            context.lineTo(llgalapagos[0], llgalapagos[1]);\n            context.closePath();\n        };\n        mercatorEcuador.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return mercatorEcuador.scale(3500);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$5(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Chile, configured by default for 960×500.\n    function transverseMercatorChile() {\n        var cache, cacheStream, mainland = d3Geo.geoTransverseMercator().rotate([72, 37]), mainlandPoint, antarctic = d3Geo.geoStereographic().rotate([72, 0]), antarcticPoint, juanFernandez = d3Geo.geoMercator().rotate([80, 33.5]), juanFernandezPoint, pascua = d3Geo.geoMercator().rotate([110, 25]), pascuaPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var mainlandBbox = [[-75.5, -15.0], [-32, -49.0]];\n        var antarcticBbox = [[-91.0, -60.0], [-43.0, -90.0]];\n        var juanFernandezBbox = [[-81.0, -33.0], [-78.5, -34.0]];\n        var pascuaBbox = [[-110, -26.6], [-108.7, -27.5]];\n        */\n        function transverseMercatorChile(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (mainlandPoint.point(x, y), point) ||\n                    (antarcticPoint.point(x, y), point) ||\n                    (juanFernandezPoint.point(x, y), point) ||\n                    (pascuaPoint.point(x, y), point);\n        }\n        transverseMercatorChile.invert = function (coordinates) {\n            var k = mainland.scale(), t = mainland.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            /*\n            //How are the return values calculated:\n            console.info(\"******\");\n            var c0 = antarctic(antarcticBbox[0]);\n            var x0 = (c0[0] - t[0]) / k;\n            var y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 antarctic\", x0 + ' - ' + y0);\n    \n            var c1 = antarctic(antarcticBbox[1]);\n            var x1 = (c1[0] - t[0]) / k;\n            var y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 antarctic\", x1 + ' - ' + y1);\n    \n            c0 = juanFernandez(juanFernandezBbox[0]);\n            x0 = (c0[0] - t[0]) / k;\n            y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 juanFernandez\", x0 + ' - ' + y0);\n    \n            c1 = juanFernandez(juanFernandezBbox[1]);\n            x1 = (c1[0] - t[0]) / k;\n            y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 juanFernandez\", x1 + ' - ' + y1);\n    \n            c0 = pascua(pascuaBbox[0]);\n            x0 = (c0[0] - t[0]) / k;\n            y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 pascua\", x0 + ' - ' + y0);\n    \n            c1 = pascua(pascuaBbox[1]);\n            x1 = (c1[0] - t[0]) / k;\n            y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 pascua\", x1 + ' - ' + y1);\n            */\n            return (y >= 0.2582 && y < 0.32 && x >= -0.1036 && x < -0.087 ? antarctic\n                : y >= -0.01298 && y < 0.0133 && x >= -0.11396 && x < -0.05944 ? juanFernandez\n                    : y >= 0.01539 && y < 0.03911 && x >= -0.089 && x < -0.0588 ? pascua\n                        : mainland).invert(coordinates);\n        };\n        transverseMercatorChile.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$5([mainland.stream(cacheStream = stream), antarctic.stream(stream), juanFernandez.stream(stream), pascua.stream(stream)]);\n        };\n        transverseMercatorChile.precision = function (_) {\n            if (!arguments.length) {\n                return mainland.precision();\n            }\n            mainland.precision(_);\n            antarctic.precision(_);\n            juanFernandez.precision(_);\n            pascua.precision(_);\n            return reset();\n        };\n        transverseMercatorChile.scale = function (_) {\n            if (!arguments.length) {\n                return mainland.scale();\n            }\n            mainland.scale(_);\n            antarctic.scale(_ * 0.15);\n            juanFernandez.scale(_ * 1.5);\n            pascua.scale(_ * 1.5);\n            return transverseMercatorChile.translate(mainland.translate());\n        };\n        transverseMercatorChile.translate = function (_) {\n            if (!arguments.length) {\n                return mainland.translate();\n            }\n            var k = mainland.scale(), x = +_[0], y = +_[1];\n            /*\n            var c0 = mainland(mainlandBbox[0]);\n           var x0 = (x - c0[0]) / k;\n           var y0 = (y - c0[1]) / k;\n        \n           var c1 = mainland(mainlandBbox[1]);\n           var x1 = (x - c1[0]) / k;\n           var y1 = (y - c1[1]) / k;\n        \n           console.info('Mainland: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k]])');\n        \n           c0 = antarctic.translate([x - 0.1 * k, y + 0.17 * k])(antarcticBbox[0]);\n           x0 = (x - c0[0]) / k;\n           y0 = (y - c0[1]) / k;\n        \n           c1 = antarctic.translate([x - 0.1 * k, y + 0.17 * k])(antarcticBbox[1]);\n           x1 = (x - c1[0]) / k;\n           y1 = (y - c1[1]) / k;\n        \n           console.info('antarctic: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('Doesn t work due to -90 latitude!' + '.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k + epsilon, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k + epsilon],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k - epsilon, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k - epsilon]])');\n        \n            c0 = juanFernandez.translate([x - 0.092 * k, y -0 * k])(juanFernandezBbox[0]);\n            x0 = (x - c0[0]) / k;\n            y0 = (y - c0[1]) / k;\n        \n            c1 = juanFernandez.translate([x - 0.092 * k, y -0 * k])(juanFernandezBbox[1]);\n            x1 = (x - c1[0]) / k;\n            y1 = (y - c1[1]) / k;\n        \n            console.info('juanFernandez: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n            console.info('.clipExtent([[x '+\n             (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n             ' * k + epsilon, y '+\n             (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n             ' * k + epsilon],[x '+\n             (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n             ' * k - epsilon, y '+\n             (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n             ' * k - epsilon]])');\n        \n             c0 = pascua.translate([x - 0.089 * k, y -0.0265 * k])(pascuaBbox[0]);\n             x0 = (x - c0[0]) / k;\n             y0 = (y - c0[1]) / k;\n        \n             c1 = pascua.translate([x - 0.089 * k, y -0.0265 * k])(pascuaBbox[1]);\n             x1 = (x - c1[0]) / k;\n             y1 = (y - c1[1]) / k;\n        \n             console.info('pascua: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n             console.info('.clipExtent([[x '+\n              (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n              ' * k + epsilon, y '+\n              (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n              ' * k + epsilon],[x '+\n              (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n              ' * k - epsilon, y '+\n              (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n              ' * k - epsilon]])');\n              */\n            mainlandPoint = mainland\n                .translate(_)\n                .clipExtent([[x - 0.059 * k, y - 0.3835 * k], [x + 0.4498 * k, y + 0.3375 * k]])\n                .stream(pointStream);\n            antarcticPoint = antarctic\n                .translate([x - 0.087 * k, y + 0.17 * k])\n                .clipExtent([[x - 0.1166 * k + epsilon, y + 0.2582 * k + epsilon], [x - 0.06 * k - epsilon, y + 0.32 * k - epsilon]])\n                .stream(pointStream);\n            juanFernandezPoint = juanFernandez\n                .translate([x - 0.092 * k, y - 0 * k])\n                .clipExtent([[x - 0.114 * k + epsilon, y - 0.013 * k + epsilon], [x - 0.0594 * k - epsilon, y + 0.0133 * k - epsilon]])\n                .stream(pointStream);\n            pascuaPoint = pascua\n                .translate([x - 0.089 * k, y - 0.0265 * k])\n                .clipExtent([[x - 0.089 * k + epsilon, y + 0.0154 * k + epsilon], [x - 0.0588 * k - epsilon, y + 0.0391 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        transverseMercatorChile.fitExtent = function (extent, object) {\n            return fitExtent(transverseMercatorChile, extent, object);\n        };\n        transverseMercatorChile.fitSize = function (size, object) {\n            return fitSize(transverseMercatorChile, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return transverseMercatorChile;\n        }\n        transverseMercatorChile.drawCompositionBorders = function (context) {\n            /*\n            console.info(\"CLIP EXTENT antarctic: \", antarctic.clipExtent());\n            console.info(\"UL BBOX:\", mainland.invert([antarctic.clipExtent()[0][0], antarctic.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", mainland.invert([antarctic.clipExtent()[1][0], antarctic.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", mainland.invert([antarctic.clipExtent()[1][0], antarctic.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", mainland.invert([antarctic.clipExtent()[0][0], antarctic.clipExtent()[1][1]]));\n        \n            console.info(\"CLIP EXTENT juanFernandez: \", juanFernandez.clipExtent());\n            console.info(\"UL BBOX:\", mainland.invert([juanFernandez.clipExtent()[0][0], juanFernandez.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", mainland.invert([juanFernandez.clipExtent()[1][0], juanFernandez.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", mainland.invert([juanFernandez.clipExtent()[1][0], juanFernandez.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", mainland.invert([juanFernandez.clipExtent()[0][0], juanFernandez.clipExtent()[1][1]]));\n        \n            console.info(\"CLIP EXTENT pascua: \", pascua.clipExtent());\n            console.info(\"UL BBOX:\", mainland.invert([pascua.clipExtent()[0][0], pascua.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", mainland.invert([pascua.clipExtent()[1][0], pascua.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", mainland.invert([pascua.clipExtent()[1][0], pascua.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", mainland.invert([pascua.clipExtent()[0][0], pascua.clipExtent()[1][1]]));\n            */\n            var ulantarctic = mainland([-82.6999, -51.3043]);\n            var urantarctic = mainland([-77.5442, -51.6631]);\n            var ldantarctic = mainland([-78.0254, -55.1860]);\n            var llantarctic = mainland([-83.6106, -54.7785]);\n            var uljuanFernandez = mainland([-80.0638, -35.9840]);\n            var urjuanFernandez = mainland([-76.2153, -36.1811]);\n            var ldjuanFernandez = mainland([-76.2994, -37.6839]);\n            var lljuanFernandez = mainland([-80.2231, -37.4757]);\n            var ulpascua = mainland([-78.442, -37.706]);\n            var urpascua = mainland([-76.263, -37.8054]);\n            var ldpascua = mainland([-76.344, -39.1595]);\n            var llpascua = mainland([-78.5638, -39.0559]);\n            context.moveTo(ulantarctic[0], ulantarctic[1]);\n            context.lineTo(urantarctic[0], urantarctic[1]);\n            context.lineTo(ldantarctic[0], ldantarctic[1]);\n            context.lineTo(ldantarctic[0], ldantarctic[1]);\n            context.lineTo(llantarctic[0], llantarctic[1]);\n            context.closePath();\n            context.moveTo(uljuanFernandez[0], uljuanFernandez[1]);\n            context.lineTo(urjuanFernandez[0], urjuanFernandez[1]);\n            context.lineTo(ldjuanFernandez[0], ldjuanFernandez[1]);\n            context.lineTo(ldjuanFernandez[0], ldjuanFernandez[1]);\n            context.lineTo(lljuanFernandez[0], lljuanFernandez[1]);\n            context.closePath();\n            context.moveTo(ulpascua[0], ulpascua[1]);\n            context.lineTo(urpascua[0], urpascua[1]);\n            context.lineTo(ldpascua[0], ldpascua[1]);\n            context.lineTo(ldpascua[0], ldpascua[1]);\n            context.lineTo(llpascua[0], llpascua[1]);\n            context.closePath();\n        };\n        transverseMercatorChile.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return transverseMercatorChile.scale(700);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$6(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Portugal, configured by default for 960×500.\n    function conicEquidistantJapan() {\n        var cache, cacheStream, mainland = d3Geo.geoConicEquidistant().rotate([-136, -22]).parallels([40, 34]), mainlandPoint, //gis.stackexchange.com/a/73135\n        hokkaido = d3Geo.geoConicEquidistant().rotate([-146, -26]).parallels([40, 34]), hokkaidoPoint, okinawa = d3Geo.geoConicEquidistant().rotate([-126, -19]).parallels([40, 34]), okinawaPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var mainlandBbox = [[126.0, 41.606], [142.97, 29.97]];\n        var hokkaidoBbox = [[138.7, 45.61], [146.2, 41.2]];\n        var okinawaBbox = [[122.6, 29.0], [130, 23.7]];\n        */\n        function conicEquidistantJapan(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (mainlandPoint.point(x, y), point) ||\n                    (hokkaidoPoint.point(x, y), point) ||\n                    (okinawaPoint.point(x, y), point);\n        }\n        conicEquidistantJapan.invert = function (coordinates) {\n            var k = mainland.scale(), t = mainland.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            /*\n            //How are the return values calculated:\n            console.info(\"******\");\n            var c0 = hokkaido(hokkaidoBbox[0]);\n            var x0 = (c0[0] - t[0]) / k;\n            var y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 hokkaido\", x0 + ' - ' + y0);\n    \n            var c1 = hokkaido(hokkaidoBbox[1]);\n            var x1 = (c1[0] - t[0]) / k;\n            var y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 hokkaido\", x1 + ' - ' + y1);\n    \n            c0 = okinawa(okinawaBbox[0]);\n            x0 = (c0[0] - t[0]) / k;\n            y0 = (c0[1] - t[1]) / k;\n    \n            console.info(\"p0 okinawa\", x0 + ' - ' + y0);\n    \n            c1 = okinawa(okinawaBbox[1]);\n            x1 = (c1[0] - t[0]) / k;\n            y1 = (c1[1] - t[1]) / k;\n    \n            console.info(\"p1 okinawa\", x1 + ' - ' + y1);\n            */\n            return (y >= -0.10925 && y < -0.02701 && x >= -0.135 && x < -0.0397 ? hokkaido\n                : y >= 0.04713 && y < 0.11138 && x >= -0.03986 && x < 0.051 ? okinawa\n                    : mainland).invert(coordinates);\n        };\n        conicEquidistantJapan.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$6([mainland.stream(cacheStream = stream), hokkaido.stream(stream), okinawa.stream(stream)]);\n        };\n        conicEquidistantJapan.precision = function (_) {\n            if (!arguments.length) {\n                return mainland.precision();\n            }\n            mainland.precision(_);\n            hokkaido.precision(_);\n            okinawa.precision(_);\n            return reset();\n        };\n        conicEquidistantJapan.scale = function (_) {\n            if (!arguments.length) {\n                return mainland.scale();\n            }\n            mainland.scale(_);\n            hokkaido.scale(_);\n            okinawa.scale(_ * 0.7);\n            return conicEquidistantJapan.translate(mainland.translate());\n        };\n        conicEquidistantJapan.translate = function (_) {\n            if (!arguments.length) {\n                return mainland.translate();\n            }\n            var k = mainland.scale(), x = +_[0], y = +_[1];\n            /*\n            var c0 = mainland(mainlandBbox[0]);\n           var x0 = (x - c0[0]) / k;\n           var y0 = (y - c0[1]) / k;\n        \n           var c1 = mainland(mainlandBbox[1]);\n           var x1 = (x - c1[0]) / k;\n           var y1 = (y - c1[1]) / k;\n        \n           console.info('Main: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k]])');\n        \n           c0 = hokkaido.translate([x - 0.0425 * k, y - 0.005 * k])(hokkaidoBbox[0]);\n           x0 = (x - c0[0]) / k;\n           y0 = (y - c0[1]) / k;\n        \n           c1 = hokkaido.translate([x - 0.0425 * k, y - 0.005 * k])(hokkaidoBbox[1]);\n           x1 = (x - c1[0]) / k;\n           y1 = (y - c1[1]) / k;\n        \n           console.info('hokkaido: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n           console.info('.clipExtent([[x '+\n            (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n            ' * k + epsilon, y '+\n            (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n            ' * k + epsilon],[x '+\n            (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n            ' * k - epsilon, y '+\n            (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n            ' * k - epsilon]])');\n        \n            c0 = okinawa.translate([x - 0 * k, y + 0 * k])(okinawaBbox[0]);\n            x0 = (x - c0[0]) / k;\n            y0 = (y - c0[1]) / k;\n        \n            c1 = okinawa.translate([x - 0 * k, y + 0 * k])(okinawaBbox[1]);\n            x1 = (x - c1[0]) / k;\n            y1 = (y - c1[1]) / k;\n        \n            console.info('okinawa: p0: ' + x0 + ', ' + y0 + ' , p1: ' + x1 + ' - ' + y1);\n            console.info('.clipExtent([[x '+\n             (x0<0?'+ ':'- ') + Math.abs(x0.toFixed(4))+\n             ' * k + epsilon, y '+\n             (y0<0?'+ ':'- ') + Math.abs(y0.toFixed(4))+\n             ' * k + epsilon],[x '+\n             (x1<0?'+ ':'- ') + Math.abs(x1.toFixed(4))+\n             ' * k - epsilon, y '+\n             (y1<0?'+ ':'- ') + Math.abs(y1.toFixed(4))+\n             ' * k - epsilon]])');\n             */\n            mainlandPoint = mainland\n                .translate(_)\n                .clipExtent([[x - 0.1352 * k, y - 0.1091 * k], [x + 0.117 * k, y + 0.098 * k]])\n                .stream(pointStream);\n            hokkaidoPoint = hokkaido\n                .translate([x - 0.0425 * k, y - 0.005 * k])\n                .clipExtent([[x - 0.135 * k + epsilon, y - 0.1093 * k + epsilon], [x - 0.0397 * k - epsilon, y - 0.027 * k - epsilon]])\n                .stream(pointStream);\n            okinawaPoint = okinawa\n                .translate(_)\n                .clipExtent([[x - 0.0399 * k + epsilon, y + 0.0471 * k + epsilon], [x + 0.051 * k - epsilon, y + 0.1114 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        conicEquidistantJapan.fitExtent = function (extent, object) {\n            return fitExtent(conicEquidistantJapan, extent, object);\n        };\n        conicEquidistantJapan.fitSize = function (size, object) {\n            return fitSize(conicEquidistantJapan, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return conicEquidistantJapan;\n        }\n        conicEquidistantJapan.drawCompositionBorders = function (context) {\n            /*\n            console.info(\"CLIP EXTENT hokkaido: \", hokkaido.clipExtent());\n            console.info(\"UL BBOX:\", mainland.invert([hokkaido.clipExtent()[0][0], hokkaido.clipExtent()[0][1]]));\n            console.info(\"UR BBOX:\", mainland.invert([hokkaido.clipExtent()[1][0], hokkaido.clipExtent()[0][1]]));\n            console.info(\"LD BBOX:\", mainland.invert([hokkaido.clipExtent()[1][0], hokkaido.clipExtent()[1][1]]));\n            console.info(\"LL BBOX:\", mainland.invert([hokkaido.clipExtent()[0][0], hokkaido.clipExtent()[1][1]]));\n            */\n            var ulhokkaido = mainland([126.01320483689143, 41.621090310215585]);\n            var urhokkaido = mainland([133.04304387025903, 42.15087523707186]);\n            var ldhokkaido = mainland([133.3021766080688, 37.43975444725098]);\n            var llhokkaido = mainland([126.87889168628224, 36.95488945159779]);\n            var llokinawa = mainland([132.9, 29.8]);\n            var lmokinawa = mainland([134, 33]);\n            var lrokinawa = mainland([139.3, 33.2]);\n            var llrokinawa = mainland([139.16, 30.5]);\n            context.moveTo(ulhokkaido[0], ulhokkaido[1]);\n            context.lineTo(urhokkaido[0], urhokkaido[1]);\n            context.lineTo(ldhokkaido[0], ldhokkaido[1]);\n            context.lineTo(llhokkaido[0], llhokkaido[1]);\n            context.closePath();\n            context.moveTo(llokinawa[0], llokinawa[1]);\n            context.lineTo(lmokinawa[0], lmokinawa[1]);\n            context.lineTo(lrokinawa[0], lrokinawa[1]);\n            context.lineTo(llrokinawa[0], llrokinawa[1]);\n        };\n        conicEquidistantJapan.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return conicEquidistantJapan.scale(2200);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$7(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for France, configured by default for 960×500.\n    function conicConformalFrance() {\n        var cache, cacheStream, europe = d3Geo.geoConicConformal().rotate([-3, -46.2]).parallels([0, 60]), europePoint, guyane = d3Geo.geoMercator().center([-53.2, 3.9]), guyanePoint, martinique = d3Geo.geoMercator().center([-61.03, 14.67]), martiniquePoint, guadeloupe = d3Geo.geoMercator().center([-61.46, 16.14]), guadeloupePoint, saintBarthelemy = d3Geo.geoMercator().center([-62.85, 17.92]), saintBarthelemyPoint, stPierreMiquelon = d3Geo.geoMercator().center([-56.23, 46.93]), stPierreMiquelonPoint, mayotte = d3Geo.geoMercator().center([45.16, -12.8]), mayottePoint, reunion = d3Geo.geoMercator().center([55.52, -21.13]), reunionPoint, nouvelleCaledonie = d3Geo.geoMercator().center([165.8, -21.07]), nouvelleCaledoniePoint, wallisFutuna = d3Geo.geoMercator().center([-178.1, -14.3]), wallisFutunaPoint, polynesie = d3Geo.geoMercator().center([-150.55, -17.11]), polynesiePoint, polynesie2 = d3Geo.geoMercator().center([-150.55, -17.11]), polynesie2Point, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var europeBbox = [[-6.5, 51], [10, 41]];\n        var guyaneBbox = [[-54.5, 6.29], [-50.9, 1.48]];\n        */\n        function conicConformalFrance(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (europePoint.point(x, y), point) ||\n                    (guyanePoint.point(x, y), point) ||\n                    (martiniquePoint.point(x, y), point) ||\n                    (guadeloupePoint.point(x, y), point) ||\n                    (saintBarthelemyPoint.point(x, y), point) ||\n                    (stPierreMiquelonPoint.point(x, y), point) ||\n                    (mayottePoint.point(x, y), point) ||\n                    (reunionPoint.point(x, y), point) ||\n                    (nouvelleCaledoniePoint.point(x, y), point) ||\n                    (wallisFutunaPoint.point(x, y), point) ||\n                    (polynesiePoint.point(x, y), point) ||\n                    (polynesie2Point.point(x, y), point);\n        }\n        conicConformalFrance.invert = function (coordinates) {\n            var k = europe.scale(), t = europe.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= 0.029 && y < 0.0864 && x >= -0.14 && x < -0.0996 ? guyane\n                : y >= 0 && y < 0.029 && x >= -0.14 && x < -0.0996 ? martinique\n                    : y >= -0.032 && y < 0 && x >= -0.14 && x < -0.0996 ? guadeloupe\n                        : y >= -0.052 && y < -0.032 && x >= -0.14 && x < -0.0996 ? saintBarthelemy\n                            : y >= -0.076 && y < 0.052 && x >= -0.14 && x < -0.0996 ? stPierreMiquelon\n                                : y >= -0.076 && y < -0.052 && x >= 0.0967 && x < 0.1371 ? mayotte\n                                    : y >= -0.052 && y < -0.02 && x >= 0.0967 && x < 0.1371 ? reunion\n                                        : y >= -0.02 && y < 0.012 && x >= 0.0967 && x < 0.1371 ? nouvelleCaledonie\n                                            : y >= 0.012 && y < 0.033 && x >= 0.0967 && x < 0.1371 ? wallisFutuna\n                                                : y >= 0.033 && y < 0.0864 && x >= 0.0967 && x < 0.1371 ? polynesie\n                                                    : europe).invert(coordinates);\n        };\n        conicConformalFrance.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$7([europe.stream(cacheStream = stream), guyane.stream(stream), martinique.stream(stream), guadeloupe.stream(stream), saintBarthelemy.stream(stream), stPierreMiquelon.stream(stream), mayotte.stream(stream), reunion.stream(stream), nouvelleCaledonie.stream(stream), wallisFutuna.stream(stream), polynesie.stream(stream), polynesie2.stream(stream)]);\n        };\n        conicConformalFrance.precision = function (_) {\n            if (!arguments.length) {\n                return europe.precision();\n            }\n            europe.precision(_);\n            guyane.precision(_);\n            martinique.precision(_);\n            guadeloupe.precision(_);\n            saintBarthelemy.precision(_);\n            stPierreMiquelon.precision(_);\n            mayotte.precision(_);\n            reunion.precision(_);\n            nouvelleCaledonie.precision(_);\n            wallisFutuna.precision(_);\n            polynesie.precision(_);\n            polynesie2.precision(_);\n            return reset();\n        };\n        conicConformalFrance.scale = function (_) {\n            if (!arguments.length) {\n                return europe.scale();\n            }\n            europe.scale(_);\n            guyane.scale(_ * 0.6);\n            martinique.scale(_ * 1.6);\n            guadeloupe.scale(_ * 1.4);\n            saintBarthelemy.scale(_ * 5);\n            stPierreMiquelon.scale(_ * 1.3);\n            mayotte.scale(_ * 1.6);\n            reunion.scale(_ * 1.2);\n            nouvelleCaledonie.scale(_ * 0.3);\n            wallisFutuna.scale(_ * 2.7);\n            polynesie.scale(_ * 0.5);\n            polynesie2.scale(_ * 0.06);\n            return conicConformalFrance.translate(europe.translate());\n        };\n        conicConformalFrance.translate = function (_) {\n            if (!arguments.length) {\n                return europe.translate();\n            }\n            var k = europe.scale(), x = +_[0], y = +_[1];\n            europePoint = europe\n                .translate(_)\n                .clipExtent([[x - 0.0996 * k, y - 0.0908 * k], [x + 0.0967 * k, y + 0.0864 * k]])\n                .stream(pointStream);\n            guyanePoint = guyane\n                .translate([x - 0.12 * k, y + 0.0575 * k])\n                .clipExtent([[x - 0.14 * k + epsilon, y + 0.029 * k + epsilon], [x - 0.0996 * k - epsilon, y + 0.0864 * k - epsilon]])\n                .stream(pointStream);\n            martiniquePoint = martinique\n                .translate([x - 0.12 * k, y + 0.013 * k])\n                .clipExtent([[x - 0.14 * k + epsilon, y + 0 * k + epsilon], [x - 0.0996 * k - epsilon, y + 0.029 * k - epsilon]])\n                .stream(pointStream);\n            guadeloupePoint = guadeloupe\n                .translate([x - 0.12 * k, y - 0.014 * k])\n                .clipExtent([[x - 0.14 * k + epsilon, y - 0.032 * k + epsilon], [x - 0.0996 * k - epsilon, y + 0 * k - epsilon]])\n                .stream(pointStream);\n            saintBarthelemyPoint = saintBarthelemy\n                .translate([x - 0.12 * k, y - 0.044 * k])\n                .clipExtent([[x - 0.14 * k + epsilon, y - 0.052 * k + epsilon], [x - 0.0996 * k - epsilon, y - 0.032 * k - epsilon]])\n                .stream(pointStream);\n            stPierreMiquelonPoint = stPierreMiquelon\n                .translate([x - 0.12 * k, y - 0.065 * k])\n                .clipExtent([[x - 0.14 * k + epsilon, y - 0.076 * k + epsilon], [x - 0.0996 * k - epsilon, y - 0.052 * k - epsilon]])\n                .stream(pointStream);\n            mayottePoint = mayotte\n                .translate([x + 0.117 * k, y - 0.064 * k])\n                .clipExtent([[x + 0.0967 * k + epsilon, y - 0.076 * k + epsilon], [x + 0.1371 * k - epsilon, y - 0.052 * k - epsilon]])\n                .stream(pointStream);\n            reunionPoint = reunion\n                .translate([x + 0.116 * k, y - 0.0355 * k])\n                .clipExtent([[x + 0.0967 * k + epsilon, y - 0.052 * k + epsilon], [x + 0.1371 * k - epsilon, y - 0.02 * k - epsilon]])\n                .stream(pointStream);\n            nouvelleCaledoniePoint = nouvelleCaledonie\n                .translate([x + 0.116 * k, y - 0.0048 * k])\n                .clipExtent([[x + 0.0967 * k + epsilon, y - 0.02 * k + epsilon], [x + 0.1371 * k - epsilon, y + 0.012 * k - epsilon]])\n                .stream(pointStream);\n            wallisFutunaPoint = wallisFutuna\n                .translate([x + 0.116 * k, y + 0.022 * k])\n                .clipExtent([[x + 0.0967 * k + epsilon, y + 0.012 * k + epsilon], [x + 0.1371 * k - epsilon, y + 0.033 * k - epsilon]])\n                .stream(pointStream);\n            polynesie2Point = polynesie2\n                .translate([x + 0.11 * k, y + 0.045 * k])\n                .clipExtent([[x + 0.0967 * k + epsilon, y + 0.033 * k + epsilon], [x + 0.1371 * k - epsilon, y + 0.06 * k - epsilon]])\n                .stream(pointStream);\n            polynesiePoint = polynesie\n                .translate([x + 0.115 * k, y + 0.075 * k])\n                .clipExtent([[x + 0.0967 * k + epsilon, y + 0.06 * k + epsilon], [x + 0.1371 * k - epsilon, y + 0.0864 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        conicConformalFrance.fitExtent = function (extent, object) {\n            return fitExtent(conicConformalFrance, extent, object);\n        };\n        conicConformalFrance.fitSize = function (size, object) {\n            return fitSize(conicConformalFrance, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return conicConformalFrance;\n        }\n        conicConformalFrance.drawCompositionBorders = function (context) {\n            /*\n            console.log(\"var ul, ur, ld, ll;\");\n            var projs = [guyane, martinique, guadeloupe, saintBarthelemy, stPierreMiquelon, mayotte, reunion, nouvelleCaledonie, wallisFutuna, polynesie, polynesie2];\n            for (var i in projs){\n              var ul = europe.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[0][1]]);\n              var ur = europe.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[0][1]]);\n              var ld = europe.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[1][1]]);\n              var ll = europe.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[1][1]]);\n        \n              console.log(\"ul = europe([\"+ul+\"]);\");\n              console.log(\"ur = europe([\"+ur+\"]);\");\n              console.log(\"ld = europe([\"+ld+\"]);\");\n              console.log(\"ll = europe([\"+ll+\"]);\");\n        \n              console.log(\"context.moveTo(ul[0], ul[1]);\");\n              console.log(\"context.lineTo(ur[0], ur[1]);\");\n              console.log(\"context.lineTo(ld[0], ld[1]);\");\n              console.log(\"context.lineTo(ll[0], ll[1]);\");\n              console.log(\"context.closePath();\");\n        \n            }*/\n            var ul, ur, ld, ll;\n            ul = europe([-7.938886725111036, 43.7219460918835]);\n            ur = europe([-4.832080896458295, 44.12930268549372]);\n            ld = europe([-4.205299743793263, 40.98096346967365]);\n            ll = europe([-7.071796453126152, 40.610037319181444]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([-8.42751373617692, 45.32889452553031]);\n            ur = europe([-5.18599305777107, 45.7566442062976]);\n            ld = europe([-4.832080905154431, 44.129302726751426]);\n            ll = europe([-7.938886737126192, 43.72194613263854]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([-9.012656899657046, 47.127733821030176]);\n            ur = europe([-5.6105244772793155, 47.579777861410626]);\n            ld = europe([-5.185993067168585, 45.756644248170346]);\n            ll = europe([-8.427513749141811, 45.32889456686326]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([-9.405747558985553, 48.26506375557457]);\n            ur = europe([-5.896175018439575, 48.733352850851624]);\n            ld = europe([-5.610524487556043, 47.57977790393761]);\n            ll = europe([-9.012656913808351, 47.127733862971255]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([-9.908436061346974, 49.642448789505856]);\n            ur = europe([-6.262026716233124, 50.131426841787174]);\n            ld = europe([-5.896175029331232, 48.73335289377258]);\n            ll = europe([-9.40574757396393, 48.26506379787767]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([11.996907706504462, 50.16039028163579]);\n            ur = europe([15.649907879773343, 49.68279246765253]);\n            ld = europe([15.156712840526632, 48.30371557625831]);\n            ll = europe([11.64122661754411, 48.761078240546816]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([11.641226606955788, 48.7610781975889]);\n            ur = europe([15.156712825832164, 48.30371553390465]);\n            ld = europe([14.549932166241172, 46.4866532486199]);\n            ll = europe([11.204443787952183, 46.91899233914248]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([11.204443778297161, 46.918992296823646]);\n            ur = europe([14.549932152815039, 46.486653206856396]);\n            ld = europe([13.994409796764009, 44.695833444323256]);\n            ll = europe([10.805306599253848, 45.105133870684924]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([10.805306590412085, 45.10513382903308]);\n            ur = europe([13.99440978444733, 44.695833403183606]);\n            ld = europe([13.654633799024392, 43.53552468558152]);\n            ll = europe([10.561516803980956, 43.930671459798624]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([10.561516795617383, 43.93067141859757]);\n            ur = europe([13.654633787361952, 43.5355246448671]);\n            ld = europe([12.867691604239901, 40.640701985019405]);\n            ll = europe([9.997809515987688, 41.00288343254471]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([10.8, 42.4]);\n            ur = europe([12.8, 42.13]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n        };\n        conicConformalFrance.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return conicConformalFrance.scale(2700);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$8(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Portugal, configured by default for 960×500.\n    function conicConformalEurope() {\n        var cache, cacheStream, europe = d3Geo.geoConicConformal().rotate([-10, -53]).parallels([0, 60]), europePoint, guadeloupe = d3Geo.geoMercator().center([-61.46, 16.14]), guadeloupePoint, guyane = d3Geo.geoMercator().center([-53.2, 3.9]), guyanePoint, azores = d3Geo.geoConicConformal().rotate([27.8, -38.9]).parallels([0, 60]), azoresPoint, azores2 = d3Geo.geoConicConformal().rotate([25.43, -37.398]).parallels([0, 60]), azores2Point, azores3 = d3Geo.geoConicConformal().rotate([31.17, -39.539]).parallels([0, 60]), azores3Point, madeira = d3Geo.geoConicConformal().rotate([17, -32.7]).parallels([0, 60]), madeiraPoint, canaryIslands = d3Geo.geoConicConformal().rotate([16, -28.5]).parallels([0, 60]), canaryIslandsPoint, martinique = d3Geo.geoMercator().center([-61.03, 14.67]), martiniquePoint, mayotte = d3Geo.geoMercator().center([45.16, -12.8]), mayottePoint, reunion = d3Geo.geoMercator().center([55.52, -21.13]), reunionPoint, malta = d3Geo.geoConicConformal().rotate([-14.4, -35.95]).parallels([0, 60]), maltaPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        /*\n        var europeBbox = [[-6.5, 51], [10, 41]];\n        var guyaneBbox = [[-54.5, 6.29], [-50.9, 1.48]];\n        */\n        function conicConformalEurope(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (europePoint.point(x, y), point) ||\n                    (guyanePoint.point(x, y), point) ||\n                    (martiniquePoint.point(x, y), point) ||\n                    (guadeloupePoint.point(x, y), point) ||\n                    (canaryIslandsPoint.point(x, y), point) ||\n                    (madeiraPoint.point(x, y), point) ||\n                    (mayottePoint.point(x, y), point) ||\n                    (reunionPoint.point(x, y), point) ||\n                    (maltaPoint.point(x, y), point) ||\n                    (azoresPoint.point(x, y), point) ||\n                    (azores2Point.point(x, y), point) ||\n                    (azores3Point.point(x, y), point);\n        }\n        conicConformalEurope.invert = function (coordinates) {\n            var k = europe.scale(), t = europe.translate(), x = (coordinates[0] - (t[0] + 0.08 * k)) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= -0.31 && y < -0.24 && x >= 0.14 && x < 0.24 ? guadeloupe\n                : y >= -0.24 && y < -0.17 && x >= 0.14 && x < 0.24 ? guyane\n                    : y >= -0.17 && y < -0.12 && x >= 0.21 && x < 0.24 ? azores2\n                        : y >= -0.17 && y < -0.14 && x >= 0.14 && x < 0.165 ? azores3\n                            : y >= -0.17 && y < -0.1 && x >= 0.14 && x < 0.24 ? azores\n                                : y >= -0.1 && y < -0.03 && x >= 0.14 && x < 0.24 ? madeira\n                                    : y >= -0.03 && y < 0.04 && x >= 0.14 && x < 0.24 ? canaryIslands\n                                        : y >= -0.31 && y < -0.24 && x >= 0.24 && x < 0.34 ? martinique\n                                            : y >= -0.24 && y < -0.17 && x >= 0.24 && x < 0.34 ? mayotte\n                                                : y >= -0.17 && y < -0.1 && x >= 0.24 && x < 0.34 ? reunion\n                                                    : y >= -0.1 && y < -0.03 && x >= 0.24 && x < 0.34 ? malta\n                                                        : europe).invert(coordinates);\n        };\n        conicConformalEurope.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$8([europe.stream(cacheStream = stream), guyane.stream(stream), martinique.stream(stream), guadeloupe.stream(stream), canaryIslands.stream(stream), madeira.stream(stream), mayotte.stream(stream), reunion.stream(stream), malta.stream(stream), azores.stream(stream), azores2.stream(stream), azores3.stream(stream)]);\n        };\n        conicConformalEurope.precision = function (_) {\n            if (!arguments.length) {\n                return europe.precision();\n            }\n            europe.precision(_);\n            guyane.precision(_);\n            martinique.precision(_);\n            guadeloupe.precision(_);\n            canaryIslands.precision(_);\n            madeira.precision(_);\n            mayotte.precision(_);\n            reunion.precision(_);\n            malta.precision(_);\n            azores.precision(_);\n            azores2.precision(_);\n            azores3.precision(_);\n            return reset();\n        };\n        conicConformalEurope.scale = function (_) {\n            if (!arguments.length) {\n                return europe.scale();\n            }\n            europe.scale(_);\n            guadeloupe.scale(_ * 3);\n            guyane.scale(_ * 0.8);\n            martinique.scale(_ * 3.5);\n            reunion.scale(_ * 2.7);\n            azores.scale(_ * 2);\n            azores2.scale(_ * 2);\n            azores3.scale(_ * 2);\n            madeira.scale(_ * 3);\n            canaryIslands.scale(_);\n            mayotte.scale(_ * 5.5);\n            malta.scale(_ * 6);\n            return conicConformalEurope.translate(europe.translate());\n        };\n        conicConformalEurope.translate = function (_) {\n            if (!arguments.length) {\n                return europe.translate();\n            }\n            var k = europe.scale(), x = +_[0], y = +_[1];\n            europePoint = europe\n                .translate([x - 0.08 * k, y])\n                .clipExtent([[x - 0.51 * k, y - 0.33 * k], [x + 0.5 * k, y + 0.33 * k]])\n                .stream(pointStream);\n            guadeloupePoint = guadeloupe\n                .translate([x + 0.19 * k, y - 0.275 * k])\n                .clipExtent([[x + 0.14 * k + epsilon, y - 0.31 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.24 * k - epsilon]])\n                .stream(pointStream);\n            guyanePoint = guyane\n                .translate([x + 0.19 * k, y - 0.205 * k])\n                .clipExtent([[x + 0.14 * k + epsilon, y - 0.24 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.17 * k - epsilon]])\n                .stream(pointStream);\n            azoresPoint = azores\n                .translate([x + 0.19 * k, y - 0.135 * k])\n                .clipExtent([[x + 0.14 * k + epsilon, y - 0.17 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.1 * k - epsilon]])\n                .stream(pointStream);\n            azores2Point = azores2\n                .translate([x + 0.225 * k, y - 0.147 * k])\n                .clipExtent([[x + 0.21 * k + epsilon, y - 0.17 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.12 * k - epsilon]])\n                .stream(pointStream);\n            azores3Point = azores3\n                .translate([x + 0.153 * k, y - 0.15 * k])\n                .clipExtent([[x + 0.14 * k + epsilon, y - 0.17 * k + epsilon], [x + 0.165 * k - epsilon, y - 0.14 * k - epsilon]])\n                .stream(pointStream);\n            madeiraPoint = madeira\n                .translate([x + 0.19 * k, y - 0.065 * k])\n                .clipExtent([[x + 0.14 * k + epsilon, y - 0.1 * k + epsilon], [x + 0.24 * k - epsilon, y - 0.03 * k - epsilon]])\n                .stream(pointStream);\n            canaryIslandsPoint = canaryIslands\n                .translate([x + 0.19 * k, y + 0.005 * k])\n                .clipExtent([[x + 0.14 * k + epsilon, y - 0.03 * k + epsilon], [x + 0.24 * k - epsilon, y + 0.04 * k - epsilon]])\n                .stream(pointStream);\n            martiniquePoint = martinique\n                .translate([x + 0.29 * k, y - 0.275 * k])\n                .clipExtent([[x + 0.24 * k + epsilon, y - 0.31 * k + epsilon], [x + 0.34 * k - epsilon, y - 0.24 * k - epsilon]])\n                .stream(pointStream);\n            mayottePoint = mayotte\n                .translate([x + 0.29 * k, y - 0.205 * k])\n                .clipExtent([[x + 0.24 * k + epsilon, y - 0.24 * k + epsilon], [x + 0.34 * k - epsilon, y - 0.17 * k - epsilon]])\n                .stream(pointStream);\n            reunionPoint = reunion\n                .translate([x + 0.29 * k, y - 0.135 * k])\n                .clipExtent([[x + 0.24 * k + epsilon, y - 0.17 * k + epsilon], [x + 0.34 * k - epsilon, y - 0.1 * k - epsilon]])\n                .stream(pointStream);\n            maltaPoint = malta\n                .translate([x + 0.29 * k, y - 0.065 * k])\n                .clipExtent([[x + 0.24 * k + epsilon, y - 0.1 * k + epsilon], [x + 0.34 * k - epsilon, y - 0.03 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        conicConformalEurope.fitExtent = function (extent, object) {\n            return fitExtent(conicConformalEurope, extent, object);\n        };\n        conicConformalEurope.fitSize = function (size, object) {\n            return fitSize(conicConformalEurope, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return conicConformalEurope;\n        }\n        conicConformalEurope.drawCompositionBorders = function (context) {\n            /*\n            console.log(\"var ul, ur, ld, ll;\");\n            var projs = [guyane, martinique, guadeloupe, canaryIslands, madeira, mayotte, reunion, malta, azores, azores2, azores3];\n            for (var i in projs){\n              var ul = europe.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[0][1]]);\n              var ur = europe.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[0][1]]);\n              var ld = europe.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[1][1]]);\n              var ll = europe.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[1][1]]);\n        \n              console.log(\"ul = europe([\"+ul+\"]);\");\n              console.log(\"ur = europe([\"+ur+\"]);\");\n              console.log(\"ld = europe([\"+ld+\"]);\");\n              console.log(\"ll = europe([\"+ll+\"]);\");\n        \n              console.log(\"context.moveTo(ul[0], ul[1]);\");\n              console.log(\"context.lineTo(ur[0], ur[1]);\");\n              console.log(\"context.lineTo(ld[0], ld[1]);\");\n              console.log(\"context.lineTo(ll[0], ll[1]);\");\n              console.log(\"context.closePath();\");\n        \n            }*/\n            var ul, ur, ld, ll;\n            ul = europe([42.45755610828648, 63.343658547914934]);\n            ur = europe([52.65837266667029, 59.35045080290929]);\n            ld = europe([47.19754502247785, 56.12653496548117]);\n            ll = europe([37.673034273363044, 59.61638268506111]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([59.41110754003403, 62.35069727399336]);\n            ur = europe([66.75050228640794, 57.11797303636038]);\n            ld = europe([60.236065725110436, 54.63331433818992]);\n            ll = europe([52.65837313153311, 59.350450804599355]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([48.81091130080243, 66.93353402634641]);\n            ur = europe([59.41110730654679, 62.35069740653086]);\n            ld = europe([52.6583728974441, 59.3504509222445]);\n            ll = europe([42.45755631675751, 63.34365868805821]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([31.054198418446475, 52.1080673766184]);\n            ur = europe([39.09869284884117, 49.400700047190554]);\n            ld = europe([36.0580811499175, 46.02944174908498]);\n            ll = europe([28.690508588835726, 48.433126979386415]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([33.977877745912025, 55.849945501331]);\n            ur = europe([42.75328432167726, 52.78455122462353]);\n            ld = europe([39.09869297540224, 49.400700176148625]);\n            ll = europe([31.05419851807008, 52.10806751810923]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([52.658372900759296, 59.35045068526415]);\n            ur = europe([60.23606549583304, 54.63331423800264]);\n            ld = europe([54.6756370953122, 51.892298789399455]);\n            ll = europe([47.19754524788189, 56.126534861222794]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([47.19754506082455, 56.126534735591456]);\n            ur = europe([54.675636900123514, 51.892298681337095]);\n            ld = europe([49.94448648951486, 48.98775484983285]);\n            ll = europe([42.75328468716108, 52.78455126060818]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([42.75328453416769, 52.78455113209101]);\n            ur = europe([49.94448632339758, 48.98775473706457]);\n            ld = europe([45.912339990394315, 45.99361784987003]);\n            ll = europe([39.09869317356607, 49.40070009378711]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([37.673034114296634, 59.61638254183119]);\n            ur = europe([47.197544835420544, 56.126534839849846]);\n            ld = europe([42.75328447467064, 52.78455135314068]);\n            ll = europe([33.977877870363905, 55.849945644671145]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([44.56748486446032, 57.26489367845818]);\n            ld = europe([43.9335791193588, 53.746540942601726]);\n            ll = europe([43, 56]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = europe([37.673034114296634, 59.61638254183119]);\n            ur = europe([40.25902691953466, 58.83002044222639]);\n            ld = europe([38.458270492742024, 57.26232178028002]);\n            ll = europe([35.97754948030156, 58.00266637992386]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n        };\n        conicConformalEurope.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return conicConformalEurope.scale(750);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$9(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Malaysia, configured by default for 960×500.\n    function mercatorMalaysia() {\n        var cache, cacheStream, peninsular = d3Geo.geoMercator().center([105.25, 4.00]), peninsularPoint, borneo = d3Geo.geoMercator().center([118.65, 2.86]), borneoPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        function mercatorMalaysia(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (peninsularPoint.point(x, y), point) ||\n                    (borneoPoint.point(x, y), point);\n        }\n        mercatorMalaysia.invert = function (coordinates) {\n            var k = peninsular.scale(), t = peninsular.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= -0.0521 && y < 0.0229 && x >= -0.0111 && x < 0.1000 ? borneo\n                : peninsular).invert(coordinates);\n        };\n        mercatorMalaysia.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$9([peninsular.stream(cacheStream = stream), borneo.stream(stream)]);\n        };\n        mercatorMalaysia.precision = function (_) {\n            if (!arguments.length) {\n                return peninsular.precision();\n            }\n            peninsular.precision(_);\n            borneo.precision(_);\n            return reset();\n        };\n        mercatorMalaysia.scale = function (_) {\n            if (!arguments.length) {\n                return peninsular.scale();\n            }\n            peninsular.scale(_);\n            borneo.scale(_ * 0.615);\n            return mercatorMalaysia.translate(peninsular.translate());\n        };\n        mercatorMalaysia.translate = function (_) {\n            if (!arguments.length) {\n                return peninsular.translate();\n            }\n            var k = peninsular.scale(), x = +_[0], y = +_[1];\n            peninsularPoint = peninsular\n                .translate(_)\n                .clipExtent([[x - 0.1100 * k, y - 0.0521 * k], [x - 0.0111 * k, y + 0.0521 * k]])\n                .stream(pointStream);\n            borneoPoint = borneo\n                .translate([x + 0.09000 * k, y - 0.00 * k])\n                .clipExtent([[x - 0.0111 * k + epsilon, y - 0.0521 * k + epsilon], [x + 0.1000 * k - epsilon, y + 0.024 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        mercatorMalaysia.fitExtent = function (extent, object) {\n            return fitExtent(mercatorMalaysia, extent, object);\n        };\n        mercatorMalaysia.fitSize = function (size, object) {\n            return fitSize(mercatorMalaysia, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return mercatorMalaysia;\n        }\n        mercatorMalaysia.drawCompositionBorders = function (context) {\n            var llbor = peninsular([106.3214, 2.0228]);\n            var lmbor = peninsular([105.1843, 2.3761]);\n            var lrbor = peninsular([104.2151, 3.3618]);\n            var llrbor = peninsular([104.2150, 4.5651]);\n            context.moveTo(llbor[0], llbor[1]);\n            context.lineTo(lmbor[0], lmbor[1]);\n            context.lineTo(lrbor[0], lrbor[1]);\n            context.lineTo(llrbor[0], llrbor[1]);\n        };\n        mercatorMalaysia.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return mercatorMalaysia.scale(4800);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex$a(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n) {\n                streams[i].point(x, y);\n            } },\n            sphere: function () { var i = -1; while (++i < n) {\n                streams[i].sphere();\n            } },\n            lineStart: function () { var i = -1; while (++i < n) {\n                streams[i].lineStart();\n            } },\n            lineEnd: function () { var i = -1; while (++i < n) {\n                streams[i].lineEnd();\n            } },\n            polygonStart: function () { var i = -1; while (++i < n) {\n                streams[i].polygonStart();\n            } },\n            polygonEnd: function () { var i = -1; while (++i < n) {\n                streams[i].polygonEnd();\n            } }\n        };\n    }\n    // A composite projection for Equatorial Guinea, configured by default for 960×500.\n    function mercatorEquatorialGuinea() {\n        var cache, cacheStream, continent = d3Geo.geoMercator().rotate([-9.5, -1.5]), continentPoint, bioko = d3Geo.geoMercator().rotate([-8.6, -3.5]), biokoPoint, annobon = d3Geo.geoMercator().rotate([-5.6, 1.45]), annobonPoint, point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        function mercatorEquatorialGuinea(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (continentPoint.point(x, y), point) ||\n                    (biokoPoint.point(x, y), point) ||\n                    (annobonPoint.point(x, y), point);\n        }\n        mercatorEquatorialGuinea.invert = function (coordinates) {\n            var k = continent.scale(), t = continent.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= -0.02 && y < 0 && x >= -0.038 && x < -0.005 ? bioko\n                : y >= 0 && y < 0.02 && x >= -0.038 && x < -0.005 ? annobon\n                    : continent).invert(coordinates);\n        };\n        mercatorEquatorialGuinea.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex$a([continent.stream(cacheStream = stream), bioko.stream(stream), annobon.stream(stream)]);\n        };\n        mercatorEquatorialGuinea.precision = function (_) {\n            if (!arguments.length) {\n                return continent.precision();\n            }\n            continent.precision(_);\n            bioko.precision(_);\n            annobon.precision(_);\n            return reset();\n        };\n        mercatorEquatorialGuinea.scale = function (_) {\n            if (!arguments.length) {\n                return continent.scale();\n            }\n            continent.scale(_);\n            bioko.scale(_ * 1.5);\n            annobon.scale(_ * 4);\n            return mercatorEquatorialGuinea.translate(continent.translate());\n        };\n        mercatorEquatorialGuinea.translate = function (_) {\n            if (!arguments.length) {\n                return continent.translate();\n            }\n            var k = continent.scale(), x = +_[0], y = +_[1];\n            continentPoint = continent\n                .translate(_)\n                .clipExtent([[x - 0.005 * k, y - 0.02 * k], [x + 0.038 * k, y + 0.02 * k]])\n                .stream(pointStream);\n            biokoPoint = bioko\n                .translate([x - 0.025 * k, y - 0.01 * k])\n                .clipExtent([[x - 0.038 * k + epsilon, y - 0.02 * k + epsilon], [x - 0.005 * k - epsilon, y + 0 * k - epsilon]])\n                .stream(pointStream);\n            annobonPoint = annobon\n                .translate([x - 0.025 * k, y + 0.01 * k])\n                .clipExtent([[x - 0.038 * k + epsilon, y - 0 * k + epsilon], [x - 0.005 * k - epsilon, y + 0.02 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        mercatorEquatorialGuinea.fitExtent = function (extent, object) {\n            return fitExtent(mercatorEquatorialGuinea, extent, object);\n        };\n        mercatorEquatorialGuinea.fitSize = function (size, object) {\n            return fitSize(mercatorEquatorialGuinea, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return mercatorEquatorialGuinea;\n        }\n        mercatorEquatorialGuinea.drawCompositionBorders = function (context) {\n            /*\n            console.log(\"var ul, ur, ld, ll;\");\n            var projs = [continent, bioko, annobon];\n            for (var i in projs){\n              var ul = continent.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[0][1]]);\n              var ur = continent.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[0][1]]);\n              var ld = continent.invert([projs[i].clipExtent()[1][0], projs[i].clipExtent()[1][1]]);\n              var ll = continent.invert([projs[i].clipExtent()[0][0], projs[i].clipExtent()[1][1]]);\n        \n              console.log(\"ul = continent([\"+ul+\"]);\");\n              console.log(\"ur = continent([\"+ur+\"]);\");\n              console.log(\"ld = continent([\"+ld+\"]);\");\n              console.log(\"ll = continent([\"+ll+\"]);\");\n        \n              console.log(\"context.moveTo(ul[0], ul[1]);\");\n              console.log(\"context.lineTo(ur[0], ur[1]);\");\n              console.log(\"context.lineTo(ld[0], ld[1]);\");\n              console.log(\"context.lineTo(ll[0], ll[1]);\");\n              console.log(\"context.closePath();\");\n        \n            }*/\n            var ul, ur, ld, ll;\n            ul = continent([9.21327272751682, 2.645820439454123]);\n            ur = continent([11.679126293239872, 2.644755519268689]);\n            ld = continent([11.676845389029227, 0.35307824637606433]);\n            ll = continent([9.213572917774014, 0.35414205204417754]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = continent([7.320873711543669, 2.64475551449975]);\n            ur = continent([9.213272722738658, 2.645820434679803]);\n            ld = continent([9.213422896480349, 1.4999812505283054]);\n            ll = continent([7.322014760520787, 1.4989168878985566]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n            ul = continent([7.3220147605302905, 1.4989168783492766]);\n            ur = continent([9.213422896481598, 1.499981240979021]);\n            ld = continent([9.213572912999604, 0.354142056817247]);\n            ll = continent([7.323154615739809, 0.353078251154504]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n        };\n        mercatorEquatorialGuinea.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return mercatorEquatorialGuinea.scale(12000);\n    }\n    function multiplex$b(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) {\n                var i = -1;\n                while (++i < n)\n                    streams[i].point(x, y);\n            },\n            sphere: function () {\n                var i = -1;\n                while (++i < n)\n                    streams[i].sphere();\n            },\n            lineStart: function () {\n                var i = -1;\n                while (++i < n)\n                    streams[i].lineStart();\n            },\n            lineEnd: function () {\n                var i = -1;\n                while (++i < n)\n                    streams[i].lineEnd();\n            },\n            polygonStart: function () {\n                var i = -1;\n                while (++i < n)\n                    streams[i].polygonStart();\n            },\n            polygonEnd: function () {\n                var i = -1;\n                while (++i < n)\n                    streams[i].polygonEnd();\n            }\n        };\n    }\n    function albersUk() {\n        var cache, cacheStream, main = d3Geo.geoAlbers()\n            .rotate([4.4, 0.8])\n            .center([0, 55.4])\n            .parallels([50, 60]), mainPoint, shetland = d3Geo.geoAlbers()\n            .rotate([4.4, 0.8])\n            .center([0, 55.4])\n            .parallels([50, 60]), shetlandPoint, point, pointStream = {\n            point: function (x, y) {\n                point = [x, y];\n            }\n        };\n        function albersUk(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return ((point = null),\n                (mainPoint.point(x, y), point) || (shetlandPoint.point(x, y), point));\n        }\n        albersUk.invert = function (coordinates) {\n            var k = main.scale(), t = main.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= -0.089 && y < 0.06 && x >= 0.029 && x < 0.046\n                ? shetland\n                : main).invert(coordinates);\n        };\n        albersUk.stream = function (stream) {\n            return cache && cacheStream === stream\n                ? cache\n                : (cache = multiplex$b([\n                    main.stream((cacheStream = stream)),\n                    shetland.stream(stream)\n                ]));\n        };\n        albersUk.precision = function (_) {\n            if (!arguments.length)\n                return main.precision();\n            main.precision(_), shetland.precision(_);\n            return reset();\n        };\n        albersUk.scale = function (_) {\n            if (!arguments.length)\n                return main.scale();\n            main.scale(_), shetland.scale(_);\n            return albersUk.translate(main.translate());\n        };\n        albersUk.translate = function (_) {\n            if (!arguments.length)\n                return main.translate();\n            var k = main.scale(), x = +_[0], y = +_[1];\n            mainPoint = main\n                .translate(_)\n                .clipExtent([\n                [x - 0.065 * k, y - 0.089 * k],\n                [x + 0.075 * k, y + 0.089 * k]\n            ])\n                .stream(pointStream);\n            shetlandPoint = shetland\n                .translate([x + 0.01 * k, y + 0.025 * k])\n                .clipExtent([\n                [x + 0.029 * k + epsilon, y - 0.089 * k + epsilon],\n                [x + 0.046 * k - epsilon, y - 0.06 * k - epsilon]\n            ])\n                .stream(pointStream);\n            return reset();\n        };\n        albersUk.fitExtent = function (extent, object) {\n            return fitExtent(albersUk, extent, object);\n        };\n        albersUk.fitSize = function (size, object) {\n            return fitSize(albersUk, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return albersUk;\n        }\n        albersUk.drawCompositionBorders = function (context) {\n            /*var ul = main.invert([\n              shetland.clipExtent()[0][0],\n              shetland.clipExtent()[0][1]\n            ]);\n            var ur = main.invert([\n              shetland.clipExtent()[1][0],\n              shetland.clipExtent()[0][1]\n            ]);\n            var ld = main.invert([\n              shetland.clipExtent()[1][0],\n              shetland.clipExtent()[1][1]\n            ]);\n            var ll = main.invert([\n              shetland.clipExtent()[0][0],\n              shetland.clipExtent()[1][1]\n            ]);\n        \n            console.log(\"ul = main([\" + ul + \"]);\");\n            console.log(\"ur = main([\" + ur + \"]);\");\n            console.log(\"ld = main([\" + ld + \"]);\");\n            console.log(\"ll = main([\" + ll + \"]);\");\n        \n            console.log(\"context.moveTo(ul[0], ul[1]);\");\n            console.log(\"context.lineTo(ur[0], ur[1]);\");\n            console.log(\"context.lineTo(ld[0], ld[1]);\");\n            console.log(\"context.lineTo(ll[0], ll[1]);\");\n            console.log(\"context.closePath();\");*/\n            var ul, ur, ld, ll;\n            ul = main([-1.113205870242365, 59.64920050773357]);\n            ur = main([0.807899092399606, 59.59085836472269]);\n            ld = main([0.5778611961420386, 57.93467822832577]);\n            ll = main([-1.25867782078448, 57.99029450085142]);\n            context.moveTo(ul[0], ul[1]);\n            context.lineTo(ur[0], ur[1]);\n            context.lineTo(ld[0], ld[1]);\n            context.lineTo(ll[0], ll[1]);\n            context.closePath();\n        };\n        albersUk.getCompositionBorders = function () {\n            var context = d3Path.path();\n            this.drawCompositionBorders(context);\n            return context.toString();\n        };\n        return albersUk.scale(2800);\n    }\n    exports.geoAlbersUk = albersUk;\n    exports.geoAlbersUsa = albersUsa;\n    exports.geoAlbersUsaTerritories = albersUsaTerritories;\n    exports.geoConicConformalEurope = conicConformalEurope;\n    exports.geoConicConformalFrance = conicConformalFrance;\n    exports.geoConicConformalPortugal = conicConformalPortugal;\n    exports.geoConicConformalSpain = conicConformalSpain;\n    exports.geoConicEquidistantJapan = conicEquidistantJapan;\n    exports.geoMercatorEcuador = mercatorEcuador;\n    exports.geoMercatorEquatorialGuinea = mercatorEquatorialGuinea;\n    exports.geoMercatorMalaysia = mercatorMalaysia;\n    exports.geoTransverseMercatorChile = transverseMercatorChile;\n    Object.defineProperty(exports, '__esModule', { value: true });\n})));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-dsv@1.2.0@d3-dsv/dist/d3-dsv.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_d3-dsv@1.2.0@d3-dsv/dist/d3-dsv.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-dsv/ v1.2.0 Copyright 2019 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports) :\n        undefined;\n}(this, function (exports) {\n    'use strict';\n    var EOL = {}, EOF = {}, QUOTE = 34, NEWLINE = 10, RETURN = 13;\n    function objectConverter(columns) {\n        return new Function(\"d\", \"return {\" + columns.map(function (name, i) {\n            return JSON.stringify(name) + \": d[\" + i + \"] || \\\"\\\"\";\n        }).join(\",\") + \"}\");\n    }\n    function customConverter(columns, f) {\n        var object = objectConverter(columns);\n        return function (row, i) {\n            return f(object(row), i, columns);\n        };\n    }\n    // Compute unique columns in order of discovery.\n    function inferColumns(rows) {\n        var columnSet = Object.create(null), columns = [];\n        rows.forEach(function (row) {\n            for (var column in row) {\n                if (!(column in columnSet)) {\n                    columns.push(columnSet[column] = column);\n                }\n            }\n        });\n        return columns;\n    }\n    function pad(value, width) {\n        var s = value + \"\", length = s.length;\n        return length < width ? new Array(width - length + 1).join(0) + s : s;\n    }\n    function formatYear(year) {\n        return year < 0 ? \"-\" + pad(-year, 6)\n            : year > 9999 ? \"+\" + pad(year, 6)\n                : pad(year, 4);\n    }\n    function formatDate(date) {\n        var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();\n        return isNaN(date) ? \"Invalid Date\"\n            : formatYear(date.getUTCFullYear()) + \"-\" + pad(date.getUTCMonth() + 1, 2) + \"-\" + pad(date.getUTCDate(), 2)\n                + (milliseconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \".\" + pad(milliseconds, 3) + \"Z\"\n                    : seconds ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \":\" + pad(seconds, 2) + \"Z\"\n                        : minutes || hours ? \"T\" + pad(hours, 2) + \":\" + pad(minutes, 2) + \"Z\"\n                            : \"\");\n    }\n    function dsv(delimiter) {\n        var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"), DELIMITER = delimiter.charCodeAt(0);\n        function parse(text, f) {\n            var convert, columns, rows = parseRows(text, function (row, i) {\n                if (convert)\n                    return convert(row, i - 1);\n                columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n            });\n            rows.columns = columns || [];\n            return rows;\n        }\n        function parseRows(text, f) {\n            var rows = [], // output rows\n            N = text.length, I = 0, // current character index\n            n = 0, // current line number\n            t, // current token\n            eof = N <= 0, // current token followed by EOF?\n            eol = false; // current token followed by EOL?\n            // Strip the trailing newline.\n            if (text.charCodeAt(N - 1) === NEWLINE)\n                --N;\n            if (text.charCodeAt(N - 1) === RETURN)\n                --N;\n            function token() {\n                if (eof)\n                    return EOF;\n                if (eol)\n                    return eol = false, EOL;\n                // Unescape quotes.\n                var i, j = I, c;\n                if (text.charCodeAt(j) === QUOTE) {\n                    while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE)\n                        ;\n                    if ((i = I) >= N)\n                        eof = true;\n                    else if ((c = text.charCodeAt(I++)) === NEWLINE)\n                        eol = true;\n                    else if (c === RETURN) {\n                        eol = true;\n                        if (text.charCodeAt(I) === NEWLINE)\n                            ++I;\n                    }\n                    return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n                }\n                // Find next delimiter or newline.\n                while (I < N) {\n                    if ((c = text.charCodeAt(i = I++)) === NEWLINE)\n                        eol = true;\n                    else if (c === RETURN) {\n                        eol = true;\n                        if (text.charCodeAt(I) === NEWLINE)\n                            ++I;\n                    }\n                    else if (c !== DELIMITER)\n                        continue;\n                    return text.slice(j, i);\n                }\n                // Return last token before EOF.\n                return eof = true, text.slice(j, N);\n            }\n            while ((t = token()) !== EOF) {\n                var row = [];\n                while (t !== EOL && t !== EOF)\n                    row.push(t), t = token();\n                if (f && (row = f(row, n++)) == null)\n                    continue;\n                rows.push(row);\n            }\n            return rows;\n        }\n        function preformatBody(rows, columns) {\n            return rows.map(function (row) {\n                return columns.map(function (column) {\n                    return formatValue(row[column]);\n                }).join(delimiter);\n            });\n        }\n        function format(rows, columns) {\n            if (columns == null)\n                columns = inferColumns(rows);\n            return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join(\"\\n\");\n        }\n        function formatBody(rows, columns) {\n            if (columns == null)\n                columns = inferColumns(rows);\n            return preformatBody(rows, columns).join(\"\\n\");\n        }\n        function formatRows(rows) {\n            return rows.map(formatRow).join(\"\\n\");\n        }\n        function formatRow(row) {\n            return row.map(formatValue).join(delimiter);\n        }\n        function formatValue(value) {\n            return value == null ? \"\"\n                : value instanceof Date ? formatDate(value)\n                    : reFormat.test(value += \"\") ? \"\\\"\" + value.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n                        : value;\n        }\n        return {\n            parse: parse,\n            parseRows: parseRows,\n            format: format,\n            formatBody: formatBody,\n            formatRows: formatRows,\n            formatRow: formatRow,\n            formatValue: formatValue\n        };\n    }\n    var csv = dsv(\",\");\n    var csvParse = csv.parse;\n    var csvParseRows = csv.parseRows;\n    var csvFormat = csv.format;\n    var csvFormatBody = csv.formatBody;\n    var csvFormatRows = csv.formatRows;\n    var csvFormatRow = csv.formatRow;\n    var csvFormatValue = csv.formatValue;\n    var tsv = dsv(\"\\t\");\n    var tsvParse = tsv.parse;\n    var tsvParseRows = tsv.parseRows;\n    var tsvFormat = tsv.format;\n    var tsvFormatBody = tsv.formatBody;\n    var tsvFormatRows = tsv.formatRows;\n    var tsvFormatRow = tsv.formatRow;\n    var tsvFormatValue = tsv.formatValue;\n    function autoType(object) {\n        for (var key in object) {\n            var value = object[key].trim(), number, m;\n            if (!value)\n                value = null;\n            else if (value === \"true\")\n                value = true;\n            else if (value === \"false\")\n                value = false;\n            else if (value === \"NaN\")\n                value = NaN;\n            else if (!isNaN(number = +value))\n                value = number;\n            else if (m = value.match(/^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/)) {\n                if (fixtz && !!m[4] && !m[7])\n                    value = value.replace(/-/g, \"/\").replace(/T/, \" \");\n                value = new Date(value);\n            }\n            else\n                continue;\n            object[key] = value;\n        }\n        return object;\n    }\n    // https://github.com/d3/d3-dsv/issues/45\n    var fixtz = new Date(\"2019-01-01T00:00\").getHours() || new Date(\"2019-07-01T00:00\").getHours();\n    exports.autoType = autoType;\n    exports.csvFormat = csvFormat;\n    exports.csvFormatBody = csvFormatBody;\n    exports.csvFormatRow = csvFormatRow;\n    exports.csvFormatRows = csvFormatRows;\n    exports.csvFormatValue = csvFormatValue;\n    exports.csvParse = csvParse;\n    exports.csvParseRows = csvParseRows;\n    exports.dsvFormat = dsv;\n    exports.tsvFormat = tsvFormat;\n    exports.tsvFormatBody = tsvFormatBody;\n    exports.tsvFormatRow = tsvFormatRow;\n    exports.tsvFormatRows = tsvFormatRows;\n    exports.tsvFormatValue = tsvFormatValue;\n    exports.tsvParse = tsvParse;\n    exports.tsvParseRows = tsvParseRows;\n    Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-geo-projection@2.1.2@d3-geo-projection/build/d3-geo-projection.js\":\n/*!********************************************************************************************!*\\\n  !*** ./node_modules/_d3-geo-projection@2.1.2@d3-geo-projection/build/d3-geo-projection.js ***!\n  \\********************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-geo-projection/ Version 2.1.2. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! d3-geo */ \"./node_modules/_d3-geo@1.11.9@d3-geo/dist/d3-geo.js\"), __webpack_require__(/*! d3-array */ \"./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js\")) :\n        undefined;\n}(this, (function (exports, d3Geo, d3Array) {\n    'use strict';\n    var abs = Math.abs;\n    var atan = Math.atan;\n    var atan2 = Math.atan2;\n    var cos = Math.cos;\n    var exp = Math.exp;\n    var floor = Math.floor;\n    var log = Math.log;\n    var max = Math.max;\n    var min = Math.min;\n    var pow = Math.pow;\n    var round = Math.round;\n    var sign = Math.sign || function (x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\n    var sin = Math.sin;\n    var tan = Math.tan;\n    var epsilon = 1e-6;\n    var epsilon2 = 1e-12;\n    var pi = Math.PI;\n    var halfPi = pi / 2;\n    var quarterPi = pi / 4;\n    var sqrt1_2 = Math.SQRT1_2;\n    var sqrt2 = sqrt(2);\n    var sqrtPi = sqrt(pi);\n    var tau = pi * 2;\n    var degrees = 180 / pi;\n    var radians = pi / 180;\n    function sinci(x) {\n        return x ? x / Math.sin(x) : 1;\n    }\n    function asin(x) {\n        return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n    }\n    function acos(x) {\n        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n    }\n    function sqrt(x) {\n        return x > 0 ? Math.sqrt(x) : 0;\n    }\n    function tanh(x) {\n        x = exp(2 * x);\n        return (x - 1) / (x + 1);\n    }\n    function sinh(x) {\n        return (exp(x) - exp(-x)) / 2;\n    }\n    function cosh(x) {\n        return (exp(x) + exp(-x)) / 2;\n    }\n    function arsinh(x) {\n        return log(x + sqrt(x * x + 1));\n    }\n    function arcosh(x) {\n        return log(x + sqrt(x * x - 1));\n    }\n    function airyRaw(beta) {\n        var tanBeta_2 = tan(beta / 2), b = 2 * log(cos(beta / 2)) / (tanBeta_2 * tanBeta_2);\n        function forward(x, y) {\n            var cosx = cos(x), cosy = cos(y), siny = sin(y), cosz = cosy * cosx, k = -((1 - cosz ? log((1 + cosz) / 2) / (1 - cosz) : -0.5) + b / (1 + cosz));\n            return [k * cosy * sin(x), k * siny];\n        }\n        forward.invert = function (x, y) {\n            var r = sqrt(x * x + y * y), z = -beta / 2, i = 50, delta;\n            if (!r)\n                return [0, 0];\n            do {\n                var z_2 = z / 2, cosz_2 = cos(z_2), sinz_2 = sin(z_2), tanz_2 = tan(z_2), lnsecz_2 = log(1 / cosz_2);\n                z -= delta = (2 / tanz_2 * lnsecz_2 - b * tanz_2 - r) / (-lnsecz_2 / (sinz_2 * sinz_2) + 1 - b / (2 * cosz_2 * cosz_2));\n            } while (abs(delta) > epsilon && --i > 0);\n            var sinz = sin(z);\n            return [atan2(x * sinz, r * cos(z)), asin(y * sinz / r)];\n        };\n        return forward;\n    }\n    var airy = function () {\n        var beta = halfPi, m = d3Geo.geoProjectionMutator(airyRaw), p = m(beta);\n        p.radius = function (_) {\n            return arguments.length ? m(beta = _ * radians) : beta * degrees;\n        };\n        return p\n            .scale(179.976)\n            .clipAngle(147);\n    };\n    function aitoffRaw(x, y) {\n        var cosy = cos(y), sincia = sinci(acos(cosy * cos(x /= 2)));\n        return [2 * cosy * sin(x) * sincia, sin(y) * sincia];\n    }\n    // Abort if [x, y] is not within an ellipse centered at [0, 0] with\n    // semi-major axis pi and semi-minor axis pi/2.\n    aitoffRaw.invert = function (x, y) {\n        if (x * x + 4 * y * y > pi * pi + epsilon)\n            return;\n        var x1 = x, y1 = y, i = 25;\n        do {\n            var sinx = sin(x1), sinx_2 = sin(x1 / 2), cosx_2 = cos(x1 / 2), siny = sin(y1), cosy = cos(y1), sin_2y = sin(2 * y1), sin2y = siny * siny, cos2y = cosy * cosy, sin2x_2 = sinx_2 * sinx_2, c = 1 - cos2y * cosx_2 * cosx_2, e = c ? acos(cosy * cosx_2) * sqrt(f = 1 / c) : f = 0, f, fx = 2 * e * cosy * sinx_2 - x, fy = e * siny - y, dxdx = f * (cos2y * sin2x_2 + e * cosy * cosx_2 * sin2y), dxdy = f * (0.5 * sinx * sin_2y - e * 2 * siny * sinx_2), dydx = f * 0.25 * (sin_2y * sinx_2 - e * siny * cos2y * sinx), dydy = f * (sin2y * cosx_2 + e * sin2x_2 * cosy), z = dxdy * dydx - dydy * dxdx;\n            if (!z)\n                break;\n            var dx = (fy * dxdy - fx * dydy) / z, dy = (fx * dydx - fy * dxdx) / z;\n            x1 -= dx, y1 -= dy;\n        } while ((abs(dx) > epsilon || abs(dy) > epsilon) && --i > 0);\n        return [x1, y1];\n    };\n    var aitoff = function () {\n        return d3Geo.geoProjection(aitoffRaw)\n            .scale(152.63);\n    };\n    function armadilloRaw(phi0) {\n        var sinPhi0 = sin(phi0), cosPhi0 = cos(phi0), sPhi0 = phi0 >= 0 ? 1 : -1, tanPhi0 = tan(sPhi0 * phi0), k = (1 + sinPhi0 - cosPhi0) / 2;\n        function forward(lambda, phi) {\n            var cosPhi = cos(phi), cosLambda = cos(lambda /= 2);\n            return [\n                (1 + cosPhi) * sin(lambda),\n                (sPhi0 * phi > -atan2(cosLambda, tanPhi0) - 1e-3 ? 0 : -sPhi0 * 10) + k + sin(phi) * cosPhi0 - (1 + cosPhi) * sinPhi0 * cosLambda // TODO D3 core should allow null or [NaN, NaN] to be returned.\n            ];\n        }\n        forward.invert = function (x, y) {\n            var lambda = 0, phi = 0, i = 50;\n            do {\n                var cosLambda = cos(lambda), sinLambda = sin(lambda), cosPhi = cos(phi), sinPhi = sin(phi), A = 1 + cosPhi, fx = A * sinLambda - x, fy = k + sinPhi * cosPhi0 - A * sinPhi0 * cosLambda - y, dxdLambda = A * cosLambda / 2, dxdPhi = -sinLambda * sinPhi, dydLambda = sinPhi0 * A * sinLambda / 2, dydPhi = cosPhi0 * cosPhi + sinPhi0 * cosLambda * sinPhi, denominator = dxdPhi * dydLambda - dydPhi * dxdLambda, dLambda = (fy * dxdPhi - fx * dydPhi) / denominator / 2, dPhi = (fx * dydLambda - fy * dxdLambda) / denominator;\n                lambda -= dLambda, phi -= dPhi;\n            } while ((abs(dLambda) > epsilon || abs(dPhi) > epsilon) && --i > 0);\n            return sPhi0 * phi > -atan2(cos(lambda), tanPhi0) - 1e-3 ? [lambda * 2, phi] : null;\n        };\n        return forward;\n    }\n    var armadillo = function () {\n        var phi0 = 20 * radians, sPhi0 = phi0 >= 0 ? 1 : -1, tanPhi0 = tan(sPhi0 * phi0), m = d3Geo.geoProjectionMutator(armadilloRaw), p = m(phi0), stream_ = p.stream;\n        p.parallel = function (_) {\n            if (!arguments.length)\n                return phi0 * degrees;\n            tanPhi0 = tan((sPhi0 = (phi0 = _ * radians) >= 0 ? 1 : -1) * phi0);\n            return m(phi0);\n        };\n        p.stream = function (stream) {\n            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));\n            p.rotate(rotate);\n            rotateStream.sphere = function () {\n                sphereStream.polygonStart(), sphereStream.lineStart();\n                for (var lambda = sPhi0 * -180; sPhi0 * lambda < 180; lambda += sPhi0 * 90)\n                    sphereStream.point(lambda, sPhi0 * 90);\n                while (sPhi0 * (lambda -= phi0) >= -180) { // TODO precision?\n                    sphereStream.point(lambda, sPhi0 * -atan2(cos(lambda * radians / 2), tanPhi0) * degrees);\n                }\n                sphereStream.lineEnd(), sphereStream.polygonEnd();\n            };\n            return rotateStream;\n        };\n        return p\n            .scale(218.695)\n            .center([0, 28.0974]);\n    };\n    function augustRaw(lambda, phi) {\n        var tanPhi = tan(phi / 2), k = sqrt(1 - tanPhi * tanPhi), c = 1 + k * cos(lambda /= 2), x = sin(lambda) * k / c, y = tanPhi / c, x2 = x * x, y2 = y * y;\n        return [\n            4 / 3 * x * (3 + x2 - 3 * y2),\n            4 / 3 * y * (3 + 3 * x2 - y2)\n        ];\n    }\n    augustRaw.invert = function (x, y) {\n        x *= 3 / 8, y *= 3 / 8;\n        if (!x && abs(y) > 1)\n            return null;\n        var x2 = x * x, y2 = y * y, s = 1 + x2 + y2, sin3Eta = sqrt((s - sqrt(s * s - 4 * y * y)) / 2), eta = asin(sin3Eta) / 3, xi = sin3Eta ? arcosh(abs(y / sin3Eta)) / 3 : arsinh(abs(x)) / 3, cosEta = cos(eta), coshXi = cosh(xi), d = coshXi * coshXi - cosEta * cosEta;\n        return [\n            sign(x) * 2 * atan2(sinh(xi) * cosEta, 0.25 - d),\n            sign(y) * 2 * atan2(coshXi * sin(eta), 0.25 + d)\n        ];\n    };\n    var august = function () {\n        return d3Geo.geoProjection(augustRaw)\n            .scale(66.1603);\n    };\n    var sqrt8 = sqrt(8);\n    var phi0 = log(1 + sqrt2);\n    function bakerRaw(lambda, phi) {\n        var phi0 = abs(phi);\n        return phi0 < quarterPi\n            ? [lambda, log(tan(quarterPi + phi / 2))]\n            : [lambda * cos(phi0) * (2 * sqrt2 - 1 / sin(phi0)), sign(phi) * (2 * sqrt2 * (phi0 - quarterPi) - log(tan(phi0 / 2)))];\n    }\n    bakerRaw.invert = function (x, y) {\n        if ((y0 = abs(y)) < phi0)\n            return [x, 2 * atan(exp(y)) - halfPi];\n        var phi = quarterPi, i = 25, delta, y0;\n        do {\n            var cosPhi_2 = cos(phi / 2), tanPhi_2 = tan(phi / 2);\n            phi -= delta = (sqrt8 * (phi - quarterPi) - log(tanPhi_2) - y0) / (sqrt8 - cosPhi_2 * cosPhi_2 / (2 * tanPhi_2));\n        } while (abs(delta) > epsilon2 && --i > 0);\n        return [x / (cos(phi) * (sqrt8 - 1 / sin(phi))), sign(y) * phi];\n    };\n    var baker = function () {\n        return d3Geo.geoProjection(bakerRaw)\n            .scale(112.314);\n    };\n    function berghausRaw(lobes) {\n        var k = 2 * pi / lobes;\n        function forward(lambda, phi) {\n            var p = d3Geo.geoAzimuthalEquidistantRaw(lambda, phi);\n            if (abs(lambda) > halfPi) { // back hemisphere\n                var theta = atan2(p[1], p[0]), r = sqrt(p[0] * p[0] + p[1] * p[1]), theta0 = k * round((theta - halfPi) / k) + halfPi, alpha = atan2(sin(theta -= theta0), 2 - cos(theta)); // angle relative to lobe end\n                theta = theta0 + asin(pi / r * sin(alpha)) - alpha;\n                p[0] = r * cos(theta);\n                p[1] = r * sin(theta);\n            }\n            return p;\n        }\n        forward.invert = function (x, y) {\n            var r = sqrt(x * x + y * y);\n            if (r > halfPi) {\n                var theta = atan2(y, x), theta0 = k * round((theta - halfPi) / k) + halfPi, s = theta > theta0 ? -1 : 1, A = r * cos(theta0 - theta), cotAlpha = 1 / tan(s * acos((A - pi) / sqrt(pi * (pi - 2 * A) + r * r)));\n                theta = theta0 + 2 * atan((cotAlpha + s * sqrt(cotAlpha * cotAlpha - 3)) / 3);\n                x = r * cos(theta), y = r * sin(theta);\n            }\n            return d3Geo.geoAzimuthalEquidistantRaw.invert(x, y);\n        };\n        return forward;\n    }\n    var berghaus = function () {\n        var lobes = 5, m = d3Geo.geoProjectionMutator(berghausRaw), p = m(lobes), projectionStream = p.stream, epsilon$$1 = 1e-2, cr = -cos(epsilon$$1 * radians), sr = sin(epsilon$$1 * radians);\n        p.lobes = function (_) {\n            return arguments.length ? m(lobes = +_) : lobes;\n        };\n        p.stream = function (stream) {\n            var rotate = p.rotate(), rotateStream = projectionStream(stream), sphereStream = (p.rotate([0, 0]), projectionStream(stream));\n            p.rotate(rotate);\n            rotateStream.sphere = function () {\n                sphereStream.polygonStart(), sphereStream.lineStart();\n                for (var i = 0, delta = 360 / lobes, delta0 = 2 * pi / lobes, phi = 90 - 180 / lobes, phi0 = halfPi; i < lobes; ++i, phi -= delta, phi0 -= delta0) {\n                    sphereStream.point(atan2(sr * cos(phi0), cr) * degrees, asin(sr * sin(phi0)) * degrees);\n                    if (phi < -90) {\n                        sphereStream.point(-90, -180 - phi - epsilon$$1);\n                        sphereStream.point(-90, -180 - phi + epsilon$$1);\n                    }\n                    else {\n                        sphereStream.point(90, phi + epsilon$$1);\n                        sphereStream.point(90, phi - epsilon$$1);\n                    }\n                }\n                sphereStream.lineEnd(), sphereStream.polygonEnd();\n            };\n            return rotateStream;\n        };\n        return p\n            .scale(87.8076)\n            .center([0, 17.1875])\n            .clipAngle(180 - 1e-3);\n    };\n    function mollweideBromleyTheta(cp, phi) {\n        var cpsinPhi = cp * sin(phi), i = 30, delta;\n        do\n            phi -= delta = (phi + sin(phi) - cpsinPhi) / (1 + cos(phi));\n        while (abs(delta) > epsilon && --i > 0);\n        return phi / 2;\n    }\n    function mollweideBromleyRaw(cx, cy, cp) {\n        function forward(lambda, phi) {\n            return [cx * lambda * cos(phi = mollweideBromleyTheta(cp, phi)), cy * sin(phi)];\n        }\n        forward.invert = function (x, y) {\n            return y = asin(y / cy), [x / (cx * cos(y)), asin((2 * y + sin(2 * y)) / cp)];\n        };\n        return forward;\n    }\n    var mollweideRaw = mollweideBromleyRaw(sqrt2 / halfPi, sqrt2, pi);\n    var mollweide = function () {\n        return d3Geo.geoProjection(mollweideRaw)\n            .scale(169.529);\n    };\n    var k = 2.00276;\n    var w = 1.11072;\n    function boggsRaw(lambda, phi) {\n        var theta = mollweideBromleyTheta(pi, phi);\n        return [k * lambda / (1 / cos(phi) + w / cos(theta)), (phi + sqrt2 * sin(theta)) / k];\n    }\n    boggsRaw.invert = function (x, y) {\n        var ky = k * y, theta = y < 0 ? -quarterPi : quarterPi, i = 25, delta, phi;\n        do {\n            phi = ky - sqrt2 * sin(theta);\n            theta -= delta = (sin(2 * theta) + 2 * theta - pi * sin(phi)) / (2 * cos(2 * theta) + 2 + pi * cos(phi) * sqrt2 * cos(theta));\n        } while (abs(delta) > epsilon && --i > 0);\n        phi = ky - sqrt2 * sin(theta);\n        return [x * (1 / cos(phi) + w / cos(theta)) / k, phi];\n    };\n    var boggs = function () {\n        return d3Geo.geoProjection(boggsRaw)\n            .scale(160.857);\n    };\n    var parallel1 = function (projectAt) {\n        var phi0 = 0, m = d3Geo.geoProjectionMutator(projectAt), p = m(phi0);\n        p.parallel = function (_) {\n            return arguments.length ? m(phi0 = _ * radians) : phi0 * degrees;\n        };\n        return p;\n    };\n    function sinusoidalRaw(lambda, phi) {\n        return [lambda * cos(phi), phi];\n    }\n    sinusoidalRaw.invert = function (x, y) {\n        return [x / cos(y), y];\n    };\n    var sinusoidal = function () {\n        return d3Geo.geoProjection(sinusoidalRaw)\n            .scale(152.63);\n    };\n    function bonneRaw(phi0) {\n        if (!phi0)\n            return sinusoidalRaw;\n        var cotPhi0 = 1 / tan(phi0);\n        function forward(lambda, phi) {\n            var rho = cotPhi0 + phi0 - phi, e = rho ? lambda * cos(phi) / rho : rho;\n            return [rho * sin(e), cotPhi0 - rho * cos(e)];\n        }\n        forward.invert = function (x, y) {\n            var rho = sqrt(x * x + (y = cotPhi0 - y) * y), phi = cotPhi0 + phi0 - rho;\n            return [rho / cos(phi) * atan2(x, y), phi];\n        };\n        return forward;\n    }\n    var bonne = function () {\n        return parallel1(bonneRaw)\n            .scale(123.082)\n            .center([0, 26.1441])\n            .parallel(45);\n    };\n    function bottomleyRaw(sinPsi) {\n        function forward(lambda, phi) {\n            var rho = halfPi - phi, eta = rho ? lambda * sinPsi * sin(rho) / rho : rho;\n            return [rho * sin(eta) / sinPsi, halfPi - rho * cos(eta)];\n        }\n        forward.invert = function (x, y) {\n            var x1 = x * sinPsi, y1 = halfPi - y, rho = sqrt(x1 * x1 + y1 * y1), eta = atan2(x1, y1);\n            return [(rho ? rho / sin(rho) : 1) * eta / sinPsi, halfPi - rho];\n        };\n        return forward;\n    }\n    var bottomley = function () {\n        var sinPsi = 0.5, m = d3Geo.geoProjectionMutator(bottomleyRaw), p = m(sinPsi);\n        p.fraction = function (_) {\n            return arguments.length ? m(sinPsi = +_) : sinPsi;\n        };\n        return p\n            .scale(158.837);\n    };\n    var bromleyRaw = mollweideBromleyRaw(1, 4 / pi, pi);\n    var bromley = function () {\n        return d3Geo.geoProjection(bromleyRaw)\n            .scale(152.63);\n    };\n    // Azimuthal distance.\n    function distance(dPhi, c1, s1, c2, s2, dLambda) {\n        var cosdLambda = cos(dLambda), r;\n        if (abs(dPhi) > 1 || abs(dLambda) > 1) {\n            r = acos(s1 * s2 + c1 * c2 * cosdLambda);\n        }\n        else {\n            var sindPhi = sin(dPhi / 2), sindLambda = sin(dLambda / 2);\n            r = 2 * asin(sqrt(sindPhi * sindPhi + c1 * c2 * sindLambda * sindLambda));\n        }\n        return abs(r) > epsilon ? [r, atan2(c2 * sin(dLambda), c1 * s2 - s1 * c2 * cosdLambda)] : [0, 0];\n    }\n    // Angle opposite a, and contained between sides of lengths b and c.\n    function angle(b, c, a) {\n        return acos((b * b + c * c - a * a) / (2 * b * c));\n    }\n    // Normalize longitude.\n    function longitude(lambda) {\n        return lambda - 2 * pi * floor((lambda + pi) / (2 * pi));\n    }\n    function chamberlinRaw(p0, p1, p2) {\n        var points = [\n            [p0[0], p0[1], sin(p0[1]), cos(p0[1])],\n            [p1[0], p1[1], sin(p1[1]), cos(p1[1])],\n            [p2[0], p2[1], sin(p2[1]), cos(p2[1])]\n        ];\n        for (var a = points[2], b, i = 0; i < 3; ++i, a = b) {\n            b = points[i];\n            a.v = distance(b[1] - a[1], a[3], a[2], b[3], b[2], b[0] - a[0]);\n            a.point = [0, 0];\n        }\n        var beta0 = angle(points[0].v[0], points[2].v[0], points[1].v[0]), beta1 = angle(points[0].v[0], points[1].v[0], points[2].v[0]), beta2 = pi - beta0;\n        points[2].point[1] = 0;\n        points[0].point[0] = -(points[1].point[0] = points[0].v[0] / 2);\n        var mean = [\n            points[2].point[0] = points[0].point[0] + points[2].v[0] * cos(beta0),\n            2 * (points[0].point[1] = points[1].point[1] = points[2].v[0] * sin(beta0))\n        ];\n        function forward(lambda, phi) {\n            var sinPhi = sin(phi), cosPhi = cos(phi), v = new Array(3), i;\n            // Compute distance and azimuth from control points.\n            for (i = 0; i < 3; ++i) {\n                var p = points[i];\n                v[i] = distance(phi - p[1], p[3], p[2], cosPhi, sinPhi, lambda - p[0]);\n                if (!v[i][0])\n                    return p.point;\n                v[i][1] = longitude(v[i][1] - p.v[1]);\n            }\n            // Arithmetic mean of interception points.\n            var point = mean.slice();\n            for (i = 0; i < 3; ++i) {\n                var j = i == 2 ? 0 : i + 1;\n                var a = angle(points[i].v[0], v[i][0], v[j][0]);\n                if (v[i][1] < 0)\n                    a = -a;\n                if (!i) {\n                    point[0] += v[i][0] * cos(a);\n                    point[1] -= v[i][0] * sin(a);\n                }\n                else if (i == 1) {\n                    a = beta1 - a;\n                    point[0] -= v[i][0] * cos(a);\n                    point[1] -= v[i][0] * sin(a);\n                }\n                else {\n                    a = beta2 - a;\n                    point[0] += v[i][0] * cos(a);\n                    point[1] += v[i][0] * sin(a);\n                }\n            }\n            point[0] /= 3, point[1] /= 3;\n            return point;\n        }\n        return forward;\n    }\n    function pointRadians(p) {\n        return p[0] *= radians, p[1] *= radians, p;\n    }\n    function chamberlinAfrica() {\n        return chamberlin([0, 22], [45, 22], [22.5, -22])\n            .scale(380)\n            .center([22.5, 2]);\n    }\n    function chamberlin(p0, p1, p2) {\n        var c = d3Geo.geoCentroid({ type: \"MultiPoint\", coordinates: [p0, p1, p2] }), R = [-c[0], -c[1]], r = d3Geo.geoRotation(R), p = d3Geo.geoProjection(chamberlinRaw(pointRadians(r(p0)), pointRadians(r(p1)), pointRadians(r(p2)))).rotate(R), center = p.center;\n        delete p.rotate;\n        p.center = function (_) {\n            return arguments.length ? center(r(_)) : r.invert(center());\n        };\n        return p\n            .clipAngle(90);\n    }\n    function collignonRaw(lambda, phi) {\n        var alpha = sqrt(1 - sin(phi));\n        return [(2 / sqrtPi) * lambda * alpha, sqrtPi * (1 - alpha)];\n    }\n    collignonRaw.invert = function (x, y) {\n        var lambda = (lambda = y / sqrtPi - 1) * lambda;\n        return [lambda > 0 ? x * sqrt(pi / lambda) / 2 : 0, asin(1 - lambda)];\n    };\n    var collignon = function () {\n        return d3Geo.geoProjection(collignonRaw)\n            .scale(95.6464)\n            .center([0, 30]);\n    };\n    function craigRaw(phi0) {\n        var tanPhi0 = tan(phi0);\n        function forward(lambda, phi) {\n            return [lambda, (lambda ? lambda / sin(lambda) : 1) * (sin(phi) * cos(lambda) - tanPhi0 * cos(phi))];\n        }\n        forward.invert = tanPhi0 ? function (x, y) {\n            if (x)\n                y *= sin(x) / x;\n            var cosLambda = cos(x);\n            return [x, 2 * atan2(sqrt(cosLambda * cosLambda + tanPhi0 * tanPhi0 - y * y) - cosLambda, tanPhi0 - y)];\n        } : function (x, y) {\n            return [x, asin(x ? y * tan(x) / x : y)];\n        };\n        return forward;\n    }\n    var craig = function () {\n        return parallel1(craigRaw)\n            .scale(249.828)\n            .clipAngle(90);\n    };\n    var sqrt3 = sqrt(3);\n    function crasterRaw(lambda, phi) {\n        return [sqrt3 * lambda * (2 * cos(2 * phi / 3) - 1) / sqrtPi, sqrt3 * sqrtPi * sin(phi / 3)];\n    }\n    crasterRaw.invert = function (x, y) {\n        var phi = 3 * asin(y / (sqrt3 * sqrtPi));\n        return [sqrtPi * x / (sqrt3 * (2 * cos(2 * phi / 3) - 1)), phi];\n    };\n    var craster = function () {\n        return d3Geo.geoProjection(crasterRaw)\n            .scale(156.19);\n    };\n    function cylindricalEqualAreaRaw(phi0) {\n        var cosPhi0 = cos(phi0);\n        function forward(lambda, phi) {\n            return [lambda * cosPhi0, sin(phi) / cosPhi0];\n        }\n        forward.invert = function (x, y) {\n            return [x / cosPhi0, asin(y * cosPhi0)];\n        };\n        return forward;\n    }\n    var cylindricalEqualArea = function () {\n        return parallel1(cylindricalEqualAreaRaw)\n            .parallel(38.58) // acos(sqrt(width / height / pi)) * radians\n            .scale(195.044); // width / (sqrt(width / height / pi) * 2 * pi)\n    };\n    function cylindricalStereographicRaw(phi0) {\n        var cosPhi0 = cos(phi0);\n        function forward(lambda, phi) {\n            return [lambda * cosPhi0, (1 + cosPhi0) * tan(phi / 2)];\n        }\n        forward.invert = function (x, y) {\n            return [x / cosPhi0, atan(y / (1 + cosPhi0)) * 2];\n        };\n        return forward;\n    }\n    var cylindricalStereographic = function () {\n        return parallel1(cylindricalStereographicRaw)\n            .scale(124.75);\n    };\n    function eckert1Raw(lambda, phi) {\n        var alpha = sqrt(8 / (3 * pi));\n        return [\n            alpha * lambda * (1 - abs(phi) / pi),\n            alpha * phi\n        ];\n    }\n    eckert1Raw.invert = function (x, y) {\n        var alpha = sqrt(8 / (3 * pi)), phi = y / alpha;\n        return [\n            x / (alpha * (1 - abs(phi) / pi)),\n            phi\n        ];\n    };\n    var eckert1 = function () {\n        return d3Geo.geoProjection(eckert1Raw)\n            .scale(165.664);\n    };\n    function eckert2Raw(lambda, phi) {\n        var alpha = sqrt(4 - 3 * sin(abs(phi)));\n        return [\n            2 / sqrt(6 * pi) * lambda * alpha,\n            sign(phi) * sqrt(2 * pi / 3) * (2 - alpha)\n        ];\n    }\n    eckert2Raw.invert = function (x, y) {\n        var alpha = 2 - abs(y) / sqrt(2 * pi / 3);\n        return [\n            x * sqrt(6 * pi) / (2 * alpha),\n            sign(y) * asin((4 - alpha * alpha) / 3)\n        ];\n    };\n    var eckert2 = function () {\n        return d3Geo.geoProjection(eckert2Raw)\n            .scale(165.664);\n    };\n    function eckert3Raw(lambda, phi) {\n        var k = sqrt(pi * (4 + pi));\n        return [\n            2 / k * lambda * (1 + sqrt(1 - 4 * phi * phi / (pi * pi))),\n            4 / k * phi\n        ];\n    }\n    eckert3Raw.invert = function (x, y) {\n        var k = sqrt(pi * (4 + pi)) / 2;\n        return [\n            x * k / (1 + sqrt(1 - y * y * (4 + pi) / (4 * pi))),\n            y * k / 2\n        ];\n    };\n    var eckert3 = function () {\n        return d3Geo.geoProjection(eckert3Raw)\n            .scale(180.739);\n    };\n    function eckert4Raw(lambda, phi) {\n        var k = (2 + halfPi) * sin(phi);\n        phi /= 2;\n        for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; i++) {\n            var cosPhi = cos(phi);\n            phi -= delta = (phi + sin(phi) * (cosPhi + 2) - k) / (2 * cosPhi * (1 + cosPhi));\n        }\n        return [\n            2 / sqrt(pi * (4 + pi)) * lambda * (1 + cos(phi)),\n            2 * sqrt(pi / (4 + pi)) * sin(phi)\n        ];\n    }\n    eckert4Raw.invert = function (x, y) {\n        var A = y * sqrt((4 + pi) / pi) / 2, k = asin(A), c = cos(k);\n        return [\n            x / (2 / sqrt(pi * (4 + pi)) * (1 + c)),\n            asin((k + A * (c + 2)) / (2 + halfPi))\n        ];\n    };\n    var eckert4 = function () {\n        return d3Geo.geoProjection(eckert4Raw)\n            .scale(180.739);\n    };\n    function eckert5Raw(lambda, phi) {\n        return [\n            lambda * (1 + cos(phi)) / sqrt(2 + pi),\n            2 * phi / sqrt(2 + pi)\n        ];\n    }\n    eckert5Raw.invert = function (x, y) {\n        var k = sqrt(2 + pi), phi = y * k / 2;\n        return [\n            k * x / (1 + cos(phi)),\n            phi\n        ];\n    };\n    var eckert5 = function () {\n        return d3Geo.geoProjection(eckert5Raw)\n            .scale(173.044);\n    };\n    function eckert6Raw(lambda, phi) {\n        var k = (1 + halfPi) * sin(phi);\n        for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; i++) {\n            phi -= delta = (phi + sin(phi) - k) / (1 + cos(phi));\n        }\n        k = sqrt(2 + pi);\n        return [\n            lambda * (1 + cos(phi)) / k,\n            2 * phi / k\n        ];\n    }\n    eckert6Raw.invert = function (x, y) {\n        var j = 1 + halfPi, k = sqrt(j / 2);\n        return [\n            x * 2 * k / (1 + cos(y *= k)),\n            asin((y + sin(y)) / j)\n        ];\n    };\n    var eckert6 = function () {\n        return d3Geo.geoProjection(eckert6Raw)\n            .scale(173.044);\n    };\n    var eisenlohrK = 3 + 2 * sqrt2;\n    function eisenlohrRaw(lambda, phi) {\n        var s0 = sin(lambda /= 2), c0 = cos(lambda), k = sqrt(cos(phi)), c1 = cos(phi /= 2), t = sin(phi) / (c1 + sqrt2 * c0 * k), c = sqrt(2 / (1 + t * t)), v = sqrt((sqrt2 * c1 + (c0 + s0) * k) / (sqrt2 * c1 + (c0 - s0) * k));\n        return [\n            eisenlohrK * (c * (v - 1 / v) - 2 * log(v)),\n            eisenlohrK * (c * t * (v + 1 / v) - 2 * atan(t))\n        ];\n    }\n    eisenlohrRaw.invert = function (x, y) {\n        if (!(p = augustRaw.invert(x / 1.2, y * 1.065)))\n            return null;\n        var lambda = p[0], phi = p[1], i = 20, p;\n        x /= eisenlohrK, y /= eisenlohrK;\n        do {\n            var _0 = lambda / 2, _1 = phi / 2, s0 = sin(_0), c0 = cos(_0), s1 = sin(_1), c1 = cos(_1), cos1 = cos(phi), k = sqrt(cos1), t = s1 / (c1 + sqrt2 * c0 * k), t2 = t * t, c = sqrt(2 / (1 + t2)), v0 = (sqrt2 * c1 + (c0 + s0) * k), v1 = (sqrt2 * c1 + (c0 - s0) * k), v2 = v0 / v1, v = sqrt(v2), vm1v = v - 1 / v, vp1v = v + 1 / v, fx = c * vm1v - 2 * log(v) - x, fy = c * t * vp1v - 2 * atan(t) - y, deltatDeltaLambda = s1 && sqrt1_2 * k * s0 * t2 / s1, deltatDeltaPhi = (sqrt2 * c0 * c1 + k) / (2 * (c1 + sqrt2 * c0 * k) * (c1 + sqrt2 * c0 * k) * k), deltacDeltat = -0.5 * t * c * c * c, deltacDeltaLambda = deltacDeltat * deltatDeltaLambda, deltacDeltaPhi = deltacDeltat * deltatDeltaPhi, A = (A = 2 * c1 + sqrt2 * k * (c0 - s0)) * A * v, deltavDeltaLambda = (sqrt2 * c0 * c1 * k + cos1) / A, deltavDeltaPhi = -(sqrt2 * s0 * s1) / (k * A), deltaxDeltaLambda = vm1v * deltacDeltaLambda - 2 * deltavDeltaLambda / v + c * (deltavDeltaLambda + deltavDeltaLambda / v2), deltaxDeltaPhi = vm1v * deltacDeltaPhi - 2 * deltavDeltaPhi / v + c * (deltavDeltaPhi + deltavDeltaPhi / v2), deltayDeltaLambda = t * vp1v * deltacDeltaLambda - 2 * deltatDeltaLambda / (1 + t2) + c * vp1v * deltatDeltaLambda + c * t * (deltavDeltaLambda - deltavDeltaLambda / v2), deltayDeltaPhi = t * vp1v * deltacDeltaPhi - 2 * deltatDeltaPhi / (1 + t2) + c * vp1v * deltatDeltaPhi + c * t * (deltavDeltaPhi - deltavDeltaPhi / v2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;\n            if (!denominator)\n                break;\n            var deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;\n            lambda -= deltaLambda;\n            phi = max(-halfPi, min(halfPi, phi - deltaPhi));\n        } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);\n        return abs(abs(phi) - halfPi) < epsilon ? [0, phi] : i && [lambda, phi];\n    };\n    var eisenlohr = function () {\n        return d3Geo.geoProjection(eisenlohrRaw)\n            .scale(62.5271);\n    };\n    var faheyK = cos(35 * radians);\n    function faheyRaw(lambda, phi) {\n        var t = tan(phi / 2);\n        return [lambda * faheyK * sqrt(1 - t * t), (1 + faheyK) * t];\n    }\n    faheyRaw.invert = function (x, y) {\n        var t = y / (1 + faheyK);\n        return [x && x / (faheyK * sqrt(1 - t * t)), 2 * atan(t)];\n    };\n    var fahey = function () {\n        return d3Geo.geoProjection(faheyRaw)\n            .scale(137.152);\n    };\n    function foucautRaw(lambda, phi) {\n        var k = phi / 2, cosk = cos(k);\n        return [2 * lambda / sqrtPi * cos(phi) * cosk * cosk, sqrtPi * tan(k)];\n    }\n    foucautRaw.invert = function (x, y) {\n        var k = atan(y / sqrtPi), cosk = cos(k), phi = 2 * k;\n        return [x * sqrtPi / 2 / (cos(phi) * cosk * cosk), phi];\n    };\n    var foucaut = function () {\n        return d3Geo.geoProjection(foucautRaw)\n            .scale(135.264);\n    };\n    function gilbertForward(point) {\n        return [point[0] / 2, asin(tan(point[1] / 2 * radians)) * degrees];\n    }\n    function gilbertInvert(point) {\n        return [point[0] * 2, 2 * atan(sin(point[1] * radians)) * degrees];\n    }\n    var gilbert = function (projectionType) {\n        if (projectionType == null)\n            projectionType = d3Geo.geoOrthographic;\n        var projection = projectionType(), equirectangular = d3Geo.geoEquirectangular().scale(degrees).precision(0).clipAngle(null).translate([0, 0]); // antimeridian cutting\n        function gilbert(point) {\n            return projection(gilbertForward(point));\n        }\n        if (projection.invert)\n            gilbert.invert = function (point) {\n                return gilbertInvert(projection.invert(point));\n            };\n        gilbert.stream = function (stream) {\n            var s1 = projection.stream(stream), s0 = equirectangular.stream({\n                point: function (lambda, phi) { s1.point(lambda / 2, asin(tan(-phi / 2 * radians)) * degrees); },\n                lineStart: function () { s1.lineStart(); },\n                lineEnd: function () { s1.lineEnd(); },\n                polygonStart: function () { s1.polygonStart(); },\n                polygonEnd: function () { s1.polygonEnd(); }\n            });\n            s0.sphere = s1.sphere;\n            return s0;\n        };\n        function property(name) {\n            gilbert[name] = function (_) {\n                return arguments.length ? (projection[name](_), gilbert) : projection[name]();\n            };\n        }\n        gilbert.rotate = function (_) {\n            return arguments.length ? (equirectangular.rotate(_), gilbert) : equirectangular.rotate();\n        };\n        gilbert.center = function (_) {\n            return arguments.length ? (projection.center(gilbertForward(_)), gilbert) : gilbertInvert(projection.center());\n        };\n        property(\"clipAngle\");\n        property(\"clipExtent\");\n        property(\"scale\");\n        property(\"translate\");\n        property(\"precision\");\n        return gilbert\n            .scale(249.5);\n    };\n    function gingeryRaw(rho, n) {\n        var k = 2 * pi / n, rho2 = rho * rho;\n        function forward(lambda, phi) {\n            var p = d3Geo.geoAzimuthalEquidistantRaw(lambda, phi), x = p[0], y = p[1], r2 = x * x + y * y;\n            if (r2 > rho2) {\n                var r = sqrt(r2), theta = atan2(y, x), theta0 = k * round(theta / k), alpha = theta - theta0, rhoCosAlpha = rho * cos(alpha), k_ = (rho * sin(alpha) - alpha * sin(rhoCosAlpha)) / (halfPi - rhoCosAlpha), s_ = gingeryLength(alpha, k_), e = (pi - rho) / gingeryIntegrate(s_, rhoCosAlpha, pi);\n                x = r;\n                var i = 50, delta;\n                do {\n                    x -= delta = (rho + gingeryIntegrate(s_, rhoCosAlpha, x) * e - r) / (s_(x) * e);\n                } while (abs(delta) > epsilon && --i > 0);\n                y = alpha * sin(x);\n                if (x < halfPi)\n                    y -= k_ * (x - halfPi);\n                var s = sin(theta0), c = cos(theta0);\n                p[0] = x * c - y * s;\n                p[1] = x * s + y * c;\n            }\n            return p;\n        }\n        forward.invert = function (x, y) {\n            var r2 = x * x + y * y;\n            if (r2 > rho2) {\n                var r = sqrt(r2), theta = atan2(y, x), theta0 = k * round(theta / k), dTheta = theta - theta0;\n                x = r * cos(dTheta);\n                y = r * sin(dTheta);\n                var x_halfPi = x - halfPi, sinx = sin(x), alpha = y / sinx, delta = x < halfPi ? Infinity : 0, i = 10;\n                while (true) {\n                    var rhosinAlpha = rho * sin(alpha), rhoCosAlpha = rho * cos(alpha), sinRhoCosAlpha = sin(rhoCosAlpha), halfPi_RhoCosAlpha = halfPi - rhoCosAlpha, k_ = (rhosinAlpha - alpha * sinRhoCosAlpha) / halfPi_RhoCosAlpha, s_ = gingeryLength(alpha, k_);\n                    if (abs(delta) < epsilon2 || !--i)\n                        break;\n                    alpha -= delta = (alpha * sinx - k_ * x_halfPi - y) / (sinx - x_halfPi * 2 * (halfPi_RhoCosAlpha * (rhoCosAlpha + alpha * rhosinAlpha * cos(rhoCosAlpha) - sinRhoCosAlpha) -\n                        rhosinAlpha * (rhosinAlpha - alpha * sinRhoCosAlpha)) / (halfPi_RhoCosAlpha * halfPi_RhoCosAlpha));\n                }\n                r = rho + gingeryIntegrate(s_, rhoCosAlpha, x) * (pi - rho) / gingeryIntegrate(s_, rhoCosAlpha, pi);\n                theta = theta0 + alpha;\n                x = r * cos(theta);\n                y = r * sin(theta);\n            }\n            return d3Geo.geoAzimuthalEquidistantRaw.invert(x, y);\n        };\n        return forward;\n    }\n    function gingeryLength(alpha, k) {\n        return function (x) {\n            var y_ = alpha * cos(x);\n            if (x < halfPi)\n                y_ -= k;\n            return sqrt(1 + y_ * y_);\n        };\n    }\n    // Numerical integration: trapezoidal rule.\n    function gingeryIntegrate(f, a, b) {\n        var n = 50, h = (b - a) / n, s = f(a) + f(b);\n        for (var i = 1, x = a; i < n; ++i)\n            s += 2 * f(x += h);\n        return s * 0.5 * h;\n    }\n    var gingery = function () {\n        var n = 6, rho = 30 * radians, cRho = cos(rho), sRho = sin(rho), m = d3Geo.geoProjectionMutator(gingeryRaw), p = m(rho, n), stream_ = p.stream, epsilon$$1 = 1e-2, cr = -cos(epsilon$$1 * radians), sr = sin(epsilon$$1 * radians);\n        p.radius = function (_) {\n            if (!arguments.length)\n                return rho * degrees;\n            cRho = cos(rho = _ * radians);\n            sRho = sin(rho);\n            return m(rho, n);\n        };\n        p.lobes = function (_) {\n            if (!arguments.length)\n                return n;\n            return m(rho, n = +_);\n        };\n        p.stream = function (stream) {\n            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));\n            p.rotate(rotate);\n            rotateStream.sphere = function () {\n                sphereStream.polygonStart(), sphereStream.lineStart();\n                for (var i = 0, delta = 2 * pi / n, phi = 0; i < n; ++i, phi -= delta) {\n                    sphereStream.point(atan2(sr * cos(phi), cr) * degrees, asin(sr * sin(phi)) * degrees);\n                    sphereStream.point(atan2(sRho * cos(phi - delta / 2), cRho) * degrees, asin(sRho * sin(phi - delta / 2)) * degrees);\n                }\n                sphereStream.lineEnd(), sphereStream.polygonEnd();\n            };\n            return rotateStream;\n        };\n        return p\n            .rotate([90, -40])\n            .scale(91.7095)\n            .clipAngle(180 - 1e-3);\n    };\n    var ginzburgPolyconicRaw = function (a, b, c, d, e, f, g, h) {\n        if (arguments.length < 8)\n            h = 0;\n        function forward(lambda, phi) {\n            if (!phi)\n                return [a * lambda / pi, 0];\n            var phi2 = phi * phi, xB = a + phi2 * (b + phi2 * (c + phi2 * d)), yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)), m = (xB * xB + yB * yB) / (2 * yB), alpha = lambda * asin(xB / m) / pi;\n            return [m * sin(alpha), phi * (1 + phi2 * h) + m * (1 - cos(alpha))];\n        }\n        forward.invert = function (x, y) {\n            var lambda = pi * x / a, phi = y, deltaLambda, deltaPhi, i = 50;\n            do {\n                var phi2 = phi * phi, xB = a + phi2 * (b + phi2 * (c + phi2 * d)), yB = phi * (e - 1 + phi2 * (f - h + phi2 * g)), p = xB * xB + yB * yB, q = 2 * yB, m = p / q, m2 = m * m, dAlphadLambda = asin(xB / m) / pi, alpha = lambda * dAlphadLambda, xB2 = xB * xB, dxBdPhi = (2 * b + phi2 * (4 * c + phi2 * 6 * d)) * phi, dyBdPhi = e + phi2 * (3 * f + phi2 * 5 * g), dpdPhi = 2 * (xB * dxBdPhi + yB * (dyBdPhi - 1)), dqdPhi = 2 * (dyBdPhi - 1), dmdPhi = (dpdPhi * q - p * dqdPhi) / (q * q), cosAlpha = cos(alpha), sinAlpha = sin(alpha), mcosAlpha = m * cosAlpha, msinAlpha = m * sinAlpha, dAlphadPhi = ((lambda / pi) * (1 / sqrt(1 - xB2 / m2)) * (dxBdPhi * m - xB * dmdPhi)) / m2, fx = msinAlpha - x, fy = phi * (1 + phi2 * h) + m - mcosAlpha - y, deltaxDeltaPhi = dmdPhi * sinAlpha + mcosAlpha * dAlphadPhi, deltaxDeltaLambda = mcosAlpha * dAlphadLambda, deltayDeltaPhi = 1 + dmdPhi - (dmdPhi * cosAlpha - msinAlpha * dAlphadPhi), deltayDeltaLambda = msinAlpha * dAlphadLambda, denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda;\n                if (!denominator)\n                    break;\n                lambda -= deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator;\n                phi -= deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;\n            } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);\n            return [lambda, phi];\n        };\n        return forward;\n    };\n    var ginzburg4Raw = ginzburgPolyconicRaw(2.8284, -1.6988, 0.75432, -0.18071, 1.76003, -0.38914, 0.042555);\n    var ginzburg4 = function () {\n        return d3Geo.geoProjection(ginzburg4Raw)\n            .scale(149.995);\n    };\n    var ginzburg5Raw = ginzburgPolyconicRaw(2.583819, -0.835827, 0.170354, -0.038094, 1.543313, -0.411435, 0.082742);\n    var ginzburg5 = function () {\n        return d3Geo.geoProjection(ginzburg5Raw)\n            .scale(153.93);\n    };\n    var ginzburg6Raw = ginzburgPolyconicRaw(5 / 6 * pi, -0.62636, -0.0344, 0, 1.3493, -0.05524, 0, 0.045);\n    var ginzburg6 = function () {\n        return d3Geo.geoProjection(ginzburg6Raw)\n            .scale(130.945);\n    };\n    function ginzburg8Raw(lambda, phi) {\n        var lambda2 = lambda * lambda, phi2 = phi * phi;\n        return [\n            lambda * (1 - 0.162388 * phi2) * (0.87 - 0.000952426 * lambda2 * lambda2),\n            phi * (1 + phi2 / 12)\n        ];\n    }\n    ginzburg8Raw.invert = function (x, y) {\n        var lambda = x, phi = y, i = 50, delta;\n        do {\n            var phi2 = phi * phi;\n            phi -= delta = (phi * (1 + phi2 / 12) - y) / (1 + phi2 / 4);\n        } while (abs(delta) > epsilon && --i > 0);\n        i = 50;\n        x /= 1 - 0.162388 * phi2;\n        do {\n            var lambda4 = (lambda4 = lambda * lambda) * lambda4;\n            lambda -= delta = (lambda * (0.87 - 0.000952426 * lambda4) - x) / (0.87 - 0.00476213 * lambda4);\n        } while (abs(delta) > epsilon && --i > 0);\n        return [lambda, phi];\n    };\n    var ginzburg8 = function () {\n        return d3Geo.geoProjection(ginzburg8Raw)\n            .scale(131.747);\n    };\n    var ginzburg9Raw = ginzburgPolyconicRaw(2.6516, -0.76534, 0.19123, -0.047094, 1.36289, -0.13965, 0.031762);\n    var ginzburg9 = function () {\n        return d3Geo.geoProjection(ginzburg9Raw)\n            .scale(131.087);\n    };\n    var squareRaw = function (project) {\n        var dx = project(halfPi, 0)[0] - project(-halfPi, 0)[0];\n        function projectSquare(lambda, phi) {\n            var s = lambda > 0 ? -0.5 : 0.5, point = project(lambda + s * pi, phi);\n            point[0] -= s * dx;\n            return point;\n        }\n        if (project.invert)\n            projectSquare.invert = function (x, y) {\n                var s = x > 0 ? -0.5 : 0.5, location = project.invert(x + s * dx, y), lambda = location[0] - s * pi;\n                if (lambda < -pi)\n                    lambda += 2 * pi;\n                else if (lambda > pi)\n                    lambda -= 2 * pi;\n                location[0] = lambda;\n                return location;\n            };\n        return projectSquare;\n    };\n    function gringortenRaw(lambda, phi) {\n        var sLambda = sign(lambda), sPhi = sign(phi), cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(sPhi * phi);\n        lambda = abs(atan2(y, z));\n        phi = asin(x);\n        if (abs(lambda - halfPi) > epsilon)\n            lambda %= halfPi;\n        var point = gringortenHexadecant(lambda > pi / 4 ? halfPi - lambda : lambda, phi);\n        if (lambda > pi / 4)\n            z = point[0], point[0] = -point[1], point[1] = -z;\n        return (point[0] *= sLambda, point[1] *= -sPhi, point);\n    }\n    gringortenRaw.invert = function (x, y) {\n        if (abs(x) > 1)\n            x = sign(x) * 2 - x;\n        if (abs(y) > 1)\n            y = sign(y) * 2 - y;\n        var sx = sign(x), sy = sign(y), x0 = -sx * x, y0 = -sy * y, t = y0 / x0 < 1, p = gringortenHexadecantInvert(t ? y0 : x0, t ? x0 : y0), lambda = p[0], phi = p[1], cosPhi = cos(phi);\n        if (t)\n            lambda = -halfPi - lambda;\n        return [sx * (atan2(sin(lambda) * cosPhi, -sin(phi)) + pi), sy * asin(cos(lambda) * cosPhi)];\n    };\n    function gringortenHexadecant(lambda, phi) {\n        if (phi === halfPi)\n            return [0, 0];\n        var sinPhi = sin(phi), r = sinPhi * sinPhi, r2 = r * r, j = 1 + r2, k = 1 + 3 * r2, q = 1 - r2, z = asin(1 / sqrt(j)), v = q + r * j * z, p2 = (1 - sinPhi) / v, p = sqrt(p2), a2 = p2 * j, a = sqrt(a2), h = p * q, x, i;\n        if (lambda === 0)\n            return [0, -(h + r * a)];\n        var cosPhi = cos(phi), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r + z * k) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = (0.5 * dp2dPhi) / p, dhdPhi = q * dpdPhi - 2 * r * p * drdPhi, dra2dPhi = r * j * dp2dPhi + p2 * k * drdPhi, mu = -secPhi * drdPhi, nu = -secPhi * dra2dPhi, zeta = -2 * secPhi * dhdPhi, lambda1 = 4 * lambda / pi, delta;\n        // Slower but accurate bisection method.\n        if (lambda > 0.222 * pi || phi < pi / 4 && lambda > 0.175 * pi) {\n            x = (h + r * sqrt(a2 * (1 + r2) - h * h)) / (1 + r2);\n            if (lambda > pi / 4)\n                return [x, x];\n            var x1 = x, x0 = 0.5 * x;\n            x = 0.5 * (x0 + x1), i = 50;\n            do {\n                var g = sqrt(a2 - x * x), f = (x * (zeta + mu * g) + nu * asin(x / a)) - lambda1;\n                if (!f)\n                    break;\n                if (f < 0)\n                    x0 = x;\n                else\n                    x1 = x;\n                x = 0.5 * (x0 + x1);\n            } while (abs(x1 - x0) > epsilon && --i > 0);\n        }\n        // Newton-Raphson.\n        else {\n            x = epsilon, i = 25;\n            do {\n                var x2 = x * x, g2 = sqrt(a2 - x2), zetaMug = zeta + mu * g2, f2 = x * zetaMug + nu * asin(x / a) - lambda1, df = zetaMug + (nu - mu * x2) / g2;\n                x -= delta = g2 ? f2 / df : 0;\n            } while (abs(delta) > epsilon && --i > 0);\n        }\n        return [x, -h - r * sqrt(a2 - x * x)];\n    }\n    function gringortenHexadecantInvert(x, y) {\n        var x0 = 0, x1 = 1, r = 0.5, i = 50;\n        while (true) {\n            var r2 = r * r, sinPhi = sqrt(r), z = asin(1 / sqrt(1 + r2)), v = (1 - r2) + r * (1 + r2) * z, p2 = (1 - sinPhi) / v, p = sqrt(p2), a2 = p2 * (1 + r2), h = p * (1 - r2), g2 = a2 - x * x, g = sqrt(g2), y0 = y + h + r * g;\n            if (abs(x1 - x0) < epsilon2 || --i === 0 || y0 === 0)\n                break;\n            if (y0 > 0)\n                x0 = r;\n            else\n                x1 = r;\n            r = 0.5 * (x0 + x1);\n        }\n        if (!i)\n            return null;\n        var phi = asin(sinPhi), cosPhi = cos(phi), secPhi = 1 / cosPhi, drdPhi = 2 * sinPhi * cosPhi, dvdPhi = (-3 * r + z * (1 + 3 * r2)) * drdPhi, dp2dPhi = (-v * cosPhi - (1 - sinPhi) * dvdPhi) / (v * v), dpdPhi = 0.5 * dp2dPhi / p, dhdPhi = (1 - r2) * dpdPhi - 2 * r * p * drdPhi, zeta = -2 * secPhi * dhdPhi, mu = -secPhi * drdPhi, nu = -secPhi * (r * (1 + r2) * dp2dPhi + p2 * (1 + 3 * r2) * drdPhi);\n        return [pi / 4 * (x * (zeta + mu * g) + nu * asin(x / sqrt(a2))), phi];\n    }\n    var gringorten = function () {\n        return d3Geo.geoProjection(squareRaw(gringortenRaw))\n            .scale(239.75);\n    };\n    // Returns [sn, cn, dn](u + iv|m).\n    function ellipticJi(u, v, m) {\n        var a, b, c;\n        if (!u) {\n            b = ellipticJ(v, 1 - m);\n            return [\n                [0, b[0] / b[1]],\n                [1 / b[1], 0],\n                [b[2] / b[1], 0]\n            ];\n        }\n        a = ellipticJ(u, m);\n        if (!v)\n            return [[a[0], 0], [a[1], 0], [a[2], 0]];\n        b = ellipticJ(v, 1 - m);\n        c = b[1] * b[1] + m * a[0] * a[0] * b[0] * b[0];\n        return [\n            [a[0] * b[2] / c, a[1] * a[2] * b[0] * b[1] / c],\n            [a[1] * b[1] / c, -a[0] * a[2] * b[0] * b[2] / c],\n            [a[2] * b[1] * b[2] / c, -m * a[0] * a[1] * b[0] / c]\n        ];\n    }\n    // Returns [sn, cn, dn, ph](u|m).\n    function ellipticJ(u, m) {\n        var ai, b, phi, t, twon;\n        if (m < epsilon) {\n            t = sin(u);\n            b = cos(u);\n            ai = m * (u - t * b) / 4;\n            return [\n                t - ai * b,\n                b + ai * t,\n                1 - m * t * t / 2,\n                u - ai\n            ];\n        }\n        if (m >= 1 - epsilon) {\n            ai = (1 - m) / 4;\n            b = cosh(u);\n            t = tanh(u);\n            phi = 1 / b;\n            twon = b * sinh(u);\n            return [\n                t + ai * (twon - u) / (b * b),\n                phi - ai * t * phi * (twon - u),\n                phi + ai * t * phi * (twon + u),\n                2 * atan(exp(u)) - halfPi + ai * (twon - u) / b\n            ];\n        }\n        var a = [1, 0, 0, 0, 0, 0, 0, 0, 0], c = [sqrt(m), 0, 0, 0, 0, 0, 0, 0, 0], i = 0;\n        b = sqrt(1 - m);\n        twon = 1;\n        while (abs(c[i] / a[i]) > epsilon && i < 8) {\n            ai = a[i++];\n            c[i] = (ai - b) / 2;\n            a[i] = (ai + b) / 2;\n            b = sqrt(ai * b);\n            twon *= 2;\n        }\n        phi = twon * a[i] * u;\n        do {\n            t = c[i] * sin(b = phi) / a[i];\n            phi = (asin(t) + phi) / 2;\n        } while (--i);\n        return [sin(phi), t = cos(phi), t / cos(phi - b), phi];\n    }\n    // Calculate F(phi+iPsi|m).\n    // See Abramowitz and Stegun, 17.4.11.\n    function ellipticFi(phi, psi, m) {\n        var r = abs(phi), i = abs(psi), sinhPsi = sinh(i);\n        if (r) {\n            var cscPhi = 1 / sin(r), cotPhi2 = 1 / (tan(r) * tan(r)), b = -(cotPhi2 + m * (sinhPsi * sinhPsi * cscPhi * cscPhi) - 1 + m), c = (m - 1) * cotPhi2, cotLambda2 = (-b + sqrt(b * b - 4 * c)) / 2;\n            return [\n                ellipticF(atan(1 / sqrt(cotLambda2)), m) * sign(phi),\n                ellipticF(atan(sqrt((cotLambda2 / cotPhi2 - 1) / m)), 1 - m) * sign(psi)\n            ];\n        }\n        return [\n            0,\n            ellipticF(atan(sinhPsi), 1 - m) * sign(psi)\n        ];\n    }\n    // Calculate F(phi|m) where m = k² = sin²α.\n    // See Abramowitz and Stegun, 17.6.7.\n    function ellipticF(phi, m) {\n        if (!m)\n            return phi;\n        if (m === 1)\n            return log(tan(phi / 2 + quarterPi));\n        var a = 1, b = sqrt(1 - m), c = sqrt(m);\n        for (var i = 0; abs(c) > epsilon; i++) {\n            if (phi % pi) {\n                var dPhi = atan(b * tan(phi) / a);\n                if (dPhi < 0)\n                    dPhi += pi;\n                phi += dPhi + ~~(phi / pi) * pi;\n            }\n            else\n                phi += phi;\n            c = (a + b) / 2;\n            b = sqrt(a * b);\n            c = ((a = c) - b) / 2;\n        }\n        return phi / (pow(2, i) * a);\n    }\n    function guyouRaw(lambda, phi) {\n        var k_ = (sqrt2 - 1) / (sqrt2 + 1), k = sqrt(1 - k_ * k_), K = ellipticF(halfPi, k * k), f = -1, psi = log(tan(pi / 4 + abs(phi) / 2)), r = exp(f * psi) / sqrt(k_), at = guyouComplexAtan(r * cos(f * lambda), r * sin(f * lambda)), t = ellipticFi(at[0], at[1], k * k);\n        return [-t[1], (phi >= 0 ? 1 : -1) * (0.5 * K - t[0])];\n    }\n    function guyouComplexAtan(x, y) {\n        var x2 = x * x, y_1 = y + 1, t = 1 - x2 - y * y;\n        return [\n            0.5 * ((x >= 0 ? halfPi : -halfPi) - atan2(t, 2 * x)),\n            -0.25 * log(t * t + 4 * x2) + 0.5 * log(y_1 * y_1 + x2)\n        ];\n    }\n    function guyouComplexDivide(a, b) {\n        var denominator = b[0] * b[0] + b[1] * b[1];\n        return [\n            (a[0] * b[0] + a[1] * b[1]) / denominator,\n            (a[1] * b[0] - a[0] * b[1]) / denominator\n        ];\n    }\n    guyouRaw.invert = function (x, y) {\n        var k_ = (sqrt2 - 1) / (sqrt2 + 1), k = sqrt(1 - k_ * k_), K = ellipticF(halfPi, k * k), f = -1, j = ellipticJi(0.5 * K - y, -x, k * k), tn = guyouComplexDivide(j[0], j[1]), lambda = atan2(tn[1], tn[0]) / f;\n        return [\n            lambda,\n            2 * atan(exp(0.5 / f * log(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfPi\n        ];\n    };\n    var guyou = function () {\n        return d3Geo.geoProjection(squareRaw(guyouRaw))\n            .scale(151.496);\n    };\n    function hammerRaw(A, B) {\n        if (arguments.length < 2)\n            B = A;\n        if (B === 1)\n            return d3Geo.geoAzimuthalEqualAreaRaw;\n        if (B === Infinity)\n            return hammerQuarticAuthalicRaw;\n        function forward(lambda, phi) {\n            var coordinates = d3Geo.geoAzimuthalEqualAreaRaw(lambda / B, phi);\n            coordinates[0] *= A;\n            return coordinates;\n        }\n        forward.invert = function (x, y) {\n            var coordinates = d3Geo.geoAzimuthalEqualAreaRaw.invert(x / A, y);\n            coordinates[0] *= B;\n            return coordinates;\n        };\n        return forward;\n    }\n    function hammerQuarticAuthalicRaw(lambda, phi) {\n        return [\n            lambda * cos(phi) / cos(phi /= 2),\n            2 * sin(phi)\n        ];\n    }\n    hammerQuarticAuthalicRaw.invert = function (x, y) {\n        var phi = 2 * asin(y / 2);\n        return [\n            x * cos(phi / 2) / cos(phi),\n            phi\n        ];\n    };\n    var hammer = function () {\n        var B = 2, m = d3Geo.geoProjectionMutator(hammerRaw), p = m(B);\n        p.coefficient = function (_) {\n            if (!arguments.length)\n                return B;\n            return m(B = +_);\n        };\n        return p\n            .scale(169.529);\n    };\n    function hammerRetroazimuthalRaw(phi0) {\n        var sinPhi0 = sin(phi0), cosPhi0 = cos(phi0), rotate = hammerRetroazimuthalRotation(phi0);\n        rotate.invert = hammerRetroazimuthalRotation(-phi0);\n        function forward(lambda, phi) {\n            var p = rotate(lambda, phi);\n            lambda = p[0], phi = p[1];\n            var sinPhi = sin(phi), cosPhi = cos(phi), cosLambda = cos(lambda), z = acos(sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosLambda), sinz = sin(z), K = abs(sinz) > epsilon ? z / sinz : 1;\n            return [\n                K * cosPhi0 * sin(lambda),\n                (abs(lambda) > halfPi ? K : -K) // rotate for back hemisphere\n                    * (sinPhi0 * cosPhi - cosPhi0 * sinPhi * cosLambda)\n            ];\n        }\n        forward.invert = function (x, y) {\n            var rho = sqrt(x * x + y * y), sinz = -sin(rho), cosz = cos(rho), a = rho * cosz, b = -y * sinz, c = rho * sinPhi0, d = sqrt(a * a + b * b - c * c), phi = atan2(a * c + b * d, b * c - a * d), lambda = (rho > halfPi ? -1 : 1) * atan2(x * sinz, rho * cos(phi) * cosz + y * sin(phi) * sinz);\n            return rotate.invert(lambda, phi);\n        };\n        return forward;\n    }\n    // Latitudinal rotation by phi0.\n    // Temporary hack until D3 supports arbitrary small-circle clipping origins.\n    function hammerRetroazimuthalRotation(phi0) {\n        var sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);\n        return function (lambda, phi) {\n            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi);\n            return [\n                atan2(y, x * cosPhi0 - z * sinPhi0),\n                asin(z * cosPhi0 + x * sinPhi0)\n            ];\n        };\n    }\n    var hammerRetroazimuthal = function () {\n        var phi0 = 0, m = d3Geo.geoProjectionMutator(hammerRetroazimuthalRaw), p = m(phi0), rotate_ = p.rotate, stream_ = p.stream, circle = d3Geo.geoCircle();\n        p.parallel = function (_) {\n            if (!arguments.length)\n                return phi0 * degrees;\n            var r = p.rotate();\n            return m(phi0 = _ * radians).rotate(r);\n        };\n        // Temporary hack; see hammerRetroazimuthalRotation.\n        p.rotate = function (_) {\n            if (!arguments.length)\n                return (_ = rotate_.call(p), _[1] += phi0 * degrees, _);\n            rotate_.call(p, [_[0], _[1] - phi0 * degrees]);\n            circle.center([-_[0], -_[1]]);\n            return p;\n        };\n        p.stream = function (stream) {\n            stream = stream_(stream);\n            stream.sphere = function () {\n                stream.polygonStart();\n                var epsilon$$1 = 1e-2, ring = circle.radius(90 - epsilon$$1)().coordinates[0], n = ring.length - 1, i = -1, p;\n                stream.lineStart();\n                while (++i < n)\n                    stream.point((p = ring[i])[0], p[1]);\n                stream.lineEnd();\n                ring = circle.radius(90 + epsilon$$1)().coordinates[0];\n                n = ring.length - 1;\n                stream.lineStart();\n                while (--i >= 0)\n                    stream.point((p = ring[i])[0], p[1]);\n                stream.lineEnd();\n                stream.polygonEnd();\n            };\n            return stream;\n        };\n        return p\n            .scale(79.4187)\n            .parallel(45)\n            .clipAngle(180 - 1e-3);\n    };\n    var healpixParallel = 41 + 48 / 36 + 37 / 3600;\n    var healpixLambert = cylindricalEqualAreaRaw(0);\n    function healpixRaw(H) {\n        var phi0 = healpixParallel * radians, dx = collignonRaw(pi, phi0)[0] - collignonRaw(-pi, phi0)[0], y0 = healpixLambert(0, phi0)[1], y1 = collignonRaw(0, phi0)[1], dy1 = sqrtPi - y1, k = tau / H, w = 4 / tau, h = y0 + (dy1 * dy1 * 4) / tau;\n        function forward(lambda, phi) {\n            var point, phi2 = abs(phi);\n            if (phi2 > phi0) {\n                var i = min(H - 1, max(0, floor((lambda + pi) / k)));\n                lambda += pi * (H - 1) / H - i * k;\n                point = collignonRaw(lambda, phi2);\n                point[0] = point[0] * tau / dx - tau * (H - 1) / (2 * H) + i * tau / H;\n                point[1] = y0 + (point[1] - y1) * 4 * dy1 / tau;\n                if (phi < 0)\n                    point[1] = -point[1];\n            }\n            else {\n                point = healpixLambert(lambda, phi);\n            }\n            point[0] *= w, point[1] /= h;\n            return point;\n        }\n        forward.invert = function (x, y) {\n            x /= w, y *= h;\n            var y2 = abs(y);\n            if (y2 > y0) {\n                var i = min(H - 1, max(0, floor((x + pi) / k)));\n                x = (x + pi * (H - 1) / H - i * k) * dx / tau;\n                var point = collignonRaw.invert(x, 0.25 * (y2 - y0) * tau / dy1 + y1);\n                point[0] -= pi * (H - 1) / H - i * k;\n                if (y < 0)\n                    point[1] = -point[1];\n                return point;\n            }\n            return healpixLambert.invert(x, y);\n        };\n        return forward;\n    }\n    function sphere(step) {\n        return {\n            type: \"Polygon\",\n            coordinates: [\n                d3Array.range(-180, 180 + step / 2, step).map(function (x, i) { return [x, i & 1 ? 90 - 1e-6 : healpixParallel]; })\n                    .concat(d3Array.range(180, -180 - step / 2, -step).map(function (x, i) { return [x, i & 1 ? -90 + 1e-6 : -healpixParallel]; }))\n            ]\n        };\n    }\n    var healpix = function () {\n        var H = 4, m = d3Geo.geoProjectionMutator(healpixRaw), p = m(H), stream_ = p.stream;\n        p.lobes = function (_) {\n            return arguments.length ? m(H = +_) : H;\n        };\n        p.stream = function (stream) {\n            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));\n            p.rotate(rotate);\n            rotateStream.sphere = function () { d3Geo.geoStream(sphere(180 / H), sphereStream); };\n            return rotateStream;\n        };\n        return p\n            .scale(239.75);\n    };\n    function hillRaw(K) {\n        var L = 1 + K, sinBt = sin(1 / L), Bt = asin(sinBt), A = 2 * sqrt(pi / (B = pi + 4 * Bt * L)), B, rho0 = 0.5 * A * (L + sqrt(K * (2 + K))), K2 = K * K, L2 = L * L;\n        function forward(lambda, phi) {\n            var t = 1 - sin(phi), rho, omega;\n            if (t && t < 2) {\n                var theta = halfPi - phi, i = 25, delta;\n                do {\n                    var sinTheta = sin(theta), cosTheta = cos(theta), Bt_Bt1 = Bt + atan2(sinTheta, L - cosTheta), C = 1 + L2 - 2 * L * cosTheta;\n                    theta -= delta = (theta - K2 * Bt - L * sinTheta + C * Bt_Bt1 - 0.5 * t * B) / (2 * L * sinTheta * Bt_Bt1);\n                } while (abs(delta) > epsilon2 && --i > 0);\n                rho = A * sqrt(C);\n                omega = lambda * Bt_Bt1 / pi;\n            }\n            else {\n                rho = A * (K + t);\n                omega = lambda * Bt / pi;\n            }\n            return [\n                rho * sin(omega),\n                rho0 - rho * cos(omega)\n            ];\n        }\n        forward.invert = function (x, y) {\n            var rho2 = x * x + (y -= rho0) * y, cosTheta = (1 + L2 - rho2 / (A * A)) / (2 * L), theta = acos(cosTheta), sinTheta = sin(theta), Bt_Bt1 = Bt + atan2(sinTheta, L - cosTheta);\n            return [\n                asin(x / sqrt(rho2)) * pi / Bt_Bt1,\n                asin(1 - 2 * (theta - K2 * Bt - L * sinTheta + (1 + L2 - 2 * L * cosTheta) * Bt_Bt1) / B)\n            ];\n        };\n        return forward;\n    }\n    var hill = function () {\n        var K = 1, m = d3Geo.geoProjectionMutator(hillRaw), p = m(K);\n        p.ratio = function (_) {\n            return arguments.length ? m(K = +_) : K;\n        };\n        return p\n            .scale(167.774)\n            .center([0, 18.67]);\n    };\n    var sinuMollweidePhi = 0.7109889596207567;\n    var sinuMollweideY = 0.0528035274542;\n    function sinuMollweideRaw(lambda, phi) {\n        return phi > -sinuMollweidePhi\n            ? (lambda = mollweideRaw(lambda, phi), lambda[1] += sinuMollweideY, lambda)\n            : sinusoidalRaw(lambda, phi);\n    }\n    sinuMollweideRaw.invert = function (x, y) {\n        return y > -sinuMollweidePhi\n            ? mollweideRaw.invert(x, y - sinuMollweideY)\n            : sinusoidalRaw.invert(x, y);\n    };\n    var sinuMollweide = function () {\n        return d3Geo.geoProjection(sinuMollweideRaw)\n            .rotate([-20, -55])\n            .scale(164.263)\n            .center([0, -5.4036]);\n    };\n    function homolosineRaw(lambda, phi) {\n        return abs(phi) > sinuMollweidePhi\n            ? (lambda = mollweideRaw(lambda, phi), lambda[1] -= phi > 0 ? sinuMollweideY : -sinuMollweideY, lambda)\n            : sinusoidalRaw(lambda, phi);\n    }\n    homolosineRaw.invert = function (x, y) {\n        return abs(y) > sinuMollweidePhi\n            ? mollweideRaw.invert(x, y + (y > 0 ? sinuMollweideY : -sinuMollweideY))\n            : sinusoidalRaw.invert(x, y);\n    };\n    var homolosine = function () {\n        return d3Geo.geoProjection(homolosineRaw)\n            .scale(152.63);\n    };\n    function pointEqual(a, b) {\n        return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n    }\n    function interpolateLine(coordinates, m) {\n        var i = -1, n = coordinates.length, p0 = coordinates[0], p1, dx, dy, resampled = [];\n        while (++i < n) {\n            p1 = coordinates[i];\n            dx = (p1[0] - p0[0]) / m;\n            dy = (p1[1] - p0[1]) / m;\n            for (var j = 0; j < m; ++j)\n                resampled.push([p0[0] + j * dx, p0[1] + j * dy]);\n            p0 = p1;\n        }\n        resampled.push(p1);\n        return resampled;\n    }\n    function interpolateSphere(lobes) {\n        var coordinates = [], lobe, lambda0, phi0, phi1, lambda2, phi2, i, n = lobes[0].length;\n        // Northern Hemisphere\n        for (i = 0; i < n; ++i) {\n            lobe = lobes[0][i];\n            lambda0 = lobe[0][0], phi0 = lobe[0][1], phi1 = lobe[1][1];\n            lambda2 = lobe[2][0], phi2 = lobe[2][1];\n            coordinates.push(interpolateLine([\n                [lambda0 + epsilon, phi0 + epsilon],\n                [lambda0 + epsilon, phi1 - epsilon],\n                [lambda2 - epsilon, phi1 - epsilon],\n                [lambda2 - epsilon, phi2 + epsilon]\n            ], 30));\n        }\n        // Southern Hemisphere\n        for (i = lobes[1].length - 1; i >= 0; --i) {\n            lobe = lobes[1][i];\n            lambda0 = lobe[0][0], phi0 = lobe[0][1], phi1 = lobe[1][1];\n            lambda2 = lobe[2][0], phi2 = lobe[2][1];\n            coordinates.push(interpolateLine([\n                [lambda2 - epsilon, phi2 - epsilon],\n                [lambda2 - epsilon, phi1 + epsilon],\n                [lambda0 + epsilon, phi1 + epsilon],\n                [lambda0 + epsilon, phi0 - epsilon]\n            ], 30));\n        }\n        return {\n            type: \"Polygon\",\n            coordinates: [d3Array.merge(coordinates)]\n        };\n    }\n    var interrupt = function (project, lobes) {\n        var sphere = interpolateSphere(lobes);\n        lobes = lobes.map(function (lobe) {\n            return lobe.map(function (l) {\n                return [\n                    [l[0][0] * radians, l[0][1] * radians],\n                    [l[1][0] * radians, l[1][1] * radians],\n                    [l[2][0] * radians, l[2][1] * radians]\n                ];\n            });\n        });\n        var bounds = lobes.map(function (lobe) {\n            return lobe.map(function (l) {\n                var x0 = project(l[0][0], l[0][1])[0], x1 = project(l[2][0], l[2][1])[0], y0 = project(l[1][0], l[0][1])[1], y1 = project(l[1][0], l[1][1])[1], t;\n                if (y0 > y1)\n                    t = y0, y0 = y1, y1 = t;\n                return [[x0, y0], [x1, y1]];\n            });\n        });\n        function forward(lambda, phi) {\n            var sign$$1 = phi < 0 ? -1 : +1, lobe = lobes[+(phi < 0)];\n            for (var i = 0, n = lobe.length - 1; i < n && lambda > lobe[i][2][0]; ++i)\n                ;\n            var p = project(lambda - lobe[i][1][0], phi);\n            p[0] += project(lobe[i][1][0], sign$$1 * phi > sign$$1 * lobe[i][0][1] ? lobe[i][0][1] : phi)[0];\n            return p;\n        }\n        // Assumes mutually exclusive bounding boxes for lobes.\n        if (project.invert)\n            forward.invert = function (x, y) {\n                var bound = bounds[+(y < 0)], lobe = lobes[+(y < 0)];\n                for (var i = 0, n = bound.length; i < n; ++i) {\n                    var b = bound[i];\n                    if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {\n                        var p = project.invert(x - project(lobe[i][1][0], 0)[0], y);\n                        p[0] += lobe[i][1][0];\n                        return pointEqual(forward(p[0], p[1]), [x, y]) ? p : null;\n                    }\n                }\n            };\n        var p = d3Geo.geoProjection(forward), stream_ = p.stream;\n        p.stream = function (stream) {\n            var rotate = p.rotate(), rotateStream = stream_(stream), sphereStream = (p.rotate([0, 0]), stream_(stream));\n            p.rotate(rotate);\n            rotateStream.sphere = function () { d3Geo.geoStream(sphere, sphereStream); };\n            return rotateStream;\n        };\n        return p;\n    };\n    var lobes = [[\n            [[-180, 0], [-100, 90], [-40, 0]],\n            [[-40, 0], [30, 90], [180, 0]]\n        ], [\n            [[-180, 0], [-160, -90], [-100, 0]],\n            [[-100, 0], [-60, -90], [-20, 0]],\n            [[-20, 0], [20, -90], [80, 0]],\n            [[80, 0], [140, -90], [180, 0]]\n        ]];\n    var boggs$1 = function () {\n        return interrupt(boggsRaw, lobes)\n            .scale(160.857);\n    };\n    var lobes$1 = [[\n            [[-180, 0], [-100, 90], [-40, 0]],\n            [[-40, 0], [30, 90], [180, 0]]\n        ], [\n            [[-180, 0], [-160, -90], [-100, 0]],\n            [[-100, 0], [-60, -90], [-20, 0]],\n            [[-20, 0], [20, -90], [80, 0]],\n            [[80, 0], [140, -90], [180, 0]]\n        ]];\n    var homolosine$1 = function () {\n        return interrupt(homolosineRaw, lobes$1)\n            .scale(152.63);\n    };\n    var lobes$2 = [[\n            [[-180, 0], [-100, 90], [-40, 0]],\n            [[-40, 0], [30, 90], [180, 0]]\n        ], [\n            [[-180, 0], [-160, -90], [-100, 0]],\n            [[-100, 0], [-60, -90], [-20, 0]],\n            [[-20, 0], [20, -90], [80, 0]],\n            [[80, 0], [140, -90], [180, 0]]\n        ]];\n    var mollweide$1 = function () {\n        return interrupt(mollweideRaw, lobes$2)\n            .scale(169.529);\n    };\n    var lobes$3 = [[\n            [[-180, 0], [-90, 90], [0, 0]],\n            [[0, 0], [90, 90], [180, 0]]\n        ], [\n            [[-180, 0], [-90, -90], [0, 0]],\n            [[0, 0], [90, -90], [180, 0]]\n        ]];\n    var mollweideHemispheres = function () {\n        return interrupt(mollweideRaw, lobes$3)\n            .scale(169.529)\n            .rotate([20, 0]);\n    };\n    var lobes$4 = [[\n            [[-180, 35], [-30, 90], [0, 35]],\n            [[0, 35], [30, 90], [180, 35]]\n        ], [\n            [[-180, -10], [-102, -90], [-65, -10]],\n            [[-65, -10], [5, -90], [77, -10]],\n            [[77, -10], [103, -90], [180, -10]]\n        ]];\n    var sinuMollweide$1 = function () {\n        return interrupt(sinuMollweideRaw, lobes$4)\n            .rotate([-20, -55])\n            .scale(164.263)\n            .center([0, -5.4036]);\n    };\n    var lobes$5 = [[\n            [[-180, 0], [-110, 90], [-40, 0]],\n            [[-40, 0], [0, 90], [40, 0]],\n            [[40, 0], [110, 90], [180, 0]]\n        ], [\n            [[-180, 0], [-110, -90], [-40, 0]],\n            [[-40, 0], [0, -90], [40, 0]],\n            [[40, 0], [110, -90], [180, 0]]\n        ]];\n    var sinusoidal$1 = function () {\n        return interrupt(sinusoidalRaw, lobes$5)\n            .scale(152.63)\n            .rotate([-20, 0]);\n    };\n    function kavrayskiy7Raw(lambda, phi) {\n        return [3 / tau * lambda * sqrt(pi * pi / 3 - phi * phi), phi];\n    }\n    kavrayskiy7Raw.invert = function (x, y) {\n        return [tau / 3 * x / sqrt(pi * pi / 3 - y * y), y];\n    };\n    var kavrayskiy7 = function () {\n        return d3Geo.geoProjection(kavrayskiy7Raw)\n            .scale(158.837);\n    };\n    function lagrangeRaw(n) {\n        function forward(lambda, phi) {\n            if (abs(abs(phi) - halfPi) < epsilon)\n                return [0, phi < 0 ? -2 : 2];\n            var sinPhi = sin(phi), v = pow((1 + sinPhi) / (1 - sinPhi), n / 2), c = 0.5 * (v + 1 / v) + cos(lambda *= n);\n            return [\n                2 * sin(lambda) / c,\n                (v - 1 / v) / c\n            ];\n        }\n        forward.invert = function (x, y) {\n            var y0 = abs(y);\n            if (abs(y0 - 2) < epsilon)\n                return x ? null : [0, sign(y) * halfPi];\n            if (y0 > 2)\n                return null;\n            x /= 2, y /= 2;\n            var x2 = x * x, y2 = y * y, t = 2 * y / (1 + x2 + y2); // tanh(nPhi)\n            t = pow((1 + t) / (1 - t), 1 / n);\n            return [\n                atan2(2 * x, 1 - x2 - y2) / n,\n                asin((t - 1) / (t + 1))\n            ];\n        };\n        return forward;\n    }\n    var lagrange = function () {\n        var n = 0.5, m = d3Geo.geoProjectionMutator(lagrangeRaw), p = m(n);\n        p.spacing = function (_) {\n            return arguments.length ? m(n = +_) : n;\n        };\n        return p\n            .scale(124.75);\n    };\n    var pi_sqrt2 = pi / sqrt2;\n    function larriveeRaw(lambda, phi) {\n        return [\n            lambda * (1 + sqrt(cos(phi))) / 2,\n            phi / (cos(phi / 2) * cos(lambda / 6))\n        ];\n    }\n    larriveeRaw.invert = function (x, y) {\n        var x0 = abs(x), y0 = abs(y), lambda = epsilon, phi = halfPi;\n        if (y0 < pi_sqrt2)\n            phi *= y0 / pi_sqrt2;\n        else\n            lambda += 6 * acos(pi_sqrt2 / y0);\n        for (var i = 0; i < 25; i++) {\n            var sinPhi = sin(phi), sqrtcosPhi = sqrt(cos(phi)), sinPhi_2 = sin(phi / 2), cosPhi_2 = cos(phi / 2), sinLambda_6 = sin(lambda / 6), cosLambda_6 = cos(lambda / 6), f0 = 0.5 * lambda * (1 + sqrtcosPhi) - x0, f1 = phi / (cosPhi_2 * cosLambda_6) - y0, df0dPhi = sqrtcosPhi ? -0.25 * lambda * sinPhi / sqrtcosPhi : 0, df0dLambda = 0.5 * (1 + sqrtcosPhi), df1dPhi = (1 + 0.5 * phi * sinPhi_2 / cosPhi_2) / (cosPhi_2 * cosLambda_6), df1dLambda = (phi / cosPhi_2) * (sinLambda_6 / 6) / (cosLambda_6 * cosLambda_6), denom = df0dPhi * df1dLambda - df1dPhi * df0dLambda, dPhi = (f0 * df1dLambda - f1 * df0dLambda) / denom, dLambda = (f1 * df0dPhi - f0 * df1dPhi) / denom;\n            phi -= dPhi;\n            lambda -= dLambda;\n            if (abs(dPhi) < epsilon && abs(dLambda) < epsilon)\n                break;\n        }\n        return [x < 0 ? -lambda : lambda, y < 0 ? -phi : phi];\n    };\n    var larrivee = function () {\n        return d3Geo.geoProjection(larriveeRaw)\n            .scale(97.2672);\n    };\n    function laskowskiRaw(lambda, phi) {\n        var lambda2 = lambda * lambda, phi2 = phi * phi;\n        return [\n            lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)),\n            phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 0.000199025) + phi2 * (0.0998909 + phi2 * -0.0491032))\n        ];\n    }\n    laskowskiRaw.invert = function (x, y) {\n        var lambda = sign(x) * pi, phi = y / 2, i = 50;\n        do {\n            var lambda2 = lambda * lambda, phi2 = phi * phi, lambdaPhi = lambda * phi, fx = lambda * (0.975534 + phi2 * (-0.119161 + lambda2 * -0.0143059 + phi2 * -0.0547009)) - x, fy = phi * (1.00384 + lambda2 * (0.0802894 + phi2 * -0.02855 + lambda2 * 0.000199025) + phi2 * (0.0998909 + phi2 * -0.0491032)) - y, deltaxDeltaLambda = 0.975534 - phi2 * (0.119161 + 3 * lambda2 * 0.0143059 + phi2 * 0.0547009), deltaxDeltaPhi = -lambdaPhi * (2 * 0.119161 + 4 * 0.0547009 * phi2 + 2 * 0.0143059 * lambda2), deltayDeltaLambda = lambdaPhi * (2 * 0.0802894 + 4 * 0.000199025 * lambda2 + 2 * -0.02855 * phi2), deltayDeltaPhi = 1.00384 + lambda2 * (0.0802894 + 0.000199025 * lambda2) + phi2 * (3 * (0.0998909 - 0.02855 * lambda2) - 5 * 0.0491032 * phi2), denominator = deltaxDeltaPhi * deltayDeltaLambda - deltayDeltaPhi * deltaxDeltaLambda, deltaLambda = (fy * deltaxDeltaPhi - fx * deltayDeltaPhi) / denominator, deltaPhi = (fx * deltayDeltaLambda - fy * deltaxDeltaLambda) / denominator;\n            lambda -= deltaLambda, phi -= deltaPhi;\n        } while ((abs(deltaLambda) > epsilon || abs(deltaPhi) > epsilon) && --i > 0);\n        return i && [lambda, phi];\n    };\n    var laskowski = function () {\n        return d3Geo.geoProjection(laskowskiRaw)\n            .scale(139.98);\n    };\n    function littrowRaw(lambda, phi) {\n        return [\n            sin(lambda) / cos(phi),\n            tan(phi) * cos(lambda)\n        ];\n    }\n    littrowRaw.invert = function (x, y) {\n        var x2 = x * x, y2 = y * y, y2_1 = y2 + 1, cosPhi = x\n            ? sqrt1_2 * sqrt((y2_1 - sqrt(x2 * x2 + 2 * x2 * (y2 - 1) + y2_1 * y2_1)) / x2 + 1)\n            : 1 / sqrt(y2_1);\n        return [\n            asin(x * cosPhi),\n            sign(y) * acos(cosPhi)\n        ];\n    };\n    var littrow = function () {\n        return d3Geo.geoProjection(littrowRaw)\n            .scale(144.049)\n            .clipAngle(90 - 1e-3);\n    };\n    function loximuthalRaw(phi0) {\n        var cosPhi0 = cos(phi0), tanPhi0 = tan(quarterPi + phi0 / 2);\n        function forward(lambda, phi) {\n            var y = phi - phi0, x = abs(y) < epsilon ? lambda * cosPhi0\n                : abs(x = quarterPi + phi / 2) < epsilon || abs(abs(x) - halfPi) < epsilon\n                    ? 0 : lambda * y / log(tan(x) / tanPhi0);\n            return [x, y];\n        }\n        forward.invert = function (x, y) {\n            var lambda, phi = y + phi0;\n            return [\n                abs(y) < epsilon ? x / cosPhi0\n                    : (abs(lambda = quarterPi + phi / 2) < epsilon || abs(abs(lambda) - halfPi) < epsilon) ? 0\n                        : x * log(tan(lambda) / tanPhi0) / y,\n                phi\n            ];\n        };\n        return forward;\n    }\n    var loximuthal = function () {\n        return parallel1(loximuthalRaw)\n            .parallel(40)\n            .scale(158.837);\n    };\n    function millerRaw(lambda, phi) {\n        return [lambda, 1.25 * log(tan(quarterPi + 0.4 * phi))];\n    }\n    millerRaw.invert = function (x, y) {\n        return [x, 2.5 * atan(exp(0.8 * y)) - 0.625 * pi];\n    };\n    var miller = function () {\n        return d3Geo.geoProjection(millerRaw)\n            .scale(108.318);\n    };\n    function modifiedStereographicRaw(C) {\n        var m = C.length - 1;\n        function forward(lambda, phi) {\n            var cosPhi = cos(phi), k = 2 / (1 + cosPhi * cos(lambda)), zr = k * cosPhi * sin(lambda), zi = k * sin(phi), i = m, w = C[i], ar = w[0], ai = w[1], t;\n            while (--i >= 0) {\n                w = C[i];\n                ar = w[0] + zr * (t = ar) - zi * ai;\n                ai = w[1] + zr * ai + zi * t;\n            }\n            ar = zr * (t = ar) - zi * ai;\n            ai = zr * ai + zi * t;\n            return [ar, ai];\n        }\n        forward.invert = function (x, y) {\n            var i = 20, zr = x, zi = y;\n            do {\n                var j = m, w = C[j], ar = w[0], ai = w[1], br = 0, bi = 0, t;\n                while (--j >= 0) {\n                    w = C[j];\n                    br = ar + zr * (t = br) - zi * bi;\n                    bi = ai + zr * bi + zi * t;\n                    ar = w[0] + zr * (t = ar) - zi * ai;\n                    ai = w[1] + zr * ai + zi * t;\n                }\n                br = ar + zr * (t = br) - zi * bi;\n                bi = ai + zr * bi + zi * t;\n                ar = zr * (t = ar) - zi * ai - x;\n                ai = zr * ai + zi * t - y;\n                var denominator = br * br + bi * bi, deltar, deltai;\n                zr -= deltar = (ar * br + ai * bi) / denominator;\n                zi -= deltai = (ai * br - ar * bi) / denominator;\n            } while (abs(deltar) + abs(deltai) > epsilon * epsilon && --i > 0);\n            if (i) {\n                var rho = sqrt(zr * zr + zi * zi), c = 2 * atan(rho * 0.5), sinc = sin(c);\n                return [atan2(zr * sinc, rho * cos(c)), rho ? asin(zi * sinc / rho) : 0];\n            }\n        };\n        return forward;\n    }\n    var alaska = [[0.9972523, 0], [0.0052513, -0.0041175], [0.0074606, 0.0048125], [-0.0153783, -0.1968253], [0.0636871, -0.1408027], [0.3660976, -0.2937382]];\n    var gs48 = [[0.98879, 0], [0, 0], [-0.050909, 0], [0, 0], [0.075528, 0]];\n    var gs50 = [[0.9842990, 0], [0.0211642, 0.0037608], [-0.1036018, -0.0575102], [-0.0329095, -0.0320119], [0.0499471, 0.1223335], [0.0260460, 0.0899805], [0.0007388, -0.1435792], [0.0075848, -0.1334108], [-0.0216473, 0.0776645], [-0.0225161, 0.0853673]];\n    var miller$1 = [[0.9245, 0], [0, 0], [0.01943, 0]];\n    var lee = [[0.721316, 0], [0, 0], [-0.00881625, -0.00617325]];\n    function modifiedStereographicAlaska() {\n        return modifiedStereographic(alaska, [152, -64])\n            .scale(1500)\n            .center([-160.908, 62.4864])\n            .clipAngle(25);\n    }\n    function modifiedStereographicGs48() {\n        return modifiedStereographic(gs48, [95, -38])\n            .scale(1000)\n            .clipAngle(55)\n            .center([-96.5563, 38.8675]);\n    }\n    function modifiedStereographicGs50() {\n        return modifiedStereographic(gs50, [120, -45])\n            .scale(359.513)\n            .clipAngle(55)\n            .center([-117.474, 53.0628]);\n    }\n    function modifiedStereographicMiller() {\n        return modifiedStereographic(miller$1, [-20, -18])\n            .scale(209.091)\n            .center([20, 16.7214])\n            .clipAngle(82);\n    }\n    function modifiedStereographicLee() {\n        return modifiedStereographic(lee, [165, 10])\n            .scale(250)\n            .clipAngle(130)\n            .center([-165, -10]);\n    }\n    function modifiedStereographic(coefficients, rotate) {\n        var p = d3Geo.geoProjection(modifiedStereographicRaw(coefficients)).rotate(rotate).clipAngle(90), r = d3Geo.geoRotation(rotate), center = p.center;\n        delete p.rotate;\n        p.center = function (_) {\n            return arguments.length ? center(r(_)) : r.invert(center());\n        };\n        return p;\n    }\n    var sqrt6 = sqrt(6);\n    var sqrt7 = sqrt(7);\n    function mtFlatPolarParabolicRaw(lambda, phi) {\n        var theta = asin(7 * sin(phi) / (3 * sqrt6));\n        return [\n            sqrt6 * lambda * (2 * cos(2 * theta / 3) - 1) / sqrt7,\n            9 * sin(theta / 3) / sqrt7\n        ];\n    }\n    mtFlatPolarParabolicRaw.invert = function (x, y) {\n        var theta = 3 * asin(y * sqrt7 / 9);\n        return [\n            x * sqrt7 / (sqrt6 * (2 * cos(2 * theta / 3) - 1)),\n            asin(sin(theta) * 3 * sqrt6 / 7)\n        ];\n    };\n    var mtFlatPolarParabolic = function () {\n        return d3Geo.geoProjection(mtFlatPolarParabolicRaw)\n            .scale(164.859);\n    };\n    function mtFlatPolarQuarticRaw(lambda, phi) {\n        var k = (1 + sqrt1_2) * sin(phi), theta = phi;\n        for (var i = 0, delta; i < 25; i++) {\n            theta -= delta = (sin(theta / 2) + sin(theta) - k) / (0.5 * cos(theta / 2) + cos(theta));\n            if (abs(delta) < epsilon)\n                break;\n        }\n        return [\n            lambda * (1 + 2 * cos(theta) / cos(theta / 2)) / (3 * sqrt2),\n            2 * sqrt(3) * sin(theta / 2) / sqrt(2 + sqrt2)\n        ];\n    }\n    mtFlatPolarQuarticRaw.invert = function (x, y) {\n        var sinTheta_2 = y * sqrt(2 + sqrt2) / (2 * sqrt(3)), theta = 2 * asin(sinTheta_2);\n        return [\n            3 * sqrt2 * x / (1 + 2 * cos(theta) / cos(theta / 2)),\n            asin((sinTheta_2 + sin(theta)) / (1 + sqrt1_2))\n        ];\n    };\n    var mtFlatPolarQuartic = function () {\n        return d3Geo.geoProjection(mtFlatPolarQuarticRaw)\n            .scale(188.209);\n    };\n    function mtFlatPolarSinusoidalRaw(lambda, phi) {\n        var A = sqrt(6 / (4 + pi)), k = (1 + pi / 4) * sin(phi), theta = phi / 2;\n        for (var i = 0, delta; i < 25; i++) {\n            theta -= delta = (theta / 2 + sin(theta) - k) / (0.5 + cos(theta));\n            if (abs(delta) < epsilon)\n                break;\n        }\n        return [\n            A * (0.5 + cos(theta)) * lambda / 1.5,\n            A * theta\n        ];\n    }\n    mtFlatPolarSinusoidalRaw.invert = function (x, y) {\n        var A = sqrt(6 / (4 + pi)), theta = y / A;\n        if (abs(abs(theta) - halfPi) < epsilon)\n            theta = theta < 0 ? -halfPi : halfPi;\n        return [\n            1.5 * x / (A * (0.5 + cos(theta))),\n            asin((theta / 2 + sin(theta)) / (1 + pi / 4))\n        ];\n    };\n    var mtFlatPolarSinusoidal = function () {\n        return d3Geo.geoProjection(mtFlatPolarSinusoidalRaw)\n            .scale(166.518);\n    };\n    function naturalEarthRaw(lambda, phi) {\n        var phi2 = phi * phi, phi4 = phi2 * phi2;\n        return [\n            lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),\n            phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))\n        ];\n    }\n    naturalEarthRaw.invert = function (x, y) {\n        var phi = y, i = 25, delta;\n        do {\n            var phi2 = phi * phi, phi4 = phi2 * phi2;\n            phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /\n                (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));\n        } while (abs(delta) > epsilon && --i > 0);\n        return [\n            x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),\n            phi\n        ];\n    };\n    var naturalEarth = function () {\n        return d3Geo.geoProjection(naturalEarthRaw)\n            .scale(175.295);\n    };\n    function naturalEarth2Raw(lambda, phi) {\n        var phi2 = phi * phi, phi4 = phi2 * phi2, phi6 = phi2 * phi4;\n        return [\n            lambda * (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 0.00331 * phi6)),\n            phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 0.00396 * phi4))\n        ];\n    }\n    naturalEarth2Raw.invert = function (x, y) {\n        var phi = y, i = 25, delta, phi2, phi4, phi6;\n        do {\n            phi2 = phi * phi;\n            phi4 = phi2 * phi2;\n            phi -= delta = ((phi * (1.01183 + phi4 * phi4 * (-0.02625 + 0.01926 * phi2 - 0.00396 * phi4))) - y) /\n                (1.01183 + phi4 * phi4 * ((9 * -0.02625) + (11 * 0.01926) * phi2 + (13 * -0.00396) * phi4));\n        } while (abs(delta) > epsilon2 && --i > 0);\n        phi2 = phi * phi;\n        phi4 = phi2 * phi2;\n        phi6 = phi2 * phi4;\n        return [\n            x / (0.84719 - 0.13063 * phi2 + phi6 * phi6 * (-0.04515 + 0.05494 * phi2 - 0.02326 * phi4 + 0.00331 * phi6)),\n            phi\n        ];\n    };\n    var naturalEarth2 = function () {\n        return d3Geo.geoProjection(naturalEarth2Raw)\n            .scale(175.295);\n    };\n    function nellHammerRaw(lambda, phi) {\n        return [\n            lambda * (1 + cos(phi)) / 2,\n            2 * (phi - tan(phi / 2))\n        ];\n    }\n    nellHammerRaw.invert = function (x, y) {\n        var p = y / 2;\n        for (var i = 0, delta = Infinity; i < 10 && abs(delta) > epsilon; ++i) {\n            var c = cos(y / 2);\n            y -= delta = (y - tan(y / 2) - p) / (1 - 0.5 / (c * c));\n        }\n        return [\n            2 * x / (1 + cos(y)),\n            y\n        ];\n    };\n    var nellHammer = function () {\n        return d3Geo.geoProjection(nellHammerRaw)\n            .scale(152.63);\n    };\n    // Based on Java implementation by Bojan Savric.\n    // https://github.com/OSUCartography/JMapProjLib/blob/master/src/com/jhlabs/map/proj/PattersonProjection.java\n    var pattersonK1 = 1.0148;\n    var pattersonK2 = 0.23185;\n    var pattersonK3 = -0.14499;\n    var pattersonK4 = 0.02406;\n    var pattersonC1 = pattersonK1;\n    var pattersonC2 = 5 * pattersonK2;\n    var pattersonC3 = 7 * pattersonK3;\n    var pattersonC4 = 9 * pattersonK4;\n    var pattersonYmax = 1.790857183;\n    function pattersonRaw(lambda, phi) {\n        var phi2 = phi * phi;\n        return [\n            lambda,\n            phi * (pattersonK1 + phi2 * phi2 * (pattersonK2 + phi2 * (pattersonK3 + pattersonK4 * phi2)))\n        ];\n    }\n    pattersonRaw.invert = function (x, y) {\n        if (y > pattersonYmax)\n            y = pattersonYmax;\n        else if (y < -pattersonYmax)\n            y = -pattersonYmax;\n        var yc = y, delta;\n        do { // Newton-Raphson\n            var y2 = yc * yc;\n            yc -= delta = ((yc * (pattersonK1 + y2 * y2 * (pattersonK2 + y2 * (pattersonK3 + pattersonK4 * y2)))) - y) / (pattersonC1 + y2 * y2 * (pattersonC2 + y2 * (pattersonC3 + pattersonC4 * y2)));\n        } while (abs(delta) > epsilon);\n        return [x, yc];\n    };\n    var patterson = function () {\n        return d3Geo.geoProjection(pattersonRaw)\n            .scale(139.319);\n    };\n    function polyconicRaw(lambda, phi) {\n        if (abs(phi) < epsilon)\n            return [lambda, 0];\n        var tanPhi = tan(phi), k = lambda * sin(phi);\n        return [\n            sin(k) / tanPhi,\n            phi + (1 - cos(k)) / tanPhi\n        ];\n    }\n    polyconicRaw.invert = function (x, y) {\n        if (abs(y) < epsilon)\n            return [x, 0];\n        var k = x * x + y * y, phi = y * 0.5, i = 10, delta;\n        do {\n            var tanPhi = tan(phi), secPhi = 1 / cos(phi), j = k - 2 * y * phi + phi * phi;\n            phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);\n        } while (abs(delta) > epsilon && --i > 0);\n        tanPhi = tan(phi);\n        return [\n            (abs(y) < abs(phi + 1 / tanPhi) ? asin(x * tanPhi) : sign(x) * (acos(abs(x * tanPhi)) + halfPi)) / sin(phi),\n            phi\n        ];\n    };\n    var polyconic = function () {\n        return d3Geo.geoProjection(polyconicRaw)\n            .scale(103.74);\n    };\n    // Note: 6-element arrays are used to denote the 3x3 affine transform matrix:\n    // [a, b, c,\n    //  d, e, f,\n    //  0, 0, 1] - this redundant row is left out.\n    // Transform matrix for [a0, a1] -> [b0, b1].\n    var matrix = function (a, b) {\n        var u = subtract(a[1], a[0]), v = subtract(b[1], b[0]), phi = angle$1(u, v), s = length(u) / length(v);\n        return multiply([\n            1, 0, a[0][0],\n            0, 1, a[0][1]\n        ], multiply([\n            s, 0, 0,\n            0, s, 0\n        ], multiply([\n            cos(phi), sin(phi), 0,\n            -sin(phi), cos(phi), 0\n        ], [\n            1, 0, -b[0][0],\n            0, 1, -b[0][1]\n        ])));\n    };\n    // Inverts a transform matrix.\n    function inverse(m) {\n        var k = 1 / (m[0] * m[4] - m[1] * m[3]);\n        return [\n            k * m[4], -k * m[1], k * (m[1] * m[5] - m[2] * m[4]),\n            -k * m[3], k * m[0], k * (m[2] * m[3] - m[0] * m[5])\n        ];\n    }\n    // Multiplies two 3x2 matrices.\n    function multiply(a, b) {\n        return [\n            a[0] * b[0] + a[1] * b[3],\n            a[0] * b[1] + a[1] * b[4],\n            a[0] * b[2] + a[1] * b[5] + a[2],\n            a[3] * b[0] + a[4] * b[3],\n            a[3] * b[1] + a[4] * b[4],\n            a[3] * b[2] + a[4] * b[5] + a[5]\n        ];\n    }\n    // Subtracts 2D vectors.\n    function subtract(a, b) {\n        return [a[0] - b[0], a[1] - b[1]];\n    }\n    // Magnitude of a 2D vector.\n    function length(v) {\n        return sqrt(v[0] * v[0] + v[1] * v[1]);\n    }\n    // Angle between two 2D vectors.\n    function angle$1(a, b) {\n        return atan2(a[0] * b[1] - a[1] * b[0], a[0] * b[0] + a[1] * b[1]);\n    }\n    // Creates a polyhedral projection.\n    //  * root: a spanning tree of polygon faces.  Nodes are automatically\n    //    augmented with a transform matrix.\n    //  * face: a function that returns the appropriate node for a given {lambda, phi}\n    //    point (radians).\n    //  * r: rotation angle for final polyhedral net.  Defaults to -pi / 6 (for\n    //    butterflies).\n    var polyhedral = function (root, face, r) {\n        r = r == null ? -pi / 6 : r; // TODO automate\n        recurse(root, { transform: [\n                cos(r), sin(r), 0,\n                -sin(r), cos(r), 0\n            ] });\n        function recurse(node, parent) {\n            node.edges = faceEdges(node.face);\n            // Find shared edge.\n            if (parent.face) {\n                var shared = node.shared = sharedEdge(node.face, parent.face), m = matrix(shared.map(parent.project), shared.map(node.project));\n                node.transform = parent.transform ? multiply(parent.transform, m) : m;\n                // Replace shared edge in parent edges array.\n                var edges = parent.edges;\n                for (var i = 0, n = edges.length; i < n; ++i) {\n                    if (pointEqual$1(shared[0], edges[i][1]) && pointEqual$1(shared[1], edges[i][0]))\n                        edges[i] = node;\n                    if (pointEqual$1(shared[0], edges[i][0]) && pointEqual$1(shared[1], edges[i][1]))\n                        edges[i] = node;\n                }\n                edges = node.edges;\n                for (i = 0, n = edges.length; i < n; ++i) {\n                    if (pointEqual$1(shared[0], edges[i][0]) && pointEqual$1(shared[1], edges[i][1]))\n                        edges[i] = parent;\n                    if (pointEqual$1(shared[0], edges[i][1]) && pointEqual$1(shared[1], edges[i][0]))\n                        edges[i] = parent;\n                }\n            }\n            else {\n                node.transform = parent.transform;\n            }\n            if (node.children) {\n                node.children.forEach(function (child) {\n                    recurse(child, node);\n                });\n            }\n            return node;\n        }\n        function forward(lambda, phi) {\n            var node = face(lambda, phi), point = node.project([lambda * degrees, phi * degrees]), t;\n            if (t = node.transform) {\n                return [\n                    t[0] * point[0] + t[1] * point[1] + t[2],\n                    -(t[3] * point[0] + t[4] * point[1] + t[5])\n                ];\n            }\n            point[1] = -point[1];\n            return point;\n        }\n        // Naive inverse!  A faster solution would use bounding boxes, or even a\n        // polygonal quadtree.\n        if (hasInverse(root))\n            forward.invert = function (x, y) {\n                var coordinates = faceInvert(root, [x, -y]);\n                return coordinates && (coordinates[0] *= radians, coordinates[1] *= radians, coordinates);\n            };\n        function faceInvert(node, coordinates) {\n            var invert = node.project.invert, t = node.transform, point = coordinates;\n            if (t) {\n                t = inverse(t);\n                point = [\n                    t[0] * point[0] + t[1] * point[1] + t[2],\n                    (t[3] * point[0] + t[4] * point[1] + t[5])\n                ];\n            }\n            if (invert && node === faceDegrees(p = invert(point)))\n                return p;\n            var p, children = node.children;\n            for (var i = 0, n = children && children.length; i < n; ++i) {\n                if (p = faceInvert(children[i], coordinates))\n                    return p;\n            }\n        }\n        function faceDegrees(coordinates) {\n            return face(coordinates[0] * radians, coordinates[1] * radians);\n        }\n        var proj = d3Geo.geoProjection(forward), stream_ = proj.stream;\n        proj.stream = function (stream) {\n            var rotate = proj.rotate(), rotateStream = stream_(stream), sphereStream = (proj.rotate([0, 0]), stream_(stream));\n            proj.rotate(rotate);\n            rotateStream.sphere = function () {\n                sphereStream.polygonStart();\n                sphereStream.lineStart();\n                outline(sphereStream, root);\n                sphereStream.lineEnd();\n                sphereStream.polygonEnd();\n            };\n            return rotateStream;\n        };\n        return proj;\n    };\n    function outline(stream, node, parent) {\n        var point, edges = node.edges, n = edges.length, edge, multiPoint = { type: \"MultiPoint\", coordinates: node.face }, notPoles = node.face.filter(function (d) { return abs(d[1]) !== 90; }), b = d3Geo.geoBounds({ type: \"MultiPoint\", coordinates: notPoles }), inside = false, j = -1, dx = b[1][0] - b[0][0];\n        // TODO\n        var c = dx === 180 || dx === 360\n            ? [(b[0][0] + b[1][0]) / 2, (b[0][1] + b[1][1]) / 2]\n            : d3Geo.geoCentroid(multiPoint);\n        // First find the shared edge…\n        if (parent)\n            while (++j < n) {\n                if (edges[j] === parent)\n                    break;\n            }\n        ++j;\n        for (var i = 0; i < n; ++i) {\n            edge = edges[(i + j) % n];\n            if (Array.isArray(edge)) {\n                if (!inside) {\n                    stream.point((point = d3Geo.geoInterpolate(edge[0], c)(epsilon))[0], point[1]);\n                    inside = true;\n                }\n                stream.point((point = d3Geo.geoInterpolate(edge[1], c)(epsilon))[0], point[1]);\n            }\n            else {\n                inside = false;\n                if (edge !== parent)\n                    outline(stream, edge, node);\n            }\n        }\n    }\n    // Tests equality of two spherical points.\n    function pointEqual$1(a, b) {\n        return a && b && a[0] === b[0] && a[1] === b[1];\n    }\n    // Finds a shared edge given two clockwise polygons.\n    function sharedEdge(a, b) {\n        var x, y, n = a.length, found = null;\n        for (var i = 0; i < n; ++i) {\n            x = a[i];\n            for (var j = b.length; --j >= 0;) {\n                y = b[j];\n                if (x[0] === y[0] && x[1] === y[1]) {\n                    if (found)\n                        return [found, x];\n                    found = x;\n                }\n            }\n        }\n    }\n    // Converts an array of n face vertices to an array of n + 1 edges.\n    function faceEdges(face) {\n        var n = face.length, edges = [];\n        for (var a = face[n - 1], i = 0; i < n; ++i)\n            edges.push([a, a = face[i]]);\n        return edges;\n    }\n    function hasInverse(node) {\n        return node.project.invert || node.children && node.children.some(hasInverse);\n    }\n    // TODO generate on-the-fly to avoid external modification.\n    var octahedron = [\n        [0, 90],\n        [-90, 0], [0, 0], [90, 0], [180, 0],\n        [0, -90]\n    ];\n    var octahedron$1 = [\n        [0, 2, 1],\n        [0, 3, 2],\n        [5, 1, 2],\n        [5, 2, 3],\n        [0, 1, 4],\n        [0, 4, 3],\n        [5, 4, 1],\n        [5, 3, 4]\n    ].map(function (face) {\n        return face.map(function (i) {\n            return octahedron[i];\n        });\n    });\n    var butterfly = function (faceProjection) {\n        faceProjection = faceProjection || function (face) {\n            var c = d3Geo.geoCentroid({ type: \"MultiPoint\", coordinates: face });\n            return d3Geo.geoGnomonic().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);\n        };\n        var faces = octahedron$1.map(function (face) {\n            return { face: face, project: faceProjection(face) };\n        });\n        [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function (d, i) {\n            var node = faces[d];\n            node && (node.children || (node.children = [])).push(faces[i]);\n        });\n        return polyhedral(faces[0], function (lambda, phi) {\n            return faces[lambda < -pi / 2 ? phi < 0 ? 6 : 4\n                : lambda < 0 ? phi < 0 ? 2 : 0\n                    : lambda < pi / 2 ? phi < 0 ? 3 : 1\n                        : phi < 0 ? 7 : 5];\n        })\n            .scale(101.858)\n            .center([0, 45]);\n    };\n    var kx = 2 / sqrt(3);\n    function collignonK(a, b) {\n        var p = collignonRaw(a, b);\n        return [p[0] * kx, p[1]];\n    }\n    collignonK.invert = function (x, y) {\n        return collignonRaw.invert(x / kx, y);\n    };\n    var collignon$1 = function (faceProjection) {\n        faceProjection = faceProjection || function (face) {\n            var c = d3Geo.geoCentroid({ type: \"MultiPoint\", coordinates: face });\n            return d3Geo.geoProjection(collignonK).translate([0, 0]).scale(1).rotate(c[1] > 0 ? [-c[0], 0] : [180 - c[0], 180]);\n        };\n        var faces = octahedron$1.map(function (face) {\n            return { face: face, project: faceProjection(face) };\n        });\n        [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function (d, i) {\n            var node = faces[d];\n            node && (node.children || (node.children = [])).push(faces[i]);\n        });\n        return polyhedral(faces[0], function (lambda, phi) {\n            return faces[lambda < -pi / 2 ? phi < 0 ? 6 : 4\n                : lambda < 0 ? phi < 0 ? 2 : 0\n                    : lambda < pi / 2 ? phi < 0 ? 3 : 1\n                        : phi < 0 ? 7 : 5];\n        })\n            .scale(121.906)\n            .center([0, 48.5904]);\n    };\n    var waterman = function (faceProjection) {\n        faceProjection = faceProjection || function (face) {\n            var c = face.length === 6 ? d3Geo.geoCentroid({ type: \"MultiPoint\", coordinates: face }) : face[0];\n            return d3Geo.geoGnomonic().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);\n        };\n        var w5 = octahedron$1.map(function (face) {\n            var xyz = face.map(cartesian), n = xyz.length, a = xyz[n - 1], b, hexagon = [];\n            for (var i = 0; i < n; ++i) {\n                b = xyz[i];\n                hexagon.push(spherical([\n                    a[0] * 0.9486832980505138 + b[0] * 0.31622776601683794,\n                    a[1] * 0.9486832980505138 + b[1] * 0.31622776601683794,\n                    a[2] * 0.9486832980505138 + b[2] * 0.31622776601683794\n                ]), spherical([\n                    b[0] * 0.9486832980505138 + a[0] * 0.31622776601683794,\n                    b[1] * 0.9486832980505138 + a[1] * 0.31622776601683794,\n                    b[2] * 0.9486832980505138 + a[2] * 0.31622776601683794\n                ]));\n                a = b;\n            }\n            return hexagon;\n        });\n        var cornerNormals = [];\n        var parents = [-1, 0, 0, 1, 0, 1, 4, 5];\n        w5.forEach(function (hexagon, j) {\n            var face = octahedron$1[j], n = face.length, normals = cornerNormals[j] = [];\n            for (var i = 0; i < n; ++i) {\n                w5.push([\n                    face[i],\n                    hexagon[(i * 2 + 2) % (2 * n)],\n                    hexagon[(i * 2 + 1) % (2 * n)]\n                ]);\n                parents.push(j);\n                normals.push(cross(cartesian(hexagon[(i * 2 + 2) % (2 * n)]), cartesian(hexagon[(i * 2 + 1) % (2 * n)])));\n            }\n        });\n        var faces = w5.map(function (face) {\n            return {\n                project: faceProjection(face),\n                face: face\n            };\n        });\n        parents.forEach(function (d, i) {\n            var parent = faces[d];\n            parent && (parent.children || (parent.children = [])).push(faces[i]);\n        });\n        function face(lambda, phi) {\n            var cosphi = cos(phi), p = [cosphi * cos(lambda), cosphi * sin(lambda), sin(phi)];\n            var hexagon = lambda < -pi / 2 ? phi < 0 ? 6 : 4\n                : lambda < 0 ? phi < 0 ? 2 : 0\n                    : lambda < pi / 2 ? phi < 0 ? 3 : 1\n                        : phi < 0 ? 7 : 5;\n            var n = cornerNormals[hexagon];\n            return faces[dot(n[0], p) < 0 ? 8 + 3 * hexagon\n                : dot(n[1], p) < 0 ? 8 + 3 * hexagon + 1\n                    : dot(n[2], p) < 0 ? 8 + 3 * hexagon + 2\n                        : hexagon];\n        }\n        return polyhedral(faces[0], face)\n            .scale(110.625)\n            .center([0, 45]);\n    };\n    function dot(a, b) {\n        for (var i = 0, n = a.length, s = 0; i < n; ++i)\n            s += a[i] * b[i];\n        return s;\n    }\n    function cross(a, b) {\n        return [\n            a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0]\n        ];\n    }\n    // Converts 3D Cartesian to spherical coordinates (degrees).\n    function spherical(cartesian) {\n        return [\n            atan2(cartesian[1], cartesian[0]) * degrees,\n            asin(max(-1, min(1, cartesian[2]))) * degrees\n        ];\n    }\n    // Converts spherical coordinates (degrees) to 3D Cartesian.\n    function cartesian(coordinates) {\n        var lambda = coordinates[0] * radians, phi = coordinates[1] * radians, cosphi = cos(phi);\n        return [\n            cosphi * cos(lambda),\n            cosphi * sin(lambda),\n            sin(phi)\n        ];\n    }\n    var noop = function () { };\n    var clockwise = function (ring) {\n        if ((n = ring.length) < 4)\n            return false;\n        var i = 0, n, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n        while (++i < n)\n            area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n        return area <= 0;\n    };\n    var contains = function (ring, point) {\n        var x = point[0], y = point[1], contains = false;\n        for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n            var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];\n            if (((yi > y) ^ (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi))\n                contains = !contains;\n        }\n        return contains;\n    };\n    var index = function (object, projection) {\n        var stream = projection.stream, project;\n        if (!stream)\n            throw new Error(\"invalid projection\");\n        switch (object && object.type) {\n            case \"Feature\":\n                project = projectFeature;\n                break;\n            case \"FeatureCollection\":\n                project = projectFeatureCollection;\n                break;\n            default:\n                project = projectGeometry;\n                break;\n        }\n        return project(object, stream);\n    };\n    function projectFeatureCollection(o, stream) {\n        return {\n            type: \"FeatureCollection\",\n            features: o.features.map(function (f) {\n                return projectFeature(f, stream);\n            })\n        };\n    }\n    function projectFeature(o, stream) {\n        return {\n            type: \"Feature\",\n            id: o.id,\n            properties: o.properties,\n            geometry: projectGeometry(o.geometry, stream)\n        };\n    }\n    function projectGeometryCollection(o, stream) {\n        return {\n            type: \"GeometryCollection\",\n            geometries: o.geometries.map(function (o) {\n                return projectGeometry(o, stream);\n            })\n        };\n    }\n    function projectGeometry(o, stream) {\n        if (!o)\n            return null;\n        if (o.type === \"GeometryCollection\")\n            return projectGeometryCollection(o, stream);\n        var sink;\n        switch (o.type) {\n            case \"Point\":\n                sink = sinkPoint;\n                break;\n            case \"MultiPoint\":\n                sink = sinkPoint;\n                break;\n            case \"LineString\":\n                sink = sinkLine;\n                break;\n            case \"MultiLineString\":\n                sink = sinkLine;\n                break;\n            case \"Polygon\":\n                sink = sinkPolygon;\n                break;\n            case \"MultiPolygon\":\n                sink = sinkPolygon;\n                break;\n            case \"Sphere\":\n                sink = sinkPolygon;\n                break;\n            default: return null;\n        }\n        d3Geo.geoStream(o, stream(sink));\n        return sink.result();\n    }\n    var points = [];\n    var lines = [];\n    var sinkPoint = {\n        point: function (x, y) {\n            points.push([x, y]);\n        },\n        result: function () {\n            var result = !points.length ? null\n                : points.length < 2 ? { type: \"Point\", coordinates: points[0] }\n                    : { type: \"MultiPoint\", coordinates: points };\n            points = [];\n            return result;\n        }\n    };\n    var sinkLine = {\n        lineStart: noop,\n        point: function (x, y) {\n            points.push([x, y]);\n        },\n        lineEnd: function () {\n            if (points.length)\n                lines.push(points), points = [];\n        },\n        result: function () {\n            var result = !lines.length ? null\n                : lines.length < 2 ? { type: \"LineString\", coordinates: lines[0] }\n                    : { type: \"MultiLineString\", coordinates: lines };\n            lines = [];\n            return result;\n        }\n    };\n    var sinkPolygon = {\n        polygonStart: noop,\n        lineStart: noop,\n        point: function (x, y) {\n            points.push([x, y]);\n        },\n        lineEnd: function () {\n            var n = points.length;\n            if (n) {\n                do\n                    points.push(points[0].slice());\n                while (++n < 4);\n                lines.push(points), points = [];\n            }\n        },\n        polygonEnd: noop,\n        result: function () {\n            if (!lines.length)\n                return null;\n            var polygons = [], holes = [];\n            // https://github.com/d3/d3/issues/1558\n            lines.forEach(function (ring) {\n                if (clockwise(ring))\n                    polygons.push([ring]);\n                else\n                    holes.push(ring);\n            });\n            holes.forEach(function (hole) {\n                var point = hole[0];\n                polygons.some(function (polygon) {\n                    if (contains(polygon[0], point)) {\n                        polygon.push(hole);\n                        return true;\n                    }\n                }) || polygons.push([hole]);\n            });\n            lines = [];\n            return !polygons.length ? null\n                : polygons.length > 1 ? { type: \"MultiPolygon\", coordinates: polygons }\n                    : { type: \"Polygon\", coordinates: polygons[0] };\n        }\n    };\n    var quincuncial = function (project) {\n        var dx = project(halfPi, 0)[0] - project(-halfPi, 0)[0];\n        function projectQuincuncial(lambda, phi) {\n            var t = abs(lambda) < halfPi, p = project(t ? lambda : lambda > 0 ? lambda - pi : lambda + pi, phi), x = (p[0] - p[1]) * sqrt1_2, y = (p[0] + p[1]) * sqrt1_2;\n            if (t)\n                return [x, y];\n            var d = dx * sqrt1_2, s = x > 0 ^ y > 0 ? -1 : 1;\n            return [s * x - sign(y) * d, s * y - sign(x) * d];\n        }\n        if (project.invert)\n            projectQuincuncial.invert = function (x0, y0) {\n                var x = (x0 + y0) * sqrt1_2, y = (y0 - x0) * sqrt1_2, t = abs(x) < 0.5 * dx && abs(y) < 0.5 * dx;\n                if (!t) {\n                    var d = dx * sqrt1_2, s = x > 0 ^ y > 0 ? -1 : 1, x1 = -s * x0 + (y > 0 ? 1 : -1) * d, y1 = -s * y0 + (x > 0 ? 1 : -1) * d;\n                    x = (-x1 - y1) * sqrt1_2;\n                    y = (x1 - y1) * sqrt1_2;\n                }\n                var p = project.invert(x, y);\n                if (!t)\n                    p[0] += x > 0 ? pi : -pi;\n                return p;\n            };\n        return d3Geo.geoProjection(projectQuincuncial)\n            .rotate([-90, -90, 45])\n            .clipAngle(180 - 1e-3);\n    };\n    var gringorten$1 = function () {\n        return quincuncial(gringortenRaw)\n            .scale(176.423);\n    };\n    var peirce = function () {\n        return quincuncial(guyouRaw)\n            .scale(111.48);\n    };\n    var quantize = function (input, digits) {\n        if (!(0 <= (digits = +digits) && digits <= 20))\n            throw new Error(\"invalid digits\");\n        function quantizePoint(input) {\n            var n = input.length, i = 2, output = new Array(n);\n            output[0] = +input[0].toFixed(digits);\n            output[1] = +input[1].toFixed(digits);\n            while (i < n)\n                output[i] = input[i], ++i;\n            return output;\n        }\n        function quantizePoints(input) {\n            return input.map(quantizePoint);\n        }\n        function quantizePolygon(input) {\n            return input.map(quantizePoints);\n        }\n        function quantizeGeometry(input) {\n            if (input == null)\n                return input;\n            var output;\n            switch (input.type) {\n                case \"GeometryCollection\":\n                    output = { type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry) };\n                    break;\n                case \"Point\":\n                    output = { type: \"Point\", coordinates: quantizePoint(input.coordinates) };\n                    break;\n                case \"MultiPoint\":\n                case \"LineString\":\n                    output = { type: input.type, coordinates: quantizePoints(input.coordinates) };\n                    break;\n                case \"MultiLineString\":\n                case \"Polygon\":\n                    output = { type: input.type, coordinates: quantizePolygon(input.coordinates) };\n                    break;\n                case \"MultiPolygon\":\n                    output = { type: \"MultiPolygon\", coordinates: input.coordinates.map(quantizePolygon) };\n                    break;\n                default: return input;\n            }\n            if (input.bbox != null)\n                output.bbox = input.bbox;\n            return output;\n        }\n        function quantizeFeature(input) {\n            var output = { type: \"Feature\", properties: input.properties, geometry: quantizeGeometry(input.geometry) };\n            if (input.id != null)\n                output.id = input.id;\n            if (input.bbox != null)\n                output.bbox = input.bbox;\n            return output;\n        }\n        if (input != null)\n            switch (input.type) {\n                case \"Feature\": return quantizeFeature(input);\n                case \"FeatureCollection\": {\n                    var output = { type: \"FeatureCollection\", features: input.features.map(quantizeFeature) };\n                    if (input.bbox != null)\n                        output.bbox = input.bbox;\n                    return output;\n                }\n                default: return quantizeGeometry(input);\n            }\n        return input;\n    };\n    function rectangularPolyconicRaw(phi0) {\n        var sinPhi0 = sin(phi0);\n        function forward(lambda, phi) {\n            var A = sinPhi0 ? tan(lambda * sinPhi0 / 2) / sinPhi0 : lambda / 2;\n            if (!phi)\n                return [2 * A, -phi0];\n            var E = 2 * atan(A * sin(phi)), cotPhi = 1 / tan(phi);\n            return [\n                sin(E) * cotPhi,\n                phi + (1 - cos(E)) * cotPhi - phi0\n            ];\n        }\n        // TODO return null for points outside outline.\n        forward.invert = function (x, y) {\n            if (abs(y += phi0) < epsilon)\n                return [sinPhi0 ? 2 * atan(sinPhi0 * x / 2) / sinPhi0 : x, 0];\n            var k = x * x + y * y, phi = 0, i = 10, delta;\n            do {\n                var tanPhi = tan(phi), secPhi = 1 / cos(phi), j = k - 2 * y * phi + phi * phi;\n                phi -= delta = (tanPhi * j + 2 * (phi - y)) / (2 + j * secPhi * secPhi + 2 * (phi - y) * tanPhi);\n            } while (abs(delta) > epsilon && --i > 0);\n            var E = x * (tanPhi = tan(phi)), A = tan(abs(y) < abs(phi + 1 / tanPhi) ? asin(E) * 0.5 : acos(E) * 0.5 + pi / 4) / sin(phi);\n            return [\n                sinPhi0 ? 2 * atan(sinPhi0 * A) / sinPhi0 : 2 * A,\n                phi\n            ];\n        };\n        return forward;\n    }\n    var rectangularPolyconic = function () {\n        return parallel1(rectangularPolyconicRaw)\n            .scale(131.215);\n    };\n    var K = [\n        [0.9986, -0.062],\n        [1.0000, 0.0000],\n        [0.9986, 0.0620],\n        [0.9954, 0.1240],\n        [0.9900, 0.1860],\n        [0.9822, 0.2480],\n        [0.9730, 0.3100],\n        [0.9600, 0.3720],\n        [0.9427, 0.4340],\n        [0.9216, 0.4958],\n        [0.8962, 0.5571],\n        [0.8679, 0.6176],\n        [0.8350, 0.6769],\n        [0.7986, 0.7346],\n        [0.7597, 0.7903],\n        [0.7186, 0.8435],\n        [0.6732, 0.8936],\n        [0.6213, 0.9394],\n        [0.5722, 0.9761],\n        [0.5322, 1.0000]\n    ];\n    K.forEach(function (d) {\n        d[1] *= 1.0144;\n    });\n    function robinsonRaw(lambda, phi) {\n        var i = min(18, abs(phi) * 36 / pi), i0 = floor(i), di = i - i0, ax = (k = K[i0])[0], ay = k[1], bx = (k = K[++i0])[0], by = k[1], cx = (k = K[min(19, ++i0)])[0], cy = k[1], k;\n        return [\n            lambda * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),\n            (phi > 0 ? halfPi : -halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)\n        ];\n    }\n    robinsonRaw.invert = function (x, y) {\n        var yy = y / halfPi, phi = yy * 90, i = min(18, abs(phi / 5)), i0 = max(0, floor(i));\n        do {\n            var ay = K[i0][1], by = K[i0 + 1][1], cy = K[min(19, i0 + 2)][1], u = cy - ay, v = cy - 2 * by + ay, t = 2 * (abs(yy) - by) / u, c = v / u, di = t * (1 - c * t * (1 - 2 * c * t));\n            if (di >= 0 || i0 === 1) {\n                phi = (y >= 0 ? 5 : -5) * (di + i);\n                var j = 50, delta;\n                do {\n                    i = min(18, abs(phi) / 5);\n                    i0 = floor(i);\n                    di = i - i0;\n                    ay = K[i0][1];\n                    by = K[i0 + 1][1];\n                    cy = K[min(19, i0 + 2)][1];\n                    phi -= (delta = (y >= 0 ? halfPi : -halfPi) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * degrees;\n                } while (abs(delta) > epsilon2 && --j > 0);\n                break;\n            }\n        } while (--i0 >= 0);\n        var ax = K[i0][0], bx = K[i0 + 1][0], cx = K[min(19, i0 + 2)][0];\n        return [\n            x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2),\n            phi * radians\n        ];\n    };\n    var robinson = function () {\n        return d3Geo.geoProjection(robinsonRaw)\n            .scale(152.63);\n    };\n    function satelliteVerticalRaw(P) {\n        function forward(lambda, phi) {\n            var cosPhi = cos(phi), k = (P - 1) / (P - cosPhi * cos(lambda));\n            return [\n                k * cosPhi * sin(lambda),\n                k * sin(phi)\n            ];\n        }\n        forward.invert = function (x, y) {\n            var rho2 = x * x + y * y, rho = sqrt(rho2), sinc = (P - sqrt(1 - rho2 * (P + 1) / (P - 1))) / ((P - 1) / rho + rho / (P - 1));\n            return [\n                atan2(x * sinc, rho * sqrt(1 - sinc * sinc)),\n                rho ? asin(y * sinc / rho) : 0\n            ];\n        };\n        return forward;\n    }\n    function satelliteRaw(P, omega) {\n        var vertical = satelliteVerticalRaw(P);\n        if (!omega)\n            return vertical;\n        var cosOmega = cos(omega), sinOmega = sin(omega);\n        function forward(lambda, phi) {\n            var coordinates = vertical(lambda, phi), y = coordinates[1], A = y * sinOmega / (P - 1) + cosOmega;\n            return [\n                coordinates[0] * cosOmega / A,\n                y / A\n            ];\n        }\n        forward.invert = function (x, y) {\n            var k = (P - 1) / (P - 1 - y * sinOmega);\n            return vertical.invert(k * x, k * y * cosOmega);\n        };\n        return forward;\n    }\n    var satellite = function () {\n        var distance = 2, omega = 0, m = d3Geo.geoProjectionMutator(satelliteRaw), p = m(distance, omega);\n        // As a multiple of radius.\n        p.distance = function (_) {\n            if (!arguments.length)\n                return distance;\n            return m(distance = +_, omega);\n        };\n        p.tilt = function (_) {\n            if (!arguments.length)\n                return omega * degrees;\n            return m(distance, omega = _ * radians);\n        };\n        return p\n            .scale(432.147)\n            .clipAngle(acos(1 / distance) * degrees - 1e-6);\n    };\n    var epsilon$1 = 1e-4;\n    var epsilonInverse = 1e4;\n    var x0 = -180;\n    var x0e = x0 + epsilon$1;\n    var x1 = 180;\n    var x1e = x1 - epsilon$1;\n    var y0 = -90;\n    var y0e = y0 + epsilon$1;\n    var y1 = 90;\n    var y1e = y1 - epsilon$1;\n    function nonempty(coordinates) {\n        return coordinates.length > 0;\n    }\n    function quantize$1(x) {\n        return Math.floor(x * epsilonInverse) / epsilonInverse;\n    }\n    function normalizePoint(y) {\n        return y === y0 || y === y1 ? [0, y] : [x0, quantize$1(y)]; // pole or antimeridian?\n    }\n    function clampPoint(p) {\n        var x = p[0], y = p[1], clamped = false;\n        if (x <= x0e)\n            x = x0, clamped = true;\n        else if (x >= x1e)\n            x = x1, clamped = true;\n        if (y <= y0e)\n            y = y0, clamped = true;\n        else if (y >= y1e)\n            y = y1, clamped = true;\n        return clamped ? [x, y] : p;\n    }\n    function clampPoints(points) {\n        return points.map(clampPoint);\n    }\n    // For each ring, detect where it crosses the antimeridian or pole.\n    function extractFragments(rings, polygon, fragments) {\n        for (var j = 0, m = rings.length; j < m; ++j) {\n            var ring = rings[j].slice();\n            // By default, assume that this ring doesn’t need any stitching.\n            fragments.push({ index: -1, polygon: polygon, ring: ring });\n            for (var i = 0, n = ring.length; i < n; ++i) {\n                var point = ring[i], x = point[0], y = point[1];\n                // If this is an antimeridian or polar point…\n                if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {\n                    ring[i] = clampPoint(point);\n                    // Advance through any antimeridian or polar points…\n                    for (var k = i + 1; k < n; ++k) {\n                        var pointk = ring[k], xk = pointk[0], yk = pointk[1];\n                        if (xk > x0e && xk < x1e && yk > y0e && yk < y1e)\n                            break;\n                    }\n                    // If this was just a single antimeridian or polar point,\n                    // we don’t need to cut this ring into a fragment;\n                    // we can just leave it as-is.\n                    if (k === i + 1)\n                        continue;\n                    // Otherwise, if this is not the first point in the ring,\n                    // cut the current fragment so that it ends at the current point.\n                    // The current point is also normalized for later joining.\n                    if (i) {\n                        var fragmentBefore = { index: -1, polygon: polygon, ring: ring.slice(0, i + 1) };\n                        fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y);\n                        fragments[fragments.length - 1] = fragmentBefore;\n                    }\n                    // If the ring started with an antimeridian fragment,\n                    // we can ignore that fragment entirely.\n                    else\n                        fragments.pop();\n                    // If the remainder of the ring is an antimeridian fragment,\n                    // move on to the next ring.\n                    if (k >= n)\n                        break;\n                    // Otherwise, add the remaining ring fragment and continue.\n                    fragments.push({ index: -1, polygon: polygon, ring: ring = ring.slice(k - 1) });\n                    ring[0] = normalizePoint(ring[0][1]);\n                    i = -1;\n                    n = ring.length;\n                }\n            }\n        }\n    }\n    // Now stitch the fragments back together into rings.\n    function stitchFragments(fragments) {\n        var i, n = fragments.length;\n        // To connect the fragments start-to-end, create a simple index by end.\n        var fragmentByStart = {}, fragmentByEnd = {}, fragment, start, startFragment, end, endFragment;\n        // For each fragment…\n        for (i = 0; i < n; ++i) {\n            fragment = fragments[i];\n            start = fragment.ring[0];\n            end = fragment.ring[fragment.ring.length - 1];\n            // If this fragment is closed, add it as a standalone ring.\n            if (start[0] === end[0] && start[1] === end[1]) {\n                fragment.polygon.push(fragment.ring);\n                fragments[i] = null;\n                continue;\n            }\n            fragment.index = i;\n            fragmentByStart[start] = fragmentByEnd[end] = fragment;\n        }\n        // For each open fragment…\n        for (i = 0; i < n; ++i) {\n            fragment = fragments[i];\n            if (fragment) {\n                start = fragment.ring[0];\n                end = fragment.ring[fragment.ring.length - 1];\n                startFragment = fragmentByEnd[start];\n                endFragment = fragmentByStart[end];\n                delete fragmentByStart[start];\n                delete fragmentByEnd[end];\n                // If this fragment is closed, add it as a standalone ring.\n                if (start[0] === end[0] && start[1] === end[1]) {\n                    fragment.polygon.push(fragment.ring);\n                    continue;\n                }\n                if (startFragment) {\n                    delete fragmentByEnd[start];\n                    delete fragmentByStart[startFragment.ring[0]];\n                    startFragment.ring.pop(); // drop the shared coordinate\n                    fragments[startFragment.index] = null;\n                    fragment = { index: -1, polygon: startFragment.polygon, ring: startFragment.ring.concat(fragment.ring) };\n                    if (startFragment === endFragment) {\n                        // Connect both ends to this single fragment to create a ring.\n                        fragment.polygon.push(fragment.ring);\n                    }\n                    else {\n                        fragment.index = n++;\n                        fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n                    }\n                }\n                else if (endFragment) {\n                    delete fragmentByStart[end];\n                    delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];\n                    fragment.ring.pop(); // drop the shared coordinate\n                    fragment = { index: n++, polygon: endFragment.polygon, ring: fragment.ring.concat(endFragment.ring) };\n                    fragments[endFragment.index] = null;\n                    fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n                }\n                else {\n                    fragment.ring.push(fragment.ring[0]); // close ring\n                    fragment.polygon.push(fragment.ring);\n                }\n            }\n        }\n    }\n    function stitchFeature(input) {\n        var output = { type: \"Feature\", geometry: stitchGeometry(input.geometry) };\n        if (input.id != null)\n            output.id = input.id;\n        if (input.bbox != null)\n            output.bbox = input.bbox;\n        if (input.properties != null)\n            output.properties = input.properties;\n        return output;\n    }\n    function stitchGeometry(input) {\n        if (input == null)\n            return input;\n        var output, fragments, i, n;\n        switch (input.type) {\n            case \"GeometryCollection\":\n                output = { type: \"GeometryCollection\", geometries: input.geometries.map(stitchGeometry) };\n                break;\n            case \"Point\":\n                output = { type: \"Point\", coordinates: clampPoint(input.coordinates) };\n                break;\n            case \"MultiPoint\":\n            case \"LineString\":\n                output = { type: input.type, coordinates: clampPoints(input.coordinates) };\n                break;\n            case \"MultiLineString\":\n                output = { type: \"MultiLineString\", coordinates: input.coordinates.map(clampPoints) };\n                break;\n            case \"Polygon\": {\n                var polygon = [];\n                extractFragments(input.coordinates, polygon, fragments = []);\n                stitchFragments(fragments);\n                output = { type: \"Polygon\", coordinates: polygon };\n                break;\n            }\n            case \"MultiPolygon\": {\n                fragments = [], i = -1, n = input.coordinates.length;\n                var polygons = new Array(n);\n                while (++i < n)\n                    extractFragments(input.coordinates[i], polygons[i] = [], fragments);\n                stitchFragments(fragments);\n                output = { type: \"MultiPolygon\", coordinates: polygons.filter(nonempty) };\n                break;\n            }\n            default: return input;\n        }\n        if (input.bbox != null)\n            output.bbox = input.bbox;\n        return output;\n    }\n    var stitch = function (input) {\n        if (input == null)\n            return input;\n        switch (input.type) {\n            case \"Feature\": return stitchFeature(input);\n            case \"FeatureCollection\": {\n                var output = { type: \"FeatureCollection\", features: input.features.map(stitchFeature) };\n                if (input.bbox != null)\n                    output.bbox = input.bbox;\n                return output;\n            }\n            default: return stitchGeometry(input);\n        }\n    };\n    function timesRaw(lambda, phi) {\n        var t = tan(phi / 2), s = sin(quarterPi * t);\n        return [\n            lambda * (0.74482 - 0.34588 * s * s),\n            1.70711 * t\n        ];\n    }\n    timesRaw.invert = function (x, y) {\n        var t = y / 1.70711, s = sin(quarterPi * t);\n        return [\n            x / (0.74482 - 0.34588 * s * s),\n            2 * atan(t)\n        ];\n    };\n    var times = function () {\n        return d3Geo.geoProjection(timesRaw)\n            .scale(146.153);\n    };\n    // Compute the origin as the midpoint of the two reference points.\n    // Rotate one of the reference points by the origin.\n    // Apply the spherical law of sines to compute gamma rotation.\n    var twoPoint = function (raw, p0, p1) {\n        var i = d3Geo.geoInterpolate(p0, p1), o = i(0.5), a = d3Geo.geoRotation([-o[0], -o[1]])(p0), b = i.distance / 2, y = -asin(sin(a[1] * radians) / sin(b)), R = [-o[0], -o[1], -(a[0] > 0 ? pi - y : y) * degrees], p = d3Geo.geoProjection(raw(b)).rotate(R), r = d3Geo.geoRotation(R), center = p.center;\n        delete p.rotate;\n        p.center = function (_) {\n            return arguments.length ? center(r(_)) : r.invert(center());\n        };\n        return p\n            .clipAngle(90);\n    };\n    function twoPointAzimuthalRaw(d) {\n        var cosd = cos(d);\n        function forward(lambda, phi) {\n            var coordinates = d3Geo.geoGnomonicRaw(lambda, phi);\n            coordinates[0] *= cosd;\n            return coordinates;\n        }\n        forward.invert = function (x, y) {\n            return d3Geo.geoGnomonicRaw.invert(x / cosd, y);\n        };\n        return forward;\n    }\n    function twoPointAzimuthalUsa() {\n        return twoPointAzimuthal([-158, 21.5], [-77, 39])\n            .clipAngle(60)\n            .scale(400);\n    }\n    function twoPointAzimuthal(p0, p1) {\n        return twoPoint(twoPointAzimuthalRaw, p0, p1);\n    }\n    // TODO clip to ellipse\n    function twoPointEquidistantRaw(z0) {\n        if (!(z0 *= 2))\n            return d3Geo.geoAzimuthalEquidistantRaw;\n        var lambdaa = -z0 / 2, lambdab = -lambdaa, z02 = z0 * z0, tanLambda0 = tan(lambdab), S = 0.5 / sin(lambdab);\n        function forward(lambda, phi) {\n            var za = acos(cos(phi) * cos(lambda - lambdaa)), zb = acos(cos(phi) * cos(lambda - lambdab)), ys = phi < 0 ? -1 : 1;\n            za *= za, zb *= zb;\n            return [\n                (za - zb) / (2 * z0),\n                ys * sqrt(4 * z02 * zb - (z02 - za + zb) * (z02 - za + zb)) / (2 * z0)\n            ];\n        }\n        forward.invert = function (x, y) {\n            var y2 = y * y, cosza = cos(sqrt(y2 + (t = x + lambdaa) * t)), coszb = cos(sqrt(y2 + (t = x + lambdab) * t)), t, d;\n            return [\n                atan2(d = cosza - coszb, t = (cosza + coszb) * tanLambda0),\n                (y < 0 ? -1 : 1) * acos(sqrt(t * t + d * d) * S)\n            ];\n        };\n        return forward;\n    }\n    function twoPointEquidistantUsa() {\n        return twoPointEquidistant([-158, 21.5], [-77, 39])\n            .clipAngle(130)\n            .scale(122.571);\n    }\n    function twoPointEquidistant(p0, p1) {\n        return twoPoint(twoPointEquidistantRaw, p0, p1);\n    }\n    function vanDerGrintenRaw(lambda, phi) {\n        if (abs(phi) < epsilon)\n            return [lambda, 0];\n        var sinTheta = abs(phi / halfPi), theta = asin(sinTheta);\n        if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon)\n            return [0, sign(phi) * pi * tan(theta / 2)];\n        var cosTheta = cos(theta), A = abs(pi / lambda - lambda / pi) / 2, A2 = A * A, G = cosTheta / (sinTheta + cosTheta - 1), P = G * (2 / sinTheta - 1), P2 = P * P, P2_A2 = P2 + A2, G_P2 = G - P2, Q = A2 + G;\n        return [\n            sign(lambda) * pi * (A * G_P2 + sqrt(A2 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2,\n            sign(phi) * pi * (P * Q - A * sqrt((A2 + 1) * P2_A2 - Q * Q)) / P2_A2\n        ];\n    }\n    vanDerGrintenRaw.invert = function (x, y) {\n        if (abs(y) < epsilon)\n            return [x, 0];\n        if (abs(x) < epsilon)\n            return [0, halfPi * sin(2 * atan(y / pi))];\n        var x2 = (x /= pi) * x, y2 = (y /= pi) * y, x2_y2 = x2 + y2, z = x2_y2 * x2_y2, c1 = -abs(y) * (1 + x2_y2), c2 = c1 - 2 * y2 + x2, c3 = -2 * c1 + 1 + 2 * y2 + z, d = y2 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27, a1 = (c1 - c2 * c2 / (3 * c3)) / c3, m1 = 2 * sqrt(-a1 / 3), theta1 = acos(3 * d / (a1 * m1)) / 3;\n        return [\n            pi * (x2_y2 - 1 + sqrt(1 + 2 * (x2 - y2) + z)) / (2 * x),\n            sign(y) * pi * (-m1 * cos(theta1 + pi / 3) - c2 / (3 * c3))\n        ];\n    };\n    var vanDerGrinten = function () {\n        return d3Geo.geoProjection(vanDerGrintenRaw)\n            .scale(79.4183);\n    };\n    function vanDerGrinten2Raw(lambda, phi) {\n        if (abs(phi) < epsilon)\n            return [lambda, 0];\n        var sinTheta = abs(phi / halfPi), theta = asin(sinTheta);\n        if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon)\n            return [0, sign(phi) * pi * tan(theta / 2)];\n        var cosTheta = cos(theta), A = abs(pi / lambda - lambda / pi) / 2, A2 = A * A, x1 = cosTheta * (sqrt(1 + A2) - A * cosTheta) / (1 + A2 * sinTheta * sinTheta);\n        return [\n            sign(lambda) * pi * x1,\n            sign(phi) * pi * sqrt(1 - x1 * (2 * A + x1))\n        ];\n    }\n    vanDerGrinten2Raw.invert = function (x, y) {\n        if (!x)\n            return [0, halfPi * sin(2 * atan(y / pi))];\n        var x1 = abs(x / pi), A = (1 - x1 * x1 - (y /= pi) * y) / (2 * x1), A2 = A * A, B = sqrt(A2 + 1);\n        return [\n            sign(x) * pi * (B - A),\n            sign(y) * halfPi * sin(2 * atan2(sqrt((1 - 2 * A * x1) * (A + B) - x1), sqrt(B + A + x1)))\n        ];\n    };\n    var vanDerGrinten2 = function () {\n        return d3Geo.geoProjection(vanDerGrinten2Raw)\n            .scale(79.4183);\n    };\n    function vanDerGrinten3Raw(lambda, phi) {\n        if (abs(phi) < epsilon)\n            return [lambda, 0];\n        var sinTheta = phi / halfPi, theta = asin(sinTheta);\n        if (abs(lambda) < epsilon || abs(abs(phi) - halfPi) < epsilon)\n            return [0, pi * tan(theta / 2)];\n        var A = (pi / lambda - lambda / pi) / 2, y1 = sinTheta / (1 + cos(theta));\n        return [\n            pi * (sign(lambda) * sqrt(A * A + 1 - y1 * y1) - A),\n            pi * y1\n        ];\n    }\n    vanDerGrinten3Raw.invert = function (x, y) {\n        if (!y)\n            return [x, 0];\n        var y1 = y / pi, A = (pi * pi * (1 - y1 * y1) - x * x) / (2 * pi * x);\n        return [\n            x ? pi * (sign(x) * sqrt(A * A + 1) - A) : 0,\n            halfPi * sin(2 * atan(y1))\n        ];\n    };\n    var vanDerGrinten3 = function () {\n        return d3Geo.geoProjection(vanDerGrinten3Raw)\n            .scale(79.4183);\n    };\n    function vanDerGrinten4Raw(lambda, phi) {\n        if (!phi)\n            return [lambda, 0];\n        var phi0 = abs(phi);\n        if (!lambda || phi0 === halfPi)\n            return [0, phi];\n        var B = phi0 / halfPi, B2 = B * B, C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)), C2 = C * C, BC = B * C, B_C2 = B2 + C2 + 2 * BC, B_3C = B + 3 * C, lambda0 = lambda / halfPi, lambda1 = lambda0 + 1 / lambda0, D = sign(abs(lambda) - halfPi) * sqrt(lambda1 * lambda1 - 4), D2 = D * D, F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + 12 * BC * C2 + 4 * C2 * C2), x1 = (D * (B_C2 + C2 - 1) + 2 * sqrt(F)) / (4 * B_C2 + D2);\n        return [\n            sign(lambda) * halfPi * x1,\n            sign(phi) * halfPi * sqrt(1 + D * abs(x1) - x1 * x1)\n        ];\n    }\n    vanDerGrinten4Raw.invert = function (x, y) {\n        var delta;\n        if (!x || !y)\n            return [x, y];\n        y /= pi;\n        var x1 = sign(x) * x / halfPi, D = (x1 * x1 - 1 + 4 * y * y) / abs(x1), D2 = D * D, B = 2 * y, i = 50;\n        do {\n            var B2 = B * B, C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)), C_ = (3 * B - B2 * B - 10) / (2 * B2 * B), C2 = C * C, BC = B * C, B_C = B + C, B_C2 = B_C * B_C, B_3C = B + 3 * C, F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + C2 * (12 * BC + 4 * C2)), F_ = -2 * B_C * (4 * BC * C2 + (1 - 4 * B2 + 3 * B2 * B2) * (1 + C_) + C2 * (-6 + 14 * B2 - D2 + (-8 + 8 * B2 - 2 * D2) * C_) + BC * (-8 + 12 * B2 + (-10 + 10 * B2 - D2) * C_)), sqrtF = sqrt(F), f = D * (B_C2 + C2 - 1) + 2 * sqrtF - x1 * (4 * B_C2 + D2), f_ = D * (2 * C * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D * (-1 + C2 + B_C2) + 2 * sqrtF) * (1 + C_) / (D2 + 4 * B_C2);\n            B -= delta = f / f_;\n        } while (delta > epsilon && --i > 0);\n        return [\n            sign(x) * (sqrt(D * D + 4) + D) * pi / 4,\n            halfPi * B\n        ];\n    };\n    var vanDerGrinten4 = function () {\n        return d3Geo.geoProjection(vanDerGrinten4Raw)\n            .scale(127.16);\n    };\n    var A = 4 * pi + 3 * sqrt(3);\n    var B = 2 * sqrt(2 * pi * sqrt(3) / A);\n    var wagner4Raw = mollweideBromleyRaw(B * sqrt(3) / pi, B, A / 6);\n    var wagner4 = function () {\n        return d3Geo.geoProjection(wagner4Raw)\n            .scale(176.84);\n    };\n    function wagner6Raw(lambda, phi) {\n        return [lambda * sqrt(1 - 3 * phi * phi / (pi * pi)), phi];\n    }\n    wagner6Raw.invert = function (x, y) {\n        return [x / sqrt(1 - 3 * y * y / (pi * pi)), y];\n    };\n    var wagner6 = function () {\n        return d3Geo.geoProjection(wagner6Raw)\n            .scale(152.63);\n    };\n    function wagner7Raw(lambda, phi) {\n        var s = 0.90631 * sin(phi), c0 = sqrt(1 - s * s), c1 = sqrt(2 / (1 + c0 * cos(lambda /= 3)));\n        return [\n            2.66723 * c0 * c1 * sin(lambda),\n            1.24104 * s * c1\n        ];\n    }\n    wagner7Raw.invert = function (x, y) {\n        var t1 = x / 2.66723, t2 = y / 1.24104, p = sqrt(t1 * t1 + t2 * t2), c = 2 * asin(p / 2);\n        return [\n            3 * atan2(x * tan(c), 2.66723 * p),\n            p && asin(y * sin(c) / (1.24104 * 0.90631 * p))\n        ];\n    };\n    var wagner7 = function () {\n        return d3Geo.geoProjection(wagner7Raw)\n            .scale(172.632);\n    };\n    function wiechelRaw(lambda, phi) {\n        var cosPhi = cos(phi), sinPhi = cos(lambda) * cosPhi, sin1_Phi = 1 - sinPhi, cosLambda = cos(lambda = atan2(sin(lambda) * cosPhi, -sin(phi))), sinLambda = sin(lambda);\n        cosPhi = sqrt(1 - sinPhi * sinPhi);\n        return [\n            sinLambda * cosPhi - cosLambda * sin1_Phi,\n            -cosLambda * cosPhi - sinLambda * sin1_Phi\n        ];\n    }\n    wiechelRaw.invert = function (x, y) {\n        var w = (x * x + y * y) / -2, k = sqrt(-w * (2 + w)), b = y * w + x * k, a = x * w - y * k, D = sqrt(a * a + b * b);\n        return [\n            atan2(k * b, D * (1 + w)),\n            D ? -asin(k * a / D) : 0\n        ];\n    };\n    var wiechel = function () {\n        return d3Geo.geoProjection(wiechelRaw)\n            .rotate([0, -90, 45])\n            .scale(124.75)\n            .clipAngle(180 - 1e-3);\n    };\n    function winkel3Raw(lambda, phi) {\n        var coordinates = aitoffRaw(lambda, phi);\n        return [\n            (coordinates[0] + lambda / halfPi) / 2,\n            (coordinates[1] + phi) / 2\n        ];\n    }\n    winkel3Raw.invert = function (x, y) {\n        var lambda = x, phi = y, i = 25;\n        do {\n            var cosphi = cos(phi), sinphi = sin(phi), sin_2phi = sin(2 * phi), sin2phi = sinphi * sinphi, cos2phi = cosphi * cosphi, sinlambda = sin(lambda), coslambda_2 = cos(lambda / 2), sinlambda_2 = sin(lambda / 2), sin2lambda_2 = sinlambda_2 * sinlambda_2, C = 1 - cos2phi * coslambda_2 * coslambda_2, E = C ? acos(cosphi * coslambda_2) * sqrt(F = 1 / C) : F = 0, F, fx = 0.5 * (2 * E * cosphi * sinlambda_2 + lambda / halfPi) - x, fy = 0.5 * (E * sinphi + phi) - y, dxdlambda = 0.5 * F * (cos2phi * sin2lambda_2 + E * cosphi * coslambda_2 * sin2phi) + 0.5 / halfPi, dxdphi = F * (sinlambda * sin_2phi / 4 - E * sinphi * sinlambda_2), dydlambda = 0.125 * F * (sin_2phi * sinlambda_2 - E * sinphi * cos2phi * sinlambda), dydphi = 0.5 * F * (sin2phi * coslambda_2 + E * sin2lambda_2 * cosphi) + 0.5, denominator = dxdphi * dydlambda - dydphi * dxdlambda, dlambda = (fy * dxdphi - fx * dydphi) / denominator, dphi = (fx * dydlambda - fy * dxdlambda) / denominator;\n            lambda -= dlambda, phi -= dphi;\n        } while ((abs(dlambda) > epsilon || abs(dphi) > epsilon) && --i > 0);\n        return [lambda, phi];\n    };\n    var winkel3 = function () {\n        return d3Geo.geoProjection(winkel3Raw)\n            .scale(158.837);\n    };\n    exports.geoAiry = airy;\n    exports.geoAiryRaw = airyRaw;\n    exports.geoAitoff = aitoff;\n    exports.geoAitoffRaw = aitoffRaw;\n    exports.geoArmadillo = armadillo;\n    exports.geoArmadilloRaw = armadilloRaw;\n    exports.geoAugust = august;\n    exports.geoAugustRaw = augustRaw;\n    exports.geoBaker = baker;\n    exports.geoBakerRaw = bakerRaw;\n    exports.geoBerghaus = berghaus;\n    exports.geoBerghausRaw = berghausRaw;\n    exports.geoBoggs = boggs;\n    exports.geoBoggsRaw = boggsRaw;\n    exports.geoBonne = bonne;\n    exports.geoBonneRaw = bonneRaw;\n    exports.geoBottomley = bottomley;\n    exports.geoBottomleyRaw = bottomleyRaw;\n    exports.geoBromley = bromley;\n    exports.geoBromleyRaw = bromleyRaw;\n    exports.geoChamberlin = chamberlin;\n    exports.geoChamberlinRaw = chamberlinRaw;\n    exports.geoChamberlinAfrica = chamberlinAfrica;\n    exports.geoCollignon = collignon;\n    exports.geoCollignonRaw = collignonRaw;\n    exports.geoCraig = craig;\n    exports.geoCraigRaw = craigRaw;\n    exports.geoCraster = craster;\n    exports.geoCrasterRaw = crasterRaw;\n    exports.geoCylindricalEqualArea = cylindricalEqualArea;\n    exports.geoCylindricalEqualAreaRaw = cylindricalEqualAreaRaw;\n    exports.geoCylindricalStereographic = cylindricalStereographic;\n    exports.geoCylindricalStereographicRaw = cylindricalStereographicRaw;\n    exports.geoEckert1 = eckert1;\n    exports.geoEckert1Raw = eckert1Raw;\n    exports.geoEckert2 = eckert2;\n    exports.geoEckert2Raw = eckert2Raw;\n    exports.geoEckert3 = eckert3;\n    exports.geoEckert3Raw = eckert3Raw;\n    exports.geoEckert4 = eckert4;\n    exports.geoEckert4Raw = eckert4Raw;\n    exports.geoEckert5 = eckert5;\n    exports.geoEckert5Raw = eckert5Raw;\n    exports.geoEckert6 = eckert6;\n    exports.geoEckert6Raw = eckert6Raw;\n    exports.geoEisenlohr = eisenlohr;\n    exports.geoEisenlohrRaw = eisenlohrRaw;\n    exports.geoFahey = fahey;\n    exports.geoFaheyRaw = faheyRaw;\n    exports.geoFoucaut = foucaut;\n    exports.geoFoucautRaw = foucautRaw;\n    exports.geoGilbert = gilbert;\n    exports.geoGingery = gingery;\n    exports.geoGingeryRaw = gingeryRaw;\n    exports.geoGinzburg4 = ginzburg4;\n    exports.geoGinzburg4Raw = ginzburg4Raw;\n    exports.geoGinzburg5 = ginzburg5;\n    exports.geoGinzburg5Raw = ginzburg5Raw;\n    exports.geoGinzburg6 = ginzburg6;\n    exports.geoGinzburg6Raw = ginzburg6Raw;\n    exports.geoGinzburg8 = ginzburg8;\n    exports.geoGinzburg8Raw = ginzburg8Raw;\n    exports.geoGinzburg9 = ginzburg9;\n    exports.geoGinzburg9Raw = ginzburg9Raw;\n    exports.geoGringorten = gringorten;\n    exports.geoGringortenRaw = gringortenRaw;\n    exports.geoGuyou = guyou;\n    exports.geoGuyouRaw = guyouRaw;\n    exports.geoHammer = hammer;\n    exports.geoHammerRaw = hammerRaw;\n    exports.geoHammerRetroazimuthal = hammerRetroazimuthal;\n    exports.geoHammerRetroazimuthalRaw = hammerRetroazimuthalRaw;\n    exports.geoHealpix = healpix;\n    exports.geoHealpixRaw = healpixRaw;\n    exports.geoHill = hill;\n    exports.geoHillRaw = hillRaw;\n    exports.geoHomolosine = homolosine;\n    exports.geoHomolosineRaw = homolosineRaw;\n    exports.geoInterrupt = interrupt;\n    exports.geoInterruptedBoggs = boggs$1;\n    exports.geoInterruptedHomolosine = homolosine$1;\n    exports.geoInterruptedMollweide = mollweide$1;\n    exports.geoInterruptedMollweideHemispheres = mollweideHemispheres;\n    exports.geoInterruptedSinuMollweide = sinuMollweide$1;\n    exports.geoInterruptedSinusoidal = sinusoidal$1;\n    exports.geoKavrayskiy7 = kavrayskiy7;\n    exports.geoKavrayskiy7Raw = kavrayskiy7Raw;\n    exports.geoLagrange = lagrange;\n    exports.geoLagrangeRaw = lagrangeRaw;\n    exports.geoLarrivee = larrivee;\n    exports.geoLarriveeRaw = larriveeRaw;\n    exports.geoLaskowski = laskowski;\n    exports.geoLaskowskiRaw = laskowskiRaw;\n    exports.geoLittrow = littrow;\n    exports.geoLittrowRaw = littrowRaw;\n    exports.geoLoximuthal = loximuthal;\n    exports.geoLoximuthalRaw = loximuthalRaw;\n    exports.geoMiller = miller;\n    exports.geoMillerRaw = millerRaw;\n    exports.geoModifiedStereographic = modifiedStereographic;\n    exports.geoModifiedStereographicRaw = modifiedStereographicRaw;\n    exports.geoModifiedStereographicAlaska = modifiedStereographicAlaska;\n    exports.geoModifiedStereographicGs48 = modifiedStereographicGs48;\n    exports.geoModifiedStereographicGs50 = modifiedStereographicGs50;\n    exports.geoModifiedStereographicMiller = modifiedStereographicMiller;\n    exports.geoModifiedStereographicLee = modifiedStereographicLee;\n    exports.geoMollweide = mollweide;\n    exports.geoMollweideRaw = mollweideRaw;\n    exports.geoMtFlatPolarParabolic = mtFlatPolarParabolic;\n    exports.geoMtFlatPolarParabolicRaw = mtFlatPolarParabolicRaw;\n    exports.geoMtFlatPolarQuartic = mtFlatPolarQuartic;\n    exports.geoMtFlatPolarQuarticRaw = mtFlatPolarQuarticRaw;\n    exports.geoMtFlatPolarSinusoidal = mtFlatPolarSinusoidal;\n    exports.geoMtFlatPolarSinusoidalRaw = mtFlatPolarSinusoidalRaw;\n    exports.geoNaturalEarth = naturalEarth;\n    exports.geoNaturalEarthRaw = naturalEarthRaw;\n    exports.geoNaturalEarth2 = naturalEarth2;\n    exports.geoNaturalEarth2Raw = naturalEarth2Raw;\n    exports.geoNellHammer = nellHammer;\n    exports.geoNellHammerRaw = nellHammerRaw;\n    exports.geoPatterson = patterson;\n    exports.geoPattersonRaw = pattersonRaw;\n    exports.geoPolyconic = polyconic;\n    exports.geoPolyconicRaw = polyconicRaw;\n    exports.geoPolyhedral = polyhedral;\n    exports.geoPolyhedralButterfly = butterfly;\n    exports.geoPolyhedralCollignon = collignon$1;\n    exports.geoPolyhedralWaterman = waterman;\n    exports.geoProject = index;\n    exports.geoGringortenQuincuncial = gringorten$1;\n    exports.geoPeirceQuincuncial = peirce;\n    exports.geoPierceQuincuncial = peirce;\n    exports.geoQuantize = quantize;\n    exports.geoQuincuncial = quincuncial;\n    exports.geoRectangularPolyconic = rectangularPolyconic;\n    exports.geoRectangularPolyconicRaw = rectangularPolyconicRaw;\n    exports.geoRobinson = robinson;\n    exports.geoRobinsonRaw = robinsonRaw;\n    exports.geoSatellite = satellite;\n    exports.geoSatelliteRaw = satelliteRaw;\n    exports.geoSinuMollweide = sinuMollweide;\n    exports.geoSinuMollweideRaw = sinuMollweideRaw;\n    exports.geoSinusoidal = sinusoidal;\n    exports.geoSinusoidalRaw = sinusoidalRaw;\n    exports.geoStitch = stitch;\n    exports.geoTimes = times;\n    exports.geoTimesRaw = timesRaw;\n    exports.geoTwoPointAzimuthal = twoPointAzimuthal;\n    exports.geoTwoPointAzimuthalRaw = twoPointAzimuthalRaw;\n    exports.geoTwoPointAzimuthalUsa = twoPointAzimuthalUsa;\n    exports.geoTwoPointEquidistant = twoPointEquidistant;\n    exports.geoTwoPointEquidistantRaw = twoPointEquidistantRaw;\n    exports.geoTwoPointEquidistantUsa = twoPointEquidistantUsa;\n    exports.geoVanDerGrinten = vanDerGrinten;\n    exports.geoVanDerGrintenRaw = vanDerGrintenRaw;\n    exports.geoVanDerGrinten2 = vanDerGrinten2;\n    exports.geoVanDerGrinten2Raw = vanDerGrinten2Raw;\n    exports.geoVanDerGrinten3 = vanDerGrinten3;\n    exports.geoVanDerGrinten3Raw = vanDerGrinten3Raw;\n    exports.geoVanDerGrinten4 = vanDerGrinten4;\n    exports.geoVanDerGrinten4Raw = vanDerGrinten4Raw;\n    exports.geoWagner4 = wagner4;\n    exports.geoWagner4Raw = wagner4Raw;\n    exports.geoWagner6 = wagner6;\n    exports.geoWagner6Raw = wagner6Raw;\n    exports.geoWagner7 = wagner7;\n    exports.geoWagner7Raw = wagner7Raw;\n    exports.geoWiechel = wiechel;\n    exports.geoWiechelRaw = wiechelRaw;\n    exports.geoWinkel3 = winkel3;\n    exports.geoWinkel3Raw = winkel3Raw;\n    Object.defineProperty(exports, '__esModule', { value: true });\n})));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-geo@1.11.9@d3-geo/dist/d3-geo.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_d3-geo@1.11.9@d3-geo/dist/d3-geo.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-geo/ v1.11.9 Copyright 2019 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! d3-array */ \"./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js\")) :\n        undefined;\n}(this, function (exports, d3Array) {\n    'use strict';\n    // Adds floating point numbers with twice the normal precision.\n    // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n    // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n    // 305–363 (1997).\n    // Code adapted from GeographicLib by Charles F. F. Karney,\n    // http://geographiclib.sourceforge.net/\n    function adder() {\n        return new Adder;\n    }\n    function Adder() {\n        this.reset();\n    }\n    Adder.prototype = {\n        constructor: Adder,\n        reset: function () {\n            this.s = // rounded value\n                this.t = 0; // exact error\n        },\n        add: function (y) {\n            add(temp, y, this.t);\n            add(this, temp.s, this.s);\n            if (this.s)\n                this.t += temp.t;\n            else\n                this.s = temp.t;\n        },\n        valueOf: function () {\n            return this.s;\n        }\n    };\n    var temp = new Adder;\n    function add(adder, a, b) {\n        var x = adder.s = a + b, bv = x - a, av = x - bv;\n        adder.t = (a - av) + (b - bv);\n    }\n    var epsilon = 1e-6;\n    var epsilon2 = 1e-12;\n    var pi = Math.PI;\n    var halfPi = pi / 2;\n    var quarterPi = pi / 4;\n    var tau = pi * 2;\n    var degrees = 180 / pi;\n    var radians = pi / 180;\n    var abs = Math.abs;\n    var atan = Math.atan;\n    var atan2 = Math.atan2;\n    var cos = Math.cos;\n    var ceil = Math.ceil;\n    var exp = Math.exp;\n    var log = Math.log;\n    var pow = Math.pow;\n    var sin = Math.sin;\n    var sign = Math.sign || function (x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\n    var sqrt = Math.sqrt;\n    var tan = Math.tan;\n    function acos(x) {\n        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n    }\n    function asin(x) {\n        return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n    }\n    function haversin(x) {\n        return (x = sin(x / 2)) * x;\n    }\n    function noop() { }\n    function streamGeometry(geometry, stream) {\n        if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n            streamGeometryType[geometry.type](geometry, stream);\n        }\n    }\n    var streamObjectType = {\n        Feature: function (object, stream) {\n            streamGeometry(object.geometry, stream);\n        },\n        FeatureCollection: function (object, stream) {\n            var features = object.features, i = -1, n = features.length;\n            while (++i < n)\n                streamGeometry(features[i].geometry, stream);\n        }\n    };\n    var streamGeometryType = {\n        Sphere: function (object, stream) {\n            stream.sphere();\n        },\n        Point: function (object, stream) {\n            object = object.coordinates;\n            stream.point(object[0], object[1], object[2]);\n        },\n        MultiPoint: function (object, stream) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                object = coordinates[i], stream.point(object[0], object[1], object[2]);\n        },\n        LineString: function (object, stream) {\n            streamLine(object.coordinates, stream, 0);\n        },\n        MultiLineString: function (object, stream) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                streamLine(coordinates[i], stream, 0);\n        },\n        Polygon: function (object, stream) {\n            streamPolygon(object.coordinates, stream);\n        },\n        MultiPolygon: function (object, stream) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                streamPolygon(coordinates[i], stream);\n        },\n        GeometryCollection: function (object, stream) {\n            var geometries = object.geometries, i = -1, n = geometries.length;\n            while (++i < n)\n                streamGeometry(geometries[i], stream);\n        }\n    };\n    function streamLine(coordinates, stream, closed) {\n        var i = -1, n = coordinates.length - closed, coordinate;\n        stream.lineStart();\n        while (++i < n)\n            coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n        stream.lineEnd();\n    }\n    function streamPolygon(coordinates, stream) {\n        var i = -1, n = coordinates.length;\n        stream.polygonStart();\n        while (++i < n)\n            streamLine(coordinates[i], stream, 1);\n        stream.polygonEnd();\n    }\n    function geoStream(object, stream) {\n        if (object && streamObjectType.hasOwnProperty(object.type)) {\n            streamObjectType[object.type](object, stream);\n        }\n        else {\n            streamGeometry(object, stream);\n        }\n    }\n    var areaRingSum = adder();\n    var areaSum = adder(), lambda00, phi00, lambda0, cosPhi0, sinPhi0;\n    var areaStream = {\n        point: noop,\n        lineStart: noop,\n        lineEnd: noop,\n        polygonStart: function () {\n            areaRingSum.reset();\n            areaStream.lineStart = areaRingStart;\n            areaStream.lineEnd = areaRingEnd;\n        },\n        polygonEnd: function () {\n            var areaRing = +areaRingSum;\n            areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);\n            this.lineStart = this.lineEnd = this.point = noop;\n        },\n        sphere: function () {\n            areaSum.add(tau);\n        }\n    };\n    function areaRingStart() {\n        areaStream.point = areaPointFirst;\n    }\n    function areaRingEnd() {\n        areaPoint(lambda00, phi00);\n    }\n    function areaPointFirst(lambda, phi) {\n        areaStream.point = areaPoint;\n        lambda00 = lambda, phi00 = phi;\n        lambda *= radians, phi *= radians;\n        lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);\n    }\n    function areaPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        phi = phi / 2 + quarterPi; // half the angular distance from south pole\n        // Spherical excess E for a spherical triangle with vertices: south pole,\n        // previous point, current point.  Uses a formula derived from Cagnoli’s\n        // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n        var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi), sinPhi = sin(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos(adLambda), v = k * sdLambda * sin(adLambda);\n        areaRingSum.add(atan2(v, u));\n        // Advance the previous points.\n        lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n    }\n    function area(object) {\n        areaSum.reset();\n        geoStream(object, areaStream);\n        return areaSum * 2;\n    }\n    function spherical(cartesian) {\n        return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n    }\n    function cartesian(spherical) {\n        var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);\n        return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n    }\n    function cartesianDot(a, b) {\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    }\n    function cartesianCross(a, b) {\n        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n    }\n    // TODO return a\n    function cartesianAddInPlace(a, b) {\n        a[0] += b[0], a[1] += b[1], a[2] += b[2];\n    }\n    function cartesianScale(vector, k) {\n        return [vector[0] * k, vector[1] * k, vector[2] * k];\n    }\n    // TODO return d\n    function cartesianNormalizeInPlace(d) {\n        var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n        d[0] /= l, d[1] /= l, d[2] /= l;\n    }\n    var lambda0$1, phi0, lambda1, phi1, // bounds\n    lambda2, // previous lambda-coordinate\n    lambda00$1, phi00$1, // first point\n    p0, // previous 3D point\n    deltaSum = adder(), ranges, range;\n    var boundsStream = {\n        point: boundsPoint,\n        lineStart: boundsLineStart,\n        lineEnd: boundsLineEnd,\n        polygonStart: function () {\n            boundsStream.point = boundsRingPoint;\n            boundsStream.lineStart = boundsRingStart;\n            boundsStream.lineEnd = boundsRingEnd;\n            deltaSum.reset();\n            areaStream.polygonStart();\n        },\n        polygonEnd: function () {\n            areaStream.polygonEnd();\n            boundsStream.point = boundsPoint;\n            boundsStream.lineStart = boundsLineStart;\n            boundsStream.lineEnd = boundsLineEnd;\n            if (areaRingSum < 0)\n                lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n            else if (deltaSum > epsilon)\n                phi1 = 90;\n            else if (deltaSum < -epsilon)\n                phi0 = -90;\n            range[0] = lambda0$1, range[1] = lambda1;\n        },\n        sphere: function () {\n            lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n        }\n    };\n    function boundsPoint(lambda, phi) {\n        ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);\n        if (phi < phi0)\n            phi0 = phi;\n        if (phi > phi1)\n            phi1 = phi;\n    }\n    function linePoint(lambda, phi) {\n        var p = cartesian([lambda * radians, phi * radians]);\n        if (p0) {\n            var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);\n            cartesianNormalizeInPlace(inflection);\n            inflection = spherical(inflection);\n            var delta = lambda - lambda2, sign = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign, phii, antimeridian = abs(delta) > 180;\n            if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n                phii = inflection[1] * degrees;\n                if (phii > phi1)\n                    phi1 = phii;\n            }\n            else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n                phii = -inflection[1] * degrees;\n                if (phii < phi0)\n                    phi0 = phii;\n            }\n            else {\n                if (phi < phi0)\n                    phi0 = phi;\n                if (phi > phi1)\n                    phi1 = phi;\n            }\n            if (antimeridian) {\n                if (lambda < lambda2) {\n                    if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))\n                        lambda1 = lambda;\n                }\n                else {\n                    if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))\n                        lambda0$1 = lambda;\n                }\n            }\n            else {\n                if (lambda1 >= lambda0$1) {\n                    if (lambda < lambda0$1)\n                        lambda0$1 = lambda;\n                    if (lambda > lambda1)\n                        lambda1 = lambda;\n                }\n                else {\n                    if (lambda > lambda2) {\n                        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))\n                            lambda1 = lambda;\n                    }\n                    else {\n                        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))\n                            lambda0$1 = lambda;\n                    }\n                }\n            }\n        }\n        else {\n            ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);\n        }\n        if (phi < phi0)\n            phi0 = phi;\n        if (phi > phi1)\n            phi1 = phi;\n        p0 = p, lambda2 = lambda;\n    }\n    function boundsLineStart() {\n        boundsStream.point = linePoint;\n    }\n    function boundsLineEnd() {\n        range[0] = lambda0$1, range[1] = lambda1;\n        boundsStream.point = boundsPoint;\n        p0 = null;\n    }\n    function boundsRingPoint(lambda, phi) {\n        if (p0) {\n            var delta = lambda - lambda2;\n            deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n        }\n        else {\n            lambda00$1 = lambda, phi00$1 = phi;\n        }\n        areaStream.point(lambda, phi);\n        linePoint(lambda, phi);\n    }\n    function boundsRingStart() {\n        areaStream.lineStart();\n    }\n    function boundsRingEnd() {\n        boundsRingPoint(lambda00$1, phi00$1);\n        areaStream.lineEnd();\n        if (abs(deltaSum) > epsilon)\n            lambda0$1 = -(lambda1 = 180);\n        range[0] = lambda0$1, range[1] = lambda1;\n        p0 = null;\n    }\n    // Finds the left-right distance between two longitudes.\n    // This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n    // the distance between ±180° to be 360°.\n    function angle(lambda0, lambda1) {\n        return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n    }\n    function rangeCompare(a, b) {\n        return a[0] - b[0];\n    }\n    function rangeContains(range, x) {\n        return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n    }\n    function bounds(feature) {\n        var i, n, a, b, merged, deltaMax, delta;\n        phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);\n        ranges = [];\n        geoStream(feature, boundsStream);\n        // First, sort ranges by their minimum longitudes.\n        if (n = ranges.length) {\n            ranges.sort(rangeCompare);\n            // Then, merge any ranges that overlap.\n            for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n                b = ranges[i];\n                if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n                    if (angle(a[0], b[1]) > angle(a[0], a[1]))\n                        a[1] = b[1];\n                    if (angle(b[0], a[1]) > angle(a[0], a[1]))\n                        a[0] = b[0];\n                }\n                else {\n                    merged.push(a = b);\n                }\n            }\n            // Finally, find the largest gap between the merged ranges.\n            // The final bounding box will be the inverse of this gap.\n            for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n                b = merged[i];\n                if ((delta = angle(a[1], b[0])) > deltaMax)\n                    deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];\n            }\n        }\n        ranges = range = null;\n        return lambda0$1 === Infinity || phi0 === Infinity\n            ? [[NaN, NaN], [NaN, NaN]]\n            : [[lambda0$1, phi0], [lambda1, phi1]];\n    }\n    var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00$2, phi00$2, // first point\n    x0, y0, z0; // previous point\n    var centroidStream = {\n        sphere: noop,\n        point: centroidPoint,\n        lineStart: centroidLineStart,\n        lineEnd: centroidLineEnd,\n        polygonStart: function () {\n            centroidStream.lineStart = centroidRingStart;\n            centroidStream.lineEnd = centroidRingEnd;\n        },\n        polygonEnd: function () {\n            centroidStream.lineStart = centroidLineStart;\n            centroidStream.lineEnd = centroidLineEnd;\n        }\n    };\n    // Arithmetic mean of Cartesian vectors.\n    function centroidPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi);\n        centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n    }\n    function centroidPointCartesian(x, y, z) {\n        ++W0;\n        X0 += (x - X0) / W0;\n        Y0 += (y - Y0) / W0;\n        Z0 += (z - Z0) / W0;\n    }\n    function centroidLineStart() {\n        centroidStream.point = centroidLinePointFirst;\n    }\n    function centroidLinePointFirst(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi);\n        x0 = cosPhi * cos(lambda);\n        y0 = cosPhi * sin(lambda);\n        z0 = sin(phi);\n        centroidStream.point = centroidLinePoint;\n        centroidPointCartesian(x0, y0, z0);\n    }\n    function centroidLinePoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n        W1 += w;\n        X1 += w * (x0 + (x0 = x));\n        Y1 += w * (y0 + (y0 = y));\n        Z1 += w * (z0 + (z0 = z));\n        centroidPointCartesian(x0, y0, z0);\n    }\n    function centroidLineEnd() {\n        centroidStream.point = centroidPoint;\n    }\n    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n    // J. Applied Mechanics 42, 239 (1975).\n    function centroidRingStart() {\n        centroidStream.point = centroidRingPointFirst;\n    }\n    function centroidRingEnd() {\n        centroidRingPoint(lambda00$2, phi00$2);\n        centroidStream.point = centroidPoint;\n    }\n    function centroidRingPointFirst(lambda, phi) {\n        lambda00$2 = lambda, phi00$2 = phi;\n        lambda *= radians, phi *= radians;\n        centroidStream.point = centroidRingPoint;\n        var cosPhi = cos(phi);\n        x0 = cosPhi * cos(lambda);\n        y0 = cosPhi * sin(lambda);\n        z0 = sin(phi);\n        centroidPointCartesian(x0, y0, z0);\n    }\n    function centroidRingPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = sqrt(cx * cx + cy * cy + cz * cz), w = asin(m), // line weight = angle\n        v = m && -w / m; // area weight multiplier\n        X2 += v * cx;\n        Y2 += v * cy;\n        Z2 += v * cz;\n        W1 += w;\n        X1 += w * (x0 + (x0 = x));\n        Y1 += w * (y0 + (y0 = y));\n        Z1 += w * (z0 + (z0 = z));\n        centroidPointCartesian(x0, y0, z0);\n    }\n    function centroid(object) {\n        W0 = W1 =\n            X0 = Y0 = Z0 =\n                X1 = Y1 = Z1 =\n                    X2 = Y2 = Z2 = 0;\n        geoStream(object, centroidStream);\n        var x = X2, y = Y2, z = Z2, m = x * x + y * y + z * z;\n        // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n        if (m < epsilon2) {\n            x = X1, y = Y1, z = Z1;\n            // If the feature has zero length, fall back to arithmetic mean of point vectors.\n            if (W1 < epsilon)\n                x = X0, y = Y0, z = Z0;\n            m = x * x + y * y + z * z;\n            // If the feature still has an undefined ccentroid, then return.\n            if (m < epsilon2)\n                return [NaN, NaN];\n        }\n        return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];\n    }\n    function constant(x) {\n        return function () {\n            return x;\n        };\n    }\n    function compose(a, b) {\n        function compose(x, y) {\n            return x = a(x, y), b(x[0], x[1]);\n        }\n        if (a.invert && b.invert)\n            compose.invert = function (x, y) {\n                return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n            };\n        return compose;\n    }\n    function rotationIdentity(lambda, phi) {\n        return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];\n    }\n    rotationIdentity.invert = rotationIdentity;\n    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n        return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n            : rotationLambda(deltaLambda))\n            : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n                : rotationIdentity);\n    }\n    function forwardRotationLambda(deltaLambda) {\n        return function (lambda, phi) {\n            return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n        };\n    }\n    function rotationLambda(deltaLambda) {\n        var rotation = forwardRotationLambda(deltaLambda);\n        rotation.invert = forwardRotationLambda(-deltaLambda);\n        return rotation;\n    }\n    function rotationPhiGamma(deltaPhi, deltaGamma) {\n        var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);\n        function rotation(lambda, phi) {\n            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;\n            return [\n                atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n                asin(k * cosDeltaGamma + y * sinDeltaGamma)\n            ];\n        }\n        rotation.invert = function (lambda, phi) {\n            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;\n            return [\n                atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n                asin(k * cosDeltaPhi - x * sinDeltaPhi)\n            ];\n        };\n        return rotation;\n    }\n    function rotation(rotate) {\n        rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n        function forward(coordinates) {\n            coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n            return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n        }\n        forward.invert = function (coordinates) {\n            coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n            return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n        };\n        return forward;\n    }\n    // Generates a circle centered at [0°, 0°], with a given radius and precision.\n    function circleStream(stream, radius, delta, direction, t0, t1) {\n        if (!delta)\n            return;\n        var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;\n        if (t0 == null) {\n            t0 = radius + direction * tau;\n            t1 = radius - step / 2;\n        }\n        else {\n            t0 = circleRadius(cosRadius, t0);\n            t1 = circleRadius(cosRadius, t1);\n            if (direction > 0 ? t0 < t1 : t0 > t1)\n                t0 += direction * tau;\n        }\n        for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n            point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n            stream.point(point[0], point[1]);\n        }\n    }\n    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\n    function circleRadius(cosRadius, point) {\n        point = cartesian(point), point[0] -= cosRadius;\n        cartesianNormalizeInPlace(point);\n        var radius = acos(-point[1]);\n        return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n    }\n    function circle() {\n        var center = constant([0, 0]), radius = constant(90), precision = constant(6), ring, rotate, stream = { point: point };\n        function point(x, y) {\n            ring.push(x = rotate(x, y));\n            x[0] *= degrees, x[1] *= degrees;\n        }\n        function circle() {\n            var c = center.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;\n            ring = [];\n            rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n            circleStream(stream, r, p, 1);\n            c = { type: \"Polygon\", coordinates: [ring] };\n            ring = rotate = null;\n            return c;\n        }\n        circle.center = function (_) {\n            return arguments.length ? (center = typeof _ === \"function\" ? _ : constant([+_[0], +_[1]]), circle) : center;\n        };\n        circle.radius = function (_) {\n            return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), circle) : radius;\n        };\n        circle.precision = function (_) {\n            return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant(+_), circle) : precision;\n        };\n        return circle;\n    }\n    function clipBuffer() {\n        var lines = [], line;\n        return {\n            point: function (x, y) {\n                line.push([x, y]);\n            },\n            lineStart: function () {\n                lines.push(line = []);\n            },\n            lineEnd: noop,\n            rejoin: function () {\n                if (lines.length > 1)\n                    lines.push(lines.pop().concat(lines.shift()));\n            },\n            result: function () {\n                var result = lines;\n                lines = [];\n                line = null;\n                return result;\n            }\n        };\n    }\n    function pointEqual(a, b) {\n        return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n    }\n    function Intersection(point, points, other, entry) {\n        this.x = point;\n        this.z = points;\n        this.o = other; // another intersection\n        this.e = entry; // is an entry?\n        this.v = false; // visited\n        this.n = this.p = null; // next & previous\n    }\n    // A generalized polygon clipping algorithm: given a polygon that has been cut\n    // into its visible line segments, and rejoins the segments by interpolating\n    // along the clip edge.\n    function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {\n        var subject = [], clip = [], i, n;\n        segments.forEach(function (segment) {\n            if ((n = segment.length - 1) <= 0)\n                return;\n            var n, p0 = segment[0], p1 = segment[n], x;\n            // If the first and last points of a segment are coincident, then treat as a\n            // closed ring. TODO if all rings are closed, then the winding order of the\n            // exterior ring should be checked.\n            if (pointEqual(p0, p1)) {\n                stream.lineStart();\n                for (i = 0; i < n; ++i)\n                    stream.point((p0 = segment[i])[0], p0[1]);\n                stream.lineEnd();\n                return;\n            }\n            subject.push(x = new Intersection(p0, segment, null, true));\n            clip.push(x.o = new Intersection(p0, null, x, false));\n            subject.push(x = new Intersection(p1, segment, null, false));\n            clip.push(x.o = new Intersection(p1, null, x, true));\n        });\n        if (!subject.length)\n            return;\n        clip.sort(compareIntersection);\n        link(subject);\n        link(clip);\n        for (i = 0, n = clip.length; i < n; ++i) {\n            clip[i].e = startInside = !startInside;\n        }\n        var start = subject[0], points, point;\n        while (1) {\n            // Find first unvisited intersection.\n            var current = start, isSubject = true;\n            while (current.v)\n                if ((current = current.n) === start)\n                    return;\n            points = current.z;\n            stream.lineStart();\n            do {\n                current.v = current.o.v = true;\n                if (current.e) {\n                    if (isSubject) {\n                        for (i = 0, n = points.length; i < n; ++i)\n                            stream.point((point = points[i])[0], point[1]);\n                    }\n                    else {\n                        interpolate(current.x, current.n.x, 1, stream);\n                    }\n                    current = current.n;\n                }\n                else {\n                    if (isSubject) {\n                        points = current.p.z;\n                        for (i = points.length - 1; i >= 0; --i)\n                            stream.point((point = points[i])[0], point[1]);\n                    }\n                    else {\n                        interpolate(current.x, current.p.x, -1, stream);\n                    }\n                    current = current.p;\n                }\n                current = current.o;\n                points = current.z;\n                isSubject = !isSubject;\n            } while (!current.v);\n            stream.lineEnd();\n        }\n    }\n    function link(array) {\n        if (!(n = array.length))\n            return;\n        var n, i = 0, a = array[0], b;\n        while (++i < n) {\n            a.n = b = array[i];\n            b.p = a;\n            a = b;\n        }\n        a.n = b = array[0];\n        b.p = a;\n    }\n    var sum = adder();\n    function longitude(point) {\n        if (abs(point[0]) <= pi)\n            return point[0];\n        else\n            return sign(point[0]) * ((abs(point[0]) + pi) % tau - pi);\n    }\n    function polygonContains(polygon, point) {\n        var lambda = longitude(point), phi = point[1], sinPhi = sin(phi), normal = [sin(lambda), -cos(lambda), 0], angle = 0, winding = 0;\n        sum.reset();\n        if (sinPhi === 1)\n            phi = halfPi + epsilon;\n        else if (sinPhi === -1)\n            phi = -halfPi - epsilon;\n        for (var i = 0, n = polygon.length; i < n; ++i) {\n            if (!(m = (ring = polygon[i]).length))\n                continue;\n            var ring, m, point0 = ring[m - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);\n            for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n                var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign = delta >= 0 ? 1 : -1, absDelta = sign * delta, antimeridian = absDelta > pi, k = sinPhi0 * sinPhi1;\n                sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n                angle += antimeridian ? delta + sign * tau : delta;\n                // Are the longitudes either side of the point’s meridian (lambda),\n                // and are the latitudes smaller than the parallel (phi)?\n                if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n                    var arc = cartesianCross(cartesian(point0), cartesian(point1));\n                    cartesianNormalizeInPlace(arc);\n                    var intersection = cartesianCross(normal, arc);\n                    cartesianNormalizeInPlace(intersection);\n                    var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n                    if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n                        winding += antimeridian ^ delta >= 0 ? 1 : -1;\n                    }\n                }\n            }\n        }\n        // First, determine whether the South pole is inside or outside:\n        //\n        // It is inside if:\n        // * the polygon winds around it in a clockwise direction.\n        // * the polygon does not (cumulatively) wind around it, but has a negative\n        //   (counter-clockwise) area.\n        //\n        // Second, count the (signed) number of times a segment crosses a lambda\n        // from the point to the South pole.  If it is zero, then the point is the\n        // same side as the South pole.\n        return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);\n    }\n    function clip(pointVisible, clipLine, interpolate, start) {\n        return function (sink) {\n            var line = clipLine(sink), ringBuffer = clipBuffer(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;\n            var clip = {\n                point: point,\n                lineStart: lineStart,\n                lineEnd: lineEnd,\n                polygonStart: function () {\n                    clip.point = pointRing;\n                    clip.lineStart = ringStart;\n                    clip.lineEnd = ringEnd;\n                    segments = [];\n                    polygon = [];\n                },\n                polygonEnd: function () {\n                    clip.point = point;\n                    clip.lineStart = lineStart;\n                    clip.lineEnd = lineEnd;\n                    segments = d3Array.merge(segments);\n                    var startInside = polygonContains(polygon, start);\n                    if (segments.length) {\n                        if (!polygonStarted)\n                            sink.polygonStart(), polygonStarted = true;\n                        clipRejoin(segments, compareIntersection, startInside, interpolate, sink);\n                    }\n                    else if (startInside) {\n                        if (!polygonStarted)\n                            sink.polygonStart(), polygonStarted = true;\n                        sink.lineStart();\n                        interpolate(null, null, 1, sink);\n                        sink.lineEnd();\n                    }\n                    if (polygonStarted)\n                        sink.polygonEnd(), polygonStarted = false;\n                    segments = polygon = null;\n                },\n                sphere: function () {\n                    sink.polygonStart();\n                    sink.lineStart();\n                    interpolate(null, null, 1, sink);\n                    sink.lineEnd();\n                    sink.polygonEnd();\n                }\n            };\n            function point(lambda, phi) {\n                if (pointVisible(lambda, phi))\n                    sink.point(lambda, phi);\n            }\n            function pointLine(lambda, phi) {\n                line.point(lambda, phi);\n            }\n            function lineStart() {\n                clip.point = pointLine;\n                line.lineStart();\n            }\n            function lineEnd() {\n                clip.point = point;\n                line.lineEnd();\n            }\n            function pointRing(lambda, phi) {\n                ring.push([lambda, phi]);\n                ringSink.point(lambda, phi);\n            }\n            function ringStart() {\n                ringSink.lineStart();\n                ring = [];\n            }\n            function ringEnd() {\n                pointRing(ring[0][0], ring[0][1]);\n                ringSink.lineEnd();\n                var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point;\n                ring.pop();\n                polygon.push(ring);\n                ring = null;\n                if (!n)\n                    return;\n                // No intersections.\n                if (clean & 1) {\n                    segment = ringSegments[0];\n                    if ((m = segment.length - 1) > 0) {\n                        if (!polygonStarted)\n                            sink.polygonStart(), polygonStarted = true;\n                        sink.lineStart();\n                        for (i = 0; i < m; ++i)\n                            sink.point((point = segment[i])[0], point[1]);\n                        sink.lineEnd();\n                    }\n                    return;\n                }\n                // Rejoin connected segments.\n                // TODO reuse ringBuffer.rejoin()?\n                if (n > 1 && clean & 2)\n                    ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n                segments.push(ringSegments.filter(validSegment));\n            }\n            return clip;\n        };\n    }\n    function validSegment(segment) {\n        return segment.length > 1;\n    }\n    // Intersections are sorted along the clip edge. For both antimeridian cutting\n    // and circle clipping, the same comparison is used.\n    function compareIntersection(a, b) {\n        return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n            - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n    }\n    var clipAntimeridian = clip(function () { return true; }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);\n    // Takes a line and cuts into visible segments. Return values: 0 - there were\n    // intersections or the line was empty; 1 - no intersections; 2 - there were\n    // intersections, and the first and last segments should be rejoined.\n    function clipAntimeridianLine(stream) {\n        var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean; // no intersections\n        return {\n            lineStart: function () {\n                stream.lineStart();\n                clean = 1;\n            },\n            point: function (lambda1, phi1) {\n                var sign1 = lambda1 > 0 ? pi : -pi, delta = abs(lambda1 - lambda0);\n                if (abs(delta - pi) < epsilon) { // line crosses a pole\n                    stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n                    stream.point(sign0, phi0);\n                    stream.lineEnd();\n                    stream.lineStart();\n                    stream.point(sign1, phi0);\n                    stream.point(lambda1, phi0);\n                    clean = 0;\n                }\n                else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian\n                    if (abs(lambda0 - sign0) < epsilon)\n                        lambda0 -= sign0 * epsilon; // handle degeneracies\n                    if (abs(lambda1 - sign1) < epsilon)\n                        lambda1 -= sign1 * epsilon;\n                    phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n                    stream.point(sign0, phi0);\n                    stream.lineEnd();\n                    stream.lineStart();\n                    stream.point(sign1, phi0);\n                    clean = 0;\n                }\n                stream.point(lambda0 = lambda1, phi0 = phi1);\n                sign0 = sign1;\n            },\n            lineEnd: function () {\n                stream.lineEnd();\n                lambda0 = phi0 = NaN;\n            },\n            clean: function () {\n                return 2 - clean; // if intersections, rejoin first and last segments\n            }\n        };\n    }\n    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n        var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);\n        return abs(sinLambda0Lambda1) > epsilon\n            ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)\n                - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))\n                / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n            : (phi0 + phi1) / 2;\n    }\n    function clipAntimeridianInterpolate(from, to, direction, stream) {\n        var phi;\n        if (from == null) {\n            phi = direction * halfPi;\n            stream.point(-pi, phi);\n            stream.point(0, phi);\n            stream.point(pi, phi);\n            stream.point(pi, 0);\n            stream.point(pi, -phi);\n            stream.point(0, -phi);\n            stream.point(-pi, -phi);\n            stream.point(-pi, 0);\n            stream.point(-pi, phi);\n        }\n        else if (abs(from[0] - to[0]) > epsilon) {\n            var lambda = from[0] < to[0] ? pi : -pi;\n            phi = direction * lambda / 2;\n            stream.point(-lambda, phi);\n            stream.point(0, phi);\n            stream.point(lambda, phi);\n        }\n        else {\n            stream.point(to[0], to[1]);\n        }\n    }\n    function clipCircle(radius) {\n        var cr = cos(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n        function interpolate(from, to, direction, stream) {\n            circleStream(stream, radius, delta, direction, from, to);\n        }\n        function visible(lambda, phi) {\n            return cos(lambda) * cos(phi) > cr;\n        }\n        // Takes a line and cuts into visible segments. Return values used for polygon\n        // clipping: 0 - there were intersections or the line was empty; 1 - no\n        // intersections 2 - there were intersections, and the first and last segments\n        // should be rejoined.\n        function clipLine(stream) {\n            var point0, // previous point\n            c0, // code for previous point\n            v0, // visibility of previous point\n            v00, // visibility of first point\n            clean; // no intersections\n            return {\n                lineStart: function () {\n                    v00 = v0 = false;\n                    clean = 1;\n                },\n                point: function (lambda, phi) {\n                    var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius\n                        ? v ? 0 : code(lambda, phi)\n                        : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n                    if (!point0 && (v00 = v0 = v))\n                        stream.lineStart();\n                    // Handle degeneracies.\n                    // TODO ignore if not clipping polygons.\n                    if (v !== v0) {\n                        point2 = intersect(point0, point1);\n                        if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n                            point1[0] += epsilon;\n                            point1[1] += epsilon;\n                            v = visible(point1[0], point1[1]);\n                        }\n                    }\n                    if (v !== v0) {\n                        clean = 0;\n                        if (v) {\n                            // outside going in\n                            stream.lineStart();\n                            point2 = intersect(point1, point0);\n                            stream.point(point2[0], point2[1]);\n                        }\n                        else {\n                            // inside going out\n                            point2 = intersect(point0, point1);\n                            stream.point(point2[0], point2[1]);\n                            stream.lineEnd();\n                        }\n                        point0 = point2;\n                    }\n                    else if (notHemisphere && point0 && smallRadius ^ v) {\n                        var t;\n                        // If the codes for two points are different, or are both zero,\n                        // and there this segment intersects with the small circle.\n                        if (!(c & c0) && (t = intersect(point1, point0, true))) {\n                            clean = 0;\n                            if (smallRadius) {\n                                stream.lineStart();\n                                stream.point(t[0][0], t[0][1]);\n                                stream.point(t[1][0], t[1][1]);\n                                stream.lineEnd();\n                            }\n                            else {\n                                stream.point(t[1][0], t[1][1]);\n                                stream.lineEnd();\n                                stream.lineStart();\n                                stream.point(t[0][0], t[0][1]);\n                            }\n                        }\n                    }\n                    if (v && (!point0 || !pointEqual(point0, point1))) {\n                        stream.point(point1[0], point1[1]);\n                    }\n                    point0 = point1, v0 = v, c0 = c;\n                },\n                lineEnd: function () {\n                    if (v0)\n                        stream.lineEnd();\n                    point0 = null;\n                },\n                // Rejoin first and last segments if there were intersections and the first\n                // and last points were visible.\n                clean: function () {\n                    return clean | ((v00 && v0) << 1);\n                }\n            };\n        }\n        // Intersects the great circle between a and b with the clip circle.\n        function intersect(a, b, two) {\n            var pa = cartesian(a), pb = cartesian(b);\n            // We have two planes, n1.p = d1 and n2.p = d2.\n            // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\n            var n1 = [1, 0, 0], // normal\n            n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], // cartesianDot(n1, n2),\n            determinant = n2n2 - n1n2 * n1n2;\n            // Two polar points.\n            if (!determinant)\n                return !two && a;\n            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c2);\n            cartesianAddInPlace(A, B);\n            // Solve |p(t)|^2 = 1.\n            var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);\n            if (t2 < 0)\n                return;\n            var t = sqrt(t2), q = cartesianScale(u, (-w - t) / uu);\n            cartesianAddInPlace(q, A);\n            q = spherical(q);\n            if (!two)\n                return q;\n            // Two intersection points.\n            var lambda0 = a[0], lambda1 = b[0], phi0 = a[1], phi1 = b[1], z;\n            if (lambda1 < lambda0)\n                z = lambda0, lambda0 = lambda1, lambda1 = z;\n            var delta = lambda1 - lambda0, polar = abs(delta - pi) < epsilon, meridian = polar || delta < epsilon;\n            if (!polar && phi1 < phi0)\n                z = phi0, phi0 = phi1, phi1 = z;\n            // Check that the first point is between a and b.\n            if (meridian\n                ? polar\n                    ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n                    : phi0 <= q[1] && q[1] <= phi1\n                : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n                var q1 = cartesianScale(u, (-w + t) / uu);\n                cartesianAddInPlace(q1, A);\n                return [q, spherical(q1)];\n            }\n        }\n        // Generates a 4-bit vector representing the location of a point relative to\n        // the small circle's bounding box.\n        function code(lambda, phi) {\n            var r = smallRadius ? radius : pi - radius, code = 0;\n            if (lambda < -r)\n                code |= 1; // left\n            else if (lambda > r)\n                code |= 2; // right\n            if (phi < -r)\n                code |= 4; // below\n            else if (phi > r)\n                code |= 8; // above\n            return code;\n        }\n        return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n    }\n    function clipLine(a, b, x0, y0, x1, y1) {\n        var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;\n        r = x0 - ax;\n        if (!dx && r > 0)\n            return;\n        r /= dx;\n        if (dx < 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        else if (dx > 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        r = x1 - ax;\n        if (!dx && r < 0)\n            return;\n        r /= dx;\n        if (dx < 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        else if (dx > 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        r = y0 - ay;\n        if (!dy && r > 0)\n            return;\n        r /= dy;\n        if (dy < 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        else if (dy > 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        r = y1 - ay;\n        if (!dy && r < 0)\n            return;\n        r /= dy;\n        if (dy < 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        else if (dy > 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        if (t0 > 0)\n            a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n        if (t1 < 1)\n            b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n        return true;\n    }\n    var clipMax = 1e9, clipMin = -clipMax;\n    // TODO Use d3-polygon’s polygonContains here for the ring check?\n    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n    function clipRectangle(x0, y0, x1, y1) {\n        function visible(x, y) {\n            return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n        }\n        function interpolate(from, to, direction, stream) {\n            var a = 0, a1 = 0;\n            if (from == null\n                || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n                || comparePoint(from, to) < 0 ^ direction > 0) {\n                do\n                    stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n                while ((a = (a + direction + 4) % 4) !== a1);\n            }\n            else {\n                stream.point(to[0], to[1]);\n            }\n        }\n        function corner(p, direction) {\n            return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n                : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n                    : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n                        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n        }\n        function compareIntersection(a, b) {\n            return comparePoint(a.x, b.x);\n        }\n        function comparePoint(a, b) {\n            var ca = corner(a, 1), cb = corner(b, 1);\n            return ca !== cb ? ca - cb\n                : ca === 0 ? b[1] - a[1]\n                    : ca === 1 ? a[0] - b[0]\n                        : ca === 2 ? a[1] - b[1]\n                            : b[0] - a[0];\n        }\n        return function (stream) {\n            var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, // first point\n            x_, y_, v_, // previous point\n            first, clean;\n            var clipStream = {\n                point: point,\n                lineStart: lineStart,\n                lineEnd: lineEnd,\n                polygonStart: polygonStart,\n                polygonEnd: polygonEnd\n            };\n            function point(x, y) {\n                if (visible(x, y))\n                    activeStream.point(x, y);\n            }\n            function polygonInside() {\n                var winding = 0;\n                for (var i = 0, n = polygon.length; i < n; ++i) {\n                    for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n                        a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n                        if (a1 <= y1) {\n                            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0))\n                                ++winding;\n                        }\n                        else {\n                            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0))\n                                --winding;\n                        }\n                    }\n                }\n                return winding;\n            }\n            // Buffer geometry within a polygon and then clip it en masse.\n            function polygonStart() {\n                activeStream = bufferStream, segments = [], polygon = [], clean = true;\n            }\n            function polygonEnd() {\n                var startInside = polygonInside(), cleanInside = clean && startInside, visible = (segments = d3Array.merge(segments)).length;\n                if (cleanInside || visible) {\n                    stream.polygonStart();\n                    if (cleanInside) {\n                        stream.lineStart();\n                        interpolate(null, null, 1, stream);\n                        stream.lineEnd();\n                    }\n                    if (visible) {\n                        clipRejoin(segments, compareIntersection, startInside, interpolate, stream);\n                    }\n                    stream.polygonEnd();\n                }\n                activeStream = stream, segments = polygon = ring = null;\n            }\n            function lineStart() {\n                clipStream.point = linePoint;\n                if (polygon)\n                    polygon.push(ring = []);\n                first = true;\n                v_ = false;\n                x_ = y_ = NaN;\n            }\n            // TODO rather than special-case polygons, simply handle them separately.\n            // Ideally, coincident intersection points should be jittered to avoid\n            // clipping issues.\n            function lineEnd() {\n                if (segments) {\n                    linePoint(x__, y__);\n                    if (v__ && v_)\n                        bufferStream.rejoin();\n                    segments.push(bufferStream.result());\n                }\n                clipStream.point = point;\n                if (v_)\n                    activeStream.lineEnd();\n            }\n            function linePoint(x, y) {\n                var v = visible(x, y);\n                if (polygon)\n                    ring.push([x, y]);\n                if (first) {\n                    x__ = x, y__ = y, v__ = v;\n                    first = false;\n                    if (v) {\n                        activeStream.lineStart();\n                        activeStream.point(x, y);\n                    }\n                }\n                else {\n                    if (v && v_)\n                        activeStream.point(x, y);\n                    else {\n                        var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n                        if (clipLine(a, b, x0, y0, x1, y1)) {\n                            if (!v_) {\n                                activeStream.lineStart();\n                                activeStream.point(a[0], a[1]);\n                            }\n                            activeStream.point(b[0], b[1]);\n                            if (!v)\n                                activeStream.lineEnd();\n                            clean = false;\n                        }\n                        else if (v) {\n                            activeStream.lineStart();\n                            activeStream.point(x, y);\n                            clean = false;\n                        }\n                    }\n                }\n                x_ = x, y_ = y, v_ = v;\n            }\n            return clipStream;\n        };\n    }\n    function extent() {\n        var x0 = 0, y0 = 0, x1 = 960, y1 = 500, cache, cacheStream, clip;\n        return clip = {\n            stream: function (stream) {\n                return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);\n            },\n            extent: function (_) {\n                return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n            }\n        };\n    }\n    var lengthSum = adder(), lambda0$2, sinPhi0$1, cosPhi0$1;\n    var lengthStream = {\n        sphere: noop,\n        point: noop,\n        lineStart: lengthLineStart,\n        lineEnd: noop,\n        polygonStart: noop,\n        polygonEnd: noop\n    };\n    function lengthLineStart() {\n        lengthStream.point = lengthPointFirst;\n        lengthStream.lineEnd = lengthLineEnd;\n    }\n    function lengthLineEnd() {\n        lengthStream.point = lengthStream.lineEnd = noop;\n    }\n    function lengthPointFirst(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);\n        lengthStream.point = lengthPoint;\n    }\n    function lengthPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var sinPhi = sin(phi), cosPhi = cos(phi), delta = abs(lambda - lambda0$2), cosDelta = cos(delta), sinDelta = sin(delta), x = cosPhi * sinDelta, y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta, z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;\n        lengthSum.add(atan2(sqrt(x * x + y * y), z));\n        lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;\n    }\n    function length(object) {\n        lengthSum.reset();\n        geoStream(object, lengthStream);\n        return +lengthSum;\n    }\n    var coordinates = [null, null], object = { type: \"LineString\", coordinates: coordinates };\n    function distance(a, b) {\n        coordinates[0] = a;\n        coordinates[1] = b;\n        return length(object);\n    }\n    var containsObjectType = {\n        Feature: function (object, point) {\n            return containsGeometry(object.geometry, point);\n        },\n        FeatureCollection: function (object, point) {\n            var features = object.features, i = -1, n = features.length;\n            while (++i < n)\n                if (containsGeometry(features[i].geometry, point))\n                    return true;\n            return false;\n        }\n    };\n    var containsGeometryType = {\n        Sphere: function () {\n            return true;\n        },\n        Point: function (object, point) {\n            return containsPoint(object.coordinates, point);\n        },\n        MultiPoint: function (object, point) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                if (containsPoint(coordinates[i], point))\n                    return true;\n            return false;\n        },\n        LineString: function (object, point) {\n            return containsLine(object.coordinates, point);\n        },\n        MultiLineString: function (object, point) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                if (containsLine(coordinates[i], point))\n                    return true;\n            return false;\n        },\n        Polygon: function (object, point) {\n            return containsPolygon(object.coordinates, point);\n        },\n        MultiPolygon: function (object, point) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                if (containsPolygon(coordinates[i], point))\n                    return true;\n            return false;\n        },\n        GeometryCollection: function (object, point) {\n            var geometries = object.geometries, i = -1, n = geometries.length;\n            while (++i < n)\n                if (containsGeometry(geometries[i], point))\n                    return true;\n            return false;\n        }\n    };\n    function containsGeometry(geometry, point) {\n        return geometry && containsGeometryType.hasOwnProperty(geometry.type)\n            ? containsGeometryType[geometry.type](geometry, point)\n            : false;\n    }\n    function containsPoint(coordinates, point) {\n        return distance(coordinates, point) === 0;\n    }\n    function containsLine(coordinates, point) {\n        var ao, bo, ab;\n        for (var i = 0, n = coordinates.length; i < n; i++) {\n            bo = distance(coordinates[i], point);\n            if (bo === 0)\n                return true;\n            if (i > 0) {\n                ab = distance(coordinates[i], coordinates[i - 1]);\n                if (ab > 0 &&\n                    ao <= ab &&\n                    bo <= ab &&\n                    (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab)\n                    return true;\n            }\n            ao = bo;\n        }\n        return false;\n    }\n    function containsPolygon(coordinates, point) {\n        return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));\n    }\n    function ringRadians(ring) {\n        return ring = ring.map(pointRadians), ring.pop(), ring;\n    }\n    function pointRadians(point) {\n        return [point[0] * radians, point[1] * radians];\n    }\n    function contains(object, point) {\n        return (object && containsObjectType.hasOwnProperty(object.type)\n            ? containsObjectType[object.type]\n            : containsGeometry)(object, point);\n    }\n    function graticuleX(y0, y1, dy) {\n        var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);\n        return function (x) { return y.map(function (y) { return [x, y]; }); };\n    }\n    function graticuleY(x0, x1, dx) {\n        var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);\n        return function (y) { return x.map(function (x) { return [x, y]; }); };\n    }\n    function graticule() {\n        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;\n        function graticule() {\n            return { type: \"MultiLineString\", coordinates: lines() };\n        }\n        function lines() {\n            return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)\n                .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))\n                .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function (x) { return abs(x % DX) > epsilon; }).map(x))\n                .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function (y) { return abs(y % DY) > epsilon; }).map(y));\n        }\n        graticule.lines = function () {\n            return lines().map(function (coordinates) { return { type: \"LineString\", coordinates: coordinates }; });\n        };\n        graticule.outline = function () {\n            return {\n                type: \"Polygon\",\n                coordinates: [\n                    X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))\n                ]\n            };\n        };\n        graticule.extent = function (_) {\n            if (!arguments.length)\n                return graticule.extentMinor();\n            return graticule.extentMajor(_).extentMinor(_);\n        };\n        graticule.extentMajor = function (_) {\n            if (!arguments.length)\n                return [[X0, Y0], [X1, Y1]];\n            X0 = +_[0][0], X1 = +_[1][0];\n            Y0 = +_[0][1], Y1 = +_[1][1];\n            if (X0 > X1)\n                _ = X0, X0 = X1, X1 = _;\n            if (Y0 > Y1)\n                _ = Y0, Y0 = Y1, Y1 = _;\n            return graticule.precision(precision);\n        };\n        graticule.extentMinor = function (_) {\n            if (!arguments.length)\n                return [[x0, y0], [x1, y1]];\n            x0 = +_[0][0], x1 = +_[1][0];\n            y0 = +_[0][1], y1 = +_[1][1];\n            if (x0 > x1)\n                _ = x0, x0 = x1, x1 = _;\n            if (y0 > y1)\n                _ = y0, y0 = y1, y1 = _;\n            return graticule.precision(precision);\n        };\n        graticule.step = function (_) {\n            if (!arguments.length)\n                return graticule.stepMinor();\n            return graticule.stepMajor(_).stepMinor(_);\n        };\n        graticule.stepMajor = function (_) {\n            if (!arguments.length)\n                return [DX, DY];\n            DX = +_[0], DY = +_[1];\n            return graticule;\n        };\n        graticule.stepMinor = function (_) {\n            if (!arguments.length)\n                return [dx, dy];\n            dx = +_[0], dy = +_[1];\n            return graticule;\n        };\n        graticule.precision = function (_) {\n            if (!arguments.length)\n                return precision;\n            precision = +_;\n            x = graticuleX(y0, y1, 90);\n            y = graticuleY(x0, x1, precision);\n            X = graticuleX(Y0, Y1, 90);\n            Y = graticuleY(X0, X1, precision);\n            return graticule;\n        };\n        return graticule\n            .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])\n            .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);\n    }\n    function graticule10() {\n        return graticule()();\n    }\n    function interpolate(a, b) {\n        var x0 = a[0] * radians, y0 = a[1] * radians, x1 = b[0] * radians, y1 = b[1] * radians, cy0 = cos(y0), sy0 = sin(y0), cy1 = cos(y1), sy1 = sin(y1), kx0 = cy0 * cos(x0), ky0 = cy0 * sin(x0), kx1 = cy1 * cos(x1), ky1 = cy1 * sin(x1), d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))), k = sin(d);\n        var interpolate = d ? function (t) {\n            var B = sin(t *= d) / k, A = sin(d - t) / k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;\n            return [\n                atan2(y, x) * degrees,\n                atan2(z, sqrt(x * x + y * y)) * degrees\n            ];\n        } : function () {\n            return [x0 * degrees, y0 * degrees];\n        };\n        interpolate.distance = d;\n        return interpolate;\n    }\n    function identity(x) {\n        return x;\n    }\n    var areaSum$1 = adder(), areaRingSum$1 = adder(), x00, y00, x0$1, y0$1;\n    var areaStream$1 = {\n        point: noop,\n        lineStart: noop,\n        lineEnd: noop,\n        polygonStart: function () {\n            areaStream$1.lineStart = areaRingStart$1;\n            areaStream$1.lineEnd = areaRingEnd$1;\n        },\n        polygonEnd: function () {\n            areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;\n            areaSum$1.add(abs(areaRingSum$1));\n            areaRingSum$1.reset();\n        },\n        result: function () {\n            var area = areaSum$1 / 2;\n            areaSum$1.reset();\n            return area;\n        }\n    };\n    function areaRingStart$1() {\n        areaStream$1.point = areaPointFirst$1;\n    }\n    function areaPointFirst$1(x, y) {\n        areaStream$1.point = areaPoint$1;\n        x00 = x0$1 = x, y00 = y0$1 = y;\n    }\n    function areaPoint$1(x, y) {\n        areaRingSum$1.add(y0$1 * x - x0$1 * y);\n        x0$1 = x, y0$1 = y;\n    }\n    function areaRingEnd$1() {\n        areaPoint$1(x00, y00);\n    }\n    var x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1;\n    var boundsStream$1 = {\n        point: boundsPoint$1,\n        lineStart: noop,\n        lineEnd: noop,\n        polygonStart: noop,\n        polygonEnd: noop,\n        result: function () {\n            var bounds = [[x0$2, y0$2], [x1, y1]];\n            x1 = y1 = -(y0$2 = x0$2 = Infinity);\n            return bounds;\n        }\n    };\n    function boundsPoint$1(x, y) {\n        if (x < x0$2)\n            x0$2 = x;\n        if (x > x1)\n            x1 = x;\n        if (y < y0$2)\n            y0$2 = y;\n        if (y > y1)\n            y1 = y;\n    }\n    // TODO Enforce positive area for exterior, negative area for interior?\n    var X0$1 = 0, Y0$1 = 0, Z0$1 = 0, X1$1 = 0, Y1$1 = 0, Z1$1 = 0, X2$1 = 0, Y2$1 = 0, Z2$1 = 0, x00$1, y00$1, x0$3, y0$3;\n    var centroidStream$1 = {\n        point: centroidPoint$1,\n        lineStart: centroidLineStart$1,\n        lineEnd: centroidLineEnd$1,\n        polygonStart: function () {\n            centroidStream$1.lineStart = centroidRingStart$1;\n            centroidStream$1.lineEnd = centroidRingEnd$1;\n        },\n        polygonEnd: function () {\n            centroidStream$1.point = centroidPoint$1;\n            centroidStream$1.lineStart = centroidLineStart$1;\n            centroidStream$1.lineEnd = centroidLineEnd$1;\n        },\n        result: function () {\n            var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]\n                : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]\n                    : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]\n                        : [NaN, NaN];\n            X0$1 = Y0$1 = Z0$1 =\n                X1$1 = Y1$1 = Z1$1 =\n                    X2$1 = Y2$1 = Z2$1 = 0;\n            return centroid;\n        }\n    };\n    function centroidPoint$1(x, y) {\n        X0$1 += x;\n        Y0$1 += y;\n        ++Z0$1;\n    }\n    function centroidLineStart$1() {\n        centroidStream$1.point = centroidPointFirstLine;\n    }\n    function centroidPointFirstLine(x, y) {\n        centroidStream$1.point = centroidPointLine;\n        centroidPoint$1(x0$3 = x, y0$3 = y);\n    }\n    function centroidPointLine(x, y) {\n        var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);\n        X1$1 += z * (x0$3 + x) / 2;\n        Y1$1 += z * (y0$3 + y) / 2;\n        Z1$1 += z;\n        centroidPoint$1(x0$3 = x, y0$3 = y);\n    }\n    function centroidLineEnd$1() {\n        centroidStream$1.point = centroidPoint$1;\n    }\n    function centroidRingStart$1() {\n        centroidStream$1.point = centroidPointFirstRing;\n    }\n    function centroidRingEnd$1() {\n        centroidPointRing(x00$1, y00$1);\n    }\n    function centroidPointFirstRing(x, y) {\n        centroidStream$1.point = centroidPointRing;\n        centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);\n    }\n    function centroidPointRing(x, y) {\n        var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);\n        X1$1 += z * (x0$3 + x) / 2;\n        Y1$1 += z * (y0$3 + y) / 2;\n        Z1$1 += z;\n        z = y0$3 * x - x0$3 * y;\n        X2$1 += z * (x0$3 + x);\n        Y2$1 += z * (y0$3 + y);\n        Z2$1 += z * 3;\n        centroidPoint$1(x0$3 = x, y0$3 = y);\n    }\n    function PathContext(context) {\n        this._context = context;\n    }\n    PathContext.prototype = {\n        _radius: 4.5,\n        pointRadius: function (_) {\n            return this._radius = _, this;\n        },\n        polygonStart: function () {\n            this._line = 0;\n        },\n        polygonEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line === 0)\n                this._context.closePath();\n            this._point = NaN;\n        },\n        point: function (x, y) {\n            switch (this._point) {\n                case 0: {\n                    this._context.moveTo(x, y);\n                    this._point = 1;\n                    break;\n                }\n                case 1: {\n                    this._context.lineTo(x, y);\n                    break;\n                }\n                default: {\n                    this._context.moveTo(x + this._radius, y);\n                    this._context.arc(x, y, this._radius, 0, tau);\n                    break;\n                }\n            }\n        },\n        result: noop\n    };\n    var lengthSum$1 = adder(), lengthRing, x00$2, y00$2, x0$4, y0$4;\n    var lengthStream$1 = {\n        point: noop,\n        lineStart: function () {\n            lengthStream$1.point = lengthPointFirst$1;\n        },\n        lineEnd: function () {\n            if (lengthRing)\n                lengthPoint$1(x00$2, y00$2);\n            lengthStream$1.point = noop;\n        },\n        polygonStart: function () {\n            lengthRing = true;\n        },\n        polygonEnd: function () {\n            lengthRing = null;\n        },\n        result: function () {\n            var length = +lengthSum$1;\n            lengthSum$1.reset();\n            return length;\n        }\n    };\n    function lengthPointFirst$1(x, y) {\n        lengthStream$1.point = lengthPoint$1;\n        x00$2 = x0$4 = x, y00$2 = y0$4 = y;\n    }\n    function lengthPoint$1(x, y) {\n        x0$4 -= x, y0$4 -= y;\n        lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));\n        x0$4 = x, y0$4 = y;\n    }\n    function PathString() {\n        this._string = [];\n    }\n    PathString.prototype = {\n        _radius: 4.5,\n        _circle: circle$1(4.5),\n        pointRadius: function (_) {\n            if ((_ = +_) !== this._radius)\n                this._radius = _, this._circle = null;\n            return this;\n        },\n        polygonStart: function () {\n            this._line = 0;\n        },\n        polygonEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line === 0)\n                this._string.push(\"Z\");\n            this._point = NaN;\n        },\n        point: function (x, y) {\n            switch (this._point) {\n                case 0: {\n                    this._string.push(\"M\", x, \",\", y);\n                    this._point = 1;\n                    break;\n                }\n                case 1: {\n                    this._string.push(\"L\", x, \",\", y);\n                    break;\n                }\n                default: {\n                    if (this._circle == null)\n                        this._circle = circle$1(this._radius);\n                    this._string.push(\"M\", x, \",\", y, this._circle);\n                    break;\n                }\n            }\n        },\n        result: function () {\n            if (this._string.length) {\n                var result = this._string.join(\"\");\n                this._string = [];\n                return result;\n            }\n            else {\n                return null;\n            }\n        }\n    };\n    function circle$1(radius) {\n        return \"m0,\" + radius\n            + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n            + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n            + \"z\";\n    }\n    function index(projection, context) {\n        var pointRadius = 4.5, projectionStream, contextStream;\n        function path(object) {\n            if (object) {\n                if (typeof pointRadius === \"function\")\n                    contextStream.pointRadius(+pointRadius.apply(this, arguments));\n                geoStream(object, projectionStream(contextStream));\n            }\n            return contextStream.result();\n        }\n        path.area = function (object) {\n            geoStream(object, projectionStream(areaStream$1));\n            return areaStream$1.result();\n        };\n        path.measure = function (object) {\n            geoStream(object, projectionStream(lengthStream$1));\n            return lengthStream$1.result();\n        };\n        path.bounds = function (object) {\n            geoStream(object, projectionStream(boundsStream$1));\n            return boundsStream$1.result();\n        };\n        path.centroid = function (object) {\n            geoStream(object, projectionStream(centroidStream$1));\n            return centroidStream$1.result();\n        };\n        path.projection = function (_) {\n            return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;\n        };\n        path.context = function (_) {\n            if (!arguments.length)\n                return context;\n            contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);\n            if (typeof pointRadius !== \"function\")\n                contextStream.pointRadius(pointRadius);\n            return path;\n        };\n        path.pointRadius = function (_) {\n            if (!arguments.length)\n                return pointRadius;\n            pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n            return path;\n        };\n        return path.projection(projection).context(context);\n    }\n    function transform(methods) {\n        return {\n            stream: transformer(methods)\n        };\n    }\n    function transformer(methods) {\n        return function (stream) {\n            var s = new TransformStream;\n            for (var key in methods)\n                s[key] = methods[key];\n            s.stream = stream;\n            return s;\n        };\n    }\n    function TransformStream() { }\n    TransformStream.prototype = {\n        constructor: TransformStream,\n        point: function (x, y) { this.stream.point(x, y); },\n        sphere: function () { this.stream.sphere(); },\n        lineStart: function () { this.stream.lineStart(); },\n        lineEnd: function () { this.stream.lineEnd(); },\n        polygonStart: function () { this.stream.polygonStart(); },\n        polygonEnd: function () { this.stream.polygonEnd(); }\n    };\n    function fit(projection, fitBounds, object) {\n        var clip = projection.clipExtent && projection.clipExtent();\n        projection.scale(150).translate([0, 0]);\n        if (clip != null)\n            projection.clipExtent(null);\n        geoStream(object, projection.stream(boundsStream$1));\n        fitBounds(boundsStream$1.result());\n        if (clip != null)\n            projection.clipExtent(clip);\n        return projection;\n    }\n    function fitExtent(projection, extent, object) {\n        return fit(projection, function (b) {\n            var w = extent[1][0] - extent[0][0], h = extent[1][1] - extent[0][1], k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n            projection.scale(150 * k).translate([x, y]);\n        }, object);\n    }\n    function fitSize(projection, size, object) {\n        return fitExtent(projection, [[0, 0], size], object);\n    }\n    function fitWidth(projection, width, object) {\n        return fit(projection, function (b) {\n            var w = +width, k = w / (b[1][0] - b[0][0]), x = (w - k * (b[1][0] + b[0][0])) / 2, y = -k * b[0][1];\n            projection.scale(150 * k).translate([x, y]);\n        }, object);\n    }\n    function fitHeight(projection, height, object) {\n        return fit(projection, function (b) {\n            var h = +height, k = h / (b[1][1] - b[0][1]), x = -k * b[0][0], y = (h - k * (b[1][1] + b[0][1])) / 2;\n            projection.scale(150 * k).translate([x, y]);\n        }, object);\n    }\n    var maxDepth = 16, // maximum depth of subdivision\n    cosMinDistance = cos(30 * radians); // cos(minimum angular distance)\n    function resample(project, delta2) {\n        return +delta2 ? resample$1(project, delta2) : resampleNone(project);\n    }\n    function resampleNone(project) {\n        return transformer({\n            point: function (x, y) {\n                x = project(x, y);\n                this.stream.point(x[0], x[1]);\n            }\n        });\n    }\n    function resample$1(project, delta2) {\n        function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;\n            if (d2 > 4 * delta2 && depth--) {\n                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a * a + b * b + c * c), phi2 = asin(c /= m), lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a), p = project(lambda2, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;\n                if (dz * dz / d2 > delta2 // perpendicular projected distance\n                    || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n                    || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n                    resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n                    stream.point(x2, y2);\n                    resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n                }\n            }\n        }\n        return function (stream) {\n            var lambda00, x00, y00, a00, b00, c00, // first point\n            lambda0, x0, y0, a0, b0, c0; // previous point\n            var resampleStream = {\n                point: point,\n                lineStart: lineStart,\n                lineEnd: lineEnd,\n                polygonStart: function () { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n                polygonEnd: function () { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n            };\n            function point(x, y) {\n                x = project(x, y);\n                stream.point(x[0], x[1]);\n            }\n            function lineStart() {\n                x0 = NaN;\n                resampleStream.point = linePoint;\n                stream.lineStart();\n            }\n            function linePoint(lambda, phi) {\n                var c = cartesian([lambda, phi]), p = project(lambda, phi);\n                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n                stream.point(x0, y0);\n            }\n            function lineEnd() {\n                resampleStream.point = point;\n                stream.lineEnd();\n            }\n            function ringStart() {\n                lineStart();\n                resampleStream.point = ringPoint;\n                resampleStream.lineEnd = ringEnd;\n            }\n            function ringPoint(lambda, phi) {\n                linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n                resampleStream.point = linePoint;\n            }\n            function ringEnd() {\n                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n                resampleStream.lineEnd = lineEnd;\n                lineEnd();\n            }\n            return resampleStream;\n        };\n    }\n    var transformRadians = transformer({\n        point: function (x, y) {\n            this.stream.point(x * radians, y * radians);\n        }\n    });\n    function transformRotate(rotate) {\n        return transformer({\n            point: function (x, y) {\n                var r = rotate(x, y);\n                return this.stream.point(r[0], r[1]);\n            }\n        });\n    }\n    function scaleTranslate(k, dx, dy) {\n        function transform(x, y) {\n            return [dx + k * x, dy - k * y];\n        }\n        transform.invert = function (x, y) {\n            return [(x - dx) / k, (dy - y) / k];\n        };\n        return transform;\n    }\n    function scaleTranslateRotate(k, dx, dy, alpha) {\n        var cosAlpha = cos(alpha), sinAlpha = sin(alpha), a = cosAlpha * k, b = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;\n        function transform(x, y) {\n            return [a * x - b * y + dx, dy - b * x - a * y];\n        }\n        transform.invert = function (x, y) {\n            return [ai * x - bi * y + ci, fi - bi * x - ai * y];\n        };\n        return transform;\n    }\n    function projection(project) {\n        return projectionMutator(function () { return project; })();\n    }\n    function projectionMutator(projectAt) {\n        var project, k = 150, // scale\n        x = 480, y = 250, // translate\n        lambda = 0, phi = 0, // center\n        deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate\n        alpha = 0, // post-rotate\n        theta = null, preclip = clipAntimeridian, // pre-clip angle\n        x0 = null, y0, x1, y1, postclip = identity, // post-clip extent\n        delta2 = 0.5, // precision\n        projectResample, projectTransform, projectRotateTransform, cache, cacheStream;\n        function projection(point) {\n            return projectRotateTransform(point[0] * radians, point[1] * radians);\n        }\n        function invert(point) {\n            point = projectRotateTransform.invert(point[0], point[1]);\n            return point && [point[0] * degrees, point[1] * degrees];\n        }\n        projection.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));\n        };\n        projection.preclip = function (_) {\n            return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;\n        };\n        projection.postclip = function (_) {\n            return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n        };\n        projection.clipAngle = function (_) {\n            return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n        };\n        projection.clipExtent = function (_) {\n            return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n        };\n        projection.scale = function (_) {\n            return arguments.length ? (k = +_, recenter()) : k;\n        };\n        projection.translate = function (_) {\n            return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n        };\n        projection.center = function (_) {\n            return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n        };\n        projection.rotate = function (_) {\n            return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n        };\n        projection.angle = function (_) {\n            return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;\n        };\n        projection.precision = function (_) {\n            return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n        };\n        projection.fitExtent = function (extent, object) {\n            return fitExtent(projection, extent, object);\n        };\n        projection.fitSize = function (size, object) {\n            return fitSize(projection, size, object);\n        };\n        projection.fitWidth = function (width, object) {\n            return fitWidth(projection, width, object);\n        };\n        projection.fitHeight = function (height, object) {\n            return fitHeight(projection, height, object);\n        };\n        function recenter() {\n            var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)), transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);\n            rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);\n            projectTransform = compose(project, transform);\n            projectRotateTransform = compose(rotate, projectTransform);\n            projectResample = resample(projectTransform, delta2);\n            return reset();\n        }\n        function reset() {\n            cache = cacheStream = null;\n            return projection;\n        }\n        return function () {\n            project = projectAt.apply(this, arguments);\n            projection.invert = project.invert && invert;\n            return recenter();\n        };\n    }\n    function conicProjection(projectAt) {\n        var phi0 = 0, phi1 = pi / 3, m = projectionMutator(projectAt), p = m(phi0, phi1);\n        p.parallels = function (_) {\n            return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];\n        };\n        return p;\n    }\n    function cylindricalEqualAreaRaw(phi0) {\n        var cosPhi0 = cos(phi0);\n        function forward(lambda, phi) {\n            return [lambda * cosPhi0, sin(phi) / cosPhi0];\n        }\n        forward.invert = function (x, y) {\n            return [x / cosPhi0, asin(y * cosPhi0)];\n        };\n        return forward;\n    }\n    function conicEqualAreaRaw(y0, y1) {\n        var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;\n        // Are the parallels symmetrical around the Equator?\n        if (abs(n) < epsilon)\n            return cylindricalEqualAreaRaw(y0);\n        var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;\n        function project(x, y) {\n            var r = sqrt(c - 2 * n * sin(y)) / n;\n            return [r * sin(x *= n), r0 - r * cos(x)];\n        }\n        project.invert = function (x, y) {\n            var r0y = r0 - y;\n            return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];\n        };\n        return project;\n    }\n    function conicEqualArea() {\n        return conicProjection(conicEqualAreaRaw)\n            .scale(155.424)\n            .center([0, 33.6442]);\n    }\n    function albers() {\n        return conicEqualArea()\n            .parallels([29.5, 45.5])\n            .scale(1070)\n            .translate([480, 250])\n            .rotate([96, 0])\n            .center([-0.6, 38.7]);\n    }\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n)\n                streams[i].point(x, y); },\n            sphere: function () { var i = -1; while (++i < n)\n                streams[i].sphere(); },\n            lineStart: function () { var i = -1; while (++i < n)\n                streams[i].lineStart(); },\n            lineEnd: function () { var i = -1; while (++i < n)\n                streams[i].lineEnd(); },\n            polygonStart: function () { var i = -1; while (++i < n)\n                streams[i].polygonStart(); },\n            polygonEnd: function () { var i = -1; while (++i < n)\n                streams[i].polygonEnd(); }\n        };\n    }\n    // A composite projection for the United States, configured by default for\n    // 960×500. The projection also works quite well at 960×600 if you change the\n    // scale to 1285 and adjust the translate accordingly. The set of standard\n    // parallels for each region comes from USGS, which is published here:\n    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\n    function albersUsa() {\n        var cache, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n        hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n        point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        function albersUsa(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (lower48Point.point(x, y), point)\n                    || (alaskaPoint.point(x, y), point)\n                    || (hawaiiPoint.point(x, y), point);\n        }\n        albersUsa.invert = function (coordinates) {\n            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n                : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n                    : lower48).invert(coordinates);\n        };\n        albersUsa.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n        };\n        albersUsa.precision = function (_) {\n            if (!arguments.length)\n                return lower48.precision();\n            lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n            return reset();\n        };\n        albersUsa.scale = function (_) {\n            if (!arguments.length)\n                return lower48.scale();\n            lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n            return albersUsa.translate(lower48.translate());\n        };\n        albersUsa.translate = function (_) {\n            if (!arguments.length)\n                return lower48.translate();\n            var k = lower48.scale(), x = +_[0], y = +_[1];\n            lower48Point = lower48\n                .translate(_)\n                .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n                .stream(pointStream);\n            alaskaPoint = alaska\n                .translate([x - 0.307 * k, y + 0.201 * k])\n                .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])\n                .stream(pointStream);\n            hawaiiPoint = hawaii\n                .translate([x - 0.205 * k, y + 0.212 * k])\n                .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        albersUsa.fitExtent = function (extent, object) {\n            return fitExtent(albersUsa, extent, object);\n        };\n        albersUsa.fitSize = function (size, object) {\n            return fitSize(albersUsa, size, object);\n        };\n        albersUsa.fitWidth = function (width, object) {\n            return fitWidth(albersUsa, width, object);\n        };\n        albersUsa.fitHeight = function (height, object) {\n            return fitHeight(albersUsa, height, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return albersUsa;\n        }\n        return albersUsa.scale(1070);\n    }\n    function azimuthalRaw(scale) {\n        return function (x, y) {\n            var cx = cos(x), cy = cos(y), k = scale(cx * cy);\n            return [\n                k * cy * sin(x),\n                k * sin(y)\n            ];\n        };\n    }\n    function azimuthalInvert(angle) {\n        return function (x, y) {\n            var z = sqrt(x * x + y * y), c = angle(z), sc = sin(c), cc = cos(c);\n            return [\n                atan2(x * sc, z * cc),\n                asin(z && y * sc / z)\n            ];\n        };\n    }\n    var azimuthalEqualAreaRaw = azimuthalRaw(function (cxcy) {\n        return sqrt(2 / (1 + cxcy));\n    });\n    azimuthalEqualAreaRaw.invert = azimuthalInvert(function (z) {\n        return 2 * asin(z / 2);\n    });\n    function azimuthalEqualArea() {\n        return projection(azimuthalEqualAreaRaw)\n            .scale(124.75)\n            .clipAngle(180 - 1e-3);\n    }\n    var azimuthalEquidistantRaw = azimuthalRaw(function (c) {\n        return (c = acos(c)) && c / sin(c);\n    });\n    azimuthalEquidistantRaw.invert = azimuthalInvert(function (z) {\n        return z;\n    });\n    function azimuthalEquidistant() {\n        return projection(azimuthalEquidistantRaw)\n            .scale(79.4188)\n            .clipAngle(180 - 1e-3);\n    }\n    function mercatorRaw(lambda, phi) {\n        return [lambda, log(tan((halfPi + phi) / 2))];\n    }\n    mercatorRaw.invert = function (x, y) {\n        return [x, 2 * atan(exp(y)) - halfPi];\n    };\n    function mercator() {\n        return mercatorProjection(mercatorRaw)\n            .scale(961 / tau);\n    }\n    function mercatorProjection(project) {\n        var m = projection(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x0 = null, y0, x1, y1; // clip extent\n        m.scale = function (_) {\n            return arguments.length ? (scale(_), reclip()) : scale();\n        };\n        m.translate = function (_) {\n            return arguments.length ? (translate(_), reclip()) : translate();\n        };\n        m.center = function (_) {\n            return arguments.length ? (center(_), reclip()) : center();\n        };\n        m.clipExtent = function (_) {\n            return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n        };\n        function reclip() {\n            var k = pi * scale(), t = m(rotation(m.rotate()).invert([0, 0]));\n            return clipExtent(x0 == null\n                ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw\n                ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]\n                : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n        }\n        return reclip();\n    }\n    function tany(y) {\n        return tan((halfPi + y) / 2);\n    }\n    function conicConformalRaw(y0, y1) {\n        var cy0 = cos(y0), n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)), f = cy0 * pow(tany(y0), n) / n;\n        if (!n)\n            return mercatorRaw;\n        function project(x, y) {\n            if (f > 0) {\n                if (y < -halfPi + epsilon)\n                    y = -halfPi + epsilon;\n            }\n            else {\n                if (y > halfPi - epsilon)\n                    y = halfPi - epsilon;\n            }\n            var r = f / pow(tany(y), n);\n            return [r * sin(n * x), f - r * cos(n * x)];\n        }\n        project.invert = function (x, y) {\n            var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);\n            return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];\n        };\n        return project;\n    }\n    function conicConformal() {\n        return conicProjection(conicConformalRaw)\n            .scale(109.5)\n            .parallels([30, 30]);\n    }\n    function equirectangularRaw(lambda, phi) {\n        return [lambda, phi];\n    }\n    equirectangularRaw.invert = equirectangularRaw;\n    function equirectangular() {\n        return projection(equirectangularRaw)\n            .scale(152.63);\n    }\n    function conicEquidistantRaw(y0, y1) {\n        var cy0 = cos(y0), n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0), g = cy0 / n + y0;\n        if (abs(n) < epsilon)\n            return equirectangularRaw;\n        function project(x, y) {\n            var gy = g - y, nx = n * x;\n            return [gy * sin(nx), g - gy * cos(nx)];\n        }\n        project.invert = function (x, y) {\n            var gy = g - y;\n            return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];\n        };\n        return project;\n    }\n    function conicEquidistant() {\n        return conicProjection(conicEquidistantRaw)\n            .scale(131.154)\n            .center([0, 13.9389]);\n    }\n    var A1 = 1.340264, A2 = -0.081106, A3 = 0.000893, A4 = 0.003796, M = sqrt(3) / 2, iterations = 12;\n    function equalEarthRaw(lambda, phi) {\n        var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;\n        return [\n            lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),\n            l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))\n        ];\n    }\n    equalEarthRaw.invert = function (x, y) {\n        var l = y, l2 = l * l, l6 = l2 * l2 * l2;\n        for (var i = 0, delta, fy, fpy; i < iterations; ++i) {\n            fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;\n            fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);\n            l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;\n            if (abs(delta) < epsilon2)\n                break;\n        }\n        return [\n            M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),\n            asin(sin(l) / M)\n        ];\n    };\n    function equalEarth() {\n        return projection(equalEarthRaw)\n            .scale(177.158);\n    }\n    function gnomonicRaw(x, y) {\n        var cy = cos(y), k = cos(x) * cy;\n        return [cy * sin(x) / k, sin(y) / k];\n    }\n    gnomonicRaw.invert = azimuthalInvert(atan);\n    function gnomonic() {\n        return projection(gnomonicRaw)\n            .scale(144.049)\n            .clipAngle(60);\n    }\n    function scaleTranslate$1(kx, ky, tx, ty) {\n        return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({\n            point: function (x, y) {\n                this.stream.point(x * kx + tx, y * ky + ty);\n            }\n        });\n    }\n    function identity$1() {\n        var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = identity, // scale, translate and reflect\n        x0 = null, y0, x1, y1, // clip extent\n        postclip = identity, cache, cacheStream, projection;\n        function reset() {\n            cache = cacheStream = null;\n            return projection;\n        }\n        return projection = {\n            stream: function (stream) {\n                return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));\n            },\n            postclip: function (_) {\n                return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n            },\n            clipExtent: function (_) {\n                return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n            },\n            scale: function (_) {\n                return arguments.length ? (transform = scaleTranslate$1((k = +_) * sx, k * sy, tx, ty), reset()) : k;\n            },\n            translate: function (_) {\n                return arguments.length ? (transform = scaleTranslate$1(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];\n            },\n            reflectX: function (_) {\n                return arguments.length ? (transform = scaleTranslate$1(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;\n            },\n            reflectY: function (_) {\n                return arguments.length ? (transform = scaleTranslate$1(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;\n            },\n            fitExtent: function (extent, object) {\n                return fitExtent(projection, extent, object);\n            },\n            fitSize: function (size, object) {\n                return fitSize(projection, size, object);\n            },\n            fitWidth: function (width, object) {\n                return fitWidth(projection, width, object);\n            },\n            fitHeight: function (height, object) {\n                return fitHeight(projection, height, object);\n            }\n        };\n    }\n    function naturalEarth1Raw(lambda, phi) {\n        var phi2 = phi * phi, phi4 = phi2 * phi2;\n        return [\n            lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),\n            phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))\n        ];\n    }\n    naturalEarth1Raw.invert = function (x, y) {\n        var phi = y, i = 25, delta;\n        do {\n            var phi2 = phi * phi, phi4 = phi2 * phi2;\n            phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /\n                (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));\n        } while (abs(delta) > epsilon && --i > 0);\n        return [\n            x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),\n            phi\n        ];\n    };\n    function naturalEarth1() {\n        return projection(naturalEarth1Raw)\n            .scale(175.295);\n    }\n    function orthographicRaw(x, y) {\n        return [cos(y) * sin(x), sin(y)];\n    }\n    orthographicRaw.invert = azimuthalInvert(asin);\n    function orthographic() {\n        return projection(orthographicRaw)\n            .scale(249.5)\n            .clipAngle(90 + epsilon);\n    }\n    function stereographicRaw(x, y) {\n        var cy = cos(y), k = 1 + cos(x) * cy;\n        return [cy * sin(x) / k, sin(y) / k];\n    }\n    stereographicRaw.invert = azimuthalInvert(function (z) {\n        return 2 * atan(z);\n    });\n    function stereographic() {\n        return projection(stereographicRaw)\n            .scale(250)\n            .clipAngle(142);\n    }\n    function transverseMercatorRaw(lambda, phi) {\n        return [log(tan((halfPi + phi) / 2)), -lambda];\n    }\n    transverseMercatorRaw.invert = function (x, y) {\n        return [-y, 2 * atan(exp(x)) - halfPi];\n    };\n    function transverseMercator() {\n        var m = mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;\n        m.center = function (_) {\n            return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n        };\n        m.rotate = function (_) {\n            return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n        };\n        return rotate([0, 0, 90])\n            .scale(159.155);\n    }\n    exports.geoAlbers = albers;\n    exports.geoAlbersUsa = albersUsa;\n    exports.geoArea = area;\n    exports.geoAzimuthalEqualArea = azimuthalEqualArea;\n    exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;\n    exports.geoAzimuthalEquidistant = azimuthalEquidistant;\n    exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;\n    exports.geoBounds = bounds;\n    exports.geoCentroid = centroid;\n    exports.geoCircle = circle;\n    exports.geoClipAntimeridian = clipAntimeridian;\n    exports.geoClipCircle = clipCircle;\n    exports.geoClipExtent = extent;\n    exports.geoClipRectangle = clipRectangle;\n    exports.geoConicConformal = conicConformal;\n    exports.geoConicConformalRaw = conicConformalRaw;\n    exports.geoConicEqualArea = conicEqualArea;\n    exports.geoConicEqualAreaRaw = conicEqualAreaRaw;\n    exports.geoConicEquidistant = conicEquidistant;\n    exports.geoConicEquidistantRaw = conicEquidistantRaw;\n    exports.geoContains = contains;\n    exports.geoDistance = distance;\n    exports.geoEqualEarth = equalEarth;\n    exports.geoEqualEarthRaw = equalEarthRaw;\n    exports.geoEquirectangular = equirectangular;\n    exports.geoEquirectangularRaw = equirectangularRaw;\n    exports.geoGnomonic = gnomonic;\n    exports.geoGnomonicRaw = gnomonicRaw;\n    exports.geoGraticule = graticule;\n    exports.geoGraticule10 = graticule10;\n    exports.geoIdentity = identity$1;\n    exports.geoInterpolate = interpolate;\n    exports.geoLength = length;\n    exports.geoMercator = mercator;\n    exports.geoMercatorRaw = mercatorRaw;\n    exports.geoNaturalEarth1 = naturalEarth1;\n    exports.geoNaturalEarth1Raw = naturalEarth1Raw;\n    exports.geoOrthographic = orthographic;\n    exports.geoOrthographicRaw = orthographicRaw;\n    exports.geoPath = index;\n    exports.geoProjection = projection;\n    exports.geoProjectionMutator = projectionMutator;\n    exports.geoRotation = rotation;\n    exports.geoStereographic = stereographic;\n    exports.geoStereographicRaw = stereographicRaw;\n    exports.geoStream = geoStream;\n    exports.geoTransform = transform;\n    exports.geoTransverseMercator = transverseMercator;\n    exports.geoTransverseMercatorRaw = transverseMercatorRaw;\n    Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-geo/ Version 1.6.4. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! d3-array */ \"./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js\")) :\n        undefined;\n}(this, (function (exports, d3Array) {\n    'use strict';\n    // Adds floating point numbers with twice the normal precision.\n    // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n    // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n    // 305–363 (1997).\n    // Code adapted from GeographicLib by Charles F. F. Karney,\n    // http://geographiclib.sourceforge.net/\n    var adder = function () {\n        return new Adder;\n    };\n    function Adder() {\n        this.reset();\n    }\n    Adder.prototype = {\n        constructor: Adder,\n        reset: function () {\n            this.s = // rounded value\n                this.t = 0; // exact error\n        },\n        add: function (y) {\n            add(temp, y, this.t);\n            add(this, temp.s, this.s);\n            if (this.s)\n                this.t += temp.t;\n            else\n                this.s = temp.t;\n        },\n        valueOf: function () {\n            return this.s;\n        }\n    };\n    var temp = new Adder;\n    function add(adder, a, b) {\n        var x = adder.s = a + b, bv = x - a, av = x - bv;\n        adder.t = (a - av) + (b - bv);\n    }\n    var epsilon = 1e-6;\n    var epsilon2 = 1e-12;\n    var pi = Math.PI;\n    var halfPi = pi / 2;\n    var quarterPi = pi / 4;\n    var tau = pi * 2;\n    var degrees = 180 / pi;\n    var radians = pi / 180;\n    var abs = Math.abs;\n    var atan = Math.atan;\n    var atan2 = Math.atan2;\n    var cos = Math.cos;\n    var ceil = Math.ceil;\n    var exp = Math.exp;\n    var log = Math.log;\n    var pow = Math.pow;\n    var sin = Math.sin;\n    var sign = Math.sign || function (x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\n    var sqrt = Math.sqrt;\n    var tan = Math.tan;\n    function acos(x) {\n        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n    }\n    function asin(x) {\n        return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n    }\n    function haversin(x) {\n        return (x = sin(x / 2)) * x;\n    }\n    function noop() { }\n    function streamGeometry(geometry, stream) {\n        if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n            streamGeometryType[geometry.type](geometry, stream);\n        }\n    }\n    var streamObjectType = {\n        Feature: function (object, stream) {\n            streamGeometry(object.geometry, stream);\n        },\n        FeatureCollection: function (object, stream) {\n            var features = object.features, i = -1, n = features.length;\n            while (++i < n)\n                streamGeometry(features[i].geometry, stream);\n        }\n    };\n    var streamGeometryType = {\n        Sphere: function (object, stream) {\n            stream.sphere();\n        },\n        Point: function (object, stream) {\n            object = object.coordinates;\n            stream.point(object[0], object[1], object[2]);\n        },\n        MultiPoint: function (object, stream) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                object = coordinates[i], stream.point(object[0], object[1], object[2]);\n        },\n        LineString: function (object, stream) {\n            streamLine(object.coordinates, stream, 0);\n        },\n        MultiLineString: function (object, stream) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                streamLine(coordinates[i], stream, 0);\n        },\n        Polygon: function (object, stream) {\n            streamPolygon(object.coordinates, stream);\n        },\n        MultiPolygon: function (object, stream) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                streamPolygon(coordinates[i], stream);\n        },\n        GeometryCollection: function (object, stream) {\n            var geometries = object.geometries, i = -1, n = geometries.length;\n            while (++i < n)\n                streamGeometry(geometries[i], stream);\n        }\n    };\n    function streamLine(coordinates, stream, closed) {\n        var i = -1, n = coordinates.length - closed, coordinate;\n        stream.lineStart();\n        while (++i < n)\n            coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n        stream.lineEnd();\n    }\n    function streamPolygon(coordinates, stream) {\n        var i = -1, n = coordinates.length;\n        stream.polygonStart();\n        while (++i < n)\n            streamLine(coordinates[i], stream, 1);\n        stream.polygonEnd();\n    }\n    var geoStream = function (object, stream) {\n        if (object && streamObjectType.hasOwnProperty(object.type)) {\n            streamObjectType[object.type](object, stream);\n        }\n        else {\n            streamGeometry(object, stream);\n        }\n    };\n    var areaRingSum = adder();\n    var areaSum = adder();\n    var lambda00;\n    var phi00;\n    var lambda0;\n    var cosPhi0;\n    var sinPhi0;\n    var areaStream = {\n        point: noop,\n        lineStart: noop,\n        lineEnd: noop,\n        polygonStart: function () {\n            areaRingSum.reset();\n            areaStream.lineStart = areaRingStart;\n            areaStream.lineEnd = areaRingEnd;\n        },\n        polygonEnd: function () {\n            var areaRing = +areaRingSum;\n            areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);\n            this.lineStart = this.lineEnd = this.point = noop;\n        },\n        sphere: function () {\n            areaSum.add(tau);\n        }\n    };\n    function areaRingStart() {\n        areaStream.point = areaPointFirst;\n    }\n    function areaRingEnd() {\n        areaPoint(lambda00, phi00);\n    }\n    function areaPointFirst(lambda, phi) {\n        areaStream.point = areaPoint;\n        lambda00 = lambda, phi00 = phi;\n        lambda *= radians, phi *= radians;\n        lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);\n    }\n    function areaPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        phi = phi / 2 + quarterPi; // half the angular distance from south pole\n        // Spherical excess E for a spherical triangle with vertices: south pole,\n        // previous point, current point.  Uses a formula derived from Cagnoli’s\n        // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n        var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi), sinPhi = sin(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos(adLambda), v = k * sdLambda * sin(adLambda);\n        areaRingSum.add(atan2(v, u));\n        // Advance the previous points.\n        lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n    }\n    var area = function (object) {\n        areaSum.reset();\n        geoStream(object, areaStream);\n        return areaSum * 2;\n    };\n    function spherical(cartesian) {\n        return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n    }\n    function cartesian(spherical) {\n        var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);\n        return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n    }\n    function cartesianDot(a, b) {\n        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    }\n    function cartesianCross(a, b) {\n        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n    }\n    // TODO return a\n    function cartesianAddInPlace(a, b) {\n        a[0] += b[0], a[1] += b[1], a[2] += b[2];\n    }\n    function cartesianScale(vector, k) {\n        return [vector[0] * k, vector[1] * k, vector[2] * k];\n    }\n    // TODO return d\n    function cartesianNormalizeInPlace(d) {\n        var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n        d[0] /= l, d[1] /= l, d[2] /= l;\n    }\n    var lambda0$1;\n    var phi0;\n    var lambda1;\n    var phi1;\n    var lambda2;\n    var lambda00$1;\n    var phi00$1;\n    var p0;\n    var deltaSum = adder();\n    var ranges;\n    var range$1;\n    var boundsStream = {\n        point: boundsPoint,\n        lineStart: boundsLineStart,\n        lineEnd: boundsLineEnd,\n        polygonStart: function () {\n            boundsStream.point = boundsRingPoint;\n            boundsStream.lineStart = boundsRingStart;\n            boundsStream.lineEnd = boundsRingEnd;\n            deltaSum.reset();\n            areaStream.polygonStart();\n        },\n        polygonEnd: function () {\n            areaStream.polygonEnd();\n            boundsStream.point = boundsPoint;\n            boundsStream.lineStart = boundsLineStart;\n            boundsStream.lineEnd = boundsLineEnd;\n            if (areaRingSum < 0)\n                lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n            else if (deltaSum > epsilon)\n                phi1 = 90;\n            else if (deltaSum < -epsilon)\n                phi0 = -90;\n            range$1[0] = lambda0$1, range$1[1] = lambda1;\n        }\n    };\n    function boundsPoint(lambda, phi) {\n        ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);\n        if (phi < phi0)\n            phi0 = phi;\n        if (phi > phi1)\n            phi1 = phi;\n    }\n    function linePoint(lambda, phi) {\n        var p = cartesian([lambda * radians, phi * radians]);\n        if (p0) {\n            var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);\n            cartesianNormalizeInPlace(inflection);\n            inflection = spherical(inflection);\n            var delta = lambda - lambda2, sign$$1 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign$$1, phii, antimeridian = abs(delta) > 180;\n            if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n                phii = inflection[1] * degrees;\n                if (phii > phi1)\n                    phi1 = phii;\n            }\n            else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {\n                phii = -inflection[1] * degrees;\n                if (phii < phi0)\n                    phi0 = phii;\n            }\n            else {\n                if (phi < phi0)\n                    phi0 = phi;\n                if (phi > phi1)\n                    phi1 = phi;\n            }\n            if (antimeridian) {\n                if (lambda < lambda2) {\n                    if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))\n                        lambda1 = lambda;\n                }\n                else {\n                    if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))\n                        lambda0$1 = lambda;\n                }\n            }\n            else {\n                if (lambda1 >= lambda0$1) {\n                    if (lambda < lambda0$1)\n                        lambda0$1 = lambda;\n                    if (lambda > lambda1)\n                        lambda1 = lambda;\n                }\n                else {\n                    if (lambda > lambda2) {\n                        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))\n                            lambda1 = lambda;\n                    }\n                    else {\n                        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))\n                            lambda0$1 = lambda;\n                    }\n                }\n            }\n        }\n        else {\n            ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);\n        }\n        if (phi < phi0)\n            phi0 = phi;\n        if (phi > phi1)\n            phi1 = phi;\n        p0 = p, lambda2 = lambda;\n    }\n    function boundsLineStart() {\n        boundsStream.point = linePoint;\n    }\n    function boundsLineEnd() {\n        range$1[0] = lambda0$1, range$1[1] = lambda1;\n        boundsStream.point = boundsPoint;\n        p0 = null;\n    }\n    function boundsRingPoint(lambda, phi) {\n        if (p0) {\n            var delta = lambda - lambda2;\n            deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n        }\n        else {\n            lambda00$1 = lambda, phi00$1 = phi;\n        }\n        areaStream.point(lambda, phi);\n        linePoint(lambda, phi);\n    }\n    function boundsRingStart() {\n        areaStream.lineStart();\n    }\n    function boundsRingEnd() {\n        boundsRingPoint(lambda00$1, phi00$1);\n        areaStream.lineEnd();\n        if (abs(deltaSum) > epsilon)\n            lambda0$1 = -(lambda1 = 180);\n        range$1[0] = lambda0$1, range$1[1] = lambda1;\n        p0 = null;\n    }\n    // Finds the left-right distance between two longitudes.\n    // This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want\n    // the distance between ±180° to be 360°.\n    function angle(lambda0, lambda1) {\n        return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n    }\n    function rangeCompare(a, b) {\n        return a[0] - b[0];\n    }\n    function rangeContains(range$$1, x) {\n        return range$$1[0] <= range$$1[1] ? range$$1[0] <= x && x <= range$$1[1] : x < range$$1[0] || range$$1[1] < x;\n    }\n    var bounds = function (feature) {\n        var i, n, a, b, merged, deltaMax, delta;\n        phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);\n        ranges = [];\n        geoStream(feature, boundsStream);\n        // First, sort ranges by their minimum longitudes.\n        if (n = ranges.length) {\n            ranges.sort(rangeCompare);\n            // Then, merge any ranges that overlap.\n            for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n                b = ranges[i];\n                if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n                    if (angle(a[0], b[1]) > angle(a[0], a[1]))\n                        a[1] = b[1];\n                    if (angle(b[0], a[1]) > angle(a[0], a[1]))\n                        a[0] = b[0];\n                }\n                else {\n                    merged.push(a = b);\n                }\n            }\n            // Finally, find the largest gap between the merged ranges.\n            // The final bounding box will be the inverse of this gap.\n            for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n                b = merged[i];\n                if ((delta = angle(a[1], b[0])) > deltaMax)\n                    deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];\n            }\n        }\n        ranges = range$1 = null;\n        return lambda0$1 === Infinity || phi0 === Infinity\n            ? [[NaN, NaN], [NaN, NaN]]\n            : [[lambda0$1, phi0], [lambda1, phi1]];\n    };\n    var W0;\n    var W1;\n    var X0;\n    var Y0;\n    var Z0;\n    var X1;\n    var Y1;\n    var Z1;\n    var X2;\n    var Y2;\n    var Z2;\n    var lambda00$2;\n    var phi00$2;\n    var x0;\n    var y0;\n    var z0; // previous point\n    var centroidStream = {\n        sphere: noop,\n        point: centroidPoint,\n        lineStart: centroidLineStart,\n        lineEnd: centroidLineEnd,\n        polygonStart: function () {\n            centroidStream.lineStart = centroidRingStart;\n            centroidStream.lineEnd = centroidRingEnd;\n        },\n        polygonEnd: function () {\n            centroidStream.lineStart = centroidLineStart;\n            centroidStream.lineEnd = centroidLineEnd;\n        }\n    };\n    // Arithmetic mean of Cartesian vectors.\n    function centroidPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi);\n        centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n    }\n    function centroidPointCartesian(x, y, z) {\n        ++W0;\n        X0 += (x - X0) / W0;\n        Y0 += (y - Y0) / W0;\n        Z0 += (z - Z0) / W0;\n    }\n    function centroidLineStart() {\n        centroidStream.point = centroidLinePointFirst;\n    }\n    function centroidLinePointFirst(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi);\n        x0 = cosPhi * cos(lambda);\n        y0 = cosPhi * sin(lambda);\n        z0 = sin(phi);\n        centroidStream.point = centroidLinePoint;\n        centroidPointCartesian(x0, y0, z0);\n    }\n    function centroidLinePoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n        W1 += w;\n        X1 += w * (x0 + (x0 = x));\n        Y1 += w * (y0 + (y0 = y));\n        Z1 += w * (z0 + (z0 = z));\n        centroidPointCartesian(x0, y0, z0);\n    }\n    function centroidLineEnd() {\n        centroidStream.point = centroidPoint;\n    }\n    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n    // J. Applied Mechanics 42, 239 (1975).\n    function centroidRingStart() {\n        centroidStream.point = centroidRingPointFirst;\n    }\n    function centroidRingEnd() {\n        centroidRingPoint(lambda00$2, phi00$2);\n        centroidStream.point = centroidPoint;\n    }\n    function centroidRingPointFirst(lambda, phi) {\n        lambda00$2 = lambda, phi00$2 = phi;\n        lambda *= radians, phi *= radians;\n        centroidStream.point = centroidRingPoint;\n        var cosPhi = cos(phi);\n        x0 = cosPhi * cos(lambda);\n        y0 = cosPhi * sin(lambda);\n        z0 = sin(phi);\n        centroidPointCartesian(x0, y0, z0);\n    }\n    function centroidRingPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = sqrt(cx * cx + cy * cy + cz * cz), w = asin(m), // line weight = angle\n        v = m && -w / m; // area weight multiplier\n        X2 += v * cx;\n        Y2 += v * cy;\n        Z2 += v * cz;\n        W1 += w;\n        X1 += w * (x0 + (x0 = x));\n        Y1 += w * (y0 + (y0 = y));\n        Z1 += w * (z0 + (z0 = z));\n        centroidPointCartesian(x0, y0, z0);\n    }\n    var centroid = function (object) {\n        W0 = W1 =\n            X0 = Y0 = Z0 =\n                X1 = Y1 = Z1 =\n                    X2 = Y2 = Z2 = 0;\n        geoStream(object, centroidStream);\n        var x = X2, y = Y2, z = Z2, m = x * x + y * y + z * z;\n        // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n        if (m < epsilon2) {\n            x = X1, y = Y1, z = Z1;\n            // If the feature has zero length, fall back to arithmetic mean of point vectors.\n            if (W1 < epsilon)\n                x = X0, y = Y0, z = Z0;\n            m = x * x + y * y + z * z;\n            // If the feature still has an undefined ccentroid, then return.\n            if (m < epsilon2)\n                return [NaN, NaN];\n        }\n        return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];\n    };\n    var constant = function (x) {\n        return function () {\n            return x;\n        };\n    };\n    var compose = function (a, b) {\n        function compose(x, y) {\n            return x = a(x, y), b(x[0], x[1]);\n        }\n        if (a.invert && b.invert)\n            compose.invert = function (x, y) {\n                return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n            };\n        return compose;\n    };\n    function rotationIdentity(lambda, phi) {\n        return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n    }\n    rotationIdentity.invert = rotationIdentity;\n    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n        return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n            : rotationLambda(deltaLambda))\n            : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n                : rotationIdentity);\n    }\n    function forwardRotationLambda(deltaLambda) {\n        return function (lambda, phi) {\n            return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n        };\n    }\n    function rotationLambda(deltaLambda) {\n        var rotation = forwardRotationLambda(deltaLambda);\n        rotation.invert = forwardRotationLambda(-deltaLambda);\n        return rotation;\n    }\n    function rotationPhiGamma(deltaPhi, deltaGamma) {\n        var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);\n        function rotation(lambda, phi) {\n            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;\n            return [\n                atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n                asin(k * cosDeltaGamma + y * sinDeltaGamma)\n            ];\n        }\n        rotation.invert = function (lambda, phi) {\n            var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;\n            return [\n                atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n                asin(k * cosDeltaPhi - x * sinDeltaPhi)\n            ];\n        };\n        return rotation;\n    }\n    var rotation = function (rotate) {\n        rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n        function forward(coordinates) {\n            coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n            return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n        }\n        forward.invert = function (coordinates) {\n            coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n            return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n        };\n        return forward;\n    };\n    // Generates a circle centered at [0°, 0°], with a given radius and precision.\n    function circleStream(stream, radius, delta, direction, t0, t1) {\n        if (!delta)\n            return;\n        var cosRadius = cos(radius), sinRadius = sin(radius), step = direction * delta;\n        if (t0 == null) {\n            t0 = radius + direction * tau;\n            t1 = radius - step / 2;\n        }\n        else {\n            t0 = circleRadius(cosRadius, t0);\n            t1 = circleRadius(cosRadius, t1);\n            if (direction > 0 ? t0 < t1 : t0 > t1)\n                t0 += direction * tau;\n        }\n        for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n            point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n            stream.point(point[0], point[1]);\n        }\n    }\n    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\n    function circleRadius(cosRadius, point) {\n        point = cartesian(point), point[0] -= cosRadius;\n        cartesianNormalizeInPlace(point);\n        var radius = acos(-point[1]);\n        return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n    }\n    var circle = function () {\n        var center = constant([0, 0]), radius = constant(90), precision = constant(6), ring, rotate, stream = { point: point };\n        function point(x, y) {\n            ring.push(x = rotate(x, y));\n            x[0] *= degrees, x[1] *= degrees;\n        }\n        function circle() {\n            var c = center.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;\n            ring = [];\n            rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n            circleStream(stream, r, p, 1);\n            c = { type: \"Polygon\", coordinates: [ring] };\n            ring = rotate = null;\n            return c;\n        }\n        circle.center = function (_) {\n            return arguments.length ? (center = typeof _ === \"function\" ? _ : constant([+_[0], +_[1]]), circle) : center;\n        };\n        circle.radius = function (_) {\n            return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), circle) : radius;\n        };\n        circle.precision = function (_) {\n            return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant(+_), circle) : precision;\n        };\n        return circle;\n    };\n    var clipBuffer = function () {\n        var lines = [], line;\n        return {\n            point: function (x, y) {\n                line.push([x, y]);\n            },\n            lineStart: function () {\n                lines.push(line = []);\n            },\n            lineEnd: noop,\n            rejoin: function () {\n                if (lines.length > 1)\n                    lines.push(lines.pop().concat(lines.shift()));\n            },\n            result: function () {\n                var result = lines;\n                lines = [];\n                line = null;\n                return result;\n            }\n        };\n    };\n    var clipLine = function (a, b, x0, y0, x1, y1) {\n        var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;\n        r = x0 - ax;\n        if (!dx && r > 0)\n            return;\n        r /= dx;\n        if (dx < 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        else if (dx > 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        r = x1 - ax;\n        if (!dx && r < 0)\n            return;\n        r /= dx;\n        if (dx < 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        else if (dx > 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        r = y0 - ay;\n        if (!dy && r > 0)\n            return;\n        r /= dy;\n        if (dy < 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        else if (dy > 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        r = y1 - ay;\n        if (!dy && r < 0)\n            return;\n        r /= dy;\n        if (dy < 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        else if (dy > 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        if (t0 > 0)\n            a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n        if (t1 < 1)\n            b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n        return true;\n    };\n    var pointEqual = function (a, b) {\n        return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n    };\n    function Intersection(point, points, other, entry) {\n        this.x = point;\n        this.z = points;\n        this.o = other; // another intersection\n        this.e = entry; // is an entry?\n        this.v = false; // visited\n        this.n = this.p = null; // next & previous\n    }\n    // A generalized polygon clipping algorithm: given a polygon that has been cut\n    // into its visible line segments, and rejoins the segments by interpolating\n    // along the clip edge.\n    var clipPolygon = function (segments, compareIntersection, startInside, interpolate, stream) {\n        var subject = [], clip = [], i, n;\n        segments.forEach(function (segment) {\n            if ((n = segment.length - 1) <= 0)\n                return;\n            var n, p0 = segment[0], p1 = segment[n], x;\n            // If the first and last points of a segment are coincident, then treat as a\n            // closed ring. TODO if all rings are closed, then the winding order of the\n            // exterior ring should be checked.\n            if (pointEqual(p0, p1)) {\n                stream.lineStart();\n                for (i = 0; i < n; ++i)\n                    stream.point((p0 = segment[i])[0], p0[1]);\n                stream.lineEnd();\n                return;\n            }\n            subject.push(x = new Intersection(p0, segment, null, true));\n            clip.push(x.o = new Intersection(p0, null, x, false));\n            subject.push(x = new Intersection(p1, segment, null, false));\n            clip.push(x.o = new Intersection(p1, null, x, true));\n        });\n        if (!subject.length)\n            return;\n        clip.sort(compareIntersection);\n        link(subject);\n        link(clip);\n        for (i = 0, n = clip.length; i < n; ++i) {\n            clip[i].e = startInside = !startInside;\n        }\n        var start = subject[0], points, point;\n        while (1) {\n            // Find first unvisited intersection.\n            var current = start, isSubject = true;\n            while (current.v)\n                if ((current = current.n) === start)\n                    return;\n            points = current.z;\n            stream.lineStart();\n            do {\n                current.v = current.o.v = true;\n                if (current.e) {\n                    if (isSubject) {\n                        for (i = 0, n = points.length; i < n; ++i)\n                            stream.point((point = points[i])[0], point[1]);\n                    }\n                    else {\n                        interpolate(current.x, current.n.x, 1, stream);\n                    }\n                    current = current.n;\n                }\n                else {\n                    if (isSubject) {\n                        points = current.p.z;\n                        for (i = points.length - 1; i >= 0; --i)\n                            stream.point((point = points[i])[0], point[1]);\n                    }\n                    else {\n                        interpolate(current.x, current.p.x, -1, stream);\n                    }\n                    current = current.p;\n                }\n                current = current.o;\n                points = current.z;\n                isSubject = !isSubject;\n            } while (!current.v);\n            stream.lineEnd();\n        }\n    };\n    function link(array) {\n        if (!(n = array.length))\n            return;\n        var n, i = 0, a = array[0], b;\n        while (++i < n) {\n            a.n = b = array[i];\n            b.p = a;\n            a = b;\n        }\n        a.n = b = array[0];\n        b.p = a;\n    }\n    var clipMax = 1e9;\n    var clipMin = -clipMax;\n    // TODO Use d3-polygon’s polygonContains here for the ring check?\n    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n    function clipExtent(x0, y0, x1, y1) {\n        function visible(x, y) {\n            return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n        }\n        function interpolate(from, to, direction, stream) {\n            var a = 0, a1 = 0;\n            if (from == null\n                || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n                || comparePoint(from, to) < 0 ^ direction > 0) {\n                do\n                    stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n                while ((a = (a + direction + 4) % 4) !== a1);\n            }\n            else {\n                stream.point(to[0], to[1]);\n            }\n        }\n        function corner(p, direction) {\n            return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n                : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n                    : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n                        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n        }\n        function compareIntersection(a, b) {\n            return comparePoint(a.x, b.x);\n        }\n        function comparePoint(a, b) {\n            var ca = corner(a, 1), cb = corner(b, 1);\n            return ca !== cb ? ca - cb\n                : ca === 0 ? b[1] - a[1]\n                    : ca === 1 ? a[0] - b[0]\n                        : ca === 2 ? a[1] - b[1]\n                            : b[0] - a[0];\n        }\n        return function (stream) {\n            var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, // first point\n            x_, y_, v_, // previous point\n            first, clean;\n            var clipStream = {\n                point: point,\n                lineStart: lineStart,\n                lineEnd: lineEnd,\n                polygonStart: polygonStart,\n                polygonEnd: polygonEnd\n            };\n            function point(x, y) {\n                if (visible(x, y))\n                    activeStream.point(x, y);\n            }\n            function polygonInside() {\n                var winding = 0;\n                for (var i = 0, n = polygon.length; i < n; ++i) {\n                    for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n                        a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n                        if (a1 <= y1) {\n                            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0))\n                                ++winding;\n                        }\n                        else {\n                            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0))\n                                --winding;\n                        }\n                    }\n                }\n                return winding;\n            }\n            // Buffer geometry within a polygon and then clip it en masse.\n            function polygonStart() {\n                activeStream = bufferStream, segments = [], polygon = [], clean = true;\n            }\n            function polygonEnd() {\n                var startInside = polygonInside(), cleanInside = clean && startInside, visible = (segments = d3Array.merge(segments)).length;\n                if (cleanInside || visible) {\n                    stream.polygonStart();\n                    if (cleanInside) {\n                        stream.lineStart();\n                        interpolate(null, null, 1, stream);\n                        stream.lineEnd();\n                    }\n                    if (visible) {\n                        clipPolygon(segments, compareIntersection, startInside, interpolate, stream);\n                    }\n                    stream.polygonEnd();\n                }\n                activeStream = stream, segments = polygon = ring = null;\n            }\n            function lineStart() {\n                clipStream.point = linePoint;\n                if (polygon)\n                    polygon.push(ring = []);\n                first = true;\n                v_ = false;\n                x_ = y_ = NaN;\n            }\n            // TODO rather than special-case polygons, simply handle them separately.\n            // Ideally, coincident intersection points should be jittered to avoid\n            // clipping issues.\n            function lineEnd() {\n                if (segments) {\n                    linePoint(x__, y__);\n                    if (v__ && v_)\n                        bufferStream.rejoin();\n                    segments.push(bufferStream.result());\n                }\n                clipStream.point = point;\n                if (v_)\n                    activeStream.lineEnd();\n            }\n            function linePoint(x, y) {\n                var v = visible(x, y);\n                if (polygon)\n                    ring.push([x, y]);\n                if (first) {\n                    x__ = x, y__ = y, v__ = v;\n                    first = false;\n                    if (v) {\n                        activeStream.lineStart();\n                        activeStream.point(x, y);\n                    }\n                }\n                else {\n                    if (v && v_)\n                        activeStream.point(x, y);\n                    else {\n                        var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n                        if (clipLine(a, b, x0, y0, x1, y1)) {\n                            if (!v_) {\n                                activeStream.lineStart();\n                                activeStream.point(a[0], a[1]);\n                            }\n                            activeStream.point(b[0], b[1]);\n                            if (!v)\n                                activeStream.lineEnd();\n                            clean = false;\n                        }\n                        else if (v) {\n                            activeStream.lineStart();\n                            activeStream.point(x, y);\n                            clean = false;\n                        }\n                    }\n                }\n                x_ = x, y_ = y, v_ = v;\n            }\n            return clipStream;\n        };\n    }\n    var extent = function () {\n        var x0 = 0, y0 = 0, x1 = 960, y1 = 500, cache, cacheStream, clip;\n        return clip = {\n            stream: function (stream) {\n                return cache && cacheStream === stream ? cache : cache = clipExtent(x0, y0, x1, y1)(cacheStream = stream);\n            },\n            extent: function (_) {\n                return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n            }\n        };\n    };\n    var sum = adder();\n    var polygonContains = function (polygon, point) {\n        var lambda = point[0], phi = point[1], normal = [sin(lambda), -cos(lambda), 0], angle = 0, winding = 0;\n        sum.reset();\n        for (var i = 0, n = polygon.length; i < n; ++i) {\n            if (!(m = (ring = polygon[i]).length))\n                continue;\n            var ring, m, point0 = ring[m - 1], lambda0 = point0[0], phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);\n            for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n                var point1 = ring[j], lambda1 = point1[0], phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign$$1 = delta >= 0 ? 1 : -1, absDelta = sign$$1 * delta, antimeridian = absDelta > pi, k = sinPhi0 * sinPhi1;\n                sum.add(atan2(k * sign$$1 * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n                angle += antimeridian ? delta + sign$$1 * tau : delta;\n                // Are the longitudes either side of the point’s meridian (lambda),\n                // and are the latitudes smaller than the parallel (phi)?\n                if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n                    var arc = cartesianCross(cartesian(point0), cartesian(point1));\n                    cartesianNormalizeInPlace(arc);\n                    var intersection = cartesianCross(normal, arc);\n                    cartesianNormalizeInPlace(intersection);\n                    var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n                    if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n                        winding += antimeridian ^ delta >= 0 ? 1 : -1;\n                    }\n                }\n            }\n        }\n        // First, determine whether the South pole is inside or outside:\n        //\n        // It is inside if:\n        // * the polygon winds around it in a clockwise direction.\n        // * the polygon does not (cumulatively) wind around it, but has a negative\n        //   (counter-clockwise) area.\n        //\n        // Second, count the (signed) number of times a segment crosses a lambda\n        // from the point to the South pole.  If it is zero, then the point is the\n        // same side as the South pole.\n        return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);\n    };\n    var lengthSum = adder();\n    var lambda0$2;\n    var sinPhi0$1;\n    var cosPhi0$1;\n    var lengthStream = {\n        sphere: noop,\n        point: noop,\n        lineStart: lengthLineStart,\n        lineEnd: noop,\n        polygonStart: noop,\n        polygonEnd: noop\n    };\n    function lengthLineStart() {\n        lengthStream.point = lengthPointFirst;\n        lengthStream.lineEnd = lengthLineEnd;\n    }\n    function lengthLineEnd() {\n        lengthStream.point = lengthStream.lineEnd = noop;\n    }\n    function lengthPointFirst(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);\n        lengthStream.point = lengthPoint;\n    }\n    function lengthPoint(lambda, phi) {\n        lambda *= radians, phi *= radians;\n        var sinPhi = sin(phi), cosPhi = cos(phi), delta = abs(lambda - lambda0$2), cosDelta = cos(delta), sinDelta = sin(delta), x = cosPhi * sinDelta, y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta, z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;\n        lengthSum.add(atan2(sqrt(x * x + y * y), z));\n        lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;\n    }\n    var length = function (object) {\n        lengthSum.reset();\n        geoStream(object, lengthStream);\n        return +lengthSum;\n    };\n    var coordinates = [null, null];\n    var object = { type: \"LineString\", coordinates: coordinates };\n    var distance = function (a, b) {\n        coordinates[0] = a;\n        coordinates[1] = b;\n        return length(object);\n    };\n    var containsObjectType = {\n        Feature: function (object, point) {\n            return containsGeometry(object.geometry, point);\n        },\n        FeatureCollection: function (object, point) {\n            var features = object.features, i = -1, n = features.length;\n            while (++i < n)\n                if (containsGeometry(features[i].geometry, point))\n                    return true;\n            return false;\n        }\n    };\n    var containsGeometryType = {\n        Sphere: function () {\n            return true;\n        },\n        Point: function (object, point) {\n            return containsPoint(object.coordinates, point);\n        },\n        MultiPoint: function (object, point) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                if (containsPoint(coordinates[i], point))\n                    return true;\n            return false;\n        },\n        LineString: function (object, point) {\n            return containsLine(object.coordinates, point);\n        },\n        MultiLineString: function (object, point) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                if (containsLine(coordinates[i], point))\n                    return true;\n            return false;\n        },\n        Polygon: function (object, point) {\n            return containsPolygon(object.coordinates, point);\n        },\n        MultiPolygon: function (object, point) {\n            var coordinates = object.coordinates, i = -1, n = coordinates.length;\n            while (++i < n)\n                if (containsPolygon(coordinates[i], point))\n                    return true;\n            return false;\n        },\n        GeometryCollection: function (object, point) {\n            var geometries = object.geometries, i = -1, n = geometries.length;\n            while (++i < n)\n                if (containsGeometry(geometries[i], point))\n                    return true;\n            return false;\n        }\n    };\n    function containsGeometry(geometry, point) {\n        return geometry && containsGeometryType.hasOwnProperty(geometry.type)\n            ? containsGeometryType[geometry.type](geometry, point)\n            : false;\n    }\n    function containsPoint(coordinates, point) {\n        return distance(coordinates, point) === 0;\n    }\n    function containsLine(coordinates, point) {\n        var ab = distance(coordinates[0], coordinates[1]), ao = distance(coordinates[0], point), ob = distance(point, coordinates[1]);\n        return ao + ob <= ab + epsilon;\n    }\n    function containsPolygon(coordinates, point) {\n        return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));\n    }\n    function ringRadians(ring) {\n        return ring = ring.map(pointRadians), ring.pop(), ring;\n    }\n    function pointRadians(point) {\n        return [point[0] * radians, point[1] * radians];\n    }\n    var contains = function (object, point) {\n        return (object && containsObjectType.hasOwnProperty(object.type)\n            ? containsObjectType[object.type]\n            : containsGeometry)(object, point);\n    };\n    function graticuleX(y0, y1, dy) {\n        var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);\n        return function (x) { return y.map(function (y) { return [x, y]; }); };\n    }\n    function graticuleY(x0, x1, dx) {\n        var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);\n        return function (y) { return x.map(function (x) { return [x, y]; }); };\n    }\n    function graticule() {\n        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;\n        function graticule() {\n            return { type: \"MultiLineString\", coordinates: lines() };\n        }\n        function lines() {\n            return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)\n                .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))\n                .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function (x) { return abs(x % DX) > epsilon; }).map(x))\n                .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function (y) { return abs(y % DY) > epsilon; }).map(y));\n        }\n        graticule.lines = function () {\n            return lines().map(function (coordinates) { return { type: \"LineString\", coordinates: coordinates }; });\n        };\n        graticule.outline = function () {\n            return {\n                type: \"Polygon\",\n                coordinates: [\n                    X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))\n                ]\n            };\n        };\n        graticule.extent = function (_) {\n            if (!arguments.length)\n                return graticule.extentMinor();\n            return graticule.extentMajor(_).extentMinor(_);\n        };\n        graticule.extentMajor = function (_) {\n            if (!arguments.length)\n                return [[X0, Y0], [X1, Y1]];\n            X0 = +_[0][0], X1 = +_[1][0];\n            Y0 = +_[0][1], Y1 = +_[1][1];\n            if (X0 > X1)\n                _ = X0, X0 = X1, X1 = _;\n            if (Y0 > Y1)\n                _ = Y0, Y0 = Y1, Y1 = _;\n            return graticule.precision(precision);\n        };\n        graticule.extentMinor = function (_) {\n            if (!arguments.length)\n                return [[x0, y0], [x1, y1]];\n            x0 = +_[0][0], x1 = +_[1][0];\n            y0 = +_[0][1], y1 = +_[1][1];\n            if (x0 > x1)\n                _ = x0, x0 = x1, x1 = _;\n            if (y0 > y1)\n                _ = y0, y0 = y1, y1 = _;\n            return graticule.precision(precision);\n        };\n        graticule.step = function (_) {\n            if (!arguments.length)\n                return graticule.stepMinor();\n            return graticule.stepMajor(_).stepMinor(_);\n        };\n        graticule.stepMajor = function (_) {\n            if (!arguments.length)\n                return [DX, DY];\n            DX = +_[0], DY = +_[1];\n            return graticule;\n        };\n        graticule.stepMinor = function (_) {\n            if (!arguments.length)\n                return [dx, dy];\n            dx = +_[0], dy = +_[1];\n            return graticule;\n        };\n        graticule.precision = function (_) {\n            if (!arguments.length)\n                return precision;\n            precision = +_;\n            x = graticuleX(y0, y1, 90);\n            y = graticuleY(x0, x1, precision);\n            X = graticuleX(Y0, Y1, 90);\n            Y = graticuleY(X0, X1, precision);\n            return graticule;\n        };\n        return graticule\n            .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])\n            .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);\n    }\n    function graticule10() {\n        return graticule()();\n    }\n    var interpolate = function (a, b) {\n        var x0 = a[0] * radians, y0 = a[1] * radians, x1 = b[0] * radians, y1 = b[1] * radians, cy0 = cos(y0), sy0 = sin(y0), cy1 = cos(y1), sy1 = sin(y1), kx0 = cy0 * cos(x0), ky0 = cy0 * sin(x0), kx1 = cy1 * cos(x1), ky1 = cy1 * sin(x1), d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))), k = sin(d);\n        var interpolate = d ? function (t) {\n            var B = sin(t *= d) / k, A = sin(d - t) / k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;\n            return [\n                atan2(y, x) * degrees,\n                atan2(z, sqrt(x * x + y * y)) * degrees\n            ];\n        } : function () {\n            return [x0 * degrees, y0 * degrees];\n        };\n        interpolate.distance = d;\n        return interpolate;\n    };\n    var identity = function (x) {\n        return x;\n    };\n    var areaSum$1 = adder();\n    var areaRingSum$1 = adder();\n    var x00;\n    var y00;\n    var x0$1;\n    var y0$1;\n    var areaStream$1 = {\n        point: noop,\n        lineStart: noop,\n        lineEnd: noop,\n        polygonStart: function () {\n            areaStream$1.lineStart = areaRingStart$1;\n            areaStream$1.lineEnd = areaRingEnd$1;\n        },\n        polygonEnd: function () {\n            areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;\n            areaSum$1.add(abs(areaRingSum$1));\n            areaRingSum$1.reset();\n        },\n        result: function () {\n            var area = areaSum$1 / 2;\n            areaSum$1.reset();\n            return area;\n        }\n    };\n    function areaRingStart$1() {\n        areaStream$1.point = areaPointFirst$1;\n    }\n    function areaPointFirst$1(x, y) {\n        areaStream$1.point = areaPoint$1;\n        x00 = x0$1 = x, y00 = y0$1 = y;\n    }\n    function areaPoint$1(x, y) {\n        areaRingSum$1.add(y0$1 * x - x0$1 * y);\n        x0$1 = x, y0$1 = y;\n    }\n    function areaRingEnd$1() {\n        areaPoint$1(x00, y00);\n    }\n    var x0$2 = Infinity;\n    var y0$2 = x0$2;\n    var x1 = -x0$2;\n    var y1 = x1;\n    var boundsStream$1 = {\n        point: boundsPoint$1,\n        lineStart: noop,\n        lineEnd: noop,\n        polygonStart: noop,\n        polygonEnd: noop,\n        result: function () {\n            var bounds = [[x0$2, y0$2], [x1, y1]];\n            x1 = y1 = -(y0$2 = x0$2 = Infinity);\n            return bounds;\n        }\n    };\n    function boundsPoint$1(x, y) {\n        if (x < x0$2)\n            x0$2 = x;\n        if (x > x1)\n            x1 = x;\n        if (y < y0$2)\n            y0$2 = y;\n        if (y > y1)\n            y1 = y;\n    }\n    // TODO Enforce positive area for exterior, negative area for interior?\n    var X0$1 = 0;\n    var Y0$1 = 0;\n    var Z0$1 = 0;\n    var X1$1 = 0;\n    var Y1$1 = 0;\n    var Z1$1 = 0;\n    var X2$1 = 0;\n    var Y2$1 = 0;\n    var Z2$1 = 0;\n    var x00$1;\n    var y00$1;\n    var x0$3;\n    var y0$3;\n    var centroidStream$1 = {\n        point: centroidPoint$1,\n        lineStart: centroidLineStart$1,\n        lineEnd: centroidLineEnd$1,\n        polygonStart: function () {\n            centroidStream$1.lineStart = centroidRingStart$1;\n            centroidStream$1.lineEnd = centroidRingEnd$1;\n        },\n        polygonEnd: function () {\n            centroidStream$1.point = centroidPoint$1;\n            centroidStream$1.lineStart = centroidLineStart$1;\n            centroidStream$1.lineEnd = centroidLineEnd$1;\n        },\n        result: function () {\n            var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]\n                : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]\n                    : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]\n                        : [NaN, NaN];\n            X0$1 = Y0$1 = Z0$1 =\n                X1$1 = Y1$1 = Z1$1 =\n                    X2$1 = Y2$1 = Z2$1 = 0;\n            return centroid;\n        }\n    };\n    function centroidPoint$1(x, y) {\n        X0$1 += x;\n        Y0$1 += y;\n        ++Z0$1;\n    }\n    function centroidLineStart$1() {\n        centroidStream$1.point = centroidPointFirstLine;\n    }\n    function centroidPointFirstLine(x, y) {\n        centroidStream$1.point = centroidPointLine;\n        centroidPoint$1(x0$3 = x, y0$3 = y);\n    }\n    function centroidPointLine(x, y) {\n        var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);\n        X1$1 += z * (x0$3 + x) / 2;\n        Y1$1 += z * (y0$3 + y) / 2;\n        Z1$1 += z;\n        centroidPoint$1(x0$3 = x, y0$3 = y);\n    }\n    function centroidLineEnd$1() {\n        centroidStream$1.point = centroidPoint$1;\n    }\n    function centroidRingStart$1() {\n        centroidStream$1.point = centroidPointFirstRing;\n    }\n    function centroidRingEnd$1() {\n        centroidPointRing(x00$1, y00$1);\n    }\n    function centroidPointFirstRing(x, y) {\n        centroidStream$1.point = centroidPointRing;\n        centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);\n    }\n    function centroidPointRing(x, y) {\n        var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);\n        X1$1 += z * (x0$3 + x) / 2;\n        Y1$1 += z * (y0$3 + y) / 2;\n        Z1$1 += z;\n        z = y0$3 * x - x0$3 * y;\n        X2$1 += z * (x0$3 + x);\n        Y2$1 += z * (y0$3 + y);\n        Z2$1 += z * 3;\n        centroidPoint$1(x0$3 = x, y0$3 = y);\n    }\n    function PathContext(context) {\n        this._context = context;\n    }\n    PathContext.prototype = {\n        _radius: 4.5,\n        pointRadius: function (_) {\n            return this._radius = _, this;\n        },\n        polygonStart: function () {\n            this._line = 0;\n        },\n        polygonEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line === 0)\n                this._context.closePath();\n            this._point = NaN;\n        },\n        point: function (x, y) {\n            switch (this._point) {\n                case 0: {\n                    this._context.moveTo(x, y);\n                    this._point = 1;\n                    break;\n                }\n                case 1: {\n                    this._context.lineTo(x, y);\n                    break;\n                }\n                default: {\n                    this._context.moveTo(x + this._radius, y);\n                    this._context.arc(x, y, this._radius, 0, tau);\n                    break;\n                }\n            }\n        },\n        result: noop\n    };\n    var lengthSum$1 = adder();\n    var lengthRing;\n    var x00$2;\n    var y00$2;\n    var x0$4;\n    var y0$4;\n    var lengthStream$1 = {\n        point: noop,\n        lineStart: function () {\n            lengthStream$1.point = lengthPointFirst$1;\n        },\n        lineEnd: function () {\n            if (lengthRing)\n                lengthPoint$1(x00$2, y00$2);\n            lengthStream$1.point = noop;\n        },\n        polygonStart: function () {\n            lengthRing = true;\n        },\n        polygonEnd: function () {\n            lengthRing = null;\n        },\n        result: function () {\n            var length = +lengthSum$1;\n            lengthSum$1.reset();\n            return length;\n        }\n    };\n    function lengthPointFirst$1(x, y) {\n        lengthStream$1.point = lengthPoint$1;\n        x00$2 = x0$4 = x, y00$2 = y0$4 = y;\n    }\n    function lengthPoint$1(x, y) {\n        x0$4 -= x, y0$4 -= y;\n        lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));\n        x0$4 = x, y0$4 = y;\n    }\n    function PathString() {\n        this._string = [];\n    }\n    PathString.prototype = {\n        _radius: 4.5,\n        _circle: circle$1(4.5),\n        pointRadius: function (_) {\n            if ((_ = +_) !== this._radius)\n                this._radius = _, this._circle = null;\n            return this;\n        },\n        polygonStart: function () {\n            this._line = 0;\n        },\n        polygonEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line === 0)\n                this._string.push(\"Z\");\n            this._point = NaN;\n        },\n        point: function (x, y) {\n            switch (this._point) {\n                case 0: {\n                    this._string.push(\"M\", x, \",\", y);\n                    this._point = 1;\n                    break;\n                }\n                case 1: {\n                    this._string.push(\"L\", x, \",\", y);\n                    break;\n                }\n                default: {\n                    if (this._circle == null)\n                        this._circle = circle$1(this._radius);\n                    this._string.push(\"M\", x, \",\", y, this._circle);\n                    break;\n                }\n            }\n        },\n        result: function () {\n            if (this._string.length) {\n                var result = this._string.join(\"\");\n                this._string = [];\n                return result;\n            }\n            else {\n                return null;\n            }\n        }\n    };\n    function circle$1(radius) {\n        return \"m0,\" + radius\n            + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n            + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n            + \"z\";\n    }\n    var index = function (projection, context) {\n        var pointRadius = 4.5, projectionStream, contextStream;\n        function path(object) {\n            if (object) {\n                if (typeof pointRadius === \"function\")\n                    contextStream.pointRadius(+pointRadius.apply(this, arguments));\n                geoStream(object, projectionStream(contextStream));\n            }\n            return contextStream.result();\n        }\n        path.area = function (object) {\n            geoStream(object, projectionStream(areaStream$1));\n            return areaStream$1.result();\n        };\n        path.measure = function (object) {\n            geoStream(object, projectionStream(lengthStream$1));\n            return lengthStream$1.result();\n        };\n        path.bounds = function (object) {\n            geoStream(object, projectionStream(boundsStream$1));\n            return boundsStream$1.result();\n        };\n        path.centroid = function (object) {\n            geoStream(object, projectionStream(centroidStream$1));\n            return centroidStream$1.result();\n        };\n        path.projection = function (_) {\n            return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;\n        };\n        path.context = function (_) {\n            if (!arguments.length)\n                return context;\n            contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);\n            if (typeof pointRadius !== \"function\")\n                contextStream.pointRadius(pointRadius);\n            return path;\n        };\n        path.pointRadius = function (_) {\n            if (!arguments.length)\n                return pointRadius;\n            pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n            return path;\n        };\n        return path.projection(projection).context(context);\n    };\n    var clip = function (pointVisible, clipLine, interpolate, start) {\n        return function (rotate, sink) {\n            var line = clipLine(sink), rotatedStart = rotate.invert(start[0], start[1]), ringBuffer = clipBuffer(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;\n            var clip = {\n                point: point,\n                lineStart: lineStart,\n                lineEnd: lineEnd,\n                polygonStart: function () {\n                    clip.point = pointRing;\n                    clip.lineStart = ringStart;\n                    clip.lineEnd = ringEnd;\n                    segments = [];\n                    polygon = [];\n                },\n                polygonEnd: function () {\n                    clip.point = point;\n                    clip.lineStart = lineStart;\n                    clip.lineEnd = lineEnd;\n                    segments = d3Array.merge(segments);\n                    var startInside = polygonContains(polygon, rotatedStart);\n                    if (segments.length) {\n                        if (!polygonStarted)\n                            sink.polygonStart(), polygonStarted = true;\n                        clipPolygon(segments, compareIntersection, startInside, interpolate, sink);\n                    }\n                    else if (startInside) {\n                        if (!polygonStarted)\n                            sink.polygonStart(), polygonStarted = true;\n                        sink.lineStart();\n                        interpolate(null, null, 1, sink);\n                        sink.lineEnd();\n                    }\n                    if (polygonStarted)\n                        sink.polygonEnd(), polygonStarted = false;\n                    segments = polygon = null;\n                },\n                sphere: function () {\n                    sink.polygonStart();\n                    sink.lineStart();\n                    interpolate(null, null, 1, sink);\n                    sink.lineEnd();\n                    sink.polygonEnd();\n                }\n            };\n            function point(lambda, phi) {\n                var point = rotate(lambda, phi);\n                if (pointVisible(lambda = point[0], phi = point[1]))\n                    sink.point(lambda, phi);\n            }\n            function pointLine(lambda, phi) {\n                var point = rotate(lambda, phi);\n                line.point(point[0], point[1]);\n            }\n            function lineStart() {\n                clip.point = pointLine;\n                line.lineStart();\n            }\n            function lineEnd() {\n                clip.point = point;\n                line.lineEnd();\n            }\n            function pointRing(lambda, phi) {\n                ring.push([lambda, phi]);\n                var point = rotate(lambda, phi);\n                ringSink.point(point[0], point[1]);\n            }\n            function ringStart() {\n                ringSink.lineStart();\n                ring = [];\n            }\n            function ringEnd() {\n                pointRing(ring[0][0], ring[0][1]);\n                ringSink.lineEnd();\n                var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point;\n                ring.pop();\n                polygon.push(ring);\n                ring = null;\n                if (!n)\n                    return;\n                // No intersections.\n                if (clean & 1) {\n                    segment = ringSegments[0];\n                    if ((m = segment.length - 1) > 0) {\n                        if (!polygonStarted)\n                            sink.polygonStart(), polygonStarted = true;\n                        sink.lineStart();\n                        for (i = 0; i < m; ++i)\n                            sink.point((point = segment[i])[0], point[1]);\n                        sink.lineEnd();\n                    }\n                    return;\n                }\n                // Rejoin connected segments.\n                // TODO reuse ringBuffer.rejoin()?\n                if (n > 1 && clean & 2)\n                    ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n                segments.push(ringSegments.filter(validSegment));\n            }\n            return clip;\n        };\n    };\n    function validSegment(segment) {\n        return segment.length > 1;\n    }\n    // Intersections are sorted along the clip edge. For both antimeridian cutting\n    // and circle clipping, the same comparison is used.\n    function compareIntersection(a, b) {\n        return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n            - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n    }\n    var clipAntimeridian = clip(function () { return true; }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi, -halfPi]);\n    // Takes a line and cuts into visible segments. Return values: 0 - there were\n    // intersections or the line was empty; 1 - no intersections; 2 - there were\n    // intersections, and the first and last segments should be rejoined.\n    function clipAntimeridianLine(stream) {\n        var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean; // no intersections\n        return {\n            lineStart: function () {\n                stream.lineStart();\n                clean = 1;\n            },\n            point: function (lambda1, phi1) {\n                var sign1 = lambda1 > 0 ? pi : -pi, delta = abs(lambda1 - lambda0);\n                if (abs(delta - pi) < epsilon) { // line crosses a pole\n                    stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n                    stream.point(sign0, phi0);\n                    stream.lineEnd();\n                    stream.lineStart();\n                    stream.point(sign1, phi0);\n                    stream.point(lambda1, phi0);\n                    clean = 0;\n                }\n                else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian\n                    if (abs(lambda0 - sign0) < epsilon)\n                        lambda0 -= sign0 * epsilon; // handle degeneracies\n                    if (abs(lambda1 - sign1) < epsilon)\n                        lambda1 -= sign1 * epsilon;\n                    phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n                    stream.point(sign0, phi0);\n                    stream.lineEnd();\n                    stream.lineStart();\n                    stream.point(sign1, phi0);\n                    clean = 0;\n                }\n                stream.point(lambda0 = lambda1, phi0 = phi1);\n                sign0 = sign1;\n            },\n            lineEnd: function () {\n                stream.lineEnd();\n                lambda0 = phi0 = NaN;\n            },\n            clean: function () {\n                return 2 - clean; // if intersections, rejoin first and last segments\n            }\n        };\n    }\n    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n        var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);\n        return abs(sinLambda0Lambda1) > epsilon\n            ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)\n                - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))\n                / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n            : (phi0 + phi1) / 2;\n    }\n    function clipAntimeridianInterpolate(from, to, direction, stream) {\n        var phi;\n        if (from == null) {\n            phi = direction * halfPi;\n            stream.point(-pi, phi);\n            stream.point(0, phi);\n            stream.point(pi, phi);\n            stream.point(pi, 0);\n            stream.point(pi, -phi);\n            stream.point(0, -phi);\n            stream.point(-pi, -phi);\n            stream.point(-pi, 0);\n            stream.point(-pi, phi);\n        }\n        else if (abs(from[0] - to[0]) > epsilon) {\n            var lambda = from[0] < to[0] ? pi : -pi;\n            phi = direction * lambda / 2;\n            stream.point(-lambda, phi);\n            stream.point(0, phi);\n            stream.point(lambda, phi);\n        }\n        else {\n            stream.point(to[0], to[1]);\n        }\n    }\n    var clipCircle = function (radius, delta) {\n        var cr = cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n        function interpolate(from, to, direction, stream) {\n            circleStream(stream, radius, delta, direction, from, to);\n        }\n        function visible(lambda, phi) {\n            return cos(lambda) * cos(phi) > cr;\n        }\n        // Takes a line and cuts into visible segments. Return values used for polygon\n        // clipping: 0 - there were intersections or the line was empty; 1 - no\n        // intersections 2 - there were intersections, and the first and last segments\n        // should be rejoined.\n        function clipLine(stream) {\n            var point0, // previous point\n            c0, // code for previous point\n            v0, // visibility of previous point\n            v00, // visibility of first point\n            clean; // no intersections\n            return {\n                lineStart: function () {\n                    v00 = v0 = false;\n                    clean = 1;\n                },\n                point: function (lambda, phi) {\n                    var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius\n                        ? v ? 0 : code(lambda, phi)\n                        : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n                    if (!point0 && (v00 = v0 = v))\n                        stream.lineStart();\n                    // Handle degeneracies.\n                    // TODO ignore if not clipping polygons.\n                    if (v !== v0) {\n                        point2 = intersect(point0, point1);\n                        if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n                            point1[0] += epsilon;\n                            point1[1] += epsilon;\n                            v = visible(point1[0], point1[1]);\n                        }\n                    }\n                    if (v !== v0) {\n                        clean = 0;\n                        if (v) {\n                            // outside going in\n                            stream.lineStart();\n                            point2 = intersect(point1, point0);\n                            stream.point(point2[0], point2[1]);\n                        }\n                        else {\n                            // inside going out\n                            point2 = intersect(point0, point1);\n                            stream.point(point2[0], point2[1]);\n                            stream.lineEnd();\n                        }\n                        point0 = point2;\n                    }\n                    else if (notHemisphere && point0 && smallRadius ^ v) {\n                        var t;\n                        // If the codes for two points are different, or are both zero,\n                        // and there this segment intersects with the small circle.\n                        if (!(c & c0) && (t = intersect(point1, point0, true))) {\n                            clean = 0;\n                            if (smallRadius) {\n                                stream.lineStart();\n                                stream.point(t[0][0], t[0][1]);\n                                stream.point(t[1][0], t[1][1]);\n                                stream.lineEnd();\n                            }\n                            else {\n                                stream.point(t[1][0], t[1][1]);\n                                stream.lineEnd();\n                                stream.lineStart();\n                                stream.point(t[0][0], t[0][1]);\n                            }\n                        }\n                    }\n                    if (v && (!point0 || !pointEqual(point0, point1))) {\n                        stream.point(point1[0], point1[1]);\n                    }\n                    point0 = point1, v0 = v, c0 = c;\n                },\n                lineEnd: function () {\n                    if (v0)\n                        stream.lineEnd();\n                    point0 = null;\n                },\n                // Rejoin first and last segments if there were intersections and the first\n                // and last points were visible.\n                clean: function () {\n                    return clean | ((v00 && v0) << 1);\n                }\n            };\n        }\n        // Intersects the great circle between a and b with the clip circle.\n        function intersect(a, b, two) {\n            var pa = cartesian(a), pb = cartesian(b);\n            // We have two planes, n1.p = d1 and n2.p = d2.\n            // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).\n            var n1 = [1, 0, 0], // normal\n            n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], // cartesianDot(n1, n2),\n            determinant = n2n2 - n1n2 * n1n2;\n            // Two polar points.\n            if (!determinant)\n                return !two && a;\n            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c2);\n            cartesianAddInPlace(A, B);\n            // Solve |p(t)|^2 = 1.\n            var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);\n            if (t2 < 0)\n                return;\n            var t = sqrt(t2), q = cartesianScale(u, (-w - t) / uu);\n            cartesianAddInPlace(q, A);\n            q = spherical(q);\n            if (!two)\n                return q;\n            // Two intersection points.\n            var lambda0 = a[0], lambda1 = b[0], phi0 = a[1], phi1 = b[1], z;\n            if (lambda1 < lambda0)\n                z = lambda0, lambda0 = lambda1, lambda1 = z;\n            var delta = lambda1 - lambda0, polar = abs(delta - pi) < epsilon, meridian = polar || delta < epsilon;\n            if (!polar && phi1 < phi0)\n                z = phi0, phi0 = phi1, phi1 = z;\n            // Check that the first point is between a and b.\n            if (meridian\n                ? polar\n                    ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n                    : phi0 <= q[1] && q[1] <= phi1\n                : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n                var q1 = cartesianScale(u, (-w + t) / uu);\n                cartesianAddInPlace(q1, A);\n                return [q, spherical(q1)];\n            }\n        }\n        // Generates a 4-bit vector representing the location of a point relative to\n        // the small circle's bounding box.\n        function code(lambda, phi) {\n            var r = smallRadius ? radius : pi - radius, code = 0;\n            if (lambda < -r)\n                code |= 1; // left\n            else if (lambda > r)\n                code |= 2; // right\n            if (phi < -r)\n                code |= 4; // below\n            else if (phi > r)\n                code |= 8; // above\n            return code;\n        }\n        return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n    };\n    var transform = function (methods) {\n        return {\n            stream: transformer(methods)\n        };\n    };\n    function transformer(methods) {\n        return function (stream) {\n            var s = new TransformStream;\n            for (var key in methods)\n                s[key] = methods[key];\n            s.stream = stream;\n            return s;\n        };\n    }\n    function TransformStream() { }\n    TransformStream.prototype = {\n        constructor: TransformStream,\n        point: function (x, y) { this.stream.point(x, y); },\n        sphere: function () { this.stream.sphere(); },\n        lineStart: function () { this.stream.lineStart(); },\n        lineEnd: function () { this.stream.lineEnd(); },\n        polygonStart: function () { this.stream.polygonStart(); },\n        polygonEnd: function () { this.stream.polygonEnd(); }\n    };\n    function fitExtent(projection, extent, object) {\n        var w = extent[1][0] - extent[0][0], h = extent[1][1] - extent[0][1], clip = projection.clipExtent && projection.clipExtent();\n        projection\n            .scale(150)\n            .translate([0, 0]);\n        if (clip != null)\n            projection.clipExtent(null);\n        geoStream(object, projection.stream(boundsStream$1));\n        var b = boundsStream$1.result(), k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n        if (clip != null)\n            projection.clipExtent(clip);\n        return projection\n            .scale(k * 150)\n            .translate([x, y]);\n    }\n    function fitSize(projection, size, object) {\n        return fitExtent(projection, [[0, 0], size], object);\n    }\n    var maxDepth = 16;\n    var cosMinDistance = cos(30 * radians); // cos(minimum angular distance)\n    var resample = function (project, delta2) {\n        return +delta2 ? resample$1(project, delta2) : resampleNone(project);\n    };\n    function resampleNone(project) {\n        return transformer({\n            point: function (x, y) {\n                x = project(x, y);\n                this.stream.point(x[0], x[1]);\n            }\n        });\n    }\n    function resample$1(project, delta2) {\n        function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;\n            if (d2 > 4 * delta2 && depth--) {\n                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt(a * a + b * b + c * c), phi2 = asin(c /= m), lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a), p = project(lambda2, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;\n                if (dz * dz / d2 > delta2 // perpendicular projected distance\n                    || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n                    || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n                    resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n                    stream.point(x2, y2);\n                    resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n                }\n            }\n        }\n        return function (stream) {\n            var lambda00, x00, y00, a00, b00, c00, // first point\n            lambda0, x0, y0, a0, b0, c0; // previous point\n            var resampleStream = {\n                point: point,\n                lineStart: lineStart,\n                lineEnd: lineEnd,\n                polygonStart: function () { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n                polygonEnd: function () { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n            };\n            function point(x, y) {\n                x = project(x, y);\n                stream.point(x[0], x[1]);\n            }\n            function lineStart() {\n                x0 = NaN;\n                resampleStream.point = linePoint;\n                stream.lineStart();\n            }\n            function linePoint(lambda, phi) {\n                var c = cartesian([lambda, phi]), p = project(lambda, phi);\n                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n                stream.point(x0, y0);\n            }\n            function lineEnd() {\n                resampleStream.point = point;\n                stream.lineEnd();\n            }\n            function ringStart() {\n                lineStart();\n                resampleStream.point = ringPoint;\n                resampleStream.lineEnd = ringEnd;\n            }\n            function ringPoint(lambda, phi) {\n                linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n                resampleStream.point = linePoint;\n            }\n            function ringEnd() {\n                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n                resampleStream.lineEnd = lineEnd;\n                lineEnd();\n            }\n            return resampleStream;\n        };\n    }\n    var transformRadians = transformer({\n        point: function (x, y) {\n            this.stream.point(x * radians, y * radians);\n        }\n    });\n    function projection(project) {\n        return projectionMutator(function () { return project; })();\n    }\n    function projectionMutator(projectAt) {\n        var project, k = 150, // scale\n        x = 480, y = 250, // translate\n        dx, dy, lambda = 0, phi = 0, // center\n        deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate\n        theta = null, preclip = clipAntimeridian, // clip angle\n        x0 = null, y0, x1, y1, postclip = identity, // clip extent\n        delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision\n        cache, cacheStream;\n        function projection(point) {\n            point = projectRotate(point[0] * radians, point[1] * radians);\n            return [point[0] * k + dx, dy - point[1] * k];\n        }\n        function invert(point) {\n            point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);\n            return point && [point[0] * degrees, point[1] * degrees];\n        }\n        function projectTransform(x, y) {\n            return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];\n        }\n        projection.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = transformRadians(preclip(rotate, projectResample(postclip(cacheStream = stream))));\n        };\n        projection.clipAngle = function (_) {\n            return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians, 6 * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n        };\n        projection.clipExtent = function (_) {\n            return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n        };\n        projection.scale = function (_) {\n            return arguments.length ? (k = +_, recenter()) : k;\n        };\n        projection.translate = function (_) {\n            return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n        };\n        projection.center = function (_) {\n            return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n        };\n        projection.rotate = function (_) {\n            return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n        };\n        projection.precision = function (_) {\n            return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n        };\n        projection.fitExtent = function (extent, object) {\n            return fitExtent(projection, extent, object);\n        };\n        projection.fitSize = function (size, object) {\n            return fitSize(projection, size, object);\n        };\n        function recenter() {\n            projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);\n            var center = project(lambda, phi);\n            dx = x - center[0] * k;\n            dy = y + center[1] * k;\n            return reset();\n        }\n        function reset() {\n            cache = cacheStream = null;\n            return projection;\n        }\n        return function () {\n            project = projectAt.apply(this, arguments);\n            projection.invert = project.invert && invert;\n            return recenter();\n        };\n    }\n    function conicProjection(projectAt) {\n        var phi0 = 0, phi1 = pi / 3, m = projectionMutator(projectAt), p = m(phi0, phi1);\n        p.parallels = function (_) {\n            return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];\n        };\n        return p;\n    }\n    function cylindricalEqualAreaRaw(phi0) {\n        var cosPhi0 = cos(phi0);\n        function forward(lambda, phi) {\n            return [lambda * cosPhi0, sin(phi) / cosPhi0];\n        }\n        forward.invert = function (x, y) {\n            return [x / cosPhi0, asin(y * cosPhi0)];\n        };\n        return forward;\n    }\n    function conicEqualAreaRaw(y0, y1) {\n        var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;\n        // Are the parallels symmetrical around the Equator?\n        if (abs(n) < epsilon)\n            return cylindricalEqualAreaRaw(y0);\n        var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;\n        function project(x, y) {\n            var r = sqrt(c - 2 * n * sin(y)) / n;\n            return [r * sin(x *= n), r0 - r * cos(x)];\n        }\n        project.invert = function (x, y) {\n            var r0y = r0 - y;\n            return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];\n        };\n        return project;\n    }\n    var conicEqualArea = function () {\n        return conicProjection(conicEqualAreaRaw)\n            .scale(155.424)\n            .center([0, 33.6442]);\n    };\n    var albers = function () {\n        return conicEqualArea()\n            .parallels([29.5, 45.5])\n            .scale(1070)\n            .translate([480, 250])\n            .rotate([96, 0])\n            .center([-0.6, 38.7]);\n    };\n    // The projections must have mutually exclusive clip regions on the sphere,\n    // as this will avoid emitting interleaving lines and polygons.\n    function multiplex(streams) {\n        var n = streams.length;\n        return {\n            point: function (x, y) { var i = -1; while (++i < n)\n                streams[i].point(x, y); },\n            sphere: function () { var i = -1; while (++i < n)\n                streams[i].sphere(); },\n            lineStart: function () { var i = -1; while (++i < n)\n                streams[i].lineStart(); },\n            lineEnd: function () { var i = -1; while (++i < n)\n                streams[i].lineEnd(); },\n            polygonStart: function () { var i = -1; while (++i < n)\n                streams[i].polygonStart(); },\n            polygonEnd: function () { var i = -1; while (++i < n)\n                streams[i].polygonEnd(); }\n        };\n    }\n    // A composite projection for the United States, configured by default for\n    // 960×500. The projection also works quite well at 960×600 if you change the\n    // scale to 1285 and adjust the translate accordingly. The set of standard\n    // parallels for each region comes from USGS, which is published here:\n    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\n    var albersUsa = function () {\n        var cache, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n        hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n        point, pointStream = { point: function (x, y) { point = [x, y]; } };\n        function albersUsa(coordinates) {\n            var x = coordinates[0], y = coordinates[1];\n            return point = null,\n                (lower48Point.point(x, y), point)\n                    || (alaskaPoint.point(x, y), point)\n                    || (hawaiiPoint.point(x, y), point);\n        }\n        albersUsa.invert = function (coordinates) {\n            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\n            return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n                : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n                    : lower48).invert(coordinates);\n        };\n        albersUsa.stream = function (stream) {\n            return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n        };\n        albersUsa.precision = function (_) {\n            if (!arguments.length)\n                return lower48.precision();\n            lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n            return reset();\n        };\n        albersUsa.scale = function (_) {\n            if (!arguments.length)\n                return lower48.scale();\n            lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n            return albersUsa.translate(lower48.translate());\n        };\n        albersUsa.translate = function (_) {\n            if (!arguments.length)\n                return lower48.translate();\n            var k = lower48.scale(), x = +_[0], y = +_[1];\n            lower48Point = lower48\n                .translate(_)\n                .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n                .stream(pointStream);\n            alaskaPoint = alaska\n                .translate([x - 0.307 * k, y + 0.201 * k])\n                .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])\n                .stream(pointStream);\n            hawaiiPoint = hawaii\n                .translate([x - 0.205 * k, y + 0.212 * k])\n                .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])\n                .stream(pointStream);\n            return reset();\n        };\n        albersUsa.fitExtent = function (extent, object) {\n            return fitExtent(albersUsa, extent, object);\n        };\n        albersUsa.fitSize = function (size, object) {\n            return fitSize(albersUsa, size, object);\n        };\n        function reset() {\n            cache = cacheStream = null;\n            return albersUsa;\n        }\n        return albersUsa.scale(1070);\n    };\n    function azimuthalRaw(scale) {\n        return function (x, y) {\n            var cx = cos(x), cy = cos(y), k = scale(cx * cy);\n            return [\n                k * cy * sin(x),\n                k * sin(y)\n            ];\n        };\n    }\n    function azimuthalInvert(angle) {\n        return function (x, y) {\n            var z = sqrt(x * x + y * y), c = angle(z), sc = sin(c), cc = cos(c);\n            return [\n                atan2(x * sc, z * cc),\n                asin(z && y * sc / z)\n            ];\n        };\n    }\n    var azimuthalEqualAreaRaw = azimuthalRaw(function (cxcy) {\n        return sqrt(2 / (1 + cxcy));\n    });\n    azimuthalEqualAreaRaw.invert = azimuthalInvert(function (z) {\n        return 2 * asin(z / 2);\n    });\n    var azimuthalEqualArea = function () {\n        return projection(azimuthalEqualAreaRaw)\n            .scale(124.75)\n            .clipAngle(180 - 1e-3);\n    };\n    var azimuthalEquidistantRaw = azimuthalRaw(function (c) {\n        return (c = acos(c)) && c / sin(c);\n    });\n    azimuthalEquidistantRaw.invert = azimuthalInvert(function (z) {\n        return z;\n    });\n    var azimuthalEquidistant = function () {\n        return projection(azimuthalEquidistantRaw)\n            .scale(79.4188)\n            .clipAngle(180 - 1e-3);\n    };\n    function mercatorRaw(lambda, phi) {\n        return [lambda, log(tan((halfPi + phi) / 2))];\n    }\n    mercatorRaw.invert = function (x, y) {\n        return [x, 2 * atan(exp(y)) - halfPi];\n    };\n    var mercator = function () {\n        return mercatorProjection(mercatorRaw)\n            .scale(961 / tau);\n    };\n    function mercatorProjection(project) {\n        var m = projection(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x0 = null, y0, x1, y1; // clip extent\n        m.scale = function (_) {\n            return arguments.length ? (scale(_), reclip()) : scale();\n        };\n        m.translate = function (_) {\n            return arguments.length ? (translate(_), reclip()) : translate();\n        };\n        m.center = function (_) {\n            return arguments.length ? (center(_), reclip()) : center();\n        };\n        m.clipExtent = function (_) {\n            return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n        };\n        function reclip() {\n            var k = pi * scale(), t = m(rotation(m.rotate()).invert([0, 0]));\n            return clipExtent(x0 == null\n                ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw\n                ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]\n                : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n        }\n        return reclip();\n    }\n    function tany(y) {\n        return tan((halfPi + y) / 2);\n    }\n    function conicConformalRaw(y0, y1) {\n        var cy0 = cos(y0), n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)), f = cy0 * pow(tany(y0), n) / n;\n        if (!n)\n            return mercatorRaw;\n        function project(x, y) {\n            if (f > 0) {\n                if (y < -halfPi + epsilon)\n                    y = -halfPi + epsilon;\n            }\n            else {\n                if (y > halfPi - epsilon)\n                    y = halfPi - epsilon;\n            }\n            var r = f / pow(tany(y), n);\n            return [r * sin(n * x), f - r * cos(n * x)];\n        }\n        project.invert = function (x, y) {\n            var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);\n            return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];\n        };\n        return project;\n    }\n    var conicConformal = function () {\n        return conicProjection(conicConformalRaw)\n            .scale(109.5)\n            .parallels([30, 30]);\n    };\n    function equirectangularRaw(lambda, phi) {\n        return [lambda, phi];\n    }\n    equirectangularRaw.invert = equirectangularRaw;\n    var equirectangular = function () {\n        return projection(equirectangularRaw)\n            .scale(152.63);\n    };\n    function conicEquidistantRaw(y0, y1) {\n        var cy0 = cos(y0), n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0), g = cy0 / n + y0;\n        if (abs(n) < epsilon)\n            return equirectangularRaw;\n        function project(x, y) {\n            var gy = g - y, nx = n * x;\n            return [gy * sin(nx), g - gy * cos(nx)];\n        }\n        project.invert = function (x, y) {\n            var gy = g - y;\n            return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];\n        };\n        return project;\n    }\n    var conicEquidistant = function () {\n        return conicProjection(conicEquidistantRaw)\n            .scale(131.154)\n            .center([0, 13.9389]);\n    };\n    function gnomonicRaw(x, y) {\n        var cy = cos(y), k = cos(x) * cy;\n        return [cy * sin(x) / k, sin(y) / k];\n    }\n    gnomonicRaw.invert = azimuthalInvert(atan);\n    var gnomonic = function () {\n        return projection(gnomonicRaw)\n            .scale(144.049)\n            .clipAngle(60);\n    };\n    function scaleTranslate(kx, ky, tx, ty) {\n        return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({\n            point: function (x, y) {\n                this.stream.point(x * kx + tx, y * ky + ty);\n            }\n        });\n    }\n    var identity$1 = function () {\n        var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = identity, // scale, translate and reflect\n        x0 = null, y0, x1, y1, clip = identity, // clip extent\n        cache, cacheStream, projection;\n        function reset() {\n            cache = cacheStream = null;\n            return projection;\n        }\n        return projection = {\n            stream: function (stream) {\n                return cache && cacheStream === stream ? cache : cache = transform(clip(cacheStream = stream));\n            },\n            clipExtent: function (_) {\n                return arguments.length ? (clip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n            },\n            scale: function (_) {\n                return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;\n            },\n            translate: function (_) {\n                return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];\n            },\n            reflectX: function (_) {\n                return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;\n            },\n            reflectY: function (_) {\n                return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;\n            },\n            fitExtent: function (extent, object) {\n                return fitExtent(projection, extent, object);\n            },\n            fitSize: function (size, object) {\n                return fitSize(projection, size, object);\n            }\n        };\n    };\n    function orthographicRaw(x, y) {\n        return [cos(y) * sin(x), sin(y)];\n    }\n    orthographicRaw.invert = azimuthalInvert(asin);\n    var orthographic = function () {\n        return projection(orthographicRaw)\n            .scale(249.5)\n            .clipAngle(90 + epsilon);\n    };\n    function stereographicRaw(x, y) {\n        var cy = cos(y), k = 1 + cos(x) * cy;\n        return [cy * sin(x) / k, sin(y) / k];\n    }\n    stereographicRaw.invert = azimuthalInvert(function (z) {\n        return 2 * atan(z);\n    });\n    var stereographic = function () {\n        return projection(stereographicRaw)\n            .scale(250)\n            .clipAngle(142);\n    };\n    function transverseMercatorRaw(lambda, phi) {\n        return [log(tan((halfPi + phi) / 2)), -lambda];\n    }\n    transverseMercatorRaw.invert = function (x, y) {\n        return [-y, 2 * atan(exp(x)) - halfPi];\n    };\n    var transverseMercator = function () {\n        var m = mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;\n        m.center = function (_) {\n            return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n        };\n        m.rotate = function (_) {\n            return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n        };\n        return rotate([0, 0, 90])\n            .scale(159.155);\n    };\n    exports.geoArea = area;\n    exports.geoBounds = bounds;\n    exports.geoCentroid = centroid;\n    exports.geoCircle = circle;\n    exports.geoClipExtent = extent;\n    exports.geoContains = contains;\n    exports.geoDistance = distance;\n    exports.geoGraticule = graticule;\n    exports.geoGraticule10 = graticule10;\n    exports.geoInterpolate = interpolate;\n    exports.geoLength = length;\n    exports.geoPath = index;\n    exports.geoAlbers = albers;\n    exports.geoAlbersUsa = albersUsa;\n    exports.geoAzimuthalEqualArea = azimuthalEqualArea;\n    exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;\n    exports.geoAzimuthalEquidistant = azimuthalEquidistant;\n    exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;\n    exports.geoConicConformal = conicConformal;\n    exports.geoConicConformalRaw = conicConformalRaw;\n    exports.geoConicEqualArea = conicEqualArea;\n    exports.geoConicEqualAreaRaw = conicEqualAreaRaw;\n    exports.geoConicEquidistant = conicEquidistant;\n    exports.geoConicEquidistantRaw = conicEquidistantRaw;\n    exports.geoEquirectangular = equirectangular;\n    exports.geoEquirectangularRaw = equirectangularRaw;\n    exports.geoGnomonic = gnomonic;\n    exports.geoGnomonicRaw = gnomonicRaw;\n    exports.geoIdentity = identity$1;\n    exports.geoProjection = projection;\n    exports.geoProjectionMutator = projectionMutator;\n    exports.geoMercator = mercator;\n    exports.geoMercatorRaw = mercatorRaw;\n    exports.geoOrthographic = orthographic;\n    exports.geoOrthographicRaw = orthographicRaw;\n    exports.geoStereographic = stereographic;\n    exports.geoStereographicRaw = stereographicRaw;\n    exports.geoTransverseMercator = transverseMercator;\n    exports.geoTransverseMercatorRaw = transverseMercatorRaw;\n    exports.geoRotation = rotation;\n    exports.geoStream = geoStream;\n    exports.geoTransform = transform;\n    Object.defineProperty(exports, '__esModule', { value: true });\n})));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-hexjson@1.1.0@d3-hexjson/build/d3-hexjson.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_d3-hexjson@1.1.0@d3-hexjson/build/d3-hexjson.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! d3-array */ \"./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js\")) :\n        undefined;\n}(this, function (exports, d3Array) {\n    'use strict';\n    // Main render method\n    function renderHexJSON(hexjson, width, height) {\n        // Get the layout\n        var layout = hexjson.layout;\n        // Get the hex objects as an array\n        var hexes = [];\n        var hexRadius = 0;\n        Object.keys(hexjson.hexes).forEach(function (key) {\n            hexjson.hexes[key].key = key;\n            hexes.push(hexjson.hexes[key]);\n        });\n        // Calculate the number of rows and columns\n        var qmax = d3Array.max(hexes, function (d) { return +d.q; }), qmin = d3Array.min(hexes, function (d) { return +d.q; }), rmax = d3Array.max(hexes, function (d) { return +d.r; }), rmin = d3Array.min(hexes, function (d) { return +d.r; });\n        var qnum = qmax - qmin + 1, rnum = rmax - rmin + 1;\n        // Calculate maximum radius the hexagons can have to fit the svg\n        if (layout === \"odd-r\" || layout === \"even-r\") {\n            hexRadius = d3Array.min([(width) / ((qnum + 0.5) * Math.sqrt(3)),\n                height / ((rnum + 1 / 3) * 1.5)]);\n        }\n        else {\n            hexRadius = d3Array.min([(height) / ((rnum + 0.5) * Math.sqrt(3)),\n                width / ((qnum + 1 / 3) * 1.5)]);\n        }\n        // Calculate the hexagon width\n        var hexWidth = hexRadius * Math.sqrt(3);\n        // Get the vertices and points for this layout\n        var vertices = getVertices(layout, hexWidth, hexRadius);\n        var points = getPoints(vertices);\n        // Calculate the values needed to render each hex and add to hexes\n        hexes.forEach(function (hex) {\n            // Calculate the absolute co-ordinates of each hex\n            hex.qc = hex.q - qmin;\n            hex.rc = rmax - hex.r;\n            // Calculate the x and y position of each hex for this svg\n            hex.x = getX(hex, layout, hexWidth, hexRadius);\n            hex.y = getY(hex, layout, hexWidth, hexRadius);\n            // Add the vertex positions and points relative to x and y\n            hex.vertices = vertices;\n            hex.points = points;\n        });\n        return hexes;\n    }\n    // Get the x position for a hex\n    function getX(hex, layout, hexWidth, hexRadius) {\n        var x = 0, xOffset = 0;\n        switch (layout) {\n            case \"odd-r\":\n                xOffset = (hex.rc % 2 === 1) ? hexWidth : (hexWidth / 2);\n                x = (hex.qc * hexWidth) + xOffset;\n                break;\n            case \"even-r\":\n                xOffset = (hex.rc % 2 === 0) ? hexWidth : (hexWidth / 2);\n                x = (hex.qc * hexWidth) + xOffset;\n                break;\n            case \"odd-q\":\n            case \"even-q\":\n                x = (hex.qc * hexRadius * 1.5) + hexRadius;\n                break;\n        }\n        return x;\n    }\n    // Get the y position for a hex\n    function getY(hex, layout, hexWidth, hexRadius) {\n        var y = 0, yOffset = 0;\n        switch (layout) {\n            case \"odd-r\":\n            case \"even-r\":\n                y = (hex.rc * hexRadius * 1.5) + hexRadius;\n                break;\n            case \"odd-q\":\n                yOffset = (hex.qc % 2 === 1) ? hexWidth : (hexWidth / 2);\n                y = (hex.rc * hexWidth) + yOffset;\n                break;\n            case \"even-q\":\n                yOffset = (hex.qc % 2 === 0) ? hexWidth : (hexWidth / 2);\n                y = (hex.rc * hexWidth) + yOffset;\n                break;\n        }\n        return y;\n    }\n    // Get the positions of the vertices for the hex:\n    // - Row layouts are ordered from the topmost vertex clockwise\n    // - Column layouts are ordered from the leftmost vertex clockwise\n    function getVertices(layout, hexWidth, hexRadius) {\n        var vertices = [];\n        switch (layout) {\n            case \"odd-r\":\n            case \"even-r\":\n                vertices.push({ x: 0, y: (0 - hexRadius) });\n                vertices.push({ x: (0 + hexWidth * 0.5), y: (0 - 0.5 * hexRadius) });\n                vertices.push({ x: (0 + hexWidth * 0.5), y: (0 + 0.5 * hexRadius) });\n                vertices.push({ x: 0, y: (0 + hexRadius) });\n                vertices.push({ x: (0 - hexWidth * 0.5), y: (0 + 0.5 * hexRadius) });\n                vertices.push({ x: (0 - hexWidth * 0.5), y: (0 - 0.5 * hexRadius) });\n                break;\n            case \"odd-q\":\n            case \"even-q\":\n                vertices.push({ x: (0 - hexRadius), y: 0 });\n                vertices.push({ x: (0 - 0.5 * hexRadius), y: (0 - hexWidth * 0.5) });\n                vertices.push({ x: (0 + 0.5 * hexRadius), y: (0 - hexWidth * 0.5) });\n                vertices.push({ x: (0 + hexRadius), y: 0 });\n                vertices.push({ x: (0 + 0.5 * hexRadius), y: (0 + hexWidth * 0.5) });\n                vertices.push({ x: (0 - 0.5 * hexRadius), y: (0 + hexWidth * 0.5) });\n                break;\n        }\n        return vertices;\n    }\n    // Get the points attribute for a polygon with these vertices\n    function getPoints(vertices) {\n        var points = \"\";\n        vertices.forEach(function (v) { points += v.x + \",\" + v.y + \" \"; });\n        return points.substring(0, points.length - 1);\n    }\n    // Creates a hexjson grid with the layout and dimensions of the given hexjson\n    function getGridForHexJSON(hexjson) {\n        // Create a new HexJSON object for the grid\n        var grid = {};\n        grid.layout = hexjson.layout;\n        grid.hexes = {};\n        // Get the hex objects from the hexjson as an array\n        var hexes = [];\n        Object.keys(hexjson.hexes).forEach(function (key) {\n            hexes.push(hexjson.hexes[key]);\n        });\n        // Calculate the number of rows and columns in the grid\n        var qmax = d3Array.max(hexes, function (d) { return +d.q; }), qmin = d3Array.min(hexes, function (d) { return +d.q; }), rmax = d3Array.max(hexes, function (d) { return +d.r; }), rmin = d3Array.min(hexes, function (d) { return +d.r; });\n        // Create the hexjson grid\n        var i, j, fkey;\n        for (i = qmin; i <= qmax; i++) {\n            for (j = rmin; j <= rmax; j++) {\n                fkey = \"Q\" + i + \"R\" + j;\n                grid.hexes[fkey] = { q: i, r: j };\n            }\n        }\n        return grid;\n    }\n    // Creates a list of dots along the boundaries between\n    // hexes which have different values of \"field\"\n    function getBoundaryDotsForHexJSON(hexjson, width, height, field) {\n        // Get the hex objects from the hexjson as an array\n        var hexes = [];\n        var layout = hexjson.layout;\n        Object.keys(hexjson.hexes).forEach(function (key) {\n            hexes.push(hexjson.hexes[key]);\n        });\n        // Calculate the number of rows and columns\n        var qmax = d3Array.max(hexes, function (d) { return +d.q; }), qmin = d3Array.min(hexes, function (d) { return +d.q; }), rmax = d3Array.max(hexes, function (d) { return +d.r; }), rmin = d3Array.min(hexes, function (d) { return +d.r; });\n        var qnum = qmax - qmin + 1, rnum = rmax - rmin + 1;\n        var hexRadius;\n        // Calculate maximum radius the hexagons can have to fit the svg\n        if (layout === \"odd-r\" || layout === \"even-r\") {\n            hexRadius = d3Array.min([(width) / ((qnum + 0.5) * Math.sqrt(3)),\n                height / ((rnum + 1 / 3) * 1.5)]);\n        }\n        else {\n            hexRadius = d3Array.min([(height) / ((rnum + 0.5) * Math.sqrt(3)),\n                width / ((qnum + 1 / 3) * 1.5)]);\n        }\n        // Calculate the hexagon width\n        var hexWidth = hexRadius * Math.sqrt(3);\n        // Create an array into which we will put points along the\n        // boundaries between differing hexes.\n        // Each edge has five points, equally spaced.\n        var lines = [];\n        var hexRadiusSquared = hexRadius * hexRadius * 4;\n        var maxHex = hexes.length;\n        if (maxHex > 1) {\n            hexes.forEach(function (hex) {\n                hex.qc = hex.q - qmin;\n                hex.rc = rmax - hex.r;\n                // Calculate the x and y position of each hex for this svg\n                hex.x = getX(hex, layout, hexWidth, hexRadius);\n                hex.y = getY(hex, layout, hexWidth, hexRadius);\n            });\n            for (var i = 0; i < maxHex - 1; i++) {\n                for (var j = i + 1; j < maxHex; j++) {\n                    var hex = hexes[i];\n                    var otherHex = hexes[j];\n                    if (hex[field] !== otherHex[field]) {\n                        if (Math.abs(hex.q - otherHex.q) <= 1 &&\n                            Math.abs(hex.r - otherHex.r) <= 1) {\n                            if (((hex.x - otherHex.x) * (hex.x - otherHex.x)) +\n                                ((hex.y - otherHex.y) * (hex.y - otherHex.y)) < hexRadiusSquared) {\n                                // They're neighbours\n                                var midpoint = {};\n                                midpoint.x = otherHex.x + (hex.x - otherHex.x) / 2;\n                                midpoint.y = otherHex.y + (hex.y - otherHex.y) / 2;\n                                var perp = {};\n                                var denom = Math.sqrt(3) * 4;\n                                perp.dx = (hex.y - otherHex.y) / denom;\n                                perp.dy = -(hex.x - otherHex.x) / denom;\n                                lines.push({ x: midpoint.x - 2 * perp.dx, y: midpoint.y - 2 * perp.dy });\n                                lines.push({ x: midpoint.x - perp.dx, y: midpoint.y - perp.dy });\n                                lines.push({ x: midpoint.x, y: midpoint.y });\n                                lines.push({ x: midpoint.x + perp.dx, y: midpoint.y + perp.dy });\n                                lines.push({ x: midpoint.x + 2 * perp.dx, y: midpoint.y + 2 * perp.dy });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return lines;\n    }\n    // Creates a list of line segments along the boundaries\n    // between hexes which have different values of \"field\"\n    function getBoundarySegmentsForHexJSON(hexjson, width, height, field) {\n        // Get the hex objects from the hexjson as an array\n        var hexes = [];\n        var layout = hexjson.layout;\n        Object.keys(hexjson.hexes).forEach(function (key) {\n            hexes.push(hexjson.hexes[key]);\n        });\n        // Calculate the number of rows and columns\n        var qmax = d3Array.max(hexes, function (d) { return +d.q; }), qmin = d3Array.min(hexes, function (d) { return +d.q; }), rmax = d3Array.max(hexes, function (d) { return +d.r; }), rmin = d3Array.min(hexes, function (d) { return +d.r; });\n        var qnum = qmax - qmin + 1, rnum = rmax - rmin + 1;\n        var hexRadius;\n        // Calculate maximum radius the hexagons can have to fit the svg\n        if (layout === \"odd-r\" || layout === \"even-r\") {\n            hexRadius = d3Array.min([(width) / ((qnum + 0.5) * Math.sqrt(3)),\n                height / ((rnum + 1 / 3) * 1.5)]);\n        }\n        else {\n            hexRadius = d3Array.min([(height) / ((rnum + 0.5) * Math.sqrt(3)),\n                width / ((qnum + 1 / 3) * 1.5)]);\n        }\n        // Calculate the hexagon width\n        var hexWidth = hexRadius * Math.sqrt(3);\n        // Create an array into which we will put points along the\n        // boundaries between differing hexes.\n        // Each segment will be of the form\n        // {x: <start point X>, y: <start point Y>, cx: <difference X>, cy: <difference Y> }\n        // intended to be used with the simple line drawing functionality of d3\n        //\n        var segments = [];\n        var hexRadiusSquared = hexRadius * hexRadius * 4;\n        var maxHex = hexes.length;\n        if (maxHex > 1) {\n            hexes.forEach(function (hex) {\n                hex.qc = hex.q - qmin;\n                hex.rc = rmax - hex.r;\n                // Calculate the x and y position of each hex for this svg\n                hex.x = getX(hex, layout, hexWidth, hexRadius);\n                hex.y = getY(hex, layout, hexWidth, hexRadius);\n            });\n            for (var i = 0; i < maxHex - 1; i++) {\n                for (var j = i + 1; j < maxHex; j++) {\n                    var hex = hexes[i];\n                    var otherHex = hexes[j];\n                    if (hex[field] !== otherHex[field]) {\n                        if (Math.abs(hex.q - otherHex.q) <= 1 &&\n                            Math.abs(hex.r - otherHex.r) <= 1) {\n                            if (((hex.x - otherHex.x) * (hex.x - otherHex.x)) +\n                                ((hex.y - otherHex.y) * (hex.y - otherHex.y)) < hexRadiusSquared) {\n                                // They're neighbours\n                                var midpoint = {};\n                                midpoint.x = otherHex.x + (hex.x - otherHex.x) / 2;\n                                midpoint.y = otherHex.y + (hex.y - otherHex.y) / 2;\n                                var perp = {};\n                                var direction = +1;\n                                if (hex[field] < otherHex[field]) {\n                                    direction = -1;\n                                } // otherwise, direction will be +1\n                                var denom = Math.sqrt(3) * 2 * direction;\n                                perp.dx = (hex.y - otherHex.y) / denom;\n                                perp.dy = -(hex.x - otherHex.x) / denom;\n                                segments.push({\n                                    x1: midpoint.x - perp.dx,\n                                    y1: midpoint.y - perp.dy,\n                                    x2: midpoint.x + perp.dx,\n                                    y2: midpoint.y + perp.dy\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return segments;\n    }\n    exports.renderHexJSON = renderHexJSON;\n    exports.getGridForHexJSON = getGridForHexJSON;\n    exports.getBoundaryDotsForHexJSON = getBoundaryDotsForHexJSON;\n    exports.getBoundarySegmentsForHexJSON = getBoundarySegmentsForHexJSON;\n    Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js\":\n/*!****************************************************************************!*\\\n  !*** ./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js ***!\n  \\****************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-hierarchy/ v1.1.9 Copyright 2019 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports) :\n        undefined;\n}(this, function (exports) {\n    'use strict';\n    function defaultSeparation(a, b) {\n        return a.parent === b.parent ? 1 : 2;\n    }\n    function meanX(children) {\n        return children.reduce(meanXReduce, 0) / children.length;\n    }\n    function meanXReduce(x, c) {\n        return x + c.x;\n    }\n    function maxY(children) {\n        return 1 + children.reduce(maxYReduce, 0);\n    }\n    function maxYReduce(y, c) {\n        return Math.max(y, c.y);\n    }\n    function leafLeft(node) {\n        var children;\n        while (children = node.children)\n            node = children[0];\n        return node;\n    }\n    function leafRight(node) {\n        var children;\n        while (children = node.children)\n            node = children[children.length - 1];\n        return node;\n    }\n    function cluster() {\n        var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;\n        function cluster(root) {\n            var previousNode, x = 0;\n            // First walk, computing the initial x & y values.\n            root.eachAfter(function (node) {\n                var children = node.children;\n                if (children) {\n                    node.x = meanX(children);\n                    node.y = maxY(children);\n                }\n                else {\n                    node.x = previousNode ? x += separation(node, previousNode) : 0;\n                    node.y = 0;\n                    previousNode = node;\n                }\n            });\n            var left = leafLeft(root), right = leafRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;\n            // Second walk, normalizing x & y to the desired size.\n            return root.eachAfter(nodeSize ? function (node) {\n                node.x = (node.x - root.x) * dx;\n                node.y = (root.y - node.y) * dy;\n            } : function (node) {\n                node.x = (node.x - x0) / (x1 - x0) * dx;\n                node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;\n            });\n        }\n        cluster.separation = function (x) {\n            return arguments.length ? (separation = x, cluster) : separation;\n        };\n        cluster.size = function (x) {\n            return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);\n        };\n        cluster.nodeSize = function (x) {\n            return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);\n        };\n        return cluster;\n    }\n    function count(node) {\n        var sum = 0, children = node.children, i = children && children.length;\n        if (!i)\n            sum = 1;\n        else\n            while (--i >= 0)\n                sum += children[i].value;\n        node.value = sum;\n    }\n    function node_count() {\n        return this.eachAfter(count);\n    }\n    function node_each(callback) {\n        var node = this, current, next = [node], children, i, n;\n        do {\n            current = next.reverse(), next = [];\n            while (node = current.pop()) {\n                callback(node), children = node.children;\n                if (children)\n                    for (i = 0, n = children.length; i < n; ++i) {\n                        next.push(children[i]);\n                    }\n            }\n        } while (next.length);\n        return this;\n    }\n    function node_eachBefore(callback) {\n        var node = this, nodes = [node], children, i;\n        while (node = nodes.pop()) {\n            callback(node), children = node.children;\n            if (children)\n                for (i = children.length - 1; i >= 0; --i) {\n                    nodes.push(children[i]);\n                }\n        }\n        return this;\n    }\n    function node_eachAfter(callback) {\n        var node = this, nodes = [node], next = [], children, i, n;\n        while (node = nodes.pop()) {\n            next.push(node), children = node.children;\n            if (children)\n                for (i = 0, n = children.length; i < n; ++i) {\n                    nodes.push(children[i]);\n                }\n        }\n        while (node = next.pop()) {\n            callback(node);\n        }\n        return this;\n    }\n    function node_sum(value) {\n        return this.eachAfter(function (node) {\n            var sum = +value(node.data) || 0, children = node.children, i = children && children.length;\n            while (--i >= 0)\n                sum += children[i].value;\n            node.value = sum;\n        });\n    }\n    function node_sort(compare) {\n        return this.eachBefore(function (node) {\n            if (node.children) {\n                node.children.sort(compare);\n            }\n        });\n    }\n    function node_path(end) {\n        var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];\n        while (start !== ancestor) {\n            start = start.parent;\n            nodes.push(start);\n        }\n        var k = nodes.length;\n        while (end !== ancestor) {\n            nodes.splice(k, 0, end);\n            end = end.parent;\n        }\n        return nodes;\n    }\n    function leastCommonAncestor(a, b) {\n        if (a === b)\n            return a;\n        var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;\n        a = aNodes.pop();\n        b = bNodes.pop();\n        while (a === b) {\n            c = a;\n            a = aNodes.pop();\n            b = bNodes.pop();\n        }\n        return c;\n    }\n    function node_ancestors() {\n        var node = this, nodes = [node];\n        while (node = node.parent) {\n            nodes.push(node);\n        }\n        return nodes;\n    }\n    function node_descendants() {\n        var nodes = [];\n        this.each(function (node) {\n            nodes.push(node);\n        });\n        return nodes;\n    }\n    function node_leaves() {\n        var leaves = [];\n        this.eachBefore(function (node) {\n            if (!node.children) {\n                leaves.push(node);\n            }\n        });\n        return leaves;\n    }\n    function node_links() {\n        var root = this, links = [];\n        root.each(function (node) {\n            if (node !== root) { // Don’t include the root’s parent, if any.\n                links.push({ source: node.parent, target: node });\n            }\n        });\n        return links;\n    }\n    function hierarchy(data, children) {\n        var root = new Node(data), valued = +data.value && (root.value = data.value), node, nodes = [root], child, childs, i, n;\n        if (children == null)\n            children = defaultChildren;\n        while (node = nodes.pop()) {\n            if (valued)\n                node.value = +node.data.value;\n            if ((childs = children(node.data)) && (n = childs.length)) {\n                node.children = new Array(n);\n                for (i = n - 1; i >= 0; --i) {\n                    nodes.push(child = node.children[i] = new Node(childs[i]));\n                    child.parent = node;\n                    child.depth = node.depth + 1;\n                }\n            }\n        }\n        return root.eachBefore(computeHeight);\n    }\n    function node_copy() {\n        return hierarchy(this).eachBefore(copyData);\n    }\n    function defaultChildren(d) {\n        return d.children;\n    }\n    function copyData(node) {\n        node.data = node.data.data;\n    }\n    function computeHeight(node) {\n        var height = 0;\n        do\n            node.height = height;\n        while ((node = node.parent) && (node.height < ++height));\n    }\n    function Node(data) {\n        this.data = data;\n        this.depth =\n            this.height = 0;\n        this.parent = null;\n    }\n    Node.prototype = hierarchy.prototype = {\n        constructor: Node,\n        count: node_count,\n        each: node_each,\n        eachAfter: node_eachAfter,\n        eachBefore: node_eachBefore,\n        sum: node_sum,\n        sort: node_sort,\n        path: node_path,\n        ancestors: node_ancestors,\n        descendants: node_descendants,\n        leaves: node_leaves,\n        links: node_links,\n        copy: node_copy\n    };\n    var slice = Array.prototype.slice;\n    function shuffle(array) {\n        var m = array.length, t, i;\n        while (m) {\n            i = Math.random() * m-- | 0;\n            t = array[m];\n            array[m] = array[i];\n            array[i] = t;\n        }\n        return array;\n    }\n    function enclose(circles) {\n        var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;\n        while (i < n) {\n            p = circles[i];\n            if (e && enclosesWeak(e, p))\n                ++i;\n            else\n                e = encloseBasis(B = extendBasis(B, p)), i = 0;\n        }\n        return e;\n    }\n    function extendBasis(B, p) {\n        var i, j;\n        if (enclosesWeakAll(p, B))\n            return [p];\n        // If we get here then B must have at least one element.\n        for (i = 0; i < B.length; ++i) {\n            if (enclosesNot(p, B[i])\n                && enclosesWeakAll(encloseBasis2(B[i], p), B)) {\n                return [B[i], p];\n            }\n        }\n        // If we get here then B must have at least two elements.\n        for (i = 0; i < B.length - 1; ++i) {\n            for (j = i + 1; j < B.length; ++j) {\n                if (enclosesNot(encloseBasis2(B[i], B[j]), p)\n                    && enclosesNot(encloseBasis2(B[i], p), B[j])\n                    && enclosesNot(encloseBasis2(B[j], p), B[i])\n                    && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {\n                    return [B[i], B[j], p];\n                }\n            }\n        }\n        // If we get here then something is very wrong.\n        throw new Error;\n    }\n    function enclosesNot(a, b) {\n        var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;\n        return dr < 0 || dr * dr < dx * dx + dy * dy;\n    }\n    function enclosesWeak(a, b) {\n        var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;\n        return dr > 0 && dr * dr > dx * dx + dy * dy;\n    }\n    function enclosesWeakAll(a, B) {\n        for (var i = 0; i < B.length; ++i) {\n            if (!enclosesWeak(a, B[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function encloseBasis(B) {\n        switch (B.length) {\n            case 1: return encloseBasis1(B[0]);\n            case 2: return encloseBasis2(B[0], B[1]);\n            case 3: return encloseBasis3(B[0], B[1], B[2]);\n        }\n    }\n    function encloseBasis1(a) {\n        return {\n            x: a.x,\n            y: a.y,\n            r: a.r\n        };\n    }\n    function encloseBasis2(a, b) {\n        var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);\n        return {\n            x: (x1 + x2 + x21 / l * r21) / 2,\n            y: (y1 + y2 + y21 / l * r21) / 2,\n            r: (l + r1 + r2) / 2\n        };\n    }\n    function encloseBasis3(a, b, c) {\n        var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c.x, y3 = c.y, r3 = c.r, a2 = x1 - x2, a3 = x1 - x3, b2 = y1 - y2, b3 = y1 - y3, c2 = r2 - r1, c3 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b2 - a2 * b3, xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1, xb = (b3 * c2 - b2 * c3) / ab, ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1, yb = (a2 * c3 - a3 * c2) / ab, A = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);\n        return {\n            x: x1 + xa + xb * r,\n            y: y1 + ya + yb * r,\n            r: r\n        };\n    }\n    function place(b, a, c) {\n        var dx = b.x - a.x, x, a2, dy = b.y - a.y, y, b2, d2 = dx * dx + dy * dy;\n        if (d2) {\n            a2 = a.r + c.r, a2 *= a2;\n            b2 = b.r + c.r, b2 *= b2;\n            if (a2 > b2) {\n                x = (d2 + b2 - a2) / (2 * d2);\n                y = Math.sqrt(Math.max(0, b2 / d2 - x * x));\n                c.x = b.x - x * dx - y * dy;\n                c.y = b.y - x * dy + y * dx;\n            }\n            else {\n                x = (d2 + a2 - b2) / (2 * d2);\n                y = Math.sqrt(Math.max(0, a2 / d2 - x * x));\n                c.x = a.x + x * dx - y * dy;\n                c.y = a.y + x * dy + y * dx;\n            }\n        }\n        else {\n            c.x = a.x + c.r;\n            c.y = a.y;\n        }\n    }\n    function intersects(a, b) {\n        var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;\n        return dr > 0 && dr * dr > dx * dx + dy * dy;\n    }\n    function score(node) {\n        var a = node._, b = node.next._, ab = a.r + b.r, dx = (a.x * b.r + b.x * a.r) / ab, dy = (a.y * b.r + b.y * a.r) / ab;\n        return dx * dx + dy * dy;\n    }\n    function Node$1(circle) {\n        this._ = circle;\n        this.next = null;\n        this.previous = null;\n    }\n    function packEnclose(circles) {\n        if (!(n = circles.length))\n            return 0;\n        var a, b, c, n, aa, ca, i, j, k, sj, sk;\n        // Place the first circle.\n        a = circles[0], a.x = 0, a.y = 0;\n        if (!(n > 1))\n            return a.r;\n        // Place the second circle.\n        b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;\n        if (!(n > 2))\n            return a.r + b.r;\n        // Place the third circle.\n        place(b, a, c = circles[2]);\n        // Initialize the front-chain using the first three circles a, b and c.\n        a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);\n        a.next = c.previous = b;\n        b.next = a.previous = c;\n        c.next = b.previous = a;\n        // Attempt to place each remaining circle…\n        pack: for (i = 3; i < n; ++i) {\n            place(a._, b._, c = circles[i]), c = new Node$1(c);\n            // Find the closest intersecting circle on the front-chain, if any.\n            // “Closeness” is determined by linear distance along the front-chain.\n            // “Ahead” or “behind” is likewise determined by linear distance.\n            j = b.next, k = a.previous, sj = b._.r, sk = a._.r;\n            do {\n                if (sj <= sk) {\n                    if (intersects(j._, c._)) {\n                        b = j, a.next = b, b.previous = a, --i;\n                        continue pack;\n                    }\n                    sj += j._.r, j = j.next;\n                }\n                else {\n                    if (intersects(k._, c._)) {\n                        a = k, a.next = b, b.previous = a, --i;\n                        continue pack;\n                    }\n                    sk += k._.r, k = k.previous;\n                }\n            } while (j !== k.next);\n            // Success! Insert the new circle c between a and b.\n            c.previous = a, c.next = b, a.next = b.previous = b = c;\n            // Compute the new closest circle pair to the centroid.\n            aa = score(a);\n            while ((c = c.next) !== b) {\n                if ((ca = score(c)) < aa) {\n                    a = c, aa = ca;\n                }\n            }\n            b = a.next;\n        }\n        // Compute the enclosing circle of the front chain.\n        a = [b._], c = b;\n        while ((c = c.next) !== b)\n            a.push(c._);\n        c = enclose(a);\n        // Translate the circles to put the enclosing circle around the origin.\n        for (i = 0; i < n; ++i)\n            a = circles[i], a.x -= c.x, a.y -= c.y;\n        return c.r;\n    }\n    function siblings(circles) {\n        packEnclose(circles);\n        return circles;\n    }\n    function optional(f) {\n        return f == null ? null : required(f);\n    }\n    function required(f) {\n        if (typeof f !== \"function\")\n            throw new Error;\n        return f;\n    }\n    function constantZero() {\n        return 0;\n    }\n    function constant(x) {\n        return function () {\n            return x;\n        };\n    }\n    function defaultRadius(d) {\n        return Math.sqrt(d.value);\n    }\n    function index() {\n        var radius = null, dx = 1, dy = 1, padding = constantZero;\n        function pack(root) {\n            root.x = dx / 2, root.y = dy / 2;\n            if (radius) {\n                root.eachBefore(radiusLeaf(radius))\n                    .eachAfter(packChildren(padding, 0.5))\n                    .eachBefore(translateChild(1));\n            }\n            else {\n                root.eachBefore(radiusLeaf(defaultRadius))\n                    .eachAfter(packChildren(constantZero, 1))\n                    .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))\n                    .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));\n            }\n            return root;\n        }\n        pack.radius = function (x) {\n            return arguments.length ? (radius = optional(x), pack) : radius;\n        };\n        pack.size = function (x) {\n            return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];\n        };\n        pack.padding = function (x) {\n            return arguments.length ? (padding = typeof x === \"function\" ? x : constant(+x), pack) : padding;\n        };\n        return pack;\n    }\n    function radiusLeaf(radius) {\n        return function (node) {\n            if (!node.children) {\n                node.r = Math.max(0, +radius(node) || 0);\n            }\n        };\n    }\n    function packChildren(padding, k) {\n        return function (node) {\n            if (children = node.children) {\n                var children, i, n = children.length, r = padding(node) * k || 0, e;\n                if (r)\n                    for (i = 0; i < n; ++i)\n                        children[i].r += r;\n                e = packEnclose(children);\n                if (r)\n                    for (i = 0; i < n; ++i)\n                        children[i].r -= r;\n                node.r = e + r;\n            }\n        };\n    }\n    function translateChild(k) {\n        return function (node) {\n            var parent = node.parent;\n            node.r *= k;\n            if (parent) {\n                node.x = parent.x + k * node.x;\n                node.y = parent.y + k * node.y;\n            }\n        };\n    }\n    function roundNode(node) {\n        node.x0 = Math.round(node.x0);\n        node.y0 = Math.round(node.y0);\n        node.x1 = Math.round(node.x1);\n        node.y1 = Math.round(node.y1);\n    }\n    function treemapDice(parent, x0, y0, x1, y1) {\n        var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;\n        while (++i < n) {\n            node = nodes[i], node.y0 = y0, node.y1 = y1;\n            node.x0 = x0, node.x1 = x0 += node.value * k;\n        }\n    }\n    function partition() {\n        var dx = 1, dy = 1, padding = 0, round = false;\n        function partition(root) {\n            var n = root.height + 1;\n            root.x0 =\n                root.y0 = padding;\n            root.x1 = dx;\n            root.y1 = dy / n;\n            root.eachBefore(positionNode(dy, n));\n            if (round)\n                root.eachBefore(roundNode);\n            return root;\n        }\n        function positionNode(dy, n) {\n            return function (node) {\n                if (node.children) {\n                    treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);\n                }\n                var x0 = node.x0, y0 = node.y0, x1 = node.x1 - padding, y1 = node.y1 - padding;\n                if (x1 < x0)\n                    x0 = x1 = (x0 + x1) / 2;\n                if (y1 < y0)\n                    y0 = y1 = (y0 + y1) / 2;\n                node.x0 = x0;\n                node.y0 = y0;\n                node.x1 = x1;\n                node.y1 = y1;\n            };\n        }\n        partition.round = function (x) {\n            return arguments.length ? (round = !!x, partition) : round;\n        };\n        partition.size = function (x) {\n            return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];\n        };\n        partition.padding = function (x) {\n            return arguments.length ? (padding = +x, partition) : padding;\n        };\n        return partition;\n    }\n    var keyPrefix = \"$\", // Protect against keys like “__proto__”.\n    preroot = { depth: -1 }, ambiguous = {};\n    function defaultId(d) {\n        return d.id;\n    }\n    function defaultParentId(d) {\n        return d.parentId;\n    }\n    function stratify() {\n        var id = defaultId, parentId = defaultParentId;\n        function stratify(data) {\n            var d, i, n = data.length, root, parent, node, nodes = new Array(n), nodeId, nodeKey, nodeByKey = {};\n            for (i = 0; i < n; ++i) {\n                d = data[i], node = nodes[i] = new Node(d);\n                if ((nodeId = id(d, i, data)) != null && (nodeId += \"\")) {\n                    nodeKey = keyPrefix + (node.id = nodeId);\n                    nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;\n                }\n            }\n            for (i = 0; i < n; ++i) {\n                node = nodes[i], nodeId = parentId(data[i], i, data);\n                if (nodeId == null || !(nodeId += \"\")) {\n                    if (root)\n                        throw new Error(\"multiple roots\");\n                    root = node;\n                }\n                else {\n                    parent = nodeByKey[keyPrefix + nodeId];\n                    if (!parent)\n                        throw new Error(\"missing: \" + nodeId);\n                    if (parent === ambiguous)\n                        throw new Error(\"ambiguous: \" + nodeId);\n                    if (parent.children)\n                        parent.children.push(node);\n                    else\n                        parent.children = [node];\n                    node.parent = parent;\n                }\n            }\n            if (!root)\n                throw new Error(\"no root\");\n            root.parent = preroot;\n            root.eachBefore(function (node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);\n            root.parent = null;\n            if (n > 0)\n                throw new Error(\"cycle\");\n            return root;\n        }\n        stratify.id = function (x) {\n            return arguments.length ? (id = required(x), stratify) : id;\n        };\n        stratify.parentId = function (x) {\n            return arguments.length ? (parentId = required(x), stratify) : parentId;\n        };\n        return stratify;\n    }\n    function defaultSeparation$1(a, b) {\n        return a.parent === b.parent ? 1 : 2;\n    }\n    // function radialSeparation(a, b) {\n    //   return (a.parent === b.parent ? 1 : 2) / a.depth;\n    // }\n    // This function is used to traverse the left contour of a subtree (or\n    // subforest). It returns the successor of v on this contour. This successor is\n    // either given by the leftmost child of v or by the thread of v. The function\n    // returns null if and only if v is on the highest level of its subtree.\n    function nextLeft(v) {\n        var children = v.children;\n        return children ? children[0] : v.t;\n    }\n    // This function works analogously to nextLeft.\n    function nextRight(v) {\n        var children = v.children;\n        return children ? children[children.length - 1] : v.t;\n    }\n    // Shifts the current subtree rooted at w+. This is done by increasing\n    // prelim(w+) and mod(w+) by shift.\n    function moveSubtree(wm, wp, shift) {\n        var change = shift / (wp.i - wm.i);\n        wp.c -= change;\n        wp.s += shift;\n        wm.c += change;\n        wp.z += shift;\n        wp.m += shift;\n    }\n    // All other shifts, applied to the smaller subtrees between w- and w+, are\n    // performed by this function. To prepare the shifts, we have to adjust\n    // change(w+), shift(w+), and change(w-).\n    function executeShifts(v) {\n        var shift = 0, change = 0, children = v.children, i = children.length, w;\n        while (--i >= 0) {\n            w = children[i];\n            w.z += shift;\n            w.m += shift;\n            shift += w.s + (change += w.c);\n        }\n    }\n    // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,\n    // returns the specified (default) ancestor.\n    function nextAncestor(vim, v, ancestor) {\n        return vim.a.parent === v.parent ? vim.a : ancestor;\n    }\n    function TreeNode(node, i) {\n        this._ = node;\n        this.parent = null;\n        this.children = null;\n        this.A = null; // default ancestor\n        this.a = this; // ancestor\n        this.z = 0; // prelim\n        this.m = 0; // mod\n        this.c = 0; // change\n        this.s = 0; // shift\n        this.t = null; // thread\n        this.i = i; // number\n    }\n    TreeNode.prototype = Object.create(Node.prototype);\n    function treeRoot(root) {\n        var tree = new TreeNode(root, 0), node, nodes = [tree], child, children, i, n;\n        while (node = nodes.pop()) {\n            if (children = node._.children) {\n                node.children = new Array(n = children.length);\n                for (i = n - 1; i >= 0; --i) {\n                    nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n                    child.parent = node;\n                }\n            }\n        }\n        (tree.parent = new TreeNode(null, 0)).children = [tree];\n        return tree;\n    }\n    // Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\n    function tree() {\n        var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = null;\n        function tree(root) {\n            var t = treeRoot(root);\n            // Compute the layout using Buchheim et al.’s algorithm.\n            t.eachAfter(firstWalk), t.parent.m = -t.z;\n            t.eachBefore(secondWalk);\n            // If a fixed node size is specified, scale x and y.\n            if (nodeSize)\n                root.eachBefore(sizeNode);\n            // If a fixed tree size is specified, scale x and y based on the extent.\n            // Compute the left-most, right-most, and depth-most nodes for extents.\n            else {\n                var left = root, right = root, bottom = root;\n                root.eachBefore(function (node) {\n                    if (node.x < left.x)\n                        left = node;\n                    if (node.x > right.x)\n                        right = node;\n                    if (node.depth > bottom.depth)\n                        bottom = node;\n                });\n                var s = left === right ? 1 : separation(left, right) / 2, tx = s - left.x, kx = dx / (right.x + s + tx), ky = dy / (bottom.depth || 1);\n                root.eachBefore(function (node) {\n                    node.x = (node.x + tx) * kx;\n                    node.y = node.depth * ky;\n                });\n            }\n            return root;\n        }\n        // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n        // applied recursively to the children of v, as well as the function\n        // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n        // node v is placed to the midpoint of its outermost children.\n        function firstWalk(v) {\n            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;\n            if (children) {\n                executeShifts(v);\n                var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n                if (w) {\n                    v.z = w.z + separation(v._, w._);\n                    v.m = v.z - midpoint;\n                }\n                else {\n                    v.z = midpoint;\n                }\n            }\n            else if (w) {\n                v.z = w.z + separation(v._, w._);\n            }\n            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n        }\n        // Computes all real x-coordinates by summing up the modifiers recursively.\n        function secondWalk(v) {\n            v._.x = v.z + v.parent.m;\n            v.m += v.parent.m;\n        }\n        // The core of the algorithm. Here, a new subtree is combined with the\n        // previous subtrees. Threads are used to traverse the inside and outside\n        // contours of the left and right subtree up to the highest common level. The\n        // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n        // superscript o means outside and i means inside, the subscript - means left\n        // subtree and + means right subtree. For summing up the modifiers along the\n        // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n        // nodes of the inside contours conflict, we compute the left one of the\n        // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n        // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n        // Finally, we add a new thread (if necessary).\n        function apportion(v, w, ancestor) {\n            if (w) {\n                var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\n                while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n                    vom = nextLeft(vom);\n                    vop = nextRight(vop);\n                    vop.a = v;\n                    shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n                    if (shift > 0) {\n                        moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n                        sip += shift;\n                        sop += shift;\n                    }\n                    sim += vim.m;\n                    sip += vip.m;\n                    som += vom.m;\n                    sop += vop.m;\n                }\n                if (vim && !nextRight(vop)) {\n                    vop.t = vim;\n                    vop.m += sim - sop;\n                }\n                if (vip && !nextLeft(vom)) {\n                    vom.t = vip;\n                    vom.m += sip - som;\n                    ancestor = v;\n                }\n            }\n            return ancestor;\n        }\n        function sizeNode(node) {\n            node.x *= dx;\n            node.y = node.depth * dy;\n        }\n        tree.separation = function (x) {\n            return arguments.length ? (separation = x, tree) : separation;\n        };\n        tree.size = function (x) {\n            return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n        };\n        tree.nodeSize = function (x) {\n            return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n        };\n        return tree;\n    }\n    function treemapSlice(parent, x0, y0, x1, y1) {\n        var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;\n        while (++i < n) {\n            node = nodes[i], node.x0 = x0, node.x1 = x1;\n            node.y0 = y0, node.y1 = y0 += node.value * k;\n        }\n    }\n    var phi = (1 + Math.sqrt(5)) / 2;\n    function squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n        var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;\n        while (i0 < n) {\n            dx = x1 - x0, dy = y1 - y0;\n            // Find the next non-empty node.\n            do\n                sumValue = nodes[i1++].value;\n            while (!sumValue && i1 < n);\n            minValue = maxValue = sumValue;\n            alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n            beta = sumValue * sumValue * alpha;\n            minRatio = Math.max(maxValue / beta, beta / minValue);\n            // Keep adding nodes while the aspect ratio maintains or improves.\n            for (; i1 < n; ++i1) {\n                sumValue += nodeValue = nodes[i1].value;\n                if (nodeValue < minValue)\n                    minValue = nodeValue;\n                if (nodeValue > maxValue)\n                    maxValue = nodeValue;\n                beta = sumValue * sumValue * alpha;\n                newRatio = Math.max(maxValue / beta, beta / minValue);\n                if (newRatio > minRatio) {\n                    sumValue -= nodeValue;\n                    break;\n                }\n                minRatio = newRatio;\n            }\n            // Position and record the row orientation.\n            rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });\n            if (row.dice)\n                treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n            else\n                treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n            value -= sumValue, i0 = i1;\n        }\n        return rows;\n    }\n    var squarify = (function custom(ratio) {\n        function squarify(parent, x0, y0, x1, y1) {\n            squarifyRatio(ratio, parent, x0, y0, x1, y1);\n        }\n        squarify.ratio = function (x) {\n            return custom((x = +x) > 1 ? x : 1);\n        };\n        return squarify;\n    })(phi);\n    function index$1() {\n        var tile = squarify, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;\n        function treemap(root) {\n            root.x0 =\n                root.y0 = 0;\n            root.x1 = dx;\n            root.y1 = dy;\n            root.eachBefore(positionNode);\n            paddingStack = [0];\n            if (round)\n                root.eachBefore(roundNode);\n            return root;\n        }\n        function positionNode(node) {\n            var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;\n            if (x1 < x0)\n                x0 = x1 = (x0 + x1) / 2;\n            if (y1 < y0)\n                y0 = y1 = (y0 + y1) / 2;\n            node.x0 = x0;\n            node.y0 = y0;\n            node.x1 = x1;\n            node.y1 = y1;\n            if (node.children) {\n                p = paddingStack[node.depth + 1] = paddingInner(node) / 2;\n                x0 += paddingLeft(node) - p;\n                y0 += paddingTop(node) - p;\n                x1 -= paddingRight(node) - p;\n                y1 -= paddingBottom(node) - p;\n                if (x1 < x0)\n                    x0 = x1 = (x0 + x1) / 2;\n                if (y1 < y0)\n                    y0 = y1 = (y0 + y1) / 2;\n                tile(node, x0, y0, x1, y1);\n            }\n        }\n        treemap.round = function (x) {\n            return arguments.length ? (round = !!x, treemap) : round;\n        };\n        treemap.size = function (x) {\n            return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];\n        };\n        treemap.tile = function (x) {\n            return arguments.length ? (tile = required(x), treemap) : tile;\n        };\n        treemap.padding = function (x) {\n            return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();\n        };\n        treemap.paddingInner = function (x) {\n            return arguments.length ? (paddingInner = typeof x === \"function\" ? x : constant(+x), treemap) : paddingInner;\n        };\n        treemap.paddingOuter = function (x) {\n            return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();\n        };\n        treemap.paddingTop = function (x) {\n            return arguments.length ? (paddingTop = typeof x === \"function\" ? x : constant(+x), treemap) : paddingTop;\n        };\n        treemap.paddingRight = function (x) {\n            return arguments.length ? (paddingRight = typeof x === \"function\" ? x : constant(+x), treemap) : paddingRight;\n        };\n        treemap.paddingBottom = function (x) {\n            return arguments.length ? (paddingBottom = typeof x === \"function\" ? x : constant(+x), treemap) : paddingBottom;\n        };\n        treemap.paddingLeft = function (x) {\n            return arguments.length ? (paddingLeft = typeof x === \"function\" ? x : constant(+x), treemap) : paddingLeft;\n        };\n        return treemap;\n    }\n    function binary(parent, x0, y0, x1, y1) {\n        var nodes = parent.children, i, n = nodes.length, sum, sums = new Array(n + 1);\n        for (sums[0] = sum = i = 0; i < n; ++i) {\n            sums[i + 1] = sum += nodes[i].value;\n        }\n        partition(0, n, parent.value, x0, y0, x1, y1);\n        function partition(i, j, value, x0, y0, x1, y1) {\n            if (i >= j - 1) {\n                var node = nodes[i];\n                node.x0 = x0, node.y0 = y0;\n                node.x1 = x1, node.y1 = y1;\n                return;\n            }\n            var valueOffset = sums[i], valueTarget = (value / 2) + valueOffset, k = i + 1, hi = j - 1;\n            while (k < hi) {\n                var mid = k + hi >>> 1;\n                if (sums[mid] < valueTarget)\n                    k = mid + 1;\n                else\n                    hi = mid;\n            }\n            if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k)\n                --k;\n            var valueLeft = sums[k] - valueOffset, valueRight = value - valueLeft;\n            if ((x1 - x0) > (y1 - y0)) {\n                var xk = (x0 * valueRight + x1 * valueLeft) / value;\n                partition(i, k, valueLeft, x0, y0, xk, y1);\n                partition(k, j, valueRight, xk, y0, x1, y1);\n            }\n            else {\n                var yk = (y0 * valueRight + y1 * valueLeft) / value;\n                partition(i, k, valueLeft, x0, y0, x1, yk);\n                partition(k, j, valueRight, x0, yk, x1, y1);\n            }\n        }\n    }\n    function sliceDice(parent, x0, y0, x1, y1) {\n        (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);\n    }\n    var resquarify = (function custom(ratio) {\n        function resquarify(parent, x0, y0, x1, y1) {\n            if ((rows = parent._squarify) && (rows.ratio === ratio)) {\n                var rows, row, nodes, i, j = -1, n, m = rows.length, value = parent.value;\n                while (++j < m) {\n                    row = rows[j], nodes = row.children;\n                    for (i = row.value = 0, n = nodes.length; i < n; ++i)\n                        row.value += nodes[i].value;\n                    if (row.dice)\n                        treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);\n                    else\n                        treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);\n                    value -= row.value;\n                }\n            }\n            else {\n                parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);\n                rows.ratio = ratio;\n            }\n        }\n        resquarify.ratio = function (x) {\n            return custom((x = +x) > 1 ? x : 1);\n        };\n        return resquarify;\n    })(phi);\n    exports.cluster = cluster;\n    exports.hierarchy = hierarchy;\n    exports.pack = index;\n    exports.packEnclose = enclose;\n    exports.packSiblings = siblings;\n    exports.partition = partition;\n    exports.stratify = stratify;\n    exports.tree = tree;\n    exports.treemap = index$1;\n    exports.treemapBinary = binary;\n    exports.treemapDice = treemapDice;\n    exports.treemapResquarify = resquarify;\n    exports.treemapSlice = treemapSlice;\n    exports.treemapSliceDice = sliceDice;\n    exports.treemapSquarify = squarify;\n    Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-path@1.0.9@d3-path/dist/d3-path.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_d3-path@1.0.9@d3-path/dist/d3-path.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-path/ v1.0.9 Copyright 2019 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports) :\n        undefined;\n}(this, function (exports) {\n    'use strict';\n    var pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;\n    function Path() {\n        this._x0 = this._y0 = // start of current subpath\n            this._x1 = this._y1 = null; // end of current subpath\n        this._ = \"\";\n    }\n    function path() {\n        return new Path;\n    }\n    Path.prototype = path.prototype = {\n        constructor: Path,\n        moveTo: function (x, y) {\n            this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y);\n        },\n        closePath: function () {\n            if (this._x1 !== null) {\n                this._x1 = this._x0, this._y1 = this._y0;\n                this._ += \"Z\";\n            }\n        },\n        lineTo: function (x, y) {\n            this._ += \"L\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n        },\n        quadraticCurveTo: function (x1, y1, x, y) {\n            this._ += \"Q\" + (+x1) + \",\" + (+y1) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n        },\n        bezierCurveTo: function (x1, y1, x2, y2, x, y) {\n            this._ += \"C\" + (+x1) + \",\" + (+y1) + \",\" + (+x2) + \",\" + (+y2) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n        },\n        arcTo: function (x1, y1, x2, y2, r) {\n            x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n            var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;\n            // Is the radius negative? Error.\n            if (r < 0)\n                throw new Error(\"negative radius: \" + r);\n            // Is this path empty? Move to (x1,y1).\n            if (this._x1 === null) {\n                this._ += \"M\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n            }\n            // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n            else if (!(l01_2 > epsilon))\n                ;\n            // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n            // Equivalently, is (x1,y1) coincident with (x2,y2)?\n            // Or, is the radius zero? Line to (x1,y1).\n            else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n                this._ += \"L\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n            }\n            // Otherwise, draw an arc!\n            else {\n                var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;\n                // If the start tangent is not coincident with (x0,y0), line to.\n                if (Math.abs(t01 - 1) > epsilon) {\n                    this._ += \"L\" + (x1 + t01 * x01) + \",\" + (y1 + t01 * y01);\n                }\n                this._ += \"A\" + r + \",\" + r + \",0,0,\" + (+(y01 * x20 > x01 * y20)) + \",\" + (this._x1 = x1 + t21 * x21) + \",\" + (this._y1 = y1 + t21 * y21);\n            }\n        },\n        arc: function (x, y, r, a0, a1, ccw) {\n            x = +x, y = +y, r = +r, ccw = !!ccw;\n            var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x + dx, y0 = y + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;\n            // Is the radius negative? Error.\n            if (r < 0)\n                throw new Error(\"negative radius: \" + r);\n            // Is this path empty? Move to (x0,y0).\n            if (this._x1 === null) {\n                this._ += \"M\" + x0 + \",\" + y0;\n            }\n            // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n            else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n                this._ += \"L\" + x0 + \",\" + y0;\n            }\n            // Is this arc empty? We’re done.\n            if (!r)\n                return;\n            // Does the angle go the wrong way? Flip the direction.\n            if (da < 0)\n                da = da % tau + tau;\n            // Is this a complete circle? Draw two arcs to complete the circle.\n            if (da > tauEpsilon) {\n                this._ += \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (x - dx) + \",\" + (y - dy) + \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (this._x1 = x0) + \",\" + (this._y1 = y0);\n            }\n            // Is this arc non-empty? Draw an arc!\n            else if (da > epsilon) {\n                this._ += \"A\" + r + \",\" + r + \",0,\" + (+(da >= pi)) + \",\" + cw + \",\" + (this._x1 = x + r * Math.cos(a1)) + \",\" + (this._y1 = y + r * Math.sin(a1));\n            }\n        },\n        rect: function (x, y, w, h) {\n            this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y) + \"h\" + (+w) + \"v\" + (+h) + \"h\" + (-w) + \"Z\";\n        },\n        toString: function () {\n            return this._;\n        }\n    };\n    exports.path = path;\n    Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-sankey@0.9.1@d3-sankey/dist/d3-sankey.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_d3-sankey@0.9.1@d3-sankey/dist/d3-sankey.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\n// https://github.com/d3/d3-sankey v0.9.1 Copyright 2019 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! d3-array */ \"./node_modules/_d3-array@1.2.4@d3-array/dist/d3-array.js\"), __webpack_require__(/*! d3-collection */ \"./node_modules/_d3-collection@1.0.7@d3-collection/dist/d3-collection.js\"), __webpack_require__(/*! d3-shape */ \"./node_modules/_d3-shape@1.3.7@d3-shape/dist/d3-shape.js\")) :\n        undefined;\n}(this, function (exports, d3Array, d3Collection, d3Shape) {\n    'use strict';\n    function targetDepth(d) {\n        return d.target.depth;\n    }\n    function left(node) {\n        return node.depth;\n    }\n    function right(node, n) {\n        return n - 1 - node.height;\n    }\n    function justify(node, n) {\n        return node.sourceLinks.length ? node.depth : n - 1;\n    }\n    function center(node) {\n        return node.targetLinks.length ? node.depth\n            : node.sourceLinks.length ? d3Array.min(node.sourceLinks, targetDepth) - 1\n                : 0;\n    }\n    function constant(x) {\n        return function () {\n            return x;\n        };\n    }\n    function ascendingSourceBreadth(a, b) {\n        return ascendingBreadth(a.source, b.source) || a.index - b.index;\n    }\n    function ascendingTargetBreadth(a, b) {\n        return ascendingBreadth(a.target, b.target) || a.index - b.index;\n    }\n    function ascendingBreadth(a, b) {\n        return a.y0 - b.y0;\n    }\n    function value(d) {\n        return d.value;\n    }\n    function defaultId(d) {\n        return d.index;\n    }\n    function defaultNodes(graph) {\n        return graph.nodes;\n    }\n    function defaultLinks(graph) {\n        return graph.links;\n    }\n    function find(nodeById, id) {\n        var node = nodeById.get(id);\n        if (!node)\n            throw new Error(\"missing: \" + id);\n        return node;\n    }\n    function Sankey() {\n        var x0 = 0, y0 = 0, x1 = 1, y1 = 1, // extent\n        dx = 24, // nodeWidth\n        py = 8, // nodePadding\n        id = defaultId, align = justify, sort, nodes = defaultNodes, links = defaultLinks, iterations = 6;\n        function sankey() {\n            var graph = { nodes: nodes.apply(null, arguments), links: links.apply(null, arguments) };\n            computeNodeLinks(graph);\n            computeNodeValues(graph);\n            computeNodeDepths(graph);\n            computeNodeBreadths(graph);\n            computeLinkBreadths(graph);\n            return graph;\n        }\n        sankey.update = function (graph) {\n            computeLinkBreadths(graph);\n            return graph;\n        };\n        sankey.nodeId = function (_) {\n            return arguments.length ? (id = typeof _ === \"function\" ? _ : constant(_), sankey) : id;\n        };\n        sankey.nodeAlign = function (_) {\n            return arguments.length ? (align = typeof _ === \"function\" ? _ : constant(_), sankey) : align;\n        };\n        sankey.nodeSort = function (_) {\n            return arguments.length ? (sort = _, sankey) : sort;\n        };\n        sankey.nodeWidth = function (_) {\n            return arguments.length ? (dx = +_, sankey) : dx;\n        };\n        sankey.nodePadding = function (_) {\n            return arguments.length ? (py = +_, sankey) : py;\n        };\n        sankey.nodes = function (_) {\n            return arguments.length ? (nodes = typeof _ === \"function\" ? _ : constant(_), sankey) : nodes;\n        };\n        sankey.links = function (_) {\n            return arguments.length ? (links = typeof _ === \"function\" ? _ : constant(_), sankey) : links;\n        };\n        sankey.size = function (_) {\n            return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];\n        };\n        sankey.extent = function (_) {\n            return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];\n        };\n        sankey.iterations = function (_) {\n            return arguments.length ? (iterations = +_, sankey) : iterations;\n        };\n        // Populate the sourceLinks and targetLinks for each node.\n        // Also, if the source and target are not objects, assume they are indices.\n        function computeNodeLinks(graph) {\n            graph.nodes.forEach(function (node, i) {\n                node.index = i;\n                node.sourceLinks = [];\n                node.targetLinks = [];\n            });\n            var nodeById = d3Collection.map(graph.nodes, id);\n            graph.links.forEach(function (link, i) {\n                link.index = i;\n                var source = link.source, target = link.target;\n                if (typeof source !== \"object\")\n                    source = link.source = find(nodeById, source);\n                if (typeof target !== \"object\")\n                    target = link.target = find(nodeById, target);\n                source.sourceLinks.push(link);\n                target.targetLinks.push(link);\n            });\n        }\n        // Compute the value (size) of each node by summing the associated links.\n        function computeNodeValues(graph) {\n            graph.nodes.forEach(function (node) {\n                node.value = Math.max(d3Array.sum(node.sourceLinks, value), d3Array.sum(node.targetLinks, value));\n            });\n        }\n        // Iteratively assign the depth (x-position) for each node.\n        // Nodes are assigned the maximum depth of incoming neighbors plus one;\n        // nodes with no incoming links are assigned depth zero, while\n        // nodes with no outgoing links are assigned the maximum depth.\n        function computeNodeDepths(graph) {\n            var nodes, next, x, n = graph.nodes.length;\n            for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {\n                if (x > n)\n                    throw new Error(\"circular link\");\n                nodes.forEach(function (node) {\n                    node.depth = x;\n                    node.sourceLinks.forEach(function (link) {\n                        if (next.indexOf(link.target) < 0) {\n                            next.push(link.target);\n                        }\n                    });\n                });\n            }\n            for (nodes = graph.nodes, next = [], x = 0; nodes.length; ++x, nodes = next, next = []) {\n                if (x > n)\n                    throw new Error(\"circular link\");\n                nodes.forEach(function (node) {\n                    node.height = x;\n                    node.targetLinks.forEach(function (link) {\n                        if (next.indexOf(link.source) < 0) {\n                            next.push(link.source);\n                        }\n                    });\n                });\n            }\n            var kx = (x1 - x0 - dx) / (x - 1);\n            graph.nodes.forEach(function (node) {\n                node.x1 = (node.x0 = x0 + Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x)))) * kx) + dx;\n            });\n        }\n        function computeNodeBreadths(graph) {\n            var columns = d3Collection.nest()\n                .key(function (d) { return d.x0; })\n                .sortKeys(d3Array.ascending)\n                .entries(graph.nodes)\n                .map(function (d) { return d.values; });\n            //\n            initializeNodeBreadth();\n            resolveCollisions();\n            for (var alpha = 0.9, n = iterations; n > 0; --n, alpha *= 0.9) {\n                relaxRightToLeft(alpha);\n                resolveCollisions();\n                relaxLeftToRight(alpha);\n                resolveCollisions();\n            }\n            function initializeNodeBreadth() {\n                var ky = d3Array.min(columns, function (nodes) {\n                    return (y1 - y0 - (nodes.length - 1) * py) / d3Array.sum(nodes, value);\n                });\n                columns.forEach(function (nodes) {\n                    if (sort != null)\n                        nodes.sort(sort);\n                    nodes.forEach(function (node, i) {\n                        node.y1 = (node.y0 = i) + node.value * ky;\n                    });\n                });\n                graph.links.forEach(function (link) {\n                    link.width = link.value * ky;\n                });\n            }\n            function relaxLeftToRight(alpha) {\n                columns.forEach(function (nodes) {\n                    nodes.forEach(function (node) {\n                        var e_1, _a, e_2, _b;\n                        var y = node.y0;\n                        try {\n                            for (var _c = tslib_1.__values(node.sourceLinks.sort(ascendingTargetBreadth)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                                var _e = _d.value, target = _e.target, width = _e.width, value_1 = _e.value;\n                                if (value_1 > 0) {\n                                    var dy = 0;\n                                    try {\n                                        for (var _f = (e_2 = void 0, tslib_1.__values(target.targetLinks)), _g = _f.next(); !_g.done; _g = _f.next()) {\n                                            var _h = _g.value, source = _h.source, width_1 = _h.width;\n                                            if (source === node)\n                                                break;\n                                            dy += width_1 + py / 2;\n                                        }\n                                    }\n                                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                                    finally {\n                                        try {\n                                            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                                        }\n                                        finally { if (e_2) throw e_2.error; }\n                                    }\n                                    dy = (y - dy - target.y0) * alpha * (value_1 / Math.min(node.value, target.value));\n                                    target.y0 += dy;\n                                    target.y1 += dy;\n                                }\n                                y += width + py / 2;\n                            }\n                        }\n                        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                        finally {\n                            try {\n                                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                            }\n                            finally { if (e_1) throw e_1.error; }\n                        }\n                    });\n                });\n            }\n            function relaxRightToLeft(alpha) {\n                columns.slice().reverse().forEach(function (nodes) {\n                    nodes.forEach(function (node) {\n                        var e_3, _a, e_4, _b;\n                        var y = node.y0;\n                        try {\n                            for (var _c = tslib_1.__values(node.targetLinks.sort(ascendingSourceBreadth)), _d = _c.next(); !_d.done; _d = _c.next()) {\n                                var _e = _d.value, source = _e.source, width = _e.width, value_2 = _e.value;\n                                if (value_2 > 0) {\n                                    var dy = 0;\n                                    try {\n                                        for (var _f = (e_4 = void 0, tslib_1.__values(source.sourceLinks)), _g = _f.next(); !_g.done; _g = _f.next()) {\n                                            var _h = _g.value, target = _h.target, width_2 = _h.width;\n                                            if (target === node)\n                                                break;\n                                            dy += width_2 + py / 2;\n                                        }\n                                    }\n                                    catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                                    finally {\n                                        try {\n                                            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                                        }\n                                        finally { if (e_4) throw e_4.error; }\n                                    }\n                                    dy = (y - dy - source.y0) * alpha * (value_2 / Math.min(node.value, source.value));\n                                    source.y0 += dy;\n                                    source.y1 += dy;\n                                }\n                                y += width + py / 2;\n                            }\n                        }\n                        catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                        finally {\n                            try {\n                                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                            }\n                            finally { if (e_3) throw e_3.error; }\n                        }\n                    });\n                });\n            }\n            function resolveCollisions() {\n                columns.forEach(function (nodes) {\n                    var node, dy, y = y0, n = nodes.length, i;\n                    // Push any overlapping nodes down.\n                    if (sort === undefined)\n                        nodes.sort(ascendingBreadth);\n                    for (i = 0; i < n; ++i) {\n                        node = nodes[i];\n                        dy = y - node.y0;\n                        if (dy > 0)\n                            node.y0 += dy, node.y1 += dy;\n                        y = node.y1 + py;\n                    }\n                    // If the bottommost node goes outside the bounds, push it back up.\n                    dy = y - py - y1;\n                    if (dy > 0) {\n                        y = (node.y0 -= dy), node.y1 -= dy;\n                        // Push any overlapping nodes back up.\n                        for (i = n - 2; i >= 0; --i) {\n                            node = nodes[i];\n                            dy = node.y1 + py - y;\n                            if (dy > 0)\n                                node.y0 -= dy, node.y1 -= dy;\n                            y = node.y0;\n                        }\n                    }\n                });\n            }\n        }\n        function computeLinkBreadths(graph) {\n            graph.nodes.forEach(function (node) {\n                node.sourceLinks.sort(ascendingTargetBreadth);\n                node.targetLinks.sort(ascendingSourceBreadth);\n            });\n            graph.nodes.forEach(function (node) {\n                var y0 = node.y0, y1 = y0;\n                node.sourceLinks.forEach(function (link) {\n                    link.y0 = y0 + link.width / 2, y0 += link.width;\n                });\n                node.targetLinks.forEach(function (link) {\n                    link.y1 = y1 + link.width / 2, y1 += link.width;\n                });\n            });\n        }\n        return sankey;\n    }\n    function horizontalSource(d) {\n        return [d.source.x1, d.y0];\n    }\n    function horizontalTarget(d) {\n        return [d.target.x0, d.y1];\n    }\n    function sankeyLinkHorizontal() {\n        return d3Shape.linkHorizontal()\n            .source(horizontalSource)\n            .target(horizontalTarget);\n    }\n    exports.sankey = Sankey;\n    exports.sankeyCenter = center;\n    exports.sankeyLeft = left;\n    exports.sankeyRight = right;\n    exports.sankeyJustify = justify;\n    exports.sankeyLinkHorizontal = sankeyLinkHorizontal;\n    Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-shape@1.3.7@d3-shape/dist/d3-shape.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_d3-shape@1.3.7@d3-shape/dist/d3-shape.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-shape/ v1.3.7 Copyright 2019 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(/*! d3-path */ \"./node_modules/_d3-path@1.0.9@d3-path/dist/d3-path.js\")) :\n        undefined;\n}(this, function (exports, d3Path) {\n    'use strict';\n    function constant(x) {\n        return function constant() {\n            return x;\n        };\n    }\n    var abs = Math.abs;\n    var atan2 = Math.atan2;\n    var cos = Math.cos;\n    var max = Math.max;\n    var min = Math.min;\n    var sin = Math.sin;\n    var sqrt = Math.sqrt;\n    var epsilon = 1e-12;\n    var pi = Math.PI;\n    var halfPi = pi / 2;\n    var tau = 2 * pi;\n    function acos(x) {\n        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n    }\n    function asin(x) {\n        return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);\n    }\n    function arcInnerRadius(d) {\n        return d.innerRadius;\n    }\n    function arcOuterRadius(d) {\n        return d.outerRadius;\n    }\n    function arcStartAngle(d) {\n        return d.startAngle;\n    }\n    function arcEndAngle(d) {\n        return d.endAngle;\n    }\n    function arcPadAngle(d) {\n        return d && d.padAngle; // Note: optional!\n    }\n    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n        var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;\n        if (t * t < epsilon)\n            return;\n        t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;\n        return [x0 + t * x10, y0 + t * y10];\n    }\n    // Compute perpendicular offset line of length rc.\n    // http://mathworld.wolfram.com/Circle-LineIntersection.html\n    function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {\n        var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;\n        // Pick the closer of the two intersection points.\n        // TODO Is there a faster way to determine which intersection to use?\n        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)\n            cx0 = cx1, cy0 = cy1;\n        return {\n            cx: cx0,\n            cy: cy0,\n            x01: -ox,\n            y01: -oy,\n            x11: cx0 * (r1 / r - 1),\n            y11: cy0 * (r1 / r - 1)\n        };\n    }\n    function arc() {\n        var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;\n        function arc() {\n            var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw = a1 > a0;\n            if (!context)\n                context = buffer = d3Path.path();\n            // Ensure that the outer radius is always larger than the inner radius.\n            if (r1 < r0)\n                r = r1, r1 = r0, r0 = r;\n            // Is it a point?\n            if (!(r1 > epsilon))\n                context.moveTo(0, 0);\n            // Or is it a circle or annulus?\n            else if (da > tau - epsilon) {\n                context.moveTo(r1 * cos(a0), r1 * sin(a0));\n                context.arc(0, 0, r1, a0, a1, !cw);\n                if (r0 > epsilon) {\n                    context.moveTo(r0 * cos(a1), r0 * sin(a1));\n                    context.arc(0, 0, r0, a1, a0, cw);\n                }\n            }\n            // Or is it a circular or annular sector?\n            else {\n                var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;\n                // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.\n                if (rp > epsilon) {\n                    var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));\n                    if ((da0 -= p0 * 2) > epsilon)\n                        p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;\n                    else\n                        da0 = 0, a00 = a10 = (a0 + a1) / 2;\n                    if ((da1 -= p1 * 2) > epsilon)\n                        p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;\n                    else\n                        da1 = 0, a01 = a11 = (a0 + a1) / 2;\n                }\n                var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);\n                // Apply rounded corners?\n                if (rc > epsilon) {\n                    var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;\n                    // Restrict the corner radius according to the sector angle.\n                    if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {\n                        var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n                        rc0 = min(rc, (r0 - lc) / (kc - 1));\n                        rc1 = min(rc, (r1 - lc) / (kc + 1));\n                    }\n                }\n                // Is the sector collapsed to a line?\n                if (!(da1 > epsilon))\n                    context.moveTo(x01, y01);\n                // Does the sector’s outer ring have rounded corners?\n                else if (rc1 > epsilon) {\n                    t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);\n                    t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n                    context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);\n                    // Have the corners merged?\n                    if (rc1 < rc)\n                        context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n                    // Otherwise, draw the two corners and the ring.\n                    else {\n                        context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n                        context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);\n                        context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n                    }\n                }\n                // Or is the outer ring just a circular arc?\n                else\n                    context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n                // Is there no inner ring, and it’s a circular sector?\n                // Or perhaps it’s an annular sector collapsed due to padding?\n                if (!(r0 > epsilon) || !(da0 > epsilon))\n                    context.lineTo(x10, y10);\n                // Does the sector’s inner ring (or point) have rounded corners?\n                else if (rc0 > epsilon) {\n                    t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n                    t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);\n                    context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);\n                    // Have the corners merged?\n                    if (rc0 < rc)\n                        context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n                    // Otherwise, draw the two corners and the ring.\n                    else {\n                        context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n                        context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);\n                        context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n                    }\n                }\n                // Or is the inner ring just a circular arc?\n                else\n                    context.arc(0, 0, r0, a10, a00, cw);\n            }\n            context.closePath();\n            if (buffer)\n                return context = null, buffer + \"\" || null;\n        }\n        arc.centroid = function () {\n            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;\n            return [cos(a) * r, sin(a) * r];\n        };\n        arc.innerRadius = function (_) {\n            return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : innerRadius;\n        };\n        arc.outerRadius = function (_) {\n            return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : outerRadius;\n        };\n        arc.cornerRadius = function (_) {\n            return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : cornerRadius;\n        };\n        arc.padRadius = function (_) {\n            return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), arc) : padRadius;\n        };\n        arc.startAngle = function (_) {\n            return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : startAngle;\n        };\n        arc.endAngle = function (_) {\n            return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : endAngle;\n        };\n        arc.padAngle = function (_) {\n            return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : padAngle;\n        };\n        arc.context = function (_) {\n            return arguments.length ? ((context = _ == null ? null : _), arc) : context;\n        };\n        return arc;\n    }\n    function Linear(context) {\n        this._context = context;\n    }\n    Linear.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line || (this._line !== 0 && this._point === 1))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n                    break;\n                case 1: this._point = 2; // proceed\n                default:\n                    this._context.lineTo(x, y);\n                    break;\n            }\n        }\n    };\n    function curveLinear(context) {\n        return new Linear(context);\n    }\n    function x(p) {\n        return p[0];\n    }\n    function y(p) {\n        return p[1];\n    }\n    function line() {\n        var x$1 = x, y$1 = y, defined = constant(true), context = null, curve = curveLinear, output = null;\n        function line(data) {\n            var i, n = data.length, d, defined0 = false, buffer;\n            if (context == null)\n                output = curve(buffer = d3Path.path());\n            for (i = 0; i <= n; ++i) {\n                if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n                    if (defined0 = !defined0)\n                        output.lineStart();\n                    else\n                        output.lineEnd();\n                }\n                if (defined0)\n                    output.point(+x$1(d, i, data), +y$1(d, i, data));\n            }\n            if (buffer)\n                return output = null, buffer + \"\" || null;\n        }\n        line.x = function (_) {\n            return arguments.length ? (x$1 = typeof _ === \"function\" ? _ : constant(+_), line) : x$1;\n        };\n        line.y = function (_) {\n            return arguments.length ? (y$1 = typeof _ === \"function\" ? _ : constant(+_), line) : y$1;\n        };\n        line.defined = function (_) {\n            return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), line) : defined;\n        };\n        line.curve = function (_) {\n            return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;\n        };\n        line.context = function (_) {\n            return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;\n        };\n        return line;\n    }\n    function area() {\n        var x0 = x, x1 = null, y0 = constant(0), y1 = y, defined = constant(true), context = null, curve = curveLinear, output = null;\n        function area(data) {\n            var i, j, k, n = data.length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);\n            if (context == null)\n                output = curve(buffer = d3Path.path());\n            for (i = 0; i <= n; ++i) {\n                if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n                    if (defined0 = !defined0) {\n                        j = i;\n                        output.areaStart();\n                        output.lineStart();\n                    }\n                    else {\n                        output.lineEnd();\n                        output.lineStart();\n                        for (k = i - 1; k >= j; --k) {\n                            output.point(x0z[k], y0z[k]);\n                        }\n                        output.lineEnd();\n                        output.areaEnd();\n                    }\n                }\n                if (defined0) {\n                    x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);\n                    output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);\n                }\n            }\n            if (buffer)\n                return output = null, buffer + \"\" || null;\n        }\n        function arealine() {\n            return line().defined(defined).curve(curve).context(context);\n        }\n        area.x = function (_) {\n            return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant(+_), x1 = null, area) : x0;\n        };\n        area.x0 = function (_) {\n            return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant(+_), area) : x0;\n        };\n        area.x1 = function (_) {\n            return arguments.length ? (x1 = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), area) : x1;\n        };\n        area.y = function (_) {\n            return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant(+_), y1 = null, area) : y0;\n        };\n        area.y0 = function (_) {\n            return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant(+_), area) : y0;\n        };\n        area.y1 = function (_) {\n            return arguments.length ? (y1 = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), area) : y1;\n        };\n        area.lineX0 =\n            area.lineY0 = function () {\n                return arealine().x(x0).y(y0);\n            };\n        area.lineY1 = function () {\n            return arealine().x(x0).y(y1);\n        };\n        area.lineX1 = function () {\n            return arealine().x(x1).y(y0);\n        };\n        area.defined = function (_) {\n            return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), area) : defined;\n        };\n        area.curve = function (_) {\n            return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;\n        };\n        area.context = function (_) {\n            return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;\n        };\n        return area;\n    }\n    function descending(a, b) {\n        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n    }\n    function identity(d) {\n        return d;\n    }\n    function pie() {\n        var value = identity, sortValues = descending, sort = null, startAngle = constant(0), endAngle = constant(tau), padAngle = constant(0);\n        function pie(data) {\n            var i, n = data.length, j, k, sum = 0, index = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;\n            for (i = 0; i < n; ++i) {\n                if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {\n                    sum += v;\n                }\n            }\n            // Optionally sort the arcs by previously-computed values or by data.\n            if (sortValues != null)\n                index.sort(function (i, j) { return sortValues(arcs[i], arcs[j]); });\n            else if (sort != null)\n                index.sort(function (i, j) { return sort(data[i], data[j]); });\n            // Compute the arcs! They are stored in the original data's order.\n            for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {\n                j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {\n                    data: data[j],\n                    index: i,\n                    value: v,\n                    startAngle: a0,\n                    endAngle: a1,\n                    padAngle: p\n                };\n            }\n            return arcs;\n        }\n        pie.value = function (_) {\n            return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(+_), pie) : value;\n        };\n        pie.sortValues = function (_) {\n            return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;\n        };\n        pie.sort = function (_) {\n            return arguments.length ? (sort = _, sortValues = null, pie) : sort;\n        };\n        pie.startAngle = function (_) {\n            return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : startAngle;\n        };\n        pie.endAngle = function (_) {\n            return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : endAngle;\n        };\n        pie.padAngle = function (_) {\n            return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : padAngle;\n        };\n        return pie;\n    }\n    var curveRadialLinear = curveRadial(curveLinear);\n    function Radial(curve) {\n        this._curve = curve;\n    }\n    Radial.prototype = {\n        areaStart: function () {\n            this._curve.areaStart();\n        },\n        areaEnd: function () {\n            this._curve.areaEnd();\n        },\n        lineStart: function () {\n            this._curve.lineStart();\n        },\n        lineEnd: function () {\n            this._curve.lineEnd();\n        },\n        point: function (a, r) {\n            this._curve.point(r * Math.sin(a), r * -Math.cos(a));\n        }\n    };\n    function curveRadial(curve) {\n        function radial(context) {\n            return new Radial(curve(context));\n        }\n        radial._curve = curve;\n        return radial;\n    }\n    function lineRadial(l) {\n        var c = l.curve;\n        l.angle = l.x, delete l.x;\n        l.radius = l.y, delete l.y;\n        l.curve = function (_) {\n            return arguments.length ? c(curveRadial(_)) : c()._curve;\n        };\n        return l;\n    }\n    function lineRadial$1() {\n        return lineRadial(line().curve(curveRadialLinear));\n    }\n    function areaRadial() {\n        var a = area().curve(curveRadialLinear), c = a.curve, x0 = a.lineX0, x1 = a.lineX1, y0 = a.lineY0, y1 = a.lineY1;\n        a.angle = a.x, delete a.x;\n        a.startAngle = a.x0, delete a.x0;\n        a.endAngle = a.x1, delete a.x1;\n        a.radius = a.y, delete a.y;\n        a.innerRadius = a.y0, delete a.y0;\n        a.outerRadius = a.y1, delete a.y1;\n        a.lineStartAngle = function () { return lineRadial(x0()); }, delete a.lineX0;\n        a.lineEndAngle = function () { return lineRadial(x1()); }, delete a.lineX1;\n        a.lineInnerRadius = function () { return lineRadial(y0()); }, delete a.lineY0;\n        a.lineOuterRadius = function () { return lineRadial(y1()); }, delete a.lineY1;\n        a.curve = function (_) {\n            return arguments.length ? c(curveRadial(_)) : c()._curve;\n        };\n        return a;\n    }\n    function pointRadial(x, y) {\n        return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];\n    }\n    var slice = Array.prototype.slice;\n    function linkSource(d) {\n        return d.source;\n    }\n    function linkTarget(d) {\n        return d.target;\n    }\n    function link(curve) {\n        var source = linkSource, target = linkTarget, x$1 = x, y$1 = y, context = null;\n        function link() {\n            var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);\n            if (!context)\n                context = buffer = d3Path.path();\n            curve(context, +x$1.apply(this, (argv[0] = s, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv));\n            if (buffer)\n                return context = null, buffer + \"\" || null;\n        }\n        link.source = function (_) {\n            return arguments.length ? (source = _, link) : source;\n        };\n        link.target = function (_) {\n            return arguments.length ? (target = _, link) : target;\n        };\n        link.x = function (_) {\n            return arguments.length ? (x$1 = typeof _ === \"function\" ? _ : constant(+_), link) : x$1;\n        };\n        link.y = function (_) {\n            return arguments.length ? (y$1 = typeof _ === \"function\" ? _ : constant(+_), link) : y$1;\n        };\n        link.context = function (_) {\n            return arguments.length ? ((context = _ == null ? null : _), link) : context;\n        };\n        return link;\n    }\n    function curveHorizontal(context, x0, y0, x1, y1) {\n        context.moveTo(x0, y0);\n        context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);\n    }\n    function curveVertical(context, x0, y0, x1, y1) {\n        context.moveTo(x0, y0);\n        context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);\n    }\n    function curveRadial$1(context, x0, y0, x1, y1) {\n        var p0 = pointRadial(x0, y0), p1 = pointRadial(x0, y0 = (y0 + y1) / 2), p2 = pointRadial(x1, y0), p3 = pointRadial(x1, y1);\n        context.moveTo(p0[0], p0[1]);\n        context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n    }\n    function linkHorizontal() {\n        return link(curveHorizontal);\n    }\n    function linkVertical() {\n        return link(curveVertical);\n    }\n    function linkRadial() {\n        var l = link(curveRadial$1);\n        l.angle = l.x, delete l.x;\n        l.radius = l.y, delete l.y;\n        return l;\n    }\n    var circle = {\n        draw: function (context, size) {\n            var r = Math.sqrt(size / pi);\n            context.moveTo(r, 0);\n            context.arc(0, 0, r, 0, tau);\n        }\n    };\n    var cross = {\n        draw: function (context, size) {\n            var r = Math.sqrt(size / 5) / 2;\n            context.moveTo(-3 * r, -r);\n            context.lineTo(-r, -r);\n            context.lineTo(-r, -3 * r);\n            context.lineTo(r, -3 * r);\n            context.lineTo(r, -r);\n            context.lineTo(3 * r, -r);\n            context.lineTo(3 * r, r);\n            context.lineTo(r, r);\n            context.lineTo(r, 3 * r);\n            context.lineTo(-r, 3 * r);\n            context.lineTo(-r, r);\n            context.lineTo(-3 * r, r);\n            context.closePath();\n        }\n    };\n    var tan30 = Math.sqrt(1 / 3), tan30_2 = tan30 * 2;\n    var diamond = {\n        draw: function (context, size) {\n            var y = Math.sqrt(size / tan30_2), x = y * tan30;\n            context.moveTo(0, -y);\n            context.lineTo(x, 0);\n            context.lineTo(0, y);\n            context.lineTo(-x, 0);\n            context.closePath();\n        }\n    };\n    var ka = 0.89081309152928522810, kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10), kx = Math.sin(tau / 10) * kr, ky = -Math.cos(tau / 10) * kr;\n    var star = {\n        draw: function (context, size) {\n            var r = Math.sqrt(size * ka), x = kx * r, y = ky * r;\n            context.moveTo(0, -r);\n            context.lineTo(x, y);\n            for (var i = 1; i < 5; ++i) {\n                var a = tau * i / 5, c = Math.cos(a), s = Math.sin(a);\n                context.lineTo(s * r, -c * r);\n                context.lineTo(c * x - s * y, s * x + c * y);\n            }\n            context.closePath();\n        }\n    };\n    var square = {\n        draw: function (context, size) {\n            var w = Math.sqrt(size), x = -w / 2;\n            context.rect(x, x, w, w);\n        }\n    };\n    var sqrt3 = Math.sqrt(3);\n    var triangle = {\n        draw: function (context, size) {\n            var y = -Math.sqrt(size / (sqrt3 * 3));\n            context.moveTo(0, y * 2);\n            context.lineTo(-sqrt3 * y, -y);\n            context.lineTo(sqrt3 * y, -y);\n            context.closePath();\n        }\n    };\n    var c = -0.5, s = Math.sqrt(3) / 2, k = 1 / Math.sqrt(12), a = (k / 2 + 1) * 3;\n    var wye = {\n        draw: function (context, size) {\n            var r = Math.sqrt(size / a), x0 = r / 2, y0 = r * k, x1 = x0, y1 = r * k + r, x2 = -x1, y2 = y1;\n            context.moveTo(x0, y0);\n            context.lineTo(x1, y1);\n            context.lineTo(x2, y2);\n            context.lineTo(c * x0 - s * y0, s * x0 + c * y0);\n            context.lineTo(c * x1 - s * y1, s * x1 + c * y1);\n            context.lineTo(c * x2 - s * y2, s * x2 + c * y2);\n            context.lineTo(c * x0 + s * y0, c * y0 - s * x0);\n            context.lineTo(c * x1 + s * y1, c * y1 - s * x1);\n            context.lineTo(c * x2 + s * y2, c * y2 - s * x2);\n            context.closePath();\n        }\n    };\n    var symbols = [\n        circle,\n        cross,\n        diamond,\n        square,\n        star,\n        triangle,\n        wye\n    ];\n    function symbol() {\n        var type = constant(circle), size = constant(64), context = null;\n        function symbol() {\n            var buffer;\n            if (!context)\n                context = buffer = d3Path.path();\n            type.apply(this, arguments).draw(context, +size.apply(this, arguments));\n            if (buffer)\n                return context = null, buffer + \"\" || null;\n        }\n        symbol.type = function (_) {\n            return arguments.length ? (type = typeof _ === \"function\" ? _ : constant(_), symbol) : type;\n        };\n        symbol.size = function (_) {\n            return arguments.length ? (size = typeof _ === \"function\" ? _ : constant(+_), symbol) : size;\n        };\n        symbol.context = function (_) {\n            return arguments.length ? (context = _ == null ? null : _, symbol) : context;\n        };\n        return symbol;\n    }\n    function noop() { }\n    function point(that, x, y) {\n        that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6);\n    }\n    function Basis(context) {\n        this._context = context;\n    }\n    Basis.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x0 = this._x1 =\n                this._y0 = this._y1 = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            switch (this._point) {\n                case 3: point(this, this._x1, this._y1); // proceed\n                case 2:\n                    this._context.lineTo(this._x1, this._y1);\n                    break;\n            }\n            if (this._line || (this._line !== 0 && this._point === 1))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n                    break;\n                case 1:\n                    this._point = 2;\n                    break;\n                case 2:\n                    this._point = 3;\n                    this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed\n                default:\n                    point(this, x, y);\n                    break;\n            }\n            this._x0 = this._x1, this._x1 = x;\n            this._y0 = this._y1, this._y1 = y;\n        }\n    };\n    function basis(context) {\n        return new Basis(context);\n    }\n    function BasisClosed(context) {\n        this._context = context;\n    }\n    BasisClosed.prototype = {\n        areaStart: noop,\n        areaEnd: noop,\n        lineStart: function () {\n            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =\n                this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            switch (this._point) {\n                case 1: {\n                    this._context.moveTo(this._x2, this._y2);\n                    this._context.closePath();\n                    break;\n                }\n                case 2: {\n                    this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);\n                    this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);\n                    this._context.closePath();\n                    break;\n                }\n                case 3: {\n                    this.point(this._x2, this._y2);\n                    this.point(this._x3, this._y3);\n                    this.point(this._x4, this._y4);\n                    break;\n                }\n            }\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._x2 = x, this._y2 = y;\n                    break;\n                case 1:\n                    this._point = 2;\n                    this._x3 = x, this._y3 = y;\n                    break;\n                case 2:\n                    this._point = 3;\n                    this._x4 = x, this._y4 = y;\n                    this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);\n                    break;\n                default:\n                    point(this, x, y);\n                    break;\n            }\n            this._x0 = this._x1, this._x1 = x;\n            this._y0 = this._y1, this._y1 = y;\n        }\n    };\n    function basisClosed(context) {\n        return new BasisClosed(context);\n    }\n    function BasisOpen(context) {\n        this._context = context;\n    }\n    BasisOpen.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x0 = this._x1 =\n                this._y0 = this._y1 = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line || (this._line !== 0 && this._point === 3))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    break;\n                case 1:\n                    this._point = 2;\n                    break;\n                case 2:\n                    this._point = 3;\n                    var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6;\n                    this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);\n                    break;\n                case 3: this._point = 4; // proceed\n                default:\n                    point(this, x, y);\n                    break;\n            }\n            this._x0 = this._x1, this._x1 = x;\n            this._y0 = this._y1, this._y1 = y;\n        }\n    };\n    function basisOpen(context) {\n        return new BasisOpen(context);\n    }\n    function Bundle(context, beta) {\n        this._basis = new Basis(context);\n        this._beta = beta;\n    }\n    Bundle.prototype = {\n        lineStart: function () {\n            this._x = [];\n            this._y = [];\n            this._basis.lineStart();\n        },\n        lineEnd: function () {\n            var x = this._x, y = this._y, j = x.length - 1;\n            if (j > 0) {\n                var x0 = x[0], y0 = y[0], dx = x[j] - x0, dy = y[j] - y0, i = -1, t;\n                while (++i <= j) {\n                    t = i / j;\n                    this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy));\n                }\n            }\n            this._x = this._y = null;\n            this._basis.lineEnd();\n        },\n        point: function (x, y) {\n            this._x.push(+x);\n            this._y.push(+y);\n        }\n    };\n    var bundle = (function custom(beta) {\n        function bundle(context) {\n            return beta === 1 ? new Basis(context) : new Bundle(context, beta);\n        }\n        bundle.beta = function (beta) {\n            return custom(+beta);\n        };\n        return bundle;\n    })(0.85);\n    function point$1(that, x, y) {\n        that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);\n    }\n    function Cardinal(context, tension) {\n        this._context = context;\n        this._k = (1 - tension) / 6;\n    }\n    Cardinal.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x0 = this._x1 = this._x2 =\n                this._y0 = this._y1 = this._y2 = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            switch (this._point) {\n                case 2:\n                    this._context.lineTo(this._x2, this._y2);\n                    break;\n                case 3:\n                    point$1(this, this._x1, this._y1);\n                    break;\n            }\n            if (this._line || (this._line !== 0 && this._point === 1))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n                    break;\n                case 1:\n                    this._point = 2;\n                    this._x1 = x, this._y1 = y;\n                    break;\n                case 2: this._point = 3; // proceed\n                default:\n                    point$1(this, x, y);\n                    break;\n            }\n            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n        }\n    };\n    var cardinal = (function custom(tension) {\n        function cardinal(context) {\n            return new Cardinal(context, tension);\n        }\n        cardinal.tension = function (tension) {\n            return custom(+tension);\n        };\n        return cardinal;\n    })(0);\n    function CardinalClosed(context, tension) {\n        this._context = context;\n        this._k = (1 - tension) / 6;\n    }\n    CardinalClosed.prototype = {\n        areaStart: noop,\n        areaEnd: noop,\n        lineStart: function () {\n            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n                this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            switch (this._point) {\n                case 1: {\n                    this._context.moveTo(this._x3, this._y3);\n                    this._context.closePath();\n                    break;\n                }\n                case 2: {\n                    this._context.lineTo(this._x3, this._y3);\n                    this._context.closePath();\n                    break;\n                }\n                case 3: {\n                    this.point(this._x3, this._y3);\n                    this.point(this._x4, this._y4);\n                    this.point(this._x5, this._y5);\n                    break;\n                }\n            }\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._x3 = x, this._y3 = y;\n                    break;\n                case 1:\n                    this._point = 2;\n                    this._context.moveTo(this._x4 = x, this._y4 = y);\n                    break;\n                case 2:\n                    this._point = 3;\n                    this._x5 = x, this._y5 = y;\n                    break;\n                default:\n                    point$1(this, x, y);\n                    break;\n            }\n            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n        }\n    };\n    var cardinalClosed = (function custom(tension) {\n        function cardinal(context) {\n            return new CardinalClosed(context, tension);\n        }\n        cardinal.tension = function (tension) {\n            return custom(+tension);\n        };\n        return cardinal;\n    })(0);\n    function CardinalOpen(context, tension) {\n        this._context = context;\n        this._k = (1 - tension) / 6;\n    }\n    CardinalOpen.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x0 = this._x1 = this._x2 =\n                this._y0 = this._y1 = this._y2 = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line || (this._line !== 0 && this._point === 3))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    break;\n                case 1:\n                    this._point = 2;\n                    break;\n                case 2:\n                    this._point = 3;\n                    this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);\n                    break;\n                case 3: this._point = 4; // proceed\n                default:\n                    point$1(this, x, y);\n                    break;\n            }\n            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n        }\n    };\n    var cardinalOpen = (function custom(tension) {\n        function cardinal(context) {\n            return new CardinalOpen(context, tension);\n        }\n        cardinal.tension = function (tension) {\n            return custom(+tension);\n        };\n        return cardinal;\n    })(0);\n    function point$2(that, x, y) {\n        var x1 = that._x1, y1 = that._y1, x2 = that._x2, y2 = that._y2;\n        if (that._l01_a > epsilon) {\n            var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);\n            x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;\n            y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;\n        }\n        if (that._l23_a > epsilon) {\n            var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);\n            x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;\n            y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;\n        }\n        that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);\n    }\n    function CatmullRom(context, alpha) {\n        this._context = context;\n        this._alpha = alpha;\n    }\n    CatmullRom.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x0 = this._x1 = this._x2 =\n                this._y0 = this._y1 = this._y2 = NaN;\n            this._l01_a = this._l12_a = this._l23_a =\n                this._l01_2a = this._l12_2a = this._l23_2a =\n                    this._point = 0;\n        },\n        lineEnd: function () {\n            switch (this._point) {\n                case 2:\n                    this._context.lineTo(this._x2, this._y2);\n                    break;\n                case 3:\n                    this.point(this._x2, this._y2);\n                    break;\n            }\n            if (this._line || (this._line !== 0 && this._point === 1))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            if (this._point) {\n                var x23 = this._x2 - x, y23 = this._y2 - y;\n                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n            }\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n                    break;\n                case 1:\n                    this._point = 2;\n                    break;\n                case 2: this._point = 3; // proceed\n                default:\n                    point$2(this, x, y);\n                    break;\n            }\n            this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n        }\n    };\n    var catmullRom = (function custom(alpha) {\n        function catmullRom(context) {\n            return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);\n        }\n        catmullRom.alpha = function (alpha) {\n            return custom(+alpha);\n        };\n        return catmullRom;\n    })(0.5);\n    function CatmullRomClosed(context, alpha) {\n        this._context = context;\n        this._alpha = alpha;\n    }\n    CatmullRomClosed.prototype = {\n        areaStart: noop,\n        areaEnd: noop,\n        lineStart: function () {\n            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n                this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n            this._l01_a = this._l12_a = this._l23_a =\n                this._l01_2a = this._l12_2a = this._l23_2a =\n                    this._point = 0;\n        },\n        lineEnd: function () {\n            switch (this._point) {\n                case 1: {\n                    this._context.moveTo(this._x3, this._y3);\n                    this._context.closePath();\n                    break;\n                }\n                case 2: {\n                    this._context.lineTo(this._x3, this._y3);\n                    this._context.closePath();\n                    break;\n                }\n                case 3: {\n                    this.point(this._x3, this._y3);\n                    this.point(this._x4, this._y4);\n                    this.point(this._x5, this._y5);\n                    break;\n                }\n            }\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            if (this._point) {\n                var x23 = this._x2 - x, y23 = this._y2 - y;\n                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n            }\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._x3 = x, this._y3 = y;\n                    break;\n                case 1:\n                    this._point = 2;\n                    this._context.moveTo(this._x4 = x, this._y4 = y);\n                    break;\n                case 2:\n                    this._point = 3;\n                    this._x5 = x, this._y5 = y;\n                    break;\n                default:\n                    point$2(this, x, y);\n                    break;\n            }\n            this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n        }\n    };\n    var catmullRomClosed = (function custom(alpha) {\n        function catmullRom(context) {\n            return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);\n        }\n        catmullRom.alpha = function (alpha) {\n            return custom(+alpha);\n        };\n        return catmullRom;\n    })(0.5);\n    function CatmullRomOpen(context, alpha) {\n        this._context = context;\n        this._alpha = alpha;\n    }\n    CatmullRomOpen.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x0 = this._x1 = this._x2 =\n                this._y0 = this._y1 = this._y2 = NaN;\n            this._l01_a = this._l12_a = this._l23_a =\n                this._l01_2a = this._l12_2a = this._l23_2a =\n                    this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._line || (this._line !== 0 && this._point === 3))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            if (this._point) {\n                var x23 = this._x2 - x, y23 = this._y2 - y;\n                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n            }\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    break;\n                case 1:\n                    this._point = 2;\n                    break;\n                case 2:\n                    this._point = 3;\n                    this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);\n                    break;\n                case 3: this._point = 4; // proceed\n                default:\n                    point$2(this, x, y);\n                    break;\n            }\n            this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n        }\n    };\n    var catmullRomOpen = (function custom(alpha) {\n        function catmullRom(context) {\n            return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);\n        }\n        catmullRom.alpha = function (alpha) {\n            return custom(+alpha);\n        };\n        return catmullRom;\n    })(0.5);\n    function LinearClosed(context) {\n        this._context = context;\n    }\n    LinearClosed.prototype = {\n        areaStart: noop,\n        areaEnd: noop,\n        lineStart: function () {\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (this._point)\n                this._context.closePath();\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            if (this._point)\n                this._context.lineTo(x, y);\n            else\n                this._point = 1, this._context.moveTo(x, y);\n        }\n    };\n    function linearClosed(context) {\n        return new LinearClosed(context);\n    }\n    function sign(x) {\n        return x < 0 ? -1 : 1;\n    }\n    // Calculate the slopes of the tangents (Hermite-type interpolation) based on\n    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic\n    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.\n    // NOV(II), P. 443, 1990.\n    function slope3(that, x2, y2) {\n        var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);\n        return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n    }\n    // Calculate a one-sided slope.\n    function slope2(that, t) {\n        var h = that._x1 - that._x0;\n        return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n    }\n    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n    // \"you can express cubic Hermite interpolation in terms of cubic Bézier curves\n    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\n    function point$3(that, t0, t1) {\n        var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;\n        that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);\n    }\n    function MonotoneX(context) {\n        this._context = context;\n    }\n    MonotoneX.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x0 = this._x1 =\n                this._y0 = this._y1 =\n                    this._t0 = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            switch (this._point) {\n                case 2:\n                    this._context.lineTo(this._x1, this._y1);\n                    break;\n                case 3:\n                    point$3(this, this._t0, slope2(this, this._t0));\n                    break;\n            }\n            if (this._line || (this._line !== 0 && this._point === 1))\n                this._context.closePath();\n            this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            var t1 = NaN;\n            x = +x, y = +y;\n            if (x === this._x1 && y === this._y1)\n                return; // Ignore coincident points.\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n                    break;\n                case 1:\n                    this._point = 2;\n                    break;\n                case 2:\n                    this._point = 3;\n                    point$3(this, slope2(this, t1 = slope3(this, x, y)), t1);\n                    break;\n                default:\n                    point$3(this, this._t0, t1 = slope3(this, x, y));\n                    break;\n            }\n            this._x0 = this._x1, this._x1 = x;\n            this._y0 = this._y1, this._y1 = y;\n            this._t0 = t1;\n        }\n    };\n    function MonotoneY(context) {\n        this._context = new ReflectContext(context);\n    }\n    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function (x, y) {\n        MonotoneX.prototype.point.call(this, y, x);\n    };\n    function ReflectContext(context) {\n        this._context = context;\n    }\n    ReflectContext.prototype = {\n        moveTo: function (x, y) { this._context.moveTo(y, x); },\n        closePath: function () { this._context.closePath(); },\n        lineTo: function (x, y) { this._context.lineTo(y, x); },\n        bezierCurveTo: function (x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }\n    };\n    function monotoneX(context) {\n        return new MonotoneX(context);\n    }\n    function monotoneY(context) {\n        return new MonotoneY(context);\n    }\n    function Natural(context) {\n        this._context = context;\n    }\n    Natural.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x = [];\n            this._y = [];\n        },\n        lineEnd: function () {\n            var x = this._x, y = this._y, n = x.length;\n            if (n) {\n                this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);\n                if (n === 2) {\n                    this._context.lineTo(x[1], y[1]);\n                }\n                else {\n                    var px = controlPoints(x), py = controlPoints(y);\n                    for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n                        this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);\n                    }\n                }\n            }\n            if (this._line || (this._line !== 0 && n === 1))\n                this._context.closePath();\n            this._line = 1 - this._line;\n            this._x = this._y = null;\n        },\n        point: function (x, y) {\n            this._x.push(+x);\n            this._y.push(+y);\n        }\n    };\n    // See https://www.particleincell.com/2012/bezier-splines/ for derivation.\n    function controlPoints(x) {\n        var i, n = x.length - 1, m, a = new Array(n), b = new Array(n), r = new Array(n);\n        a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];\n        for (i = 1; i < n - 1; ++i)\n            a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];\n        a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];\n        for (i = 1; i < n; ++i)\n            m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];\n        a[n - 1] = r[n - 1] / b[n - 1];\n        for (i = n - 2; i >= 0; --i)\n            a[i] = (r[i] - a[i + 1]) / b[i];\n        b[n - 1] = (x[n] + a[n - 1]) / 2;\n        for (i = 0; i < n - 1; ++i)\n            b[i] = 2 * x[i + 1] - a[i + 1];\n        return [a, b];\n    }\n    function natural(context) {\n        return new Natural(context);\n    }\n    function Step(context, t) {\n        this._context = context;\n        this._t = t;\n    }\n    Step.prototype = {\n        areaStart: function () {\n            this._line = 0;\n        },\n        areaEnd: function () {\n            this._line = NaN;\n        },\n        lineStart: function () {\n            this._x = this._y = NaN;\n            this._point = 0;\n        },\n        lineEnd: function () {\n            if (0 < this._t && this._t < 1 && this._point === 2)\n                this._context.lineTo(this._x, this._y);\n            if (this._line || (this._line !== 0 && this._point === 1))\n                this._context.closePath();\n            if (this._line >= 0)\n                this._t = 1 - this._t, this._line = 1 - this._line;\n        },\n        point: function (x, y) {\n            x = +x, y = +y;\n            switch (this._point) {\n                case 0:\n                    this._point = 1;\n                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);\n                    break;\n                case 1: this._point = 2; // proceed\n                default: {\n                    if (this._t <= 0) {\n                        this._context.lineTo(this._x, y);\n                        this._context.lineTo(x, y);\n                    }\n                    else {\n                        var x1 = this._x * (1 - this._t) + x * this._t;\n                        this._context.lineTo(x1, this._y);\n                        this._context.lineTo(x1, y);\n                    }\n                    break;\n                }\n            }\n            this._x = x, this._y = y;\n        }\n    };\n    function step(context) {\n        return new Step(context, 0.5);\n    }\n    function stepBefore(context) {\n        return new Step(context, 0);\n    }\n    function stepAfter(context) {\n        return new Step(context, 1);\n    }\n    function none(series, order) {\n        if (!((n = series.length) > 1))\n            return;\n        for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {\n            s0 = s1, s1 = series[order[i]];\n            for (j = 0; j < m; ++j) {\n                s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];\n            }\n        }\n    }\n    function none$1(series) {\n        var n = series.length, o = new Array(n);\n        while (--n >= 0)\n            o[n] = n;\n        return o;\n    }\n    function stackValue(d, key) {\n        return d[key];\n    }\n    function stack() {\n        var keys = constant([]), order = none$1, offset = none, value = stackValue;\n        function stack(data) {\n            var kz = keys.apply(this, arguments), i, m = data.length, n = kz.length, sz = new Array(n), oz;\n            for (i = 0; i < n; ++i) {\n                for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {\n                    si[j] = sij = [0, +value(data[j], ki, j, data)];\n                    sij.data = data[j];\n                }\n                si.key = ki;\n            }\n            for (i = 0, oz = order(sz); i < n; ++i) {\n                sz[oz[i]].index = i;\n            }\n            offset(sz, oz);\n            return sz;\n        }\n        stack.keys = function (_) {\n            return arguments.length ? (keys = typeof _ === \"function\" ? _ : constant(slice.call(_)), stack) : keys;\n        };\n        stack.value = function (_) {\n            return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(+_), stack) : value;\n        };\n        stack.order = function (_) {\n            return arguments.length ? (order = _ == null ? none$1 : typeof _ === \"function\" ? _ : constant(slice.call(_)), stack) : order;\n        };\n        stack.offset = function (_) {\n            return arguments.length ? (offset = _ == null ? none : _, stack) : offset;\n        };\n        return stack;\n    }\n    function expand(series, order) {\n        if (!((n = series.length) > 0))\n            return;\n        for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {\n            for (y = i = 0; i < n; ++i)\n                y += series[i][j][1] || 0;\n            if (y)\n                for (i = 0; i < n; ++i)\n                    series[i][j][1] /= y;\n        }\n        none(series, order);\n    }\n    function diverging(series, order) {\n        if (!((n = series.length) > 0))\n            return;\n        for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {\n            for (yp = yn = 0, i = 0; i < n; ++i) {\n                if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {\n                    d[0] = yp, d[1] = yp += dy;\n                }\n                else if (dy < 0) {\n                    d[1] = yn, d[0] = yn += dy;\n                }\n                else {\n                    d[0] = 0, d[1] = dy;\n                }\n            }\n        }\n    }\n    function silhouette(series, order) {\n        if (!((n = series.length) > 0))\n            return;\n        for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {\n            for (var i = 0, y = 0; i < n; ++i)\n                y += series[i][j][1] || 0;\n            s0[j][1] += s0[j][0] = -y / 2;\n        }\n        none(series, order);\n    }\n    function wiggle(series, order) {\n        if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0))\n            return;\n        for (var y = 0, j = 1, s0, m, n; j < m; ++j) {\n            for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {\n                var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;\n                for (var k = 0; k < i; ++k) {\n                    var sk = series[order[k]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;\n                    s3 += skj0 - skj1;\n                }\n                s1 += sij0, s2 += s3 * sij0;\n            }\n            s0[j - 1][1] += s0[j - 1][0] = y;\n            if (s1)\n                y -= s2 / s1;\n        }\n        s0[j - 1][1] += s0[j - 1][0] = y;\n        none(series, order);\n    }\n    function appearance(series) {\n        var peaks = series.map(peak);\n        return none$1(series).sort(function (a, b) { return peaks[a] - peaks[b]; });\n    }\n    function peak(series) {\n        var i = -1, j = 0, n = series.length, vi, vj = -Infinity;\n        while (++i < n)\n            if ((vi = +series[i][1]) > vj)\n                vj = vi, j = i;\n        return j;\n    }\n    function ascending(series) {\n        var sums = series.map(sum);\n        return none$1(series).sort(function (a, b) { return sums[a] - sums[b]; });\n    }\n    function sum(series) {\n        var s = 0, i = -1, n = series.length, v;\n        while (++i < n)\n            if (v = +series[i][1])\n                s += v;\n        return s;\n    }\n    function descending$1(series) {\n        return ascending(series).reverse();\n    }\n    function insideOut(series) {\n        var n = series.length, i, j, sums = series.map(sum), order = appearance(series), top = 0, bottom = 0, tops = [], bottoms = [];\n        for (i = 0; i < n; ++i) {\n            j = order[i];\n            if (top < bottom) {\n                top += sums[j];\n                tops.push(j);\n            }\n            else {\n                bottom += sums[j];\n                bottoms.push(j);\n            }\n        }\n        return bottoms.reverse().concat(tops);\n    }\n    function reverse(series) {\n        return none$1(series).reverse();\n    }\n    exports.arc = arc;\n    exports.area = area;\n    exports.areaRadial = areaRadial;\n    exports.curveBasis = basis;\n    exports.curveBasisClosed = basisClosed;\n    exports.curveBasisOpen = basisOpen;\n    exports.curveBundle = bundle;\n    exports.curveCardinal = cardinal;\n    exports.curveCardinalClosed = cardinalClosed;\n    exports.curveCardinalOpen = cardinalOpen;\n    exports.curveCatmullRom = catmullRom;\n    exports.curveCatmullRomClosed = catmullRomClosed;\n    exports.curveCatmullRomOpen = catmullRomOpen;\n    exports.curveLinear = curveLinear;\n    exports.curveLinearClosed = linearClosed;\n    exports.curveMonotoneX = monotoneX;\n    exports.curveMonotoneY = monotoneY;\n    exports.curveNatural = natural;\n    exports.curveStep = step;\n    exports.curveStepAfter = stepAfter;\n    exports.curveStepBefore = stepBefore;\n    exports.line = line;\n    exports.lineRadial = lineRadial$1;\n    exports.linkHorizontal = linkHorizontal;\n    exports.linkRadial = linkRadial;\n    exports.linkVertical = linkVertical;\n    exports.pie = pie;\n    exports.pointRadial = pointRadial;\n    exports.radialArea = areaRadial;\n    exports.radialLine = lineRadial$1;\n    exports.stack = stack;\n    exports.stackOffsetDiverging = diverging;\n    exports.stackOffsetExpand = expand;\n    exports.stackOffsetNone = none;\n    exports.stackOffsetSilhouette = silhouette;\n    exports.stackOffsetWiggle = wiggle;\n    exports.stackOrderAppearance = appearance;\n    exports.stackOrderAscending = ascending;\n    exports.stackOrderDescending = descending$1;\n    exports.stackOrderInsideOut = insideOut;\n    exports.stackOrderNone = none$1;\n    exports.stackOrderReverse = reverse;\n    exports.symbol = symbol;\n    exports.symbolCircle = circle;\n    exports.symbolCross = cross;\n    exports.symbolDiamond = diamond;\n    exports.symbolSquare = square;\n    exports.symbolStar = star;\n    exports.symbolTriangle = triangle;\n    exports.symbolWye = wye;\n    exports.symbols = symbols;\n    Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_d3-voronoi@1.1.4@d3-voronoi/dist/d3-voronoi.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_d3-voronoi@1.1.4@d3-voronoi/dist/d3-voronoi.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://d3js.org/d3-voronoi/ v1.1.4 Copyright 2018 Mike Bostock\n(function (global, factory) {\n     true ? factory(exports) :\n        undefined;\n}(this, (function (exports) {\n    'use strict';\n    function constant(x) {\n        return function () {\n            return x;\n        };\n    }\n    function x(d) {\n        return d[0];\n    }\n    function y(d) {\n        return d[1];\n    }\n    function RedBlackTree() {\n        this._ = null; // root node\n    }\n    function RedBlackNode(node) {\n        node.U = // parent node\n            node.C = // color - true for red, false for black\n                node.L = // left node\n                    node.R = // right node\n                        node.P = // previous node\n                            node.N = null; // next node\n    }\n    RedBlackTree.prototype = {\n        constructor: RedBlackTree,\n        insert: function (after, node) {\n            var parent, grandpa, uncle;\n            if (after) {\n                node.P = after;\n                node.N = after.N;\n                if (after.N)\n                    after.N.P = node;\n                after.N = node;\n                if (after.R) {\n                    after = after.R;\n                    while (after.L)\n                        after = after.L;\n                    after.L = node;\n                }\n                else {\n                    after.R = node;\n                }\n                parent = after;\n            }\n            else if (this._) {\n                after = RedBlackFirst(this._);\n                node.P = null;\n                node.N = after;\n                after.P = after.L = node;\n                parent = after;\n            }\n            else {\n                node.P = node.N = null;\n                this._ = node;\n                parent = null;\n            }\n            node.L = node.R = null;\n            node.U = parent;\n            node.C = true;\n            after = node;\n            while (parent && parent.C) {\n                grandpa = parent.U;\n                if (parent === grandpa.L) {\n                    uncle = grandpa.R;\n                    if (uncle && uncle.C) {\n                        parent.C = uncle.C = false;\n                        grandpa.C = true;\n                        after = grandpa;\n                    }\n                    else {\n                        if (after === parent.R) {\n                            RedBlackRotateLeft(this, parent);\n                            after = parent;\n                            parent = after.U;\n                        }\n                        parent.C = false;\n                        grandpa.C = true;\n                        RedBlackRotateRight(this, grandpa);\n                    }\n                }\n                else {\n                    uncle = grandpa.L;\n                    if (uncle && uncle.C) {\n                        parent.C = uncle.C = false;\n                        grandpa.C = true;\n                        after = grandpa;\n                    }\n                    else {\n                        if (after === parent.L) {\n                            RedBlackRotateRight(this, parent);\n                            after = parent;\n                            parent = after.U;\n                        }\n                        parent.C = false;\n                        grandpa.C = true;\n                        RedBlackRotateLeft(this, grandpa);\n                    }\n                }\n                parent = after.U;\n            }\n            this._.C = false;\n        },\n        remove: function (node) {\n            if (node.N)\n                node.N.P = node.P;\n            if (node.P)\n                node.P.N = node.N;\n            node.N = node.P = null;\n            var parent = node.U, sibling, left = node.L, right = node.R, next, red;\n            if (!left)\n                next = right;\n            else if (!right)\n                next = left;\n            else\n                next = RedBlackFirst(right);\n            if (parent) {\n                if (parent.L === node)\n                    parent.L = next;\n                else\n                    parent.R = next;\n            }\n            else {\n                this._ = next;\n            }\n            if (left && right) {\n                red = next.C;\n                next.C = node.C;\n                next.L = left;\n                left.U = next;\n                if (next !== right) {\n                    parent = next.U;\n                    next.U = node.U;\n                    node = next.R;\n                    parent.L = node;\n                    next.R = right;\n                    right.U = next;\n                }\n                else {\n                    next.U = parent;\n                    parent = next;\n                    node = next.R;\n                }\n            }\n            else {\n                red = node.C;\n                node = next;\n            }\n            if (node)\n                node.U = parent;\n            if (red)\n                return;\n            if (node && node.C) {\n                node.C = false;\n                return;\n            }\n            do {\n                if (node === this._)\n                    break;\n                if (node === parent.L) {\n                    sibling = parent.R;\n                    if (sibling.C) {\n                        sibling.C = false;\n                        parent.C = true;\n                        RedBlackRotateLeft(this, parent);\n                        sibling = parent.R;\n                    }\n                    if ((sibling.L && sibling.L.C)\n                        || (sibling.R && sibling.R.C)) {\n                        if (!sibling.R || !sibling.R.C) {\n                            sibling.L.C = false;\n                            sibling.C = true;\n                            RedBlackRotateRight(this, sibling);\n                            sibling = parent.R;\n                        }\n                        sibling.C = parent.C;\n                        parent.C = sibling.R.C = false;\n                        RedBlackRotateLeft(this, parent);\n                        node = this._;\n                        break;\n                    }\n                }\n                else {\n                    sibling = parent.L;\n                    if (sibling.C) {\n                        sibling.C = false;\n                        parent.C = true;\n                        RedBlackRotateRight(this, parent);\n                        sibling = parent.L;\n                    }\n                    if ((sibling.L && sibling.L.C)\n                        || (sibling.R && sibling.R.C)) {\n                        if (!sibling.L || !sibling.L.C) {\n                            sibling.R.C = false;\n                            sibling.C = true;\n                            RedBlackRotateLeft(this, sibling);\n                            sibling = parent.L;\n                        }\n                        sibling.C = parent.C;\n                        parent.C = sibling.L.C = false;\n                        RedBlackRotateRight(this, parent);\n                        node = this._;\n                        break;\n                    }\n                }\n                sibling.C = true;\n                node = parent;\n                parent = parent.U;\n            } while (!node.C);\n            if (node)\n                node.C = false;\n        }\n    };\n    function RedBlackRotateLeft(tree, node) {\n        var p = node, q = node.R, parent = p.U;\n        if (parent) {\n            if (parent.L === p)\n                parent.L = q;\n            else\n                parent.R = q;\n        }\n        else {\n            tree._ = q;\n        }\n        q.U = parent;\n        p.U = q;\n        p.R = q.L;\n        if (p.R)\n            p.R.U = p;\n        q.L = p;\n    }\n    function RedBlackRotateRight(tree, node) {\n        var p = node, q = node.L, parent = p.U;\n        if (parent) {\n            if (parent.L === p)\n                parent.L = q;\n            else\n                parent.R = q;\n        }\n        else {\n            tree._ = q;\n        }\n        q.U = parent;\n        p.U = q;\n        p.L = q.R;\n        if (p.L)\n            p.L.U = p;\n        q.R = p;\n    }\n    function RedBlackFirst(node) {\n        while (node.L)\n            node = node.L;\n        return node;\n    }\n    function createEdge(left, right, v0, v1) {\n        var edge = [null, null], index = edges.push(edge) - 1;\n        edge.left = left;\n        edge.right = right;\n        if (v0)\n            setEdgeEnd(edge, left, right, v0);\n        if (v1)\n            setEdgeEnd(edge, right, left, v1);\n        cells[left.index].halfedges.push(index);\n        cells[right.index].halfedges.push(index);\n        return edge;\n    }\n    function createBorderEdge(left, v0, v1) {\n        var edge = [v0, v1];\n        edge.left = left;\n        return edge;\n    }\n    function setEdgeEnd(edge, left, right, vertex) {\n        if (!edge[0] && !edge[1]) {\n            edge[0] = vertex;\n            edge.left = left;\n            edge.right = right;\n        }\n        else if (edge.left === right) {\n            edge[1] = vertex;\n        }\n        else {\n            edge[0] = vertex;\n        }\n    }\n    // Liang–Barsky line clipping.\n    function clipEdge(edge, x0, y0, x1, y1) {\n        var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;\n        r = x0 - ax;\n        if (!dx && r > 0)\n            return;\n        r /= dx;\n        if (dx < 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        else if (dx > 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        r = x1 - ax;\n        if (!dx && r < 0)\n            return;\n        r /= dx;\n        if (dx < 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        else if (dx > 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        r = y0 - ay;\n        if (!dy && r > 0)\n            return;\n        r /= dy;\n        if (dy < 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        else if (dy > 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        r = y1 - ay;\n        if (!dy && r < 0)\n            return;\n        r /= dy;\n        if (dy < 0) {\n            if (r > t1)\n                return;\n            if (r > t0)\n                t0 = r;\n        }\n        else if (dy > 0) {\n            if (r < t0)\n                return;\n            if (r < t1)\n                t1 = r;\n        }\n        if (!(t0 > 0) && !(t1 < 1))\n            return true; // TODO Better check?\n        if (t0 > 0)\n            edge[0] = [ax + t0 * dx, ay + t0 * dy];\n        if (t1 < 1)\n            edge[1] = [ax + t1 * dx, ay + t1 * dy];\n        return true;\n    }\n    function connectEdge(edge, x0, y0, x1, y1) {\n        var v1 = edge[1];\n        if (v1)\n            return true;\n        var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;\n        if (ry === ly) {\n            if (fx < x0 || fx >= x1)\n                return;\n            if (lx > rx) {\n                if (!v0)\n                    v0 = [fx, y0];\n                else if (v0[1] >= y1)\n                    return;\n                v1 = [fx, y1];\n            }\n            else {\n                if (!v0)\n                    v0 = [fx, y1];\n                else if (v0[1] < y0)\n                    return;\n                v1 = [fx, y0];\n            }\n        }\n        else {\n            fm = (lx - rx) / (ry - ly);\n            fb = fy - fm * fx;\n            if (fm < -1 || fm > 1) {\n                if (lx > rx) {\n                    if (!v0)\n                        v0 = [(y0 - fb) / fm, y0];\n                    else if (v0[1] >= y1)\n                        return;\n                    v1 = [(y1 - fb) / fm, y1];\n                }\n                else {\n                    if (!v0)\n                        v0 = [(y1 - fb) / fm, y1];\n                    else if (v0[1] < y0)\n                        return;\n                    v1 = [(y0 - fb) / fm, y0];\n                }\n            }\n            else {\n                if (ly < ry) {\n                    if (!v0)\n                        v0 = [x0, fm * x0 + fb];\n                    else if (v0[0] >= x1)\n                        return;\n                    v1 = [x1, fm * x1 + fb];\n                }\n                else {\n                    if (!v0)\n                        v0 = [x1, fm * x1 + fb];\n                    else if (v0[0] < x0)\n                        return;\n                    v1 = [x0, fm * x0 + fb];\n                }\n            }\n        }\n        edge[0] = v0;\n        edge[1] = v1;\n        return true;\n    }\n    function clipEdges(x0, y0, x1, y1) {\n        var i = edges.length, edge;\n        while (i--) {\n            if (!connectEdge(edge = edges[i], x0, y0, x1, y1)\n                || !clipEdge(edge, x0, y0, x1, y1)\n                || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon\n                    || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {\n                delete edges[i];\n            }\n        }\n    }\n    function createCell(site) {\n        return cells[site.index] = {\n            site: site,\n            halfedges: []\n        };\n    }\n    function cellHalfedgeAngle(cell, edge) {\n        var site = cell.site, va = edge.left, vb = edge.right;\n        if (site === vb)\n            vb = va, va = site;\n        if (vb)\n            return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n        if (site === va)\n            va = edge[1], vb = edge[0];\n        else\n            va = edge[0], vb = edge[1];\n        return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n    }\n    function cellHalfedgeStart(cell, edge) {\n        return edge[+(edge.left !== cell.site)];\n    }\n    function cellHalfedgeEnd(cell, edge) {\n        return edge[+(edge.left === cell.site)];\n    }\n    function sortCellHalfedges() {\n        for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n            if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n                var index = new Array(m), array = new Array(m);\n                for (j = 0; j < m; ++j)\n                    index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\n                index.sort(function (i, j) { return array[j] - array[i]; });\n                for (j = 0; j < m; ++j)\n                    array[j] = halfedges[index[j]];\n                for (j = 0; j < m; ++j)\n                    halfedges[j] = array[j];\n            }\n        }\n    }\n    function clipCells(x0, y0, x1, y1) {\n        var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;\n        for (iCell = 0; iCell < nCells; ++iCell) {\n            if (cell = cells[iCell]) {\n                site = cell.site;\n                halfedges = cell.halfedges;\n                iHalfedge = halfedges.length;\n                // Remove any dangling clipped edges.\n                while (iHalfedge--) {\n                    if (!edges[halfedges[iHalfedge]]) {\n                        halfedges.splice(iHalfedge, 1);\n                    }\n                }\n                // Insert any border edges as necessary.\n                iHalfedge = 0, nHalfedges = halfedges.length;\n                while (iHalfedge < nHalfedges) {\n                    end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n                    start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n                    if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {\n                        halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end, Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]\n                            : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]\n                                : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]\n                                    : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]\n                                        : null)) - 1);\n                        ++nHalfedges;\n                    }\n                }\n                if (nHalfedges)\n                    cover = false;\n            }\n        }\n        // If there weren’t any edges, have the closest site cover the extent.\n        // It doesn’t matter which corner of the extent we measure!\n        if (cover) {\n            var dx, dy, d2, dc = Infinity;\n            for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n                if (cell = cells[iCell]) {\n                    site = cell.site;\n                    dx = site[0] - x0;\n                    dy = site[1] - y0;\n                    d2 = dx * dx + dy * dy;\n                    if (d2 < dc)\n                        dc = d2, cover = cell;\n                }\n            }\n            if (cover) {\n                var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\n                cover.halfedges.push(edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1, edges.push(createBorderEdge(site, v01, v11)) - 1, edges.push(createBorderEdge(site, v11, v10)) - 1, edges.push(createBorderEdge(site, v10, v00)) - 1);\n            }\n        }\n        // Lastly delete any cells with no edges; these were entirely clipped.\n        for (iCell = 0; iCell < nCells; ++iCell) {\n            if (cell = cells[iCell]) {\n                if (!cell.halfedges.length) {\n                    delete cells[iCell];\n                }\n            }\n        }\n    }\n    var circlePool = [];\n    var firstCircle;\n    function Circle() {\n        RedBlackNode(this);\n        this.x =\n            this.y =\n                this.arc =\n                    this.site =\n                        this.cy = null;\n    }\n    function attachCircle(arc) {\n        var lArc = arc.P, rArc = arc.N;\n        if (!lArc || !rArc)\n            return;\n        var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;\n        if (lSite === rSite)\n            return;\n        var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;\n        var d = 2 * (ax * cy - ay * cx);\n        if (d >= -epsilon2)\n            return;\n        var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d;\n        var circle = circlePool.pop() || new Circle;\n        circle.arc = arc;\n        circle.site = cSite;\n        circle.x = x + bx;\n        circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom\n        arc.circle = circle;\n        var before = null, node = circles._;\n        while (node) {\n            if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {\n                if (node.L)\n                    node = node.L;\n                else {\n                    before = node.P;\n                    break;\n                }\n            }\n            else {\n                if (node.R)\n                    node = node.R;\n                else {\n                    before = node;\n                    break;\n                }\n            }\n        }\n        circles.insert(before, circle);\n        if (!before)\n            firstCircle = circle;\n    }\n    function detachCircle(arc) {\n        var circle = arc.circle;\n        if (circle) {\n            if (!circle.P)\n                firstCircle = circle.N;\n            circles.remove(circle);\n            circlePool.push(circle);\n            RedBlackNode(circle);\n            arc.circle = null;\n        }\n    }\n    var beachPool = [];\n    function Beach() {\n        RedBlackNode(this);\n        this.edge =\n            this.site =\n                this.circle = null;\n    }\n    function createBeach(site) {\n        var beach = beachPool.pop() || new Beach;\n        beach.site = site;\n        return beach;\n    }\n    function detachBeach(beach) {\n        detachCircle(beach);\n        beaches.remove(beach);\n        beachPool.push(beach);\n        RedBlackNode(beach);\n    }\n    function removeBeach(beach) {\n        var circle = beach.circle, x = circle.x, y = circle.cy, vertex = [x, y], previous = beach.P, next = beach.N, disappearing = [beach];\n        detachBeach(beach);\n        var lArc = previous;\n        while (lArc.circle\n            && Math.abs(x - lArc.circle.x) < epsilon\n            && Math.abs(y - lArc.circle.cy) < epsilon) {\n            previous = lArc.P;\n            disappearing.unshift(lArc);\n            detachBeach(lArc);\n            lArc = previous;\n        }\n        disappearing.unshift(lArc);\n        detachCircle(lArc);\n        var rArc = next;\n        while (rArc.circle\n            && Math.abs(x - rArc.circle.x) < epsilon\n            && Math.abs(y - rArc.circle.cy) < epsilon) {\n            next = rArc.N;\n            disappearing.push(rArc);\n            detachBeach(rArc);\n            rArc = next;\n        }\n        disappearing.push(rArc);\n        detachCircle(rArc);\n        var nArcs = disappearing.length, iArc;\n        for (iArc = 1; iArc < nArcs; ++iArc) {\n            rArc = disappearing[iArc];\n            lArc = disappearing[iArc - 1];\n            setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n        }\n        lArc = disappearing[0];\n        rArc = disappearing[nArcs - 1];\n        rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);\n        attachCircle(lArc);\n        attachCircle(rArc);\n    }\n    function addBeach(site) {\n        var x = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;\n        while (node) {\n            dxl = leftBreakPoint(node, directrix) - x;\n            if (dxl > epsilon)\n                node = node.L;\n            else {\n                dxr = x - rightBreakPoint(node, directrix);\n                if (dxr > epsilon) {\n                    if (!node.R) {\n                        lArc = node;\n                        break;\n                    }\n                    node = node.R;\n                }\n                else {\n                    if (dxl > -epsilon) {\n                        lArc = node.P;\n                        rArc = node;\n                    }\n                    else if (dxr > -epsilon) {\n                        lArc = node;\n                        rArc = node.N;\n                    }\n                    else {\n                        lArc = rArc = node;\n                    }\n                    break;\n                }\n            }\n        }\n        createCell(site);\n        var newArc = createBeach(site);\n        beaches.insert(lArc, newArc);\n        if (!lArc && !rArc)\n            return;\n        if (lArc === rArc) {\n            detachCircle(lArc);\n            rArc = createBeach(lArc.site);\n            beaches.insert(newArc, rArc);\n            newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);\n            attachCircle(lArc);\n            attachCircle(rArc);\n            return;\n        }\n        if (!rArc) { // && lArc\n            newArc.edge = createEdge(lArc.site, newArc.site);\n            return;\n        }\n        // else lArc !== rArc\n        detachCircle(lArc);\n        detachCircle(rArc);\n        var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];\n        setEdgeEnd(rArc.edge, lSite, rSite, vertex);\n        newArc.edge = createEdge(lSite, site, null, vertex);\n        rArc.edge = createEdge(site, rSite, null, vertex);\n        attachCircle(lArc);\n        attachCircle(rArc);\n    }\n    function leftBreakPoint(arc, directrix) {\n        var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;\n        if (!pby2)\n            return rfocx;\n        var lArc = arc.P;\n        if (!lArc)\n            return -Infinity;\n        site = lArc.site;\n        var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;\n        if (!plby2)\n            return lfocx;\n        var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;\n        if (aby2)\n            return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n        return (rfocx + lfocx) / 2;\n    }\n    function rightBreakPoint(arc, directrix) {\n        var rArc = arc.N;\n        if (rArc)\n            return leftBreakPoint(rArc, directrix);\n        var site = arc.site;\n        return site[1] === directrix ? site[0] : Infinity;\n    }\n    var epsilon = 1e-6;\n    var epsilon2 = 1e-12;\n    var beaches;\n    var cells;\n    var circles;\n    var edges;\n    function triangleArea(a, b, c) {\n        return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);\n    }\n    function lexicographic(a, b) {\n        return b[1] - a[1]\n            || b[0] - a[0];\n    }\n    function Diagram(sites, extent) {\n        var site = sites.sort(lexicographic).pop(), x, y, circle;\n        edges = [];\n        cells = new Array(sites.length);\n        beaches = new RedBlackTree;\n        circles = new RedBlackTree;\n        while (true) {\n            circle = firstCircle;\n            if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {\n                if (site[0] !== x || site[1] !== y) {\n                    addBeach(site);\n                    x = site[0], y = site[1];\n                }\n                site = sites.pop();\n            }\n            else if (circle) {\n                removeBeach(circle.arc);\n            }\n            else {\n                break;\n            }\n        }\n        sortCellHalfedges();\n        if (extent) {\n            var x0 = +extent[0][0], y0 = +extent[0][1], x1 = +extent[1][0], y1 = +extent[1][1];\n            clipEdges(x0, y0, x1, y1);\n            clipCells(x0, y0, x1, y1);\n        }\n        this.edges = edges;\n        this.cells = cells;\n        beaches =\n            circles =\n                edges =\n                    cells = null;\n    }\n    Diagram.prototype = {\n        constructor: Diagram,\n        polygons: function () {\n            var edges = this.edges;\n            return this.cells.map(function (cell) {\n                var polygon = cell.halfedges.map(function (i) { return cellHalfedgeStart(cell, edges[i]); });\n                polygon.data = cell.site.data;\n                return polygon;\n            });\n        },\n        triangles: function () {\n            var triangles = [], edges = this.edges;\n            this.cells.forEach(function (cell, i) {\n                if (!(m = (halfedges = cell.halfedges).length))\n                    return;\n                var site = cell.site, halfedges, j = -1, m, s0, e1 = edges[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;\n                while (++j < m) {\n                    s0 = s1;\n                    e1 = edges[halfedges[j]];\n                    s1 = e1.left === site ? e1.right : e1.left;\n                    if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {\n                        triangles.push([site.data, s0.data, s1.data]);\n                    }\n                }\n            });\n            return triangles;\n        },\n        links: function () {\n            return this.edges.filter(function (edge) {\n                return edge.right;\n            }).map(function (edge) {\n                return {\n                    source: edge.left.data,\n                    target: edge.right.data\n                };\n            });\n        },\n        find: function (x, y, radius) {\n            var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;\n            // Use the previously-found cell, or start with an arbitrary one.\n            while (!(cell = that.cells[i1]))\n                if (++i1 >= n)\n                    return null;\n            var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;\n            // Traverse the half-edges to find a closer cell, if any.\n            do {\n                cell = that.cells[i0 = i1], i1 = null;\n                cell.halfedges.forEach(function (e) {\n                    var edge = that.edges[e], v = edge.left;\n                    if ((v === cell.site || !v) && !(v = edge.right))\n                        return;\n                    var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;\n                    if (v2 < d2)\n                        d2 = v2, i1 = v.index;\n                });\n            } while (i1 !== null);\n            that._found = i0;\n            return radius == null || d2 <= radius * radius ? cell.site : null;\n        }\n    };\n    function voronoi() {\n        var x$$1 = x, y$$1 = y, extent = null;\n        function voronoi(data) {\n            return new Diagram(data.map(function (d, i) {\n                var s = [Math.round(x$$1(d, i, data) / epsilon) * epsilon, Math.round(y$$1(d, i, data) / epsilon) * epsilon];\n                s.index = i;\n                s.data = d;\n                return s;\n            }), extent);\n        }\n        voronoi.polygons = function (data) {\n            return voronoi(data).polygons();\n        };\n        voronoi.links = function (data) {\n            return voronoi(data).links();\n        };\n        voronoi.triangles = function (data) {\n            return voronoi(data).triangles();\n        };\n        voronoi.x = function (_) {\n            return arguments.length ? (x$$1 = typeof _ === \"function\" ? _ : constant(+_), voronoi) : x$$1;\n        };\n        voronoi.y = function (_) {\n            return arguments.length ? (y$$1 = typeof _ === \"function\" ? _ : constant(+_), voronoi) : y$$1;\n        };\n        voronoi.extent = function (_) {\n            return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];\n        };\n        voronoi.size = function (_) {\n            return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];\n        };\n        return voronoi;\n    }\n    exports.voronoi = voronoi;\n    Object.defineProperty(exports, '__esModule', { value: true });\n})));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/index.js\":\n/*!**************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/index.js ***!\n  \\**************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\nCopyright (c) 2012-2014 Chris Pettitt\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nmodule.exports = {\n  graphlib: __webpack_require__(/*! ./lib/graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\"),\n\n  layout: __webpack_require__(/*! ./lib/layout */ \"./node_modules/_dagre@0.8.5@dagre/lib/layout.js\"),\n  debug: __webpack_require__(/*! ./lib/debug */ \"./node_modules/_dagre@0.8.5@dagre/lib/debug.js\"),\n  util: {\n    time: __webpack_require__(/*! ./lib/util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\").time,\n    notime: __webpack_require__(/*! ./lib/util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\").notime\n  },\n  version: __webpack_require__(/*! ./lib/version */ \"./node_modules/_dagre@0.8.5@dagre/lib/version.js\")\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/acyclic.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/acyclic.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar greedyFAS = __webpack_require__(/*! ./greedy-fas */ \"./node_modules/_dagre@0.8.5@dagre/lib/greedy-fas.js\");\n\nmodule.exports = {\n  run: run,\n  undo: undo\n};\n\nfunction run(g) {\n  var fas = (g.graph().acyclicer === \"greedy\"\n    ? greedyFAS(g, weightFn(g))\n    : dfsFAS(g));\n  _.forEach(fas, function(e) {\n    var label = g.edge(e);\n    g.removeEdge(e);\n    label.forwardName = e.name;\n    label.reversed = true;\n    g.setEdge(e.w, e.v, label, _.uniqueId(\"rev\"));\n  });\n\n  function weightFn(g) {\n    return function(e) {\n      return g.edge(e).weight;\n    };\n  }\n}\n\nfunction dfsFAS(g) {\n  var fas = [];\n  var stack = {};\n  var visited = {};\n\n  function dfs(v) {\n    if (_.has(visited, v)) {\n      return;\n    }\n    visited[v] = true;\n    stack[v] = true;\n    _.forEach(g.outEdges(v), function(e) {\n      if (_.has(stack, e.w)) {\n        fas.push(e);\n      } else {\n        dfs(e.w);\n      }\n    });\n    delete stack[v];\n  }\n\n  _.forEach(g.nodes(), dfs);\n  return fas;\n}\n\nfunction undo(g) {\n  _.forEach(g.edges(), function(e) {\n    var label = g.edge(e);\n    if (label.reversed) {\n      g.removeEdge(e);\n\n      var forwardName = label.forwardName;\n      delete label.reversed;\n      delete label.forwardName;\n      g.setEdge(e.w, e.v, label, forwardName);\n    }\n  });\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/add-border-segments.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/add-border-segments.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\n\nmodule.exports = addBorderSegments;\n\nfunction addBorderSegments(g) {\n  function dfs(v) {\n    var children = g.children(v);\n    var node = g.node(v);\n    if (children.length) {\n      _.forEach(children, dfs);\n    }\n\n    if (_.has(node, \"minRank\")) {\n      node.borderLeft = [];\n      node.borderRight = [];\n      for (var rank = node.minRank, maxRank = node.maxRank + 1;\n        rank < maxRank;\n        ++rank) {\n        addBorderNode(g, \"borderLeft\", \"_bl\", v, node, rank);\n        addBorderNode(g, \"borderRight\", \"_br\", v, node, rank);\n      }\n    }\n  }\n\n  _.forEach(g.children(), dfs);\n}\n\nfunction addBorderNode(g, prop, prefix, sg, sgNode, rank) {\n  var label = { width: 0, height: 0, rank: rank, borderType: prop };\n  var prev = sgNode[prop][rank - 1];\n  var curr = util.addDummyNode(g, \"border\", label, prefix);\n  sgNode[prop][rank] = curr;\n  g.setParent(curr, sg);\n  if (prev) {\n    g.setEdge(prev, curr, { weight: 1 });\n  }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/coordinate-system.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/coordinate-system.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = {\n  adjust: adjust,\n  undo: undo\n};\n\nfunction adjust(g) {\n  var rankDir = g.graph().rankdir.toLowerCase();\n  if (rankDir === \"lr\" || rankDir === \"rl\") {\n    swapWidthHeight(g);\n  }\n}\n\nfunction undo(g) {\n  var rankDir = g.graph().rankdir.toLowerCase();\n  if (rankDir === \"bt\" || rankDir === \"rl\") {\n    reverseY(g);\n  }\n\n  if (rankDir === \"lr\" || rankDir === \"rl\") {\n    swapXY(g);\n    swapWidthHeight(g);\n  }\n}\n\nfunction swapWidthHeight(g) {\n  _.forEach(g.nodes(), function(v) { swapWidthHeightOne(g.node(v)); });\n  _.forEach(g.edges(), function(e) { swapWidthHeightOne(g.edge(e)); });\n}\n\nfunction swapWidthHeightOne(attrs) {\n  var w = attrs.width;\n  attrs.width = attrs.height;\n  attrs.height = w;\n}\n\nfunction reverseY(g) {\n  _.forEach(g.nodes(), function(v) { reverseYOne(g.node(v)); });\n\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    _.forEach(edge.points, reverseYOne);\n    if (_.has(edge, \"y\")) {\n      reverseYOne(edge);\n    }\n  });\n}\n\nfunction reverseYOne(attrs) {\n  attrs.y = -attrs.y;\n}\n\nfunction swapXY(g) {\n  _.forEach(g.nodes(), function(v) { swapXYOne(g.node(v)); });\n\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    _.forEach(edge.points, swapXYOne);\n    if (_.has(edge, \"x\")) {\n      swapXYOne(edge);\n    }\n  });\n}\n\nfunction swapXYOne(attrs) {\n  var x = attrs.x;\n  attrs.x = attrs.y;\n  attrs.y = x;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/data/list.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/data/list.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/*\n * Simple doubly linked list implementation derived from Cormen, et al.,\n * \"Introduction to Algorithms\".\n */\n\nmodule.exports = List;\n\nfunction List() {\n  var sentinel = {};\n  sentinel._next = sentinel._prev = sentinel;\n  this._sentinel = sentinel;\n}\n\nList.prototype.dequeue = function() {\n  var sentinel = this._sentinel;\n  var entry = sentinel._prev;\n  if (entry !== sentinel) {\n    unlink(entry);\n    return entry;\n  }\n};\n\nList.prototype.enqueue = function(entry) {\n  var sentinel = this._sentinel;\n  if (entry._prev && entry._next) {\n    unlink(entry);\n  }\n  entry._next = sentinel._next;\n  sentinel._next._prev = entry;\n  sentinel._next = entry;\n  entry._prev = sentinel;\n};\n\nList.prototype.toString = function() {\n  var strs = [];\n  var sentinel = this._sentinel;\n  var curr = sentinel._prev;\n  while (curr !== sentinel) {\n    strs.push(JSON.stringify(curr, filterOutLinks));\n    curr = curr._prev;\n  }\n  return \"[\" + strs.join(\", \") + \"]\";\n};\n\nfunction unlink(entry) {\n  entry._prev._next = entry._next;\n  entry._next._prev = entry._prev;\n  delete entry._next;\n  delete entry._prev;\n}\n\nfunction filterOutLinks(k, v) {\n  if (k !== \"_next\" && k !== \"_prev\") {\n    return v;\n  }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/debug.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/debug.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\nvar Graph = __webpack_require__(/*! ./graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\n\nmodule.exports = {\n  debugOrdering: debugOrdering\n};\n\n/* istanbul ignore next */\nfunction debugOrdering(g) {\n  var layerMatrix = util.buildLayerMatrix(g);\n\n  var h = new Graph({ compound: true, multigraph: true }).setGraph({});\n\n  _.forEach(g.nodes(), function(v) {\n    h.setNode(v, { label: v });\n    h.setParent(v, \"layer\" + g.node(v).rank);\n  });\n\n  _.forEach(g.edges(), function(e) {\n    h.setEdge(e.v, e.w, {}, e.name);\n  });\n\n  _.forEach(layerMatrix, function(layer, i) {\n    var layerV = \"layer\" + i;\n    h.setNode(layerV, { rank: \"same\" });\n    _.reduce(layer, function(u, v) {\n      h.setEdge(u, v, { style: \"invis\" });\n      return v;\n    });\n  });\n\n  return h;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* global window */\n\nvar graphlib;\n\nif (true) {\n  try {\n    graphlib = __webpack_require__(/*! graphlib */ \"./node_modules/_graphlib@2.1.8@graphlib/index.js\");\n  } catch (e) {\n    // continue regardless of error\n  }\n}\n\nif (!graphlib) {\n  graphlib = window.graphlib;\n}\n\nmodule.exports = graphlib;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/greedy-fas.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/greedy-fas.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar Graph = __webpack_require__(/*! ./graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\nvar List = __webpack_require__(/*! ./data/list */ \"./node_modules/_dagre@0.8.5@dagre/lib/data/list.js\");\n\n/*\n * A greedy heuristic for finding a feedback arc set for a graph. A feedback\n * arc set is a set of edges that can be removed to make a graph acyclic.\n * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, \"A fast and\n * effective heuristic for the feedback arc set problem.\" This implementation\n * adjusts that from the paper to allow for weighted edges.\n */\nmodule.exports = greedyFAS;\n\nvar DEFAULT_WEIGHT_FN = _.constant(1);\n\nfunction greedyFAS(g, weightFn) {\n  if (g.nodeCount() <= 1) {\n    return [];\n  }\n  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);\n  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);\n\n  // Expand multi-edges\n  return _.flatten(_.map(results, function(e) {\n    return g.outEdges(e.v, e.w);\n  }), true);\n}\n\nfunction doGreedyFAS(g, buckets, zeroIdx) {\n  var results = [];\n  var sources = buckets[buckets.length - 1];\n  var sinks = buckets[0];\n\n  var entry;\n  while (g.nodeCount()) {\n    while ((entry = sinks.dequeue()))   { removeNode(g, buckets, zeroIdx, entry); }\n    while ((entry = sources.dequeue())) { removeNode(g, buckets, zeroIdx, entry); }\n    if (g.nodeCount()) {\n      for (var i = buckets.length - 2; i > 0; --i) {\n        entry = buckets[i].dequeue();\n        if (entry) {\n          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));\n          break;\n        }\n      }\n    }\n  }\n\n  return results;\n}\n\nfunction removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {\n  var results = collectPredecessors ? [] : undefined;\n\n  _.forEach(g.inEdges(entry.v), function(edge) {\n    var weight = g.edge(edge);\n    var uEntry = g.node(edge.v);\n\n    if (collectPredecessors) {\n      results.push({ v: edge.v, w: edge.w });\n    }\n\n    uEntry.out -= weight;\n    assignBucket(buckets, zeroIdx, uEntry);\n  });\n\n  _.forEach(g.outEdges(entry.v), function(edge) {\n    var weight = g.edge(edge);\n    var w = edge.w;\n    var wEntry = g.node(w);\n    wEntry[\"in\"] -= weight;\n    assignBucket(buckets, zeroIdx, wEntry);\n  });\n\n  g.removeNode(entry.v);\n\n  return results;\n}\n\nfunction buildState(g, weightFn) {\n  var fasGraph = new Graph();\n  var maxIn = 0;\n  var maxOut = 0;\n\n  _.forEach(g.nodes(), function(v) {\n    fasGraph.setNode(v, { v: v, \"in\": 0, out: 0 });\n  });\n\n  // Aggregate weights on nodes, but also sum the weights across multi-edges\n  // into a single edge for the fasGraph.\n  _.forEach(g.edges(), function(e) {\n    var prevWeight = fasGraph.edge(e.v, e.w) || 0;\n    var weight = weightFn(e);\n    var edgeWeight = prevWeight + weight;\n    fasGraph.setEdge(e.v, e.w, edgeWeight);\n    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);\n    maxIn  = Math.max(maxIn,  fasGraph.node(e.w)[\"in\"]  += weight);\n  });\n\n  var buckets = _.range(maxOut + maxIn + 3).map(function() { return new List(); });\n  var zeroIdx = maxIn + 1;\n\n  _.forEach(fasGraph.nodes(), function(v) {\n    assignBucket(buckets, zeroIdx, fasGraph.node(v));\n  });\n\n  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx };\n}\n\nfunction assignBucket(buckets, zeroIdx, entry) {\n  if (!entry.out) {\n    buckets[0].enqueue(entry);\n  } else if (!entry[\"in\"]) {\n    buckets[buckets.length - 1].enqueue(entry);\n  } else {\n    buckets[entry.out - entry[\"in\"] + zeroIdx].enqueue(entry);\n  }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/layout.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/layout.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar acyclic = __webpack_require__(/*! ./acyclic */ \"./node_modules/_dagre@0.8.5@dagre/lib/acyclic.js\");\nvar normalize = __webpack_require__(/*! ./normalize */ \"./node_modules/_dagre@0.8.5@dagre/lib/normalize.js\");\nvar rank = __webpack_require__(/*! ./rank */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/index.js\");\nvar normalizeRanks = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\").normalizeRanks;\nvar parentDummyChains = __webpack_require__(/*! ./parent-dummy-chains */ \"./node_modules/_dagre@0.8.5@dagre/lib/parent-dummy-chains.js\");\nvar removeEmptyRanks = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\").removeEmptyRanks;\nvar nestingGraph = __webpack_require__(/*! ./nesting-graph */ \"./node_modules/_dagre@0.8.5@dagre/lib/nesting-graph.js\");\nvar addBorderSegments = __webpack_require__(/*! ./add-border-segments */ \"./node_modules/_dagre@0.8.5@dagre/lib/add-border-segments.js\");\nvar coordinateSystem = __webpack_require__(/*! ./coordinate-system */ \"./node_modules/_dagre@0.8.5@dagre/lib/coordinate-system.js\");\nvar order = __webpack_require__(/*! ./order */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/index.js\");\nvar position = __webpack_require__(/*! ./position */ \"./node_modules/_dagre@0.8.5@dagre/lib/position/index.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\nvar Graph = __webpack_require__(/*! ./graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\n\nmodule.exports = layout;\n\nfunction layout(g, opts) {\n  var time = opts && opts.debugTiming ? util.time : util.notime;\n  time(\"layout\", function() {\n    var layoutGraph = \n      time(\"  buildLayoutGraph\", function() { return buildLayoutGraph(g); });\n    time(\"  runLayout\",        function() { runLayout(layoutGraph, time); });\n    time(\"  updateInputGraph\", function() { updateInputGraph(g, layoutGraph); });\n  });\n}\n\nfunction runLayout(g, time) {\n  time(\"    makeSpaceForEdgeLabels\", function() { makeSpaceForEdgeLabels(g); });\n  time(\"    removeSelfEdges\",        function() { removeSelfEdges(g); });\n  time(\"    acyclic\",                function() { acyclic.run(g); });\n  time(\"    nestingGraph.run\",       function() { nestingGraph.run(g); });\n  time(\"    rank\",                   function() { rank(util.asNonCompoundGraph(g)); });\n  time(\"    injectEdgeLabelProxies\", function() { injectEdgeLabelProxies(g); });\n  time(\"    removeEmptyRanks\",       function() { removeEmptyRanks(g); });\n  time(\"    nestingGraph.cleanup\",   function() { nestingGraph.cleanup(g); });\n  time(\"    normalizeRanks\",         function() { normalizeRanks(g); });\n  time(\"    assignRankMinMax\",       function() { assignRankMinMax(g); });\n  time(\"    removeEdgeLabelProxies\", function() { removeEdgeLabelProxies(g); });\n  time(\"    normalize.run\",          function() { normalize.run(g); });\n  time(\"    parentDummyChains\",      function() { parentDummyChains(g); });\n  time(\"    addBorderSegments\",      function() { addBorderSegments(g); });\n  time(\"    order\",                  function() { order(g); });\n  time(\"    insertSelfEdges\",        function() { insertSelfEdges(g); });\n  time(\"    adjustCoordinateSystem\", function() { coordinateSystem.adjust(g); });\n  time(\"    position\",               function() { position(g); });\n  time(\"    positionSelfEdges\",      function() { positionSelfEdges(g); });\n  time(\"    removeBorderNodes\",      function() { removeBorderNodes(g); });\n  time(\"    normalize.undo\",         function() { normalize.undo(g); });\n  time(\"    fixupEdgeLabelCoords\",   function() { fixupEdgeLabelCoords(g); });\n  time(\"    undoCoordinateSystem\",   function() { coordinateSystem.undo(g); });\n  time(\"    translateGraph\",         function() { translateGraph(g); });\n  time(\"    assignNodeIntersects\",   function() { assignNodeIntersects(g); });\n  time(\"    reversePoints\",          function() { reversePointsForReversedEdges(g); });\n  time(\"    acyclic.undo\",           function() { acyclic.undo(g); });\n}\n\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction updateInputGraph(inputGraph, layoutGraph) {\n  _.forEach(inputGraph.nodes(), function(v) {\n    var inputLabel = inputGraph.node(v);\n    var layoutLabel = layoutGraph.node(v);\n\n    if (inputLabel) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n\n      if (layoutGraph.children(v).length) {\n        inputLabel.width = layoutLabel.width;\n        inputLabel.height = layoutLabel.height;\n      }\n    }\n  });\n\n  _.forEach(inputGraph.edges(), function(e) {\n    var inputLabel = inputGraph.edge(e);\n    var layoutLabel = layoutGraph.edge(e);\n\n    inputLabel.points = layoutLabel.points;\n    if (_.has(layoutLabel, \"x\")) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n    }\n  });\n\n  inputGraph.graph().width = layoutGraph.graph().width;\n  inputGraph.graph().height = layoutGraph.graph().height;\n}\n\nvar graphNumAttrs = [\"nodesep\", \"edgesep\", \"ranksep\", \"marginx\", \"marginy\"];\nvar graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: \"tb\" };\nvar graphAttrs = [\"acyclicer\", \"ranker\", \"rankdir\", \"align\"];\nvar nodeNumAttrs = [\"width\", \"height\"];\nvar nodeDefaults = { width: 0, height: 0 };\nvar edgeNumAttrs = [\"minlen\", \"weight\", \"width\", \"height\", \"labeloffset\"];\nvar edgeDefaults = {\n  minlen: 1, weight: 1, width: 0, height: 0,\n  labeloffset: 10, labelpos: \"r\"\n};\nvar edgeAttrs = [\"labelpos\"];\n\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction buildLayoutGraph(inputGraph) {\n  var g = new Graph({ multigraph: true, compound: true });\n  var graph = canonicalize(inputGraph.graph());\n\n  g.setGraph(_.merge({},\n    graphDefaults,\n    selectNumberAttrs(graph, graphNumAttrs),\n    _.pick(graph, graphAttrs)));\n\n  _.forEach(inputGraph.nodes(), function(v) {\n    var node = canonicalize(inputGraph.node(v));\n    g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));\n    g.setParent(v, inputGraph.parent(v));\n  });\n\n  _.forEach(inputGraph.edges(), function(e) {\n    var edge = canonicalize(inputGraph.edge(e));\n    g.setEdge(e, _.merge({},\n      edgeDefaults,\n      selectNumberAttrs(edge, edgeNumAttrs),\n      _.pick(edge, edgeAttrs)));\n  });\n\n  return g;\n}\n\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\nfunction makeSpaceForEdgeLabels(g) {\n  var graph = g.graph();\n  graph.ranksep /= 2;\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    edge.minlen *= 2;\n    if (edge.labelpos.toLowerCase() !== \"c\") {\n      if (graph.rankdir === \"TB\" || graph.rankdir === \"BT\") {\n        edge.width += edge.labeloffset;\n      } else {\n        edge.height += edge.labeloffset;\n      }\n    }\n  });\n}\n\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\nfunction injectEdgeLabelProxies(g) {\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (edge.width && edge.height) {\n      var v = g.node(e.v);\n      var w = g.node(e.w);\n      var label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };\n      util.addDummyNode(g, \"edge-proxy\", label, \"_ep\");\n    }\n  });\n}\n\nfunction assignRankMinMax(g) {\n  var maxRank = 0;\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    if (node.borderTop) {\n      node.minRank = g.node(node.borderTop).rank;\n      node.maxRank = g.node(node.borderBottom).rank;\n      maxRank = _.max(maxRank, node.maxRank);\n    }\n  });\n  g.graph().maxRank = maxRank;\n}\n\nfunction removeEdgeLabelProxies(g) {\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    if (node.dummy === \"edge-proxy\") {\n      g.edge(node.e).labelRank = node.rank;\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction translateGraph(g) {\n  var minX = Number.POSITIVE_INFINITY;\n  var maxX = 0;\n  var minY = Number.POSITIVE_INFINITY;\n  var maxY = 0;\n  var graphLabel = g.graph();\n  var marginX = graphLabel.marginx || 0;\n  var marginY = graphLabel.marginy || 0;\n\n  function getExtremes(attrs) {\n    var x = attrs.x;\n    var y = attrs.y;\n    var w = attrs.width;\n    var h = attrs.height;\n    minX = Math.min(minX, x - w / 2);\n    maxX = Math.max(maxX, x + w / 2);\n    minY = Math.min(minY, y - h / 2);\n    maxY = Math.max(maxY, y + h / 2);\n  }\n\n  _.forEach(g.nodes(), function(v) { getExtremes(g.node(v)); });\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (_.has(edge, \"x\")) {\n      getExtremes(edge);\n    }\n  });\n\n  minX -= marginX;\n  minY -= marginY;\n\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    node.x -= minX;\n    node.y -= minY;\n  });\n\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    _.forEach(edge.points, function(p) {\n      p.x -= minX;\n      p.y -= minY;\n    });\n    if (_.has(edge, \"x\")) { edge.x -= minX; }\n    if (_.has(edge, \"y\")) { edge.y -= minY; }\n  });\n\n  graphLabel.width = maxX - minX + marginX;\n  graphLabel.height = maxY - minY + marginY;\n}\n\nfunction assignNodeIntersects(g) {\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    var nodeV = g.node(e.v);\n    var nodeW = g.node(e.w);\n    var p1, p2;\n    if (!edge.points) {\n      edge.points = [];\n      p1 = nodeW;\n      p2 = nodeV;\n    } else {\n      p1 = edge.points[0];\n      p2 = edge.points[edge.points.length - 1];\n    }\n    edge.points.unshift(util.intersectRect(nodeV, p1));\n    edge.points.push(util.intersectRect(nodeW, p2));\n  });\n}\n\nfunction fixupEdgeLabelCoords(g) {\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (_.has(edge, \"x\")) {\n      if (edge.labelpos === \"l\" || edge.labelpos === \"r\") {\n        edge.width -= edge.labeloffset;\n      }\n      switch (edge.labelpos) {\n      case \"l\": edge.x -= edge.width / 2 + edge.labeloffset; break;\n      case \"r\": edge.x += edge.width / 2 + edge.labeloffset; break;\n      }\n    }\n  });\n}\n\nfunction reversePointsForReversedEdges(g) {\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (edge.reversed) {\n      edge.points.reverse();\n    }\n  });\n}\n\nfunction removeBorderNodes(g) {\n  _.forEach(g.nodes(), function(v) {\n    if (g.children(v).length) {\n      var node = g.node(v);\n      var t = g.node(node.borderTop);\n      var b = g.node(node.borderBottom);\n      var l = g.node(_.last(node.borderLeft));\n      var r = g.node(_.last(node.borderRight));\n\n      node.width = Math.abs(r.x - l.x);\n      node.height = Math.abs(b.y - t.y);\n      node.x = l.x + node.width / 2;\n      node.y = t.y + node.height / 2;\n    }\n  });\n\n  _.forEach(g.nodes(), function(v) {\n    if (g.node(v).dummy === \"border\") {\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction removeSelfEdges(g) {\n  _.forEach(g.edges(), function(e) {\n    if (e.v === e.w) {\n      var node = g.node(e.v);\n      if (!node.selfEdges) {\n        node.selfEdges = [];\n      }\n      node.selfEdges.push({ e: e, label: g.edge(e) });\n      g.removeEdge(e);\n    }\n  });\n}\n\nfunction insertSelfEdges(g) {\n  var layers = util.buildLayerMatrix(g);\n  _.forEach(layers, function(layer) {\n    var orderShift = 0;\n    _.forEach(layer, function(v, i) {\n      var node = g.node(v);\n      node.order = i + orderShift;\n      _.forEach(node.selfEdges, function(selfEdge) {\n        util.addDummyNode(g, \"selfedge\", {\n          width: selfEdge.label.width,\n          height: selfEdge.label.height,\n          rank: node.rank,\n          order: i + (++orderShift),\n          e: selfEdge.e,\n          label: selfEdge.label\n        }, \"_se\");\n      });\n      delete node.selfEdges;\n    });\n  });\n}\n\nfunction positionSelfEdges(g) {\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    if (node.dummy === \"selfedge\") {\n      var selfNode = g.node(node.e.v);\n      var x = selfNode.x + selfNode.width / 2;\n      var y = selfNode.y;\n      var dx = node.x - x;\n      var dy = selfNode.height / 2;\n      g.setEdge(node.e, node.label);\n      g.removeNode(v);\n      node.label.points = [\n        { x: x + 2 * dx / 3, y: y - dy },\n        { x: x + 5 * dx / 6, y: y - dy },\n        { x: x +     dx    , y: y },\n        { x: x + 5 * dx / 6, y: y + dy },\n        { x: x + 2 * dx / 3, y: y + dy }\n      ];\n      node.label.x = node.x;\n      node.label.y = node.y;\n    }\n  });\n}\n\nfunction selectNumberAttrs(obj, attrs) {\n  return _.mapValues(_.pick(obj, attrs), Number);\n}\n\nfunction canonicalize(attrs) {\n  var newAttrs = {};\n  _.forEach(attrs, function(v, k) {\n    newAttrs[k.toLowerCase()] = v;\n  });\n  return newAttrs;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/lodash.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* global window */\n\nvar lodash;\n\nif (true) {\n  try {\n    lodash = {\n      cloneDeep: __webpack_require__(/*! lodash/cloneDeep */ \"./node_modules/_lodash@4.17.15@lodash/cloneDeep.js\"),\n      constant: __webpack_require__(/*! lodash/constant */ \"./node_modules/_lodash@4.17.15@lodash/constant.js\"),\n      defaults: __webpack_require__(/*! lodash/defaults */ \"./node_modules/_lodash@4.17.15@lodash/defaults.js\"),\n      each: __webpack_require__(/*! lodash/each */ \"./node_modules/_lodash@4.17.15@lodash/each.js\"),\n      filter: __webpack_require__(/*! lodash/filter */ \"./node_modules/_lodash@4.17.15@lodash/filter.js\"),\n      find: __webpack_require__(/*! lodash/find */ \"./node_modules/_lodash@4.17.15@lodash/find.js\"),\n      flatten: __webpack_require__(/*! lodash/flatten */ \"./node_modules/_lodash@4.17.15@lodash/flatten.js\"),\n      forEach: __webpack_require__(/*! lodash/forEach */ \"./node_modules/_lodash@4.17.15@lodash/forEach.js\"),\n      forIn: __webpack_require__(/*! lodash/forIn */ \"./node_modules/_lodash@4.17.15@lodash/forIn.js\"),\n      has:  __webpack_require__(/*! lodash/has */ \"./node_modules/_lodash@4.17.15@lodash/has.js\"),\n      isUndefined: __webpack_require__(/*! lodash/isUndefined */ \"./node_modules/_lodash@4.17.15@lodash/isUndefined.js\"),\n      last: __webpack_require__(/*! lodash/last */ \"./node_modules/_lodash@4.17.15@lodash/last.js\"),\n      map: __webpack_require__(/*! lodash/map */ \"./node_modules/_lodash@4.17.15@lodash/map.js\"),\n      mapValues: __webpack_require__(/*! lodash/mapValues */ \"./node_modules/_lodash@4.17.15@lodash/mapValues.js\"),\n      max: __webpack_require__(/*! lodash/max */ \"./node_modules/_lodash@4.17.15@lodash/max.js\"),\n      merge: __webpack_require__(/*! lodash/merge */ \"./node_modules/_lodash@4.17.15@lodash/merge.js\"),\n      min: __webpack_require__(/*! lodash/min */ \"./node_modules/_lodash@4.17.15@lodash/min.js\"),\n      minBy: __webpack_require__(/*! lodash/minBy */ \"./node_modules/_lodash@4.17.15@lodash/minBy.js\"),\n      now: __webpack_require__(/*! lodash/now */ \"./node_modules/_lodash@4.17.15@lodash/now.js\"),\n      pick: __webpack_require__(/*! lodash/pick */ \"./node_modules/_lodash@4.17.15@lodash/pick.js\"),\n      range: __webpack_require__(/*! lodash/range */ \"./node_modules/_lodash@4.17.15@lodash/range.js\"),\n      reduce: __webpack_require__(/*! lodash/reduce */ \"./node_modules/_lodash@4.17.15@lodash/reduce.js\"),\n      sortBy: __webpack_require__(/*! lodash/sortBy */ \"./node_modules/_lodash@4.17.15@lodash/sortBy.js\"),\n      uniqueId: __webpack_require__(/*! lodash/uniqueId */ \"./node_modules/_lodash@4.17.15@lodash/uniqueId.js\"),\n      values: __webpack_require__(/*! lodash/values */ \"./node_modules/_lodash@4.17.15@lodash/values.js\"),\n      zipObject: __webpack_require__(/*! lodash/zipObject */ \"./node_modules/_lodash@4.17.15@lodash/zipObject.js\"),\n    };\n  } catch (e) {\n    // continue regardless of error\n  }\n}\n\nif (!lodash) {\n  lodash = window._;\n}\n\nmodule.exports = lodash;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/nesting-graph.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/nesting-graph.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\n\nmodule.exports = {\n  run: run,\n  cleanup: cleanup\n};\n\n/*\n * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,\n * adds appropriate edges to ensure that all cluster nodes are placed between\n * these boundries, and ensures that the graph is connected.\n *\n * In addition we ensure, through the use of the minlen property, that nodes\n * and subgraph border nodes to not end up on the same rank.\n *\n * Preconditions:\n *\n *    1. Input graph is a DAG\n *    2. Nodes in the input graph has a minlen attribute\n *\n * Postconditions:\n *\n *    1. Input graph is connected.\n *    2. Dummy nodes are added for the tops and bottoms of subgraphs.\n *    3. The minlen attribute for nodes is adjusted to ensure nodes do not\n *       get placed on the same rank as subgraph border nodes.\n *\n * The nesting graph idea comes from Sander, \"Layout of Compound Directed\n * Graphs.\"\n */\nfunction run(g) {\n  var root = util.addDummyNode(g, \"root\", {}, \"_root\");\n  var depths = treeDepths(g);\n  var height = _.max(_.values(depths)) - 1; // Note: depths is an Object not an array\n  var nodeSep = 2 * height + 1;\n\n  g.graph().nestingRoot = root;\n\n  // Multiply minlen by nodeSep to align nodes on non-border ranks.\n  _.forEach(g.edges(), function(e) { g.edge(e).minlen *= nodeSep; });\n\n  // Calculate a weight that is sufficient to keep subgraphs vertically compact\n  var weight = sumWeights(g) + 1;\n\n  // Create border nodes and link them up\n  _.forEach(g.children(), function(child) {\n    dfs(g, root, nodeSep, weight, height, depths, child);\n  });\n\n  // Save the multiplier for node layers for later removal of empty border\n  // layers.\n  g.graph().nodeRankFactor = nodeSep;\n}\n\nfunction dfs(g, root, nodeSep, weight, height, depths, v) {\n  var children = g.children(v);\n  if (!children.length) {\n    if (v !== root) {\n      g.setEdge(root, v, { weight: 0, minlen: nodeSep });\n    }\n    return;\n  }\n\n  var top = util.addBorderNode(g, \"_bt\");\n  var bottom = util.addBorderNode(g, \"_bb\");\n  var label = g.node(v);\n\n  g.setParent(top, v);\n  label.borderTop = top;\n  g.setParent(bottom, v);\n  label.borderBottom = bottom;\n\n  _.forEach(children, function(child) {\n    dfs(g, root, nodeSep, weight, height, depths, child);\n\n    var childNode = g.node(child);\n    var childTop = childNode.borderTop ? childNode.borderTop : child;\n    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;\n    var thisWeight = childNode.borderTop ? weight : 2 * weight;\n    var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;\n\n    g.setEdge(top, childTop, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true\n    });\n\n    g.setEdge(childBottom, bottom, {\n      weight: thisWeight,\n      minlen: minlen,\n      nestingEdge: true\n    });\n  });\n\n  if (!g.parent(v)) {\n    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });\n  }\n}\n\nfunction treeDepths(g) {\n  var depths = {};\n  function dfs(v, depth) {\n    var children = g.children(v);\n    if (children && children.length) {\n      _.forEach(children, function(child) {\n        dfs(child, depth + 1);\n      });\n    }\n    depths[v] = depth;\n  }\n  _.forEach(g.children(), function(v) { dfs(v, 1); });\n  return depths;\n}\n\nfunction sumWeights(g) {\n  return _.reduce(g.edges(), function(acc, e) {\n    return acc + g.edge(e).weight;\n  }, 0);\n}\n\nfunction cleanup(g) {\n  var graphLabel = g.graph();\n  g.removeNode(graphLabel.nestingRoot);\n  delete graphLabel.nestingRoot;\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (edge.nestingEdge) {\n      g.removeEdge(e);\n    }\n  });\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/normalize.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/normalize.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\n\nmodule.exports = {\n  run: run,\n  undo: undo\n};\n\n/*\n * Breaks any long edges in the graph into short segments that span 1 layer\n * each. This operation is undoable with the denormalize function.\n *\n * Pre-conditions:\n *\n *    1. The input graph is a DAG.\n *    2. Each node in the graph has a \"rank\" property.\n *\n * Post-condition:\n *\n *    1. All edges in the graph have a length of 1.\n *    2. Dummy nodes are added where edges have been split into segments.\n *    3. The graph is augmented with a \"dummyChains\" attribute which contains\n *       the first dummy in each chain of dummy nodes produced.\n */\nfunction run(g) {\n  g.graph().dummyChains = [];\n  _.forEach(g.edges(), function(edge) { normalizeEdge(g, edge); });\n}\n\nfunction normalizeEdge(g, e) {\n  var v = e.v;\n  var vRank = g.node(v).rank;\n  var w = e.w;\n  var wRank = g.node(w).rank;\n  var name = e.name;\n  var edgeLabel = g.edge(e);\n  var labelRank = edgeLabel.labelRank;\n\n  if (wRank === vRank + 1) return;\n\n  g.removeEdge(e);\n\n  var dummy, attrs, i;\n  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {\n    edgeLabel.points = [];\n    attrs = {\n      width: 0, height: 0,\n      edgeLabel: edgeLabel, edgeObj: e,\n      rank: vRank\n    };\n    dummy = util.addDummyNode(g, \"edge\", attrs, \"_d\");\n    if (vRank === labelRank) {\n      attrs.width = edgeLabel.width;\n      attrs.height = edgeLabel.height;\n      attrs.dummy = \"edge-label\";\n      attrs.labelpos = edgeLabel.labelpos;\n    }\n    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);\n    if (i === 0) {\n      g.graph().dummyChains.push(dummy);\n    }\n    v = dummy;\n  }\n\n  g.setEdge(v, w, { weight: edgeLabel.weight }, name);\n}\n\nfunction undo(g) {\n  _.forEach(g.graph().dummyChains, function(v) {\n    var node = g.node(v);\n    var origLabel = node.edgeLabel;\n    var w;\n    g.setEdge(node.edgeObj, origLabel);\n    while (node.dummy) {\n      w = g.successors(v)[0];\n      g.removeNode(v);\n      origLabel.points.push({ x: node.x, y: node.y });\n      if (node.dummy === \"edge-label\") {\n        origLabel.x = node.x;\n        origLabel.y = node.y;\n        origLabel.width = node.width;\n        origLabel.height = node.height;\n      }\n      v = w;\n      node = g.node(v);\n    }\n  });\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/add-subgraph-constraints.js\":\n/*!*******************************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/add-subgraph-constraints.js ***!\n  \\*******************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = addSubgraphConstraints;\n\nfunction addSubgraphConstraints(g, cg, vs) {\n  var prev = {},\n    rootPrev;\n\n  _.forEach(vs, function(v) {\n    var child = g.parent(v),\n      parent,\n      prevChild;\n    while (child) {\n      parent = g.parent(child);\n      if (parent) {\n        prevChild = prev[parent];\n        prev[parent] = child;\n      } else {\n        prevChild = rootPrev;\n        rootPrev = child;\n      }\n      if (prevChild && prevChild !== child) {\n        cg.setEdge(prevChild, child);\n        return;\n      }\n      child = parent;\n    }\n  });\n\n  /*\n  function dfs(v) {\n    var children = v ? g.children(v) : g.children();\n    if (children.length) {\n      var min = Number.POSITIVE_INFINITY,\n          subgraphs = [];\n      _.each(children, function(child) {\n        var childMin = dfs(child);\n        if (g.children(child).length) {\n          subgraphs.push({ v: child, order: childMin });\n        }\n        min = Math.min(min, childMin);\n      });\n      _.reduce(_.sortBy(subgraphs, \"order\"), function(prev, curr) {\n        cg.setEdge(prev.v, curr.v);\n        return curr;\n      });\n      return min;\n    }\n    return g.node(v).order;\n  }\n  dfs(undefined);\n  */\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/barycenter.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/barycenter.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = barycenter;\n\nfunction barycenter(g, movable) {\n  return _.map(movable, function(v) {\n    var inV = g.inEdges(v);\n    if (!inV.length) {\n      return { v: v };\n    } else {\n      var result = _.reduce(inV, function(acc, e) {\n        var edge = g.edge(e),\n          nodeU = g.node(e.v);\n        return {\n          sum: acc.sum + (edge.weight * nodeU.order),\n          weight: acc.weight + edge.weight\n        };\n      }, { sum: 0, weight: 0 });\n\n      return {\n        v: v,\n        barycenter: result.sum / result.weight,\n        weight: result.weight\n      };\n    }\n  });\n}\n\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/build-layer-graph.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/build-layer-graph.js ***!\n  \\************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar Graph = __webpack_require__(/*! ../graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\n\nmodule.exports = buildLayerGraph;\n\n/*\n * Constructs a graph that can be used to sort a layer of nodes. The graph will\n * contain all base and subgraph nodes from the request layer in their original\n * hierarchy and any edges that are incident on these nodes and are of the type\n * requested by the \"relationship\" parameter.\n *\n * Nodes from the requested rank that do not have parents are assigned a root\n * node in the output graph, which is set in the root graph attribute. This\n * makes it easy to walk the hierarchy of movable nodes during ordering.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG\n *    2. Base nodes in the input graph have a rank attribute\n *    3. Subgraph nodes in the input graph has minRank and maxRank attributes\n *    4. Edges have an assigned weight\n *\n * Post-conditions:\n *\n *    1. Output graph has all nodes in the movable rank with preserved\n *       hierarchy.\n *    2. Root nodes in the movable layer are made children of the node\n *       indicated by the root attribute of the graph.\n *    3. Non-movable nodes incident on movable nodes, selected by the\n *       relationship parameter, are included in the graph (without hierarchy).\n *    4. Edges incident on movable nodes, selected by the relationship\n *       parameter, are added to the output graph.\n *    5. The weights for copied edges are aggregated as need, since the output\n *       graph is not a multi-graph.\n */\nfunction buildLayerGraph(g, rank, relationship) {\n  var root = createRootNode(g),\n    result = new Graph({ compound: true }).setGraph({ root: root })\n      .setDefaultNodeLabel(function(v) { return g.node(v); });\n\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v),\n      parent = g.parent(v);\n\n    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {\n      result.setNode(v);\n      result.setParent(v, parent || root);\n\n      // This assumes we have only short edges!\n      _.forEach(g[relationship](v), function(e) {\n        var u = e.v === v ? e.w : e.v,\n          edge = result.edge(u, v),\n          weight = !_.isUndefined(edge) ? edge.weight : 0;\n        result.setEdge(u, v, { weight: g.edge(e).weight + weight });\n      });\n\n      if (_.has(node, \"minRank\")) {\n        result.setNode(v, {\n          borderLeft: node.borderLeft[rank],\n          borderRight: node.borderRight[rank]\n        });\n      }\n    }\n  });\n\n  return result;\n}\n\nfunction createRootNode(g) {\n  var v;\n  while (g.hasNode((v = _.uniqueId(\"_root\"))));\n  return v;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/cross-count.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/cross-count.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = crossCount;\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nfunction crossCount(g, layering) {\n  var cc = 0;\n  for (var i = 1; i < layering.length; ++i) {\n    cc += twoLayerCrossCount(g, layering[i-1], layering[i]);\n  }\n  return cc;\n}\n\nfunction twoLayerCrossCount(g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  var southPos = _.zipObject(southLayer,\n    _.map(southLayer, function (v, i) { return i; }));\n  var southEntries = _.flatten(_.map(northLayer, function(v) {\n    return _.sortBy(_.map(g.outEdges(v), function(e) {\n      return { pos: southPos[e.w], weight: g.edge(e).weight };\n    }), \"pos\");\n  }), true);\n\n  // Build the accumulator tree\n  var firstIndex = 1;\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n  var treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  var tree = _.map(new Array(treeSize), function() { return 0; });\n\n  // Calculate the weighted crossings\n  var cc = 0;\n  _.forEach(southEntries.forEach(function(entry) {\n    var index = entry.pos + firstIndex;\n    tree[index] += entry.weight;\n    var weightSum = 0;\n    while (index > 0) {\n      if (index % 2) {\n        weightSum += tree[index + 1];\n      }\n      index = (index - 1) >> 1;\n      tree[index] += entry.weight;\n    }\n    cc += entry.weight * weightSum;\n  }));\n\n  return cc;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/index.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/index.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar initOrder = __webpack_require__(/*! ./init-order */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/init-order.js\");\nvar crossCount = __webpack_require__(/*! ./cross-count */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/cross-count.js\");\nvar sortSubgraph = __webpack_require__(/*! ./sort-subgraph */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/sort-subgraph.js\");\nvar buildLayerGraph = __webpack_require__(/*! ./build-layer-graph */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/build-layer-graph.js\");\nvar addSubgraphConstraints = __webpack_require__(/*! ./add-subgraph-constraints */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/add-subgraph-constraints.js\");\nvar Graph = __webpack_require__(/*! ../graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\n\nmodule.exports = order;\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nfunction order(g) {\n  var maxRank = util.maxRank(g),\n    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), \"inEdges\"),\n    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), \"outEdges\");\n\n  var layering = initOrder(g);\n  assignOrder(g, layering);\n\n  var bestCC = Number.POSITIVE_INFINITY,\n    best;\n\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n\n    layering = util.buildLayerMatrix(g);\n    var cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = _.cloneDeep(layering);\n      bestCC = cc;\n    }\n  }\n\n  assignOrder(g, best);\n}\n\nfunction buildLayerGraphs(g, ranks, relationship) {\n  return _.map(ranks, function(rank) {\n    return buildLayerGraph(g, rank, relationship);\n  });\n}\n\nfunction sweepLayerGraphs(layerGraphs, biasRight) {\n  var cg = new Graph();\n  _.forEach(layerGraphs, function(lg) {\n    var root = lg.graph().root;\n    var sorted = sortSubgraph(lg, root, cg, biasRight);\n    _.forEach(sorted.vs, function(v, i) {\n      lg.node(v).order = i;\n    });\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n}\n\nfunction assignOrder(g, layering) {\n  _.forEach(layering, function(layer) {\n    _.forEach(layer, function(v, i) {\n      g.node(v).order = i;\n    });\n  });\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/init-order.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/init-order.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = initOrder;\n\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nfunction initOrder(g) {\n  var visited = {};\n  var simpleNodes = _.filter(g.nodes(), function(v) {\n    return !g.children(v).length;\n  });\n  var maxRank = _.max(_.map(simpleNodes, function(v) { return g.node(v).rank; }));\n  var layers = _.map(_.range(maxRank + 1), function() { return []; });\n\n  function dfs(v) {\n    if (_.has(visited, v)) return;\n    visited[v] = true;\n    var node = g.node(v);\n    layers[node.rank].push(v);\n    _.forEach(g.successors(v), dfs);\n  }\n\n  var orderedVs = _.sortBy(simpleNodes, function(v) { return g.node(v).rank; });\n  _.forEach(orderedVs, dfs);\n\n  return layers;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/resolve-conflicts.js\":\n/*!************************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/resolve-conflicts.js ***!\n  \\************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = resolveConflicts;\n\n/*\n * Given a list of entries of the form {v, barycenter, weight} and a\n * constraint graph this function will resolve any conflicts between the\n * constraint graph and the barycenters for the entries. If the barycenters for\n * an entry would violate a constraint in the constraint graph then we coalesce\n * the nodes in the conflict into a new node that respects the contraint and\n * aggregates barycenter and weight information.\n *\n * This implementation is based on the description in Forster, \"A Fast and\n * Simple Hueristic for Constrained Two-Level Crossing Reduction,\" thought it\n * differs in some specific details.\n *\n * Pre-conditions:\n *\n *    1. Each entry has the form {v, barycenter, weight}, or if the node has\n *       no barycenter, then {v}.\n *\n * Returns:\n *\n *    A new list of entries of the form {vs, i, barycenter, weight}. The list\n *    `vs` may either be a singleton or it may be an aggregation of nodes\n *    ordered such that they do not violate constraints from the constraint\n *    graph. The property `i` is the lowest original index of any of the\n *    elements in `vs`.\n */\nfunction resolveConflicts(entries, cg) {\n  var mappedEntries = {};\n  _.forEach(entries, function(entry, i) {\n    var tmp = mappedEntries[entry.v] = {\n      indegree: 0,\n      \"in\": [],\n      out: [],\n      vs: [entry.v],\n      i: i\n    };\n    if (!_.isUndefined(entry.barycenter)) {\n      tmp.barycenter = entry.barycenter;\n      tmp.weight = entry.weight;\n    }\n  });\n\n  _.forEach(cg.edges(), function(e) {\n    var entryV = mappedEntries[e.v];\n    var entryW = mappedEntries[e.w];\n    if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {\n      entryW.indegree++;\n      entryV.out.push(mappedEntries[e.w]);\n    }\n  });\n\n  var sourceSet = _.filter(mappedEntries, function(entry) {\n    return !entry.indegree;\n  });\n\n  return doResolveConflicts(sourceSet);\n}\n\nfunction doResolveConflicts(sourceSet) {\n  var entries = [];\n\n  function handleIn(vEntry) {\n    return function(uEntry) {\n      if (uEntry.merged) {\n        return;\n      }\n      if (_.isUndefined(uEntry.barycenter) ||\n          _.isUndefined(vEntry.barycenter) ||\n          uEntry.barycenter >= vEntry.barycenter) {\n        mergeEntries(vEntry, uEntry);\n      }\n    };\n  }\n\n  function handleOut(vEntry) {\n    return function(wEntry) {\n      wEntry[\"in\"].push(vEntry);\n      if (--wEntry.indegree === 0) {\n        sourceSet.push(wEntry);\n      }\n    };\n  }\n\n  while (sourceSet.length) {\n    var entry = sourceSet.pop();\n    entries.push(entry);\n    _.forEach(entry[\"in\"].reverse(), handleIn(entry));\n    _.forEach(entry.out, handleOut(entry));\n  }\n\n  return _.map(_.filter(entries, function(entry) { return !entry.merged; }),\n    function(entry) {\n      return _.pick(entry, [\"vs\", \"i\", \"barycenter\", \"weight\"]);\n    });\n\n}\n\nfunction mergeEntries(target, source) {\n  var sum = 0;\n  var weight = 0;\n\n  if (target.weight) {\n    sum += target.barycenter * target.weight;\n    weight += target.weight;\n  }\n\n  if (source.weight) {\n    sum += source.barycenter * source.weight;\n    weight += source.weight;\n  }\n\n  target.vs = source.vs.concat(target.vs);\n  target.barycenter = sum / weight;\n  target.weight = weight;\n  target.i = Math.min(source.i, target.i);\n  source.merged = true;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/sort-subgraph.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/sort-subgraph.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar barycenter = __webpack_require__(/*! ./barycenter */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/barycenter.js\");\nvar resolveConflicts = __webpack_require__(/*! ./resolve-conflicts */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/resolve-conflicts.js\");\nvar sort = __webpack_require__(/*! ./sort */ \"./node_modules/_dagre@0.8.5@dagre/lib/order/sort.js\");\n\nmodule.exports = sortSubgraph;\n\nfunction sortSubgraph(g, v, cg, biasRight) {\n  var movable = g.children(v);\n  var node = g.node(v);\n  var bl = node ? node.borderLeft : undefined;\n  var br = node ? node.borderRight: undefined;\n  var subgraphs = {};\n\n  if (bl) {\n    movable = _.filter(movable, function(w) {\n      return w !== bl && w !== br;\n    });\n  }\n\n  var barycenters = barycenter(g, movable);\n  _.forEach(barycenters, function(entry) {\n    if (g.children(entry.v).length) {\n      var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);\n      subgraphs[entry.v] = subgraphResult;\n      if (_.has(subgraphResult, \"barycenter\")) {\n        mergeBarycenters(entry, subgraphResult);\n      }\n    }\n  });\n\n  var entries = resolveConflicts(barycenters, cg);\n  expandSubgraphs(entries, subgraphs);\n\n  var result = sort(entries, biasRight);\n\n  if (bl) {\n    result.vs = _.flatten([bl, result.vs, br], true);\n    if (g.predecessors(bl).length) {\n      var blPred = g.node(g.predecessors(bl)[0]),\n        brPred = g.node(g.predecessors(br)[0]);\n      if (!_.has(result, \"barycenter\")) {\n        result.barycenter = 0;\n        result.weight = 0;\n      }\n      result.barycenter = (result.barycenter * result.weight +\n                           blPred.order + brPred.order) / (result.weight + 2);\n      result.weight += 2;\n    }\n  }\n\n  return result;\n}\n\nfunction expandSubgraphs(entries, subgraphs) {\n  _.forEach(entries, function(entry) {\n    entry.vs = _.flatten(entry.vs.map(function(v) {\n      if (subgraphs[v]) {\n        return subgraphs[v].vs;\n      }\n      return v;\n    }), true);\n  });\n}\n\nfunction mergeBarycenters(target, other) {\n  if (!_.isUndefined(target.barycenter)) {\n    target.barycenter = (target.barycenter * target.weight +\n                         other.barycenter * other.weight) /\n                        (target.weight + other.weight);\n    target.weight += other.weight;\n  } else {\n    target.barycenter = other.barycenter;\n    target.weight = other.weight;\n  }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/order/sort.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/order/sort.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\n\nmodule.exports = sort;\n\nfunction sort(entries, biasRight) {\n  var parts = util.partition(entries, function(entry) {\n    return _.has(entry, \"barycenter\");\n  });\n  var sortable = parts.lhs,\n    unsortable = _.sortBy(parts.rhs, function(entry) { return -entry.i; }),\n    vs = [],\n    sum = 0,\n    weight = 0,\n    vsIndex = 0;\n\n  sortable.sort(compareWithBias(!!biasRight));\n\n  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n\n  _.forEach(sortable, function (entry) {\n    vsIndex += entry.vs.length;\n    vs.push(entry.vs);\n    sum += entry.barycenter * entry.weight;\n    weight += entry.weight;\n    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n  });\n\n  var result = { vs: _.flatten(vs, true) };\n  if (weight) {\n    result.barycenter = sum / weight;\n    result.weight = weight;\n  }\n  return result;\n}\n\nfunction consumeUnsortable(vs, unsortable, index) {\n  var last;\n  while (unsortable.length && (last = _.last(unsortable)).i <= index) {\n    unsortable.pop();\n    vs.push(last.vs);\n    index++;\n  }\n  return index;\n}\n\nfunction compareWithBias(bias) {\n  return function(entryV, entryW) {\n    if (entryV.barycenter < entryW.barycenter) {\n      return -1;\n    } else if (entryV.barycenter > entryW.barycenter) {\n      return 1;\n    }\n\n    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;\n  };\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/parent-dummy-chains.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/parent-dummy-chains.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = parentDummyChains;\n\nfunction parentDummyChains(g) {\n  var postorderNums = postorder(g);\n\n  _.forEach(g.graph().dummyChains, function(v) {\n    var node = g.node(v);\n    var edgeObj = node.edgeObj;\n    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);\n    var path = pathData.path;\n    var lca = pathData.lca;\n    var pathIdx = 0;\n    var pathV = path[pathIdx];\n    var ascending = true;\n\n    while (v !== edgeObj.w) {\n      node = g.node(v);\n\n      if (ascending) {\n        while ((pathV = path[pathIdx]) !== lca &&\n               g.node(pathV).maxRank < node.rank) {\n          pathIdx++;\n        }\n\n        if (pathV === lca) {\n          ascending = false;\n        }\n      }\n\n      if (!ascending) {\n        while (pathIdx < path.length - 1 &&\n               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {\n          pathIdx++;\n        }\n        pathV = path[pathIdx];\n      }\n\n      g.setParent(v, pathV);\n      v = g.successors(v)[0];\n    }\n  });\n}\n\n// Find a path from v to w through the lowest common ancestor (LCA). Return the\n// full path and the LCA.\nfunction findPath(g, postorderNums, v, w) {\n  var vPath = [];\n  var wPath = [];\n  var low = Math.min(postorderNums[v].low, postorderNums[w].low);\n  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);\n  var parent;\n  var lca;\n\n  // Traverse up from v to find the LCA\n  parent = v;\n  do {\n    parent = g.parent(parent);\n    vPath.push(parent);\n  } while (parent &&\n           (postorderNums[parent].low > low || lim > postorderNums[parent].lim));\n  lca = parent;\n\n  // Traverse from w to LCA\n  parent = w;\n  while ((parent = g.parent(parent)) !== lca) {\n    wPath.push(parent);\n  }\n\n  return { path: vPath.concat(wPath.reverse()), lca: lca };\n}\n\nfunction postorder(g) {\n  var result = {};\n  var lim = 0;\n\n  function dfs(v) {\n    var low = lim;\n    _.forEach(g.children(v), dfs);\n    result[v] = { low: low, lim: lim++ };\n  }\n  _.forEach(g.children(), dfs);\n\n  return result;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/position/bk.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/position/bk.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar Graph = __webpack_require__(/*! ../graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\n\n/*\n * This module provides coordinate assignment based on Brandes and Köpf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\n\nmodule.exports = {\n  positionX: positionX,\n  findType1Conflicts: findType1Conflicts,\n  findType2Conflicts: findType2Conflicts,\n  addConflict: addConflict,\n  hasConflict: hasConflict,\n  verticalAlignment: verticalAlignment,\n  horizontalCompaction: horizontalCompaction,\n  alignCoordinates: alignCoordinates,\n  findSmallestWidthAlignment: findSmallestWidthAlignment,\n  balance: balance\n};\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\nfunction findType1Conflicts(g, layering) {\n  var conflicts = {};\n\n  function visitLayer(prevLayer, layer) {\n    var\n      // last visited node in the previous layer that is incident on an inner\n      // segment.\n      k0 = 0,\n      // Tracks the last node in this layer scanned for crossings with a type-1\n      // segment.\n      scanPos = 0,\n      prevLayerLength = prevLayer.length,\n      lastNode = _.last(layer);\n\n    _.forEach(layer, function(v, i) {\n      var w = findOtherInnerSegmentNode(g, v),\n        k1 = w ? g.node(w).order : prevLayerLength;\n\n      if (w || v === lastNode) {\n        _.forEach(layer.slice(scanPos, i +1), function(scanNode) {\n          _.forEach(g.predecessors(scanNode), function(u) {\n            var uLabel = g.node(u),\n              uPos = uLabel.order;\n            if ((uPos < k0 || k1 < uPos) &&\n                !(uLabel.dummy && g.node(scanNode).dummy)) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n\n    return layer;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findType2Conflicts(g, layering) {\n  var conflicts = {};\n\n  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    var v;\n    _.forEach(_.range(southPos, southEnd), function(i) {\n      v = south[i];\n      if (g.node(v).dummy) {\n        _.forEach(g.predecessors(v), function(u) {\n          var uNode = g.node(u);\n          if (uNode.dummy &&\n              (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  }\n\n\n  function visitLayer(north, south) {\n    var prevNorthPos = -1,\n      nextNorthPos,\n      southPos = 0;\n\n    _.forEach(south, function(v, southLookahead) {\n      if (g.node(v).dummy === \"border\") {\n        var predecessors = g.predecessors(v);\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n\n    return south;\n  }\n\n  _.reduce(layering, visitLayer);\n  return conflicts;\n}\n\nfunction findOtherInnerSegmentNode(g, v) {\n  if (g.node(v).dummy) {\n    return _.find(g.predecessors(v), function(u) {\n      return g.node(u).dummy;\n    });\n  }\n}\n\nfunction addConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n\n  var conflictsV = conflicts[v];\n  if (!conflictsV) {\n    conflicts[v] = conflictsV = {};\n  }\n  conflictsV[w] = true;\n}\n\nfunction hasConflict(conflicts, v, w) {\n  if (v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return _.has(conflicts[v], w);\n}\n\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nfunction verticalAlignment(g, layering, conflicts, neighborFn) {\n  var root = {},\n    align = {},\n    pos = {};\n\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  _.forEach(layering, function(layer) {\n    _.forEach(layer, function(v, order) {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n\n  _.forEach(layering, function(layer) {\n    var prevIdx = -1;\n    _.forEach(layer, function(v) {\n      var ws = neighborFn(v);\n      if (ws.length) {\n        ws = _.sortBy(ws, function(w) { return pos[w]; });\n        var mp = (ws.length - 1) / 2;\n        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          var w = ws[i];\n          if (align[v] === v &&\n              prevIdx < pos[w] &&\n              !hasConflict(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n\n  return { root: root, align: align };\n}\n\nfunction horizontalCompaction(g, layering, root, align, reverseSep) {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  var xs = {},\n    blockG = buildBlockGraph(g, layering, root, reverseSep),\n    borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n\n  function iterate(setXsFunc, nextNodesFunc) {\n    var stack = blockG.nodes();\n    var elem = stack.pop();\n    var visited = {};\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n\n      elem = stack.pop();\n    }\n  }\n\n  // First pass, assign smallest coordinates\n  function pass1(elem) {\n    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {\n      return Math.max(acc, xs[e.v] + blockG.edge(e));\n    }, 0);\n  }\n\n  // Second pass, assign greatest coordinates\n  function pass2(elem) {\n    var min = blockG.outEdges(elem).reduce(function(acc, e) {\n      return Math.min(acc, xs[e.w] - blockG.edge(e));\n    }, Number.POSITIVE_INFINITY);\n\n    var node = g.node(elem);\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  }\n\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG));\n\n  // Assign x coordinates to all nodes\n  _.forEach(align, function(v) {\n    xs[v] = xs[root[v]];\n  });\n\n  return xs;\n}\n\n\nfunction buildBlockGraph(g, layering, root, reverseSep) {\n  var blockGraph = new Graph(),\n    graphLabel = g.graph(),\n    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n\n  _.forEach(layering, function(layer) {\n    var u;\n    _.forEach(layer, function(v) {\n      var vRoot = root[v];\n      blockGraph.setNode(vRoot);\n      if (u) {\n        var uRoot = root[u],\n          prevMax = blockGraph.edge(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n      u = v;\n    });\n  });\n\n  return blockGraph;\n}\n\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nfunction findSmallestWidthAlignment(g, xss) {\n  return _.minBy(_.values(xss), function (xs) {\n    var max = Number.NEGATIVE_INFINITY;\n    var min = Number.POSITIVE_INFINITY;\n\n    _.forIn(xs, function (x, v) {\n      var halfWidth = width(g, v) / 2;\n\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n\n    return max - min;\n  });\n}\n\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates(xss, alignTo) {\n  var alignToVals = _.values(alignTo),\n    alignToMin = _.min(alignToVals),\n    alignToMax = _.max(alignToVals);\n\n  _.forEach([\"u\", \"d\"], function(vert) {\n    _.forEach([\"l\", \"r\"], function(horiz) {\n      var alignment = vert + horiz,\n        xs = xss[alignment],\n        delta;\n      if (xs === alignTo) return;\n\n      var xsVals = _.values(xs);\n      delta = horiz === \"l\" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);\n\n      if (delta) {\n        xss[alignment] = _.mapValues(xs, function(x) { return x + delta; });\n      }\n    });\n  });\n}\n\nfunction balance(xss, align) {\n  return _.mapValues(xss.ul, function(ignore, v) {\n    if (align) {\n      return xss[align.toLowerCase()][v];\n    } else {\n      var xs = _.sortBy(_.map(xss, v));\n      return (xs[1] + xs[2]) / 2;\n    }\n  });\n}\n\nfunction positionX(g) {\n  var layering = util.buildLayerMatrix(g);\n  var conflicts = _.merge(\n    findType1Conflicts(g, layering),\n    findType2Conflicts(g, layering));\n\n  var xss = {};\n  var adjustedLayering;\n  _.forEach([\"u\", \"d\"], function(vert) {\n    adjustedLayering = vert === \"u\" ? layering : _.values(layering).reverse();\n    _.forEach([\"l\", \"r\"], function(horiz) {\n      if (horiz === \"r\") {\n        adjustedLayering = _.map(adjustedLayering, function(inner) {\n          return _.values(inner).reverse();\n        });\n      }\n\n      var neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\n      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);\n      var xs = horizontalCompaction(g, adjustedLayering,\n        align.root, align.align, horiz === \"r\");\n      if (horiz === \"r\") {\n        xs = _.mapValues(xs, function(x) { return -x; });\n      }\n      xss[vert + horiz] = xs;\n    });\n  });\n\n  var smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align);\n}\n\nfunction sep(nodeSep, edgeSep, reverseSep) {\n  return function(g, v, w) {\n    var vLabel = g.node(v);\n    var wLabel = g.node(w);\n    var sum = 0;\n    var delta;\n\n    sum += vLabel.width / 2;\n    if (_.has(vLabel, \"labelpos\")) {\n      switch (vLabel.labelpos.toLowerCase()) {\n      case \"l\": delta = -vLabel.width / 2; break;\n      case \"r\": delta = vLabel.width / 2; break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n\n    sum += wLabel.width / 2;\n    if (_.has(wLabel, \"labelpos\")) {\n      switch (wLabel.labelpos.toLowerCase()) {\n      case \"l\": delta = wLabel.width / 2; break;\n      case \"r\": delta = -wLabel.width / 2; break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    return sum;\n  };\n}\n\nfunction width(g, v) {\n  return g.node(v).width;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/position/index.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/position/index.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\");\nvar positionX = __webpack_require__(/*! ./bk */ \"./node_modules/_dagre@0.8.5@dagre/lib/position/bk.js\").positionX;\n\nmodule.exports = position;\n\nfunction position(g) {\n  g = util.asNonCompoundGraph(g);\n\n  positionY(g);\n  _.forEach(positionX(g), function(x, v) {\n    g.node(v).x = x;\n  });\n}\n\nfunction positionY(g) {\n  var layering = util.buildLayerMatrix(g);\n  var rankSep = g.graph().ranksep;\n  var prevY = 0;\n  _.forEach(layering, function(layer) {\n    var maxHeight = _.max(_.map(layer, function(v) { return g.node(v).height; }));\n    _.forEach(layer, function(v) {\n      g.node(v).y = prevY + maxHeight / 2;\n    });\n    prevY += maxHeight + rankSep;\n  });\n}\n\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/feasible-tree.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/rank/feasible-tree.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar Graph = __webpack_require__(/*! ../graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\nvar slack = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js\").slack;\n\nmodule.exports = feasibleTree;\n\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nfunction feasibleTree(g) {\n  var t = new Graph({ directed: false });\n\n  // Choose arbitrary node from which to start our tree\n  var start = g.nodes()[0];\n  var size = g.nodeCount();\n  t.setNode(start, {});\n\n  var edge, delta;\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);\n    shiftRanks(t, g, delta);\n  }\n\n  return t;\n}\n\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nfunction tightTree(t, g) {\n  function dfs(v) {\n    _.forEach(g.nodeEdges(v), function(e) {\n      var edgeV = e.v,\n        w = (v === edgeV) ? e.w : edgeV;\n      if (!t.hasNode(w) && !slack(g, e)) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  }\n\n  _.forEach(t.nodes(), dfs);\n  return t.nodeCount();\n}\n\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nfunction findMinSlackEdge(t, g) {\n  return _.minBy(g.edges(), function(e) {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return slack(g, e);\n    }\n  });\n}\n\nfunction shiftRanks(t, g, delta) {\n  _.forEach(t.nodes(), function(v) {\n    g.node(v).rank += delta;\n  });\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/index.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/rank/index.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar rankUtil = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js\");\nvar longestPath = rankUtil.longestPath;\nvar feasibleTree = __webpack_require__(/*! ./feasible-tree */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/feasible-tree.js\");\nvar networkSimplex = __webpack_require__(/*! ./network-simplex */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/network-simplex.js\");\n\nmodule.exports = rank;\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank(g) {\n  switch(g.graph().ranker) {\n  case \"network-simplex\": networkSimplexRanker(g); break;\n  case \"tight-tree\": tightTreeRanker(g); break;\n  case \"longest-path\": longestPathRanker(g); break;\n  default: networkSimplexRanker(g);\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker = longestPath;\n\nfunction tightTreeRanker(g) {\n  longestPath(g);\n  feasibleTree(g);\n}\n\nfunction networkSimplexRanker(g) {\n  networkSimplex(g);\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/network-simplex.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/rank/network-simplex.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar feasibleTree = __webpack_require__(/*! ./feasible-tree */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/feasible-tree.js\");\nvar slack = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js\").slack;\nvar initRank = __webpack_require__(/*! ./util */ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js\").longestPath;\nvar preorder = __webpack_require__(/*! ../graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").alg.preorder;\nvar postorder = __webpack_require__(/*! ../graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").alg.postorder;\nvar simplify = __webpack_require__(/*! ../util */ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\").simplify;\n\nmodule.exports = networkSimplex;\n\n// Expose some internals for testing purposes\nnetworkSimplex.initLowLimValues = initLowLimValues;\nnetworkSimplex.initCutValues = initCutValues;\nnetworkSimplex.calcCutValue = calcCutValue;\nnetworkSimplex.leaveEdge = leaveEdge;\nnetworkSimplex.enterEdge = enterEdge;\nnetworkSimplex.exchangeEdges = exchangeEdges;\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nfunction networkSimplex(g) {\n  g = simplify(g);\n  initRank(g);\n  var t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n\n  var e, f;\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n}\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nfunction initCutValues(t, g) {\n  var vs = postorder(t, t.nodes());\n  vs = vs.slice(0, vs.length - 1);\n  _.forEach(vs, function(v) {\n    assignCutValue(t, g, v);\n  });\n}\n\nfunction assignCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);\n}\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nfunction calcCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  var childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  var graphEdge = g.edge(child, parent);\n  // The accumulated cut value for the edge between this node and its parent\n  var cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edge(parent, child);\n  }\n\n  cutValue = graphEdge.weight;\n\n  _.forEach(g.nodeEdges(child), function(e) {\n    var isOutEdge = e.v === child,\n      other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail,\n        otherWeight = g.edge(e).weight;\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edge(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n\n  return cutValue;\n}\n\nfunction initLowLimValues(tree, root) {\n  if (arguments.length < 2) {\n    root = tree.nodes()[0];\n  }\n  dfsAssignLowLim(tree, {}, 1, root);\n}\n\nfunction dfsAssignLowLim(tree, visited, nextLim, v, parent) {\n  var low = nextLim;\n  var label = tree.node(v);\n\n  visited[v] = true;\n  _.forEach(tree.neighbors(v), function(w) {\n    if (!_.has(visited, w)) {\n      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);\n    }\n  });\n\n  label.low = low;\n  label.lim = nextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return nextLim;\n}\n\nfunction leaveEdge(tree) {\n  return _.find(tree.edges(), function(e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n}\n\nfunction enterEdge(t, g, edge) {\n  var v = edge.v;\n  var w = edge.w;\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false;\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  var candidates = _.filter(g.edges(), function(edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n           flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n\n  return _.minBy(candidates, function(edge) { return slack(g, edge); });\n}\n\nfunction exchangeEdges(t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n}\n\nfunction updateRanks(t, g) {\n  var root = _.find(t.nodes(), function(v) { return !g.node(v).parent; });\n  var vs = preorder(t, root);\n  vs = vs.slice(1);\n  _.forEach(vs, function(v) {\n    var parent = t.node(v).parent,\n      edge = g.edge(v, parent),\n      flipped = false;\n\n    if (!edge) {\n      edge = g.edge(parent, v);\n      flipped = true;\n    }\n\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n}\n\n/*\n * Returns true if the edge is in the tree.\n */\nfunction isTreeEdge(tree, u, v) {\n  return tree.hasEdge(u, v);\n}\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nfunction isDescendant(tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/rank/util.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\n\nmodule.exports = {\n  longestPath: longestPath,\n  slack: slack\n};\n\n/*\n * Initializes ranks for the input graph using the longest path algorithm. This\n * algorithm scales well and is fast in practice, it yields rather poor\n * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom\n * ranks wide and leaving edges longer than necessary. However, due to its\n * speed, this algorithm is good for getting an initial ranking that can be fed\n * into other algorithms.\n *\n * This algorithm does not normalize layers because it will be used by other\n * algorithms in most cases. If using this algorithm directly, be sure to\n * run normalize at the end.\n *\n * Pre-conditions:\n *\n *    1. Input graph is a DAG.\n *    2. Input graph node labels can be assigned properties.\n *\n * Post-conditions:\n *\n *    1. Each node will be assign an (unnormalized) \"rank\" property.\n */\nfunction longestPath(g) {\n  var visited = {};\n\n  function dfs(v) {\n    var label = g.node(v);\n    if (_.has(visited, v)) {\n      return label.rank;\n    }\n    visited[v] = true;\n\n    var rank = _.min(_.map(g.outEdges(v), function(e) {\n      return dfs(e.w) - g.edge(e).minlen;\n    }));\n\n    if (rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3\n        rank === undefined || // return value of _.map([]) for Lodash 4\n        rank === null) { // return value of _.map([null])\n      rank = 0;\n    }\n\n    return (label.rank = rank);\n  }\n\n  _.forEach(g.sources(), dfs);\n}\n\n/*\n * Returns the amount of slack for the given edge. The slack is defined as the\n * difference between the length of the edge and its minimum length.\n */\nfunction slack(g, e) {\n  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/util.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/util.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* eslint \"no-console\": off */\n\n\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_dagre@0.8.5@dagre/lib/lodash.js\");\nvar Graph = __webpack_require__(/*! ./graphlib */ \"./node_modules/_dagre@0.8.5@dagre/lib/graphlib.js\").Graph;\n\nmodule.exports = {\n  addDummyNode: addDummyNode,\n  simplify: simplify,\n  asNonCompoundGraph: asNonCompoundGraph,\n  successorWeights: successorWeights,\n  predecessorWeights: predecessorWeights,\n  intersectRect: intersectRect,\n  buildLayerMatrix: buildLayerMatrix,\n  normalizeRanks: normalizeRanks,\n  removeEmptyRanks: removeEmptyRanks,\n  addBorderNode: addBorderNode,\n  maxRank: maxRank,\n  partition: partition,\n  time: time,\n  notime: notime\n};\n\n/*\n * Adds a dummy node to the graph and return v.\n */\nfunction addDummyNode(g, type, attrs, name) {\n  var v;\n  do {\n    v = _.uniqueId(name);\n  } while (g.hasNode(v));\n\n  attrs.dummy = type;\n  g.setNode(v, attrs);\n  return v;\n}\n\n/*\n * Returns a new graph with only simple edges. Handles aggregation of data\n * associated with multi-edges.\n */\nfunction simplify(g) {\n  var simplified = new Graph().setGraph(g.graph());\n  _.forEach(g.nodes(), function(v) { simplified.setNode(v, g.node(v)); });\n  _.forEach(g.edges(), function(e) {\n    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };\n    var label = g.edge(e);\n    simplified.setEdge(e.v, e.w, {\n      weight: simpleLabel.weight + label.weight,\n      minlen: Math.max(simpleLabel.minlen, label.minlen)\n    });\n  });\n  return simplified;\n}\n\nfunction asNonCompoundGraph(g) {\n  var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());\n  _.forEach(g.nodes(), function(v) {\n    if (!g.children(v).length) {\n      simplified.setNode(v, g.node(v));\n    }\n  });\n  _.forEach(g.edges(), function(e) {\n    simplified.setEdge(e, g.edge(e));\n  });\n  return simplified;\n}\n\nfunction successorWeights(g) {\n  var weightMap = _.map(g.nodes(), function(v) {\n    var sucs = {};\n    _.forEach(g.outEdges(v), function(e) {\n      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;\n    });\n    return sucs;\n  });\n  return _.zipObject(g.nodes(), weightMap);\n}\n\nfunction predecessorWeights(g) {\n  var weightMap = _.map(g.nodes(), function(v) {\n    var preds = {};\n    _.forEach(g.inEdges(v), function(e) {\n      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;\n    });\n    return preds;\n  });\n  return _.zipObject(g.nodes(), weightMap);\n}\n\n/*\n * Finds where a line starting at point ({x, y}) would intersect a rectangle\n * ({x, y, width, height}) if it were pointing at the rectangle's center.\n */\nfunction intersectRect(rect, point) {\n  var x = rect.x;\n  var y = rect.y;\n\n  // Rectangle intersection algorithm from:\n  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes\n  var dx = point.x - x;\n  var dy = point.y - y;\n  var w = rect.width / 2;\n  var h = rect.height / 2;\n\n  if (!dx && !dy) {\n    throw new Error(\"Not possible to find intersection inside of the rectangle\");\n  }\n\n  var sx, sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    // Intersection is top or bottom of rect.\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = h * dx / dy;\n    sy = h;\n  } else {\n    // Intersection is left or right of rect.\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = w * dy / dx;\n  }\n\n  return { x: x + sx, y: y + sy };\n}\n\n/*\n * Given a DAG with each node assigned \"rank\" and \"order\" properties, this\n * function will produce a matrix with the ids of each node.\n */\nfunction buildLayerMatrix(g) {\n  var layering = _.map(_.range(maxRank(g) + 1), function() { return []; });\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    var rank = node.rank;\n    if (!_.isUndefined(rank)) {\n      layering[rank][node.order] = v;\n    }\n  });\n  return layering;\n}\n\n/*\n * Adjusts the ranks for all nodes in the graph such that all nodes v have\n * rank(v) >= 0 and at least one node w has rank(w) = 0.\n */\nfunction normalizeRanks(g) {\n  var min = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    if (_.has(node, \"rank\")) {\n      node.rank -= min;\n    }\n  });\n}\n\nfunction removeEmptyRanks(g) {\n  // Ranks may not start at 0, so we need to offset them\n  var offset = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));\n\n  var layers = [];\n  _.forEach(g.nodes(), function(v) {\n    var rank = g.node(v).rank - offset;\n    if (!layers[rank]) {\n      layers[rank] = [];\n    }\n    layers[rank].push(v);\n  });\n\n  var delta = 0;\n  var nodeRankFactor = g.graph().nodeRankFactor;\n  _.forEach(layers, function(vs, i) {\n    if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {\n      --delta;\n    } else if (delta) {\n      _.forEach(vs, function(v) { g.node(v).rank += delta; });\n    }\n  });\n}\n\nfunction addBorderNode(g, prefix, rank, order) {\n  var node = {\n    width: 0,\n    height: 0\n  };\n  if (arguments.length >= 4) {\n    node.rank = rank;\n    node.order = order;\n  }\n  return addDummyNode(g, \"border\", node, prefix);\n}\n\nfunction maxRank(g) {\n  return _.max(_.map(g.nodes(), function(v) {\n    var rank = g.node(v).rank;\n    if (!_.isUndefined(rank)) {\n      return rank;\n    }\n  }));\n}\n\n/*\n * Partition a collection into two groups: `lhs` and `rhs`. If the supplied\n * function returns true for an entry it goes into `lhs`. Otherwise it goes\n * into `rhs.\n */\nfunction partition(collection, fn) {\n  var result = { lhs: [], rhs: [] };\n  _.forEach(collection, function(value) {\n    if (fn(value)) {\n      result.lhs.push(value);\n    } else {\n      result.rhs.push(value);\n    }\n  });\n  return result;\n}\n\n/*\n * Returns a new function that wraps `fn` with a timer. The wrapper logs the\n * time it takes to execute the function.\n */\nfunction time(name, fn) {\n  var start = _.now();\n  try {\n    return fn();\n  } finally {\n    console.log(name + \" time: \" + (_.now() - start) + \"ms\");\n  }\n}\n\nfunction notime(name, fn) {\n  return fn();\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_dagre@0.8.5@dagre/lib/version.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_dagre@0.8.5@dagre/lib/version.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"0.8.5\";\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/index.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/index.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Copyright (c) 2014, Chris Pettitt\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the copyright holder nor the names of its contributors\n * may be used to endorse or promote products derived from this software without\n * specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar lib = __webpack_require__(/*! ./lib */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/index.js\");\n\nmodule.exports = {\n  Graph: lib.Graph,\n  json: __webpack_require__(/*! ./lib/json */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/json.js\"),\n  alg: __webpack_require__(/*! ./lib/alg */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/index.js\"),\n  version: lib.version\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/components.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/components.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = components;\n\nfunction components(g) {\n  var visited = {};\n  var cmpts = [];\n  var cmpt;\n\n  function dfs(v) {\n    if (_.has(visited, v)) return;\n    visited[v] = true;\n    cmpt.push(v);\n    _.each(g.successors(v), dfs);\n    _.each(g.predecessors(v), dfs);\n  }\n\n  _.each(g.nodes(), function(v) {\n    cmpt = [];\n    dfs(v);\n    if (cmpt.length) {\n      cmpts.push(cmpt);\n    }\n  });\n\n  return cmpts;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dfs.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dfs.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = dfs;\n\n/*\n * A helper that preforms a pre- or post-order traversal on the input graph\n * and returns the nodes in the order they were visited. If the graph is\n * undirected then this algorithm will navigate using neighbors. If the graph\n * is directed then this algorithm will navigate using successors.\n *\n * Order must be one of \"pre\" or \"post\".\n */\nfunction dfs(g, vs, order) {\n  if (!_.isArray(vs)) {\n    vs = [vs];\n  }\n\n  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);\n\n  var acc = [];\n  var visited = {};\n  _.each(vs, function(v) {\n    if (!g.hasNode(v)) {\n      throw new Error(\"Graph does not have node: \" + v);\n    }\n\n    doDfs(g, v, order === \"post\", visited, navigation, acc);\n  });\n  return acc;\n}\n\nfunction doDfs(g, v, postorder, visited, navigation, acc) {\n  if (!_.has(visited, v)) {\n    visited[v] = true;\n\n    if (!postorder) { acc.push(v); }\n    _.each(navigation(v), function(w) {\n      doDfs(g, w, postorder, visited, navigation, acc);\n    });\n    if (postorder) { acc.push(v); }\n  }\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra-all.js\":\n/*!***********************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra-all.js ***!\n  \\***********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dijkstra = __webpack_require__(/*! ./dijkstra */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra.js\");\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = dijkstraAll;\n\nfunction dijkstraAll(g, weightFunc, edgeFunc) {\n  return _.transform(g.nodes(), function(acc, v) {\n    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);\n  }, {});\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\nvar PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/data/priority-queue.js\");\n\nmodule.exports = dijkstra;\n\nvar DEFAULT_WEIGHT_FUNC = _.constant(1);\n\nfunction dijkstra(g, source, weightFn, edgeFn) {\n  return runDijkstra(g, String(source),\n    weightFn || DEFAULT_WEIGHT_FUNC,\n    edgeFn || function(v) { return g.outEdges(v); });\n}\n\nfunction runDijkstra(g, source, weightFn, edgeFn) {\n  var results = {};\n  var pq = new PriorityQueue();\n  var v, vEntry;\n\n  var updateNeighbors = function(edge) {\n    var w = edge.v !== v ? edge.v : edge.w;\n    var wEntry = results[w];\n    var weight = weightFn(edge);\n    var distance = vEntry.distance + weight;\n\n    if (weight < 0) {\n      throw new Error(\"dijkstra does not allow negative edge weights. \" +\n                      \"Bad edge: \" + edge + \" Weight: \" + weight);\n    }\n\n    if (distance < wEntry.distance) {\n      wEntry.distance = distance;\n      wEntry.predecessor = v;\n      pq.decrease(w, distance);\n    }\n  };\n\n  g.nodes().forEach(function(v) {\n    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;\n    results[v] = { distance: distance };\n    pq.add(v, distance);\n  });\n\n  while (pq.size() > 0) {\n    v = pq.removeMin();\n    vEntry = results[v];\n    if (vEntry.distance === Number.POSITIVE_INFINITY) {\n      break;\n    }\n\n    edgeFn(v).forEach(updateNeighbors);\n  }\n\n  return results;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/find-cycles.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/find-cycles.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\nvar tarjan = __webpack_require__(/*! ./tarjan */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/tarjan.js\");\n\nmodule.exports = findCycles;\n\nfunction findCycles(g) {\n  return _.filter(tarjan(g), function(cmpt) {\n    return cmpt.length > 1 || (cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]));\n  });\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/floyd-warshall.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/floyd-warshall.js ***!\n  \\*************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = floydWarshall;\n\nvar DEFAULT_WEIGHT_FUNC = _.constant(1);\n\nfunction floydWarshall(g, weightFn, edgeFn) {\n  return runFloydWarshall(g,\n    weightFn || DEFAULT_WEIGHT_FUNC,\n    edgeFn || function(v) { return g.outEdges(v); });\n}\n\nfunction runFloydWarshall(g, weightFn, edgeFn) {\n  var results = {};\n  var nodes = g.nodes();\n\n  nodes.forEach(function(v) {\n    results[v] = {};\n    results[v][v] = { distance: 0 };\n    nodes.forEach(function(w) {\n      if (v !== w) {\n        results[v][w] = { distance: Number.POSITIVE_INFINITY };\n      }\n    });\n    edgeFn(v).forEach(function(edge) {\n      var w = edge.v === v ? edge.w : edge.v;\n      var d = weightFn(edge);\n      results[v][w] = { distance: d, predecessor: v };\n    });\n  });\n\n  nodes.forEach(function(k) {\n    var rowK = results[k];\n    nodes.forEach(function(i) {\n      var rowI = results[i];\n      nodes.forEach(function(j) {\n        var ik = rowI[k];\n        var kj = rowK[j];\n        var ij = rowI[j];\n        var altDistance = ik.distance + kj.distance;\n        if (altDistance < ij.distance) {\n          ij.distance = altDistance;\n          ij.predecessor = kj.predecessor;\n        }\n      });\n    });\n  });\n\n  return results;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/index.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/index.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  components: __webpack_require__(/*! ./components */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/components.js\"),\n  dijkstra: __webpack_require__(/*! ./dijkstra */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra.js\"),\n  dijkstraAll: __webpack_require__(/*! ./dijkstra-all */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dijkstra-all.js\"),\n  findCycles: __webpack_require__(/*! ./find-cycles */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/find-cycles.js\"),\n  floydWarshall: __webpack_require__(/*! ./floyd-warshall */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/floyd-warshall.js\"),\n  isAcyclic: __webpack_require__(/*! ./is-acyclic */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/is-acyclic.js\"),\n  postorder: __webpack_require__(/*! ./postorder */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/postorder.js\"),\n  preorder: __webpack_require__(/*! ./preorder */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/preorder.js\"),\n  prim: __webpack_require__(/*! ./prim */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/prim.js\"),\n  tarjan: __webpack_require__(/*! ./tarjan */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/tarjan.js\"),\n  topsort: __webpack_require__(/*! ./topsort */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/topsort.js\")\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/is-acyclic.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/is-acyclic.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar topsort = __webpack_require__(/*! ./topsort */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/topsort.js\");\n\nmodule.exports = isAcyclic;\n\nfunction isAcyclic(g) {\n  try {\n    topsort(g);\n  } catch (e) {\n    if (e instanceof topsort.CycleException) {\n      return false;\n    }\n    throw e;\n  }\n  return true;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/postorder.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/postorder.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dfs = __webpack_require__(/*! ./dfs */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dfs.js\");\n\nmodule.exports = postorder;\n\nfunction postorder(g, vs) {\n  return dfs(g, vs, \"post\");\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/preorder.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/preorder.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar dfs = __webpack_require__(/*! ./dfs */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/dfs.js\");\n\nmodule.exports = preorder;\n\nfunction preorder(g, vs) {\n  return dfs(g, vs, \"pre\");\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/prim.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/prim.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\nvar Graph = __webpack_require__(/*! ../graph */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/graph.js\");\nvar PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/data/priority-queue.js\");\n\nmodule.exports = prim;\n\nfunction prim(g, weightFunc) {\n  var result = new Graph();\n  var parents = {};\n  var pq = new PriorityQueue();\n  var v;\n\n  function updateNeighbors(edge) {\n    var w = edge.v === v ? edge.w : edge.v;\n    var pri = pq.priority(w);\n    if (pri !== undefined) {\n      var edgeWeight = weightFunc(edge);\n      if (edgeWeight < pri) {\n        parents[w] = v;\n        pq.decrease(w, edgeWeight);\n      }\n    }\n  }\n\n  if (g.nodeCount() === 0) {\n    return result;\n  }\n\n  _.each(g.nodes(), function(v) {\n    pq.add(v, Number.POSITIVE_INFINITY);\n    result.setNode(v);\n  });\n\n  // Start from an arbitrary node\n  pq.decrease(g.nodes()[0], 0);\n\n  var init = false;\n  while (pq.size() > 0) {\n    v = pq.removeMin();\n    if (_.has(parents, v)) {\n      result.setEdge(v, parents[v]);\n    } else if (init) {\n      throw new Error(\"Input graph is not connected: \" + g);\n    } else {\n      init = true;\n    }\n\n    g.nodeEdges(v).forEach(updateNeighbors);\n  }\n\n  return result;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/tarjan.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/tarjan.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = tarjan;\n\nfunction tarjan(g) {\n  var index = 0;\n  var stack = [];\n  var visited = {}; // node id -> { onStack, lowlink, index }\n  var results = [];\n\n  function dfs(v) {\n    var entry = visited[v] = {\n      onStack: true,\n      lowlink: index,\n      index: index++\n    };\n    stack.push(v);\n\n    g.successors(v).forEach(function(w) {\n      if (!_.has(visited, w)) {\n        dfs(w);\n        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);\n      } else if (visited[w].onStack) {\n        entry.lowlink = Math.min(entry.lowlink, visited[w].index);\n      }\n    });\n\n    if (entry.lowlink === entry.index) {\n      var cmpt = [];\n      var w;\n      do {\n        w = stack.pop();\n        visited[w].onStack = false;\n        cmpt.push(w);\n      } while (v !== w);\n      results.push(cmpt);\n    }\n  }\n\n  g.nodes().forEach(function(v) {\n    if (!_.has(visited, v)) {\n      dfs(v);\n    }\n  });\n\n  return results;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/alg/topsort.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/alg/topsort.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = topsort;\ntopsort.CycleException = CycleException;\n\nfunction topsort(g) {\n  var visited = {};\n  var stack = {};\n  var results = [];\n\n  function visit(node) {\n    if (_.has(stack, node)) {\n      throw new CycleException();\n    }\n\n    if (!_.has(visited, node)) {\n      stack[node] = true;\n      visited[node] = true;\n      _.each(g.predecessors(node), visit);\n      delete stack[node];\n      results.push(node);\n    }\n  }\n\n  _.each(g.sinks(), visit);\n\n  if (_.size(visited) !== g.nodeCount()) {\n    throw new CycleException();\n  }\n\n  return results;\n}\n\nfunction CycleException() {}\nCycleException.prototype = new Error(); // must be an instance of Error to pass testing\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/data/priority-queue.js\":\n/*!**************************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/data/priority-queue.js ***!\n  \\**************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ../lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = PriorityQueue;\n\n/**\n * A min-priority queue data structure. This algorithm is derived from Cormen,\n * et al., \"Introduction to Algorithms\". The basic idea of a min-priority\n * queue is that you can efficiently (in O(1) time) get the smallest key in\n * the queue. Adding and removing elements takes O(log n) time. A key can\n * have its priority decreased in O(log n) time.\n */\nfunction PriorityQueue() {\n  this._arr = [];\n  this._keyIndices = {};\n}\n\n/**\n * Returns the number of elements in the queue. Takes `O(1)` time.\n */\nPriorityQueue.prototype.size = function() {\n  return this._arr.length;\n};\n\n/**\n * Returns the keys that are in the queue. Takes `O(n)` time.\n */\nPriorityQueue.prototype.keys = function() {\n  return this._arr.map(function(x) { return x.key; });\n};\n\n/**\n * Returns `true` if **key** is in the queue and `false` if not.\n */\nPriorityQueue.prototype.has = function(key) {\n  return _.has(this._keyIndices, key);\n};\n\n/**\n * Returns the priority for **key**. If **key** is not present in the queue\n * then this function returns `undefined`. Takes `O(1)` time.\n *\n * @param {Object} key\n */\nPriorityQueue.prototype.priority = function(key) {\n  var index = this._keyIndices[key];\n  if (index !== undefined) {\n    return this._arr[index].priority;\n  }\n};\n\n/**\n * Returns the key for the minimum element in this queue. If the queue is\n * empty this function throws an Error. Takes `O(1)` time.\n */\nPriorityQueue.prototype.min = function() {\n  if (this.size() === 0) {\n    throw new Error(\"Queue underflow\");\n  }\n  return this._arr[0].key;\n};\n\n/**\n * Inserts a new key into the priority queue. If the key already exists in\n * the queue this function returns `false`; otherwise it will return `true`.\n * Takes `O(n)` time.\n *\n * @param {Object} key the key to add\n * @param {Number} priority the initial priority for the key\n */\nPriorityQueue.prototype.add = function(key, priority) {\n  var keyIndices = this._keyIndices;\n  key = String(key);\n  if (!_.has(keyIndices, key)) {\n    var arr = this._arr;\n    var index = arr.length;\n    keyIndices[key] = index;\n    arr.push({key: key, priority: priority});\n    this._decrease(index);\n    return true;\n  }\n  return false;\n};\n\n/**\n * Removes and returns the smallest key in the queue. Takes `O(log n)` time.\n */\nPriorityQueue.prototype.removeMin = function() {\n  this._swap(0, this._arr.length - 1);\n  var min = this._arr.pop();\n  delete this._keyIndices[min.key];\n  this._heapify(0);\n  return min.key;\n};\n\n/**\n * Decreases the priority for **key** to **priority**. If the new priority is\n * greater than the previous priority, this function will throw an Error.\n *\n * @param {Object} key the key for which to raise priority\n * @param {Number} priority the new priority for the key\n */\nPriorityQueue.prototype.decrease = function(key, priority) {\n  var index = this._keyIndices[key];\n  if (priority > this._arr[index].priority) {\n    throw new Error(\"New priority is greater than current priority. \" +\n        \"Key: \" + key + \" Old: \" + this._arr[index].priority + \" New: \" + priority);\n  }\n  this._arr[index].priority = priority;\n  this._decrease(index);\n};\n\nPriorityQueue.prototype._heapify = function(i) {\n  var arr = this._arr;\n  var l = 2 * i;\n  var r = l + 1;\n  var largest = i;\n  if (l < arr.length) {\n    largest = arr[l].priority < arr[largest].priority ? l : largest;\n    if (r < arr.length) {\n      largest = arr[r].priority < arr[largest].priority ? r : largest;\n    }\n    if (largest !== i) {\n      this._swap(i, largest);\n      this._heapify(largest);\n    }\n  }\n};\n\nPriorityQueue.prototype._decrease = function(index) {\n  var arr = this._arr;\n  var priority = arr[index].priority;\n  var parent;\n  while (index !== 0) {\n    parent = index >> 1;\n    if (arr[parent].priority < priority) {\n      break;\n    }\n    this._swap(index, parent);\n    index = parent;\n  }\n};\n\nPriorityQueue.prototype._swap = function(i, j) {\n  var arr = this._arr;\n  var keyIndices = this._keyIndices;\n  var origArrI = arr[i];\n  var origArrJ = arr[j];\n  arr[i] = origArrJ;\n  arr[j] = origArrI;\n  keyIndices[origArrJ.key] = i;\n  keyIndices[origArrI.key] = j;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/graph.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/graph.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\n\nmodule.exports = Graph;\n\nvar DEFAULT_EDGE_NAME = \"\\x00\";\nvar GRAPH_NODE = \"\\x00\";\nvar EDGE_KEY_DELIM = \"\\x01\";\n\n// Implementation notes:\n//\n//  * Node id query functions should return string ids for the nodes\n//  * Edge id query functions should return an \"edgeObj\", edge object, that is\n//    composed of enough information to uniquely identify an edge: {v, w, name}.\n//  * Internally we use an \"edgeId\", a stringified form of the edgeObj, to\n//    reference edges. This is because we need a performant way to look these\n//    edges up and, object properties, which have string keys, are the closest\n//    we're going to get to a performant hashtable in JavaScript.\n\nfunction Graph(opts) {\n  this._isDirected = _.has(opts, \"directed\") ? opts.directed : true;\n  this._isMultigraph = _.has(opts, \"multigraph\") ? opts.multigraph : false;\n  this._isCompound = _.has(opts, \"compound\") ? opts.compound : false;\n\n  // Label for the graph itself\n  this._label = undefined;\n\n  // Defaults to be set when creating a new node\n  this._defaultNodeLabelFn = _.constant(undefined);\n\n  // Defaults to be set when creating a new edge\n  this._defaultEdgeLabelFn = _.constant(undefined);\n\n  // v -> label\n  this._nodes = {};\n\n  if (this._isCompound) {\n    // v -> parent\n    this._parent = {};\n\n    // v -> children\n    this._children = {};\n    this._children[GRAPH_NODE] = {};\n  }\n\n  // v -> edgeObj\n  this._in = {};\n\n  // u -> v -> Number\n  this._preds = {};\n\n  // v -> edgeObj\n  this._out = {};\n\n  // v -> w -> Number\n  this._sucs = {};\n\n  // e -> edgeObj\n  this._edgeObjs = {};\n\n  // e -> label\n  this._edgeLabels = {};\n}\n\n/* Number of nodes in the graph. Should only be changed by the implementation. */\nGraph.prototype._nodeCount = 0;\n\n/* Number of edges in the graph. Should only be changed by the implementation. */\nGraph.prototype._edgeCount = 0;\n\n\n/* === Graph functions ========= */\n\nGraph.prototype.isDirected = function() {\n  return this._isDirected;\n};\n\nGraph.prototype.isMultigraph = function() {\n  return this._isMultigraph;\n};\n\nGraph.prototype.isCompound = function() {\n  return this._isCompound;\n};\n\nGraph.prototype.setGraph = function(label) {\n  this._label = label;\n  return this;\n};\n\nGraph.prototype.graph = function() {\n  return this._label;\n};\n\n\n/* === Node functions ========== */\n\nGraph.prototype.setDefaultNodeLabel = function(newDefault) {\n  if (!_.isFunction(newDefault)) {\n    newDefault = _.constant(newDefault);\n  }\n  this._defaultNodeLabelFn = newDefault;\n  return this;\n};\n\nGraph.prototype.nodeCount = function() {\n  return this._nodeCount;\n};\n\nGraph.prototype.nodes = function() {\n  return _.keys(this._nodes);\n};\n\nGraph.prototype.sources = function() {\n  var self = this;\n  return _.filter(this.nodes(), function(v) {\n    return _.isEmpty(self._in[v]);\n  });\n};\n\nGraph.prototype.sinks = function() {\n  var self = this;\n  return _.filter(this.nodes(), function(v) {\n    return _.isEmpty(self._out[v]);\n  });\n};\n\nGraph.prototype.setNodes = function(vs, value) {\n  var args = arguments;\n  var self = this;\n  _.each(vs, function(v) {\n    if (args.length > 1) {\n      self.setNode(v, value);\n    } else {\n      self.setNode(v);\n    }\n  });\n  return this;\n};\n\nGraph.prototype.setNode = function(v, value) {\n  if (_.has(this._nodes, v)) {\n    if (arguments.length > 1) {\n      this._nodes[v] = value;\n    }\n    return this;\n  }\n\n  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);\n  if (this._isCompound) {\n    this._parent[v] = GRAPH_NODE;\n    this._children[v] = {};\n    this._children[GRAPH_NODE][v] = true;\n  }\n  this._in[v] = {};\n  this._preds[v] = {};\n  this._out[v] = {};\n  this._sucs[v] = {};\n  ++this._nodeCount;\n  return this;\n};\n\nGraph.prototype.node = function(v) {\n  return this._nodes[v];\n};\n\nGraph.prototype.hasNode = function(v) {\n  return _.has(this._nodes, v);\n};\n\nGraph.prototype.removeNode =  function(v) {\n  var self = this;\n  if (_.has(this._nodes, v)) {\n    var removeEdge = function(e) { self.removeEdge(self._edgeObjs[e]); };\n    delete this._nodes[v];\n    if (this._isCompound) {\n      this._removeFromParentsChildList(v);\n      delete this._parent[v];\n      _.each(this.children(v), function(child) {\n        self.setParent(child);\n      });\n      delete this._children[v];\n    }\n    _.each(_.keys(this._in[v]), removeEdge);\n    delete this._in[v];\n    delete this._preds[v];\n    _.each(_.keys(this._out[v]), removeEdge);\n    delete this._out[v];\n    delete this._sucs[v];\n    --this._nodeCount;\n  }\n  return this;\n};\n\nGraph.prototype.setParent = function(v, parent) {\n  if (!this._isCompound) {\n    throw new Error(\"Cannot set parent in a non-compound graph\");\n  }\n\n  if (_.isUndefined(parent)) {\n    parent = GRAPH_NODE;\n  } else {\n    // Coerce parent to string\n    parent += \"\";\n    for (var ancestor = parent;\n      !_.isUndefined(ancestor);\n      ancestor = this.parent(ancestor)) {\n      if (ancestor === v) {\n        throw new Error(\"Setting \" + parent+ \" as parent of \" + v +\n                        \" would create a cycle\");\n      }\n    }\n\n    this.setNode(parent);\n  }\n\n  this.setNode(v);\n  this._removeFromParentsChildList(v);\n  this._parent[v] = parent;\n  this._children[parent][v] = true;\n  return this;\n};\n\nGraph.prototype._removeFromParentsChildList = function(v) {\n  delete this._children[this._parent[v]][v];\n};\n\nGraph.prototype.parent = function(v) {\n  if (this._isCompound) {\n    var parent = this._parent[v];\n    if (parent !== GRAPH_NODE) {\n      return parent;\n    }\n  }\n};\n\nGraph.prototype.children = function(v) {\n  if (_.isUndefined(v)) {\n    v = GRAPH_NODE;\n  }\n\n  if (this._isCompound) {\n    var children = this._children[v];\n    if (children) {\n      return _.keys(children);\n    }\n  } else if (v === GRAPH_NODE) {\n    return this.nodes();\n  } else if (this.hasNode(v)) {\n    return [];\n  }\n};\n\nGraph.prototype.predecessors = function(v) {\n  var predsV = this._preds[v];\n  if (predsV) {\n    return _.keys(predsV);\n  }\n};\n\nGraph.prototype.successors = function(v) {\n  var sucsV = this._sucs[v];\n  if (sucsV) {\n    return _.keys(sucsV);\n  }\n};\n\nGraph.prototype.neighbors = function(v) {\n  var preds = this.predecessors(v);\n  if (preds) {\n    return _.union(preds, this.successors(v));\n  }\n};\n\nGraph.prototype.isLeaf = function (v) {\n  var neighbors;\n  if (this.isDirected()) {\n    neighbors = this.successors(v);\n  } else {\n    neighbors = this.neighbors(v);\n  }\n  return neighbors.length === 0;\n};\n\nGraph.prototype.filterNodes = function(filter) {\n  var copy = new this.constructor({\n    directed: this._isDirected,\n    multigraph: this._isMultigraph,\n    compound: this._isCompound\n  });\n\n  copy.setGraph(this.graph());\n\n  var self = this;\n  _.each(this._nodes, function(value, v) {\n    if (filter(v)) {\n      copy.setNode(v, value);\n    }\n  });\n\n  _.each(this._edgeObjs, function(e) {\n    if (copy.hasNode(e.v) && copy.hasNode(e.w)) {\n      copy.setEdge(e, self.edge(e));\n    }\n  });\n\n  var parents = {};\n  function findParent(v) {\n    var parent = self.parent(v);\n    if (parent === undefined || copy.hasNode(parent)) {\n      parents[v] = parent;\n      return parent;\n    } else if (parent in parents) {\n      return parents[parent];\n    } else {\n      return findParent(parent);\n    }\n  }\n\n  if (this._isCompound) {\n    _.each(copy.nodes(), function(v) {\n      copy.setParent(v, findParent(v));\n    });\n  }\n\n  return copy;\n};\n\n/* === Edge functions ========== */\n\nGraph.prototype.setDefaultEdgeLabel = function(newDefault) {\n  if (!_.isFunction(newDefault)) {\n    newDefault = _.constant(newDefault);\n  }\n  this._defaultEdgeLabelFn = newDefault;\n  return this;\n};\n\nGraph.prototype.edgeCount = function() {\n  return this._edgeCount;\n};\n\nGraph.prototype.edges = function() {\n  return _.values(this._edgeObjs);\n};\n\nGraph.prototype.setPath = function(vs, value) {\n  var self = this;\n  var args = arguments;\n  _.reduce(vs, function(v, w) {\n    if (args.length > 1) {\n      self.setEdge(v, w, value);\n    } else {\n      self.setEdge(v, w);\n    }\n    return w;\n  });\n  return this;\n};\n\n/*\n * setEdge(v, w, [value, [name]])\n * setEdge({ v, w, [name] }, [value])\n */\nGraph.prototype.setEdge = function() {\n  var v, w, name, value;\n  var valueSpecified = false;\n  var arg0 = arguments[0];\n\n  if (typeof arg0 === \"object\" && arg0 !== null && \"v\" in arg0) {\n    v = arg0.v;\n    w = arg0.w;\n    name = arg0.name;\n    if (arguments.length === 2) {\n      value = arguments[1];\n      valueSpecified = true;\n    }\n  } else {\n    v = arg0;\n    w = arguments[1];\n    name = arguments[3];\n    if (arguments.length > 2) {\n      value = arguments[2];\n      valueSpecified = true;\n    }\n  }\n\n  v = \"\" + v;\n  w = \"\" + w;\n  if (!_.isUndefined(name)) {\n    name = \"\" + name;\n  }\n\n  var e = edgeArgsToId(this._isDirected, v, w, name);\n  if (_.has(this._edgeLabels, e)) {\n    if (valueSpecified) {\n      this._edgeLabels[e] = value;\n    }\n    return this;\n  }\n\n  if (!_.isUndefined(name) && !this._isMultigraph) {\n    throw new Error(\"Cannot set a named edge when isMultigraph = false\");\n  }\n\n  // It didn't exist, so we need to create it.\n  // First ensure the nodes exist.\n  this.setNode(v);\n  this.setNode(w);\n\n  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);\n\n  var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);\n  // Ensure we add undirected edges in a consistent way.\n  v = edgeObj.v;\n  w = edgeObj.w;\n\n  Object.freeze(edgeObj);\n  this._edgeObjs[e] = edgeObj;\n  incrementOrInitEntry(this._preds[w], v);\n  incrementOrInitEntry(this._sucs[v], w);\n  this._in[w][e] = edgeObj;\n  this._out[v][e] = edgeObj;\n  this._edgeCount++;\n  return this;\n};\n\nGraph.prototype.edge = function(v, w, name) {\n  var e = (arguments.length === 1\n    ? edgeObjToId(this._isDirected, arguments[0])\n    : edgeArgsToId(this._isDirected, v, w, name));\n  return this._edgeLabels[e];\n};\n\nGraph.prototype.hasEdge = function(v, w, name) {\n  var e = (arguments.length === 1\n    ? edgeObjToId(this._isDirected, arguments[0])\n    : edgeArgsToId(this._isDirected, v, w, name));\n  return _.has(this._edgeLabels, e);\n};\n\nGraph.prototype.removeEdge = function(v, w, name) {\n  var e = (arguments.length === 1\n    ? edgeObjToId(this._isDirected, arguments[0])\n    : edgeArgsToId(this._isDirected, v, w, name));\n  var edge = this._edgeObjs[e];\n  if (edge) {\n    v = edge.v;\n    w = edge.w;\n    delete this._edgeLabels[e];\n    delete this._edgeObjs[e];\n    decrementOrRemoveEntry(this._preds[w], v);\n    decrementOrRemoveEntry(this._sucs[v], w);\n    delete this._in[w][e];\n    delete this._out[v][e];\n    this._edgeCount--;\n  }\n  return this;\n};\n\nGraph.prototype.inEdges = function(v, u) {\n  var inV = this._in[v];\n  if (inV) {\n    var edges = _.values(inV);\n    if (!u) {\n      return edges;\n    }\n    return _.filter(edges, function(edge) { return edge.v === u; });\n  }\n};\n\nGraph.prototype.outEdges = function(v, w) {\n  var outV = this._out[v];\n  if (outV) {\n    var edges = _.values(outV);\n    if (!w) {\n      return edges;\n    }\n    return _.filter(edges, function(edge) { return edge.w === w; });\n  }\n};\n\nGraph.prototype.nodeEdges = function(v, w) {\n  var inEdges = this.inEdges(v, w);\n  if (inEdges) {\n    return inEdges.concat(this.outEdges(v, w));\n  }\n};\n\nfunction incrementOrInitEntry(map, k) {\n  if (map[k]) {\n    map[k]++;\n  } else {\n    map[k] = 1;\n  }\n}\n\nfunction decrementOrRemoveEntry(map, k) {\n  if (!--map[k]) { delete map[k]; }\n}\n\nfunction edgeArgsToId(isDirected, v_, w_, name) {\n  var v = \"\" + v_;\n  var w = \"\" + w_;\n  if (!isDirected && v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM +\n             (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);\n}\n\nfunction edgeArgsToObj(isDirected, v_, w_, name) {\n  var v = \"\" + v_;\n  var w = \"\" + w_;\n  if (!isDirected && v > w) {\n    var tmp = v;\n    v = w;\n    w = tmp;\n  }\n  var edgeObj =  { v: v, w: w };\n  if (name) {\n    edgeObj.name = name;\n  }\n  return edgeObj;\n}\n\nfunction edgeObjToId(isDirected, edgeObj) {\n  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/index.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/index.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Includes only the \"core\" of graphlib\nmodule.exports = {\n  Graph: __webpack_require__(/*! ./graph */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/graph.js\"),\n  version: __webpack_require__(/*! ./version */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/version.js\")\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/json.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/json.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _ = __webpack_require__(/*! ./lodash */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\");\nvar Graph = __webpack_require__(/*! ./graph */ \"./node_modules/_graphlib@2.1.8@graphlib/lib/graph.js\");\n\nmodule.exports = {\n  write: write,\n  read: read\n};\n\nfunction write(g) {\n  var json = {\n    options: {\n      directed: g.isDirected(),\n      multigraph: g.isMultigraph(),\n      compound: g.isCompound()\n    },\n    nodes: writeNodes(g),\n    edges: writeEdges(g)\n  };\n  if (!_.isUndefined(g.graph())) {\n    json.value = _.clone(g.graph());\n  }\n  return json;\n}\n\nfunction writeNodes(g) {\n  return _.map(g.nodes(), function(v) {\n    var nodeValue = g.node(v);\n    var parent = g.parent(v);\n    var node = { v: v };\n    if (!_.isUndefined(nodeValue)) {\n      node.value = nodeValue;\n    }\n    if (!_.isUndefined(parent)) {\n      node.parent = parent;\n    }\n    return node;\n  });\n}\n\nfunction writeEdges(g) {\n  return _.map(g.edges(), function(e) {\n    var edgeValue = g.edge(e);\n    var edge = { v: e.v, w: e.w };\n    if (!_.isUndefined(e.name)) {\n      edge.name = e.name;\n    }\n    if (!_.isUndefined(edgeValue)) {\n      edge.value = edgeValue;\n    }\n    return edge;\n  });\n}\n\nfunction read(json) {\n  var g = new Graph(json.options).setGraph(json.value);\n  _.each(json.nodes, function(entry) {\n    g.setNode(entry.v, entry.value);\n    if (entry.parent) {\n      g.setParent(entry.v, entry.parent);\n    }\n  });\n  _.each(json.edges, function(entry) {\n    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);\n  });\n  return g;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/lodash.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* global window */\n\nvar lodash;\n\nif (true) {\n  try {\n    lodash = {\n      clone: __webpack_require__(/*! lodash/clone */ \"./node_modules/_lodash@4.17.15@lodash/clone.js\"),\n      constant: __webpack_require__(/*! lodash/constant */ \"./node_modules/_lodash@4.17.15@lodash/constant.js\"),\n      each: __webpack_require__(/*! lodash/each */ \"./node_modules/_lodash@4.17.15@lodash/each.js\"),\n      filter: __webpack_require__(/*! lodash/filter */ \"./node_modules/_lodash@4.17.15@lodash/filter.js\"),\n      has:  __webpack_require__(/*! lodash/has */ \"./node_modules/_lodash@4.17.15@lodash/has.js\"),\n      isArray: __webpack_require__(/*! lodash/isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n      isEmpty: __webpack_require__(/*! lodash/isEmpty */ \"./node_modules/_lodash@4.17.15@lodash/isEmpty.js\"),\n      isFunction: __webpack_require__(/*! lodash/isFunction */ \"./node_modules/_lodash@4.17.15@lodash/isFunction.js\"),\n      isUndefined: __webpack_require__(/*! lodash/isUndefined */ \"./node_modules/_lodash@4.17.15@lodash/isUndefined.js\"),\n      keys: __webpack_require__(/*! lodash/keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\"),\n      map: __webpack_require__(/*! lodash/map */ \"./node_modules/_lodash@4.17.15@lodash/map.js\"),\n      reduce: __webpack_require__(/*! lodash/reduce */ \"./node_modules/_lodash@4.17.15@lodash/reduce.js\"),\n      size: __webpack_require__(/*! lodash/size */ \"./node_modules/_lodash@4.17.15@lodash/size.js\"),\n      transform: __webpack_require__(/*! lodash/transform */ \"./node_modules/_lodash@4.17.15@lodash/transform.js\"),\n      union: __webpack_require__(/*! lodash/union */ \"./node_modules/_lodash@4.17.15@lodash/union.js\"),\n      values: __webpack_require__(/*! lodash/values */ \"./node_modules/_lodash@4.17.15@lodash/values.js\")\n    };\n  } catch (e) {\n    // continue regardless of error\n  }\n}\n\nif (!lodash) {\n  lodash = window._;\n}\n\nmodule.exports = lodash;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_graphlib@2.1.8@graphlib/lib/version.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_graphlib@2.1.8@graphlib/lib/version.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = '2.1.8';\n\n\n/***/ }),\n\n/***/ \"./node_modules/_isarray@0.0.1@isarray/index.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_isarray@0.0.1@isarray/index.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_DataView.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_DataView.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView');\n\nmodule.exports = DataView;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_Hash.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_Hash.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar hashClear = __webpack_require__(/*! ./_hashClear */ \"./node_modules/_lodash@4.17.15@lodash/_hashClear.js\"),\n    hashDelete = __webpack_require__(/*! ./_hashDelete */ \"./node_modules/_lodash@4.17.15@lodash/_hashDelete.js\"),\n    hashGet = __webpack_require__(/*! ./_hashGet */ \"./node_modules/_lodash@4.17.15@lodash/_hashGet.js\"),\n    hashHas = __webpack_require__(/*! ./_hashHas */ \"./node_modules/_lodash@4.17.15@lodash/_hashHas.js\"),\n    hashSet = __webpack_require__(/*! ./_hashSet */ \"./node_modules/_lodash@4.17.15@lodash/_hashSet.js\");\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_ListCache.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_ListCache.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar listCacheClear = __webpack_require__(/*! ./_listCacheClear */ \"./node_modules/_lodash@4.17.15@lodash/_listCacheClear.js\"),\n    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ \"./node_modules/_lodash@4.17.15@lodash/_listCacheDelete.js\"),\n    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ \"./node_modules/_lodash@4.17.15@lodash/_listCacheGet.js\"),\n    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ \"./node_modules/_lodash@4.17.15@lodash/_listCacheHas.js\"),\n    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ \"./node_modules/_lodash@4.17.15@lodash/_listCacheSet.js\");\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_Map.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_Map.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_MapCache.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_MapCache.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheClear.js\"),\n    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheDelete.js\"),\n    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheGet.js\"),\n    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheHas.js\"),\n    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheSet.js\");\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_Promise.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_Promise.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar Promise = getNative(root, 'Promise');\n\nmodule.exports = Promise;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_Set.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_Set.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar Set = getNative(root, 'Set');\n\nmodule.exports = Set;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_SetCache.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_SetCache.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar MapCache = __webpack_require__(/*! ./_MapCache */ \"./node_modules/_lodash@4.17.15@lodash/_MapCache.js\"),\n    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ \"./node_modules/_lodash@4.17.15@lodash/_setCacheAdd.js\"),\n    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ \"./node_modules/_lodash@4.17.15@lodash/_setCacheHas.js\");\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\nmodule.exports = SetCache;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_Stack.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_Stack.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ListCache = __webpack_require__(/*! ./_ListCache */ \"./node_modules/_lodash@4.17.15@lodash/_ListCache.js\"),\n    stackClear = __webpack_require__(/*! ./_stackClear */ \"./node_modules/_lodash@4.17.15@lodash/_stackClear.js\"),\n    stackDelete = __webpack_require__(/*! ./_stackDelete */ \"./node_modules/_lodash@4.17.15@lodash/_stackDelete.js\"),\n    stackGet = __webpack_require__(/*! ./_stackGet */ \"./node_modules/_lodash@4.17.15@lodash/_stackGet.js\"),\n    stackHas = __webpack_require__(/*! ./_stackHas */ \"./node_modules/_lodash@4.17.15@lodash/_stackHas.js\"),\n    stackSet = __webpack_require__(/*! ./_stackSet */ \"./node_modules/_lodash@4.17.15@lodash/_stackSet.js\");\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\nmodule.exports = Stack;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_Symbol.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_Symbol.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_Uint8Array.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_Uint8Array.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/** Built-in value references. */\nvar Uint8Array = root.Uint8Array;\n\nmodule.exports = Uint8Array;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_WeakMap.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_WeakMap.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\"),\n    root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/* Built-in method references that are verified to be native. */\nvar WeakMap = getNative(root, 'WeakMap');\n\nmodule.exports = WeakMap;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_apply.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_apply.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\nmodule.exports = apply;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayEach.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayEach.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\nmodule.exports = arrayEach;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayFilter.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayFilter.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayFilter;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayIncludes.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayIncludes.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ \"./node_modules/_lodash@4.17.15@lodash/_baseIndexOf.js\");\n\n/**\n * A specialized version of `_.includes` for arrays without support for\n * specifying an index to search from.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludes(array, value) {\n  var length = array == null ? 0 : array.length;\n  return !!length && baseIndexOf(array, value, 0) > -1;\n}\n\nmodule.exports = arrayIncludes;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayIncludesWith.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayIncludesWith.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * This function is like `arrayIncludes` except that it accepts a comparator.\n *\n * @private\n * @param {Array} [array] The array to inspect.\n * @param {*} target The value to search for.\n * @param {Function} comparator The comparator invoked per element.\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\n */\nfunction arrayIncludesWith(array, value, comparator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (comparator(value, array[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arrayIncludesWith;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayLikeKeys.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayLikeKeys.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseTimes = __webpack_require__(/*! ./_baseTimes */ \"./node_modules/_lodash@4.17.15@lodash/_baseTimes.js\"),\n    isArguments = __webpack_require__(/*! ./isArguments */ \"./node_modules/_lodash@4.17.15@lodash/isArguments.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/_lodash@4.17.15@lodash/isBuffer.js\"),\n    isIndex = __webpack_require__(/*! ./_isIndex */ \"./node_modules/_lodash@4.17.15@lodash/_isIndex.js\"),\n    isTypedArray = __webpack_require__(/*! ./isTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/isTypedArray.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = arrayLikeKeys;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayMap.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayMap.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayPush.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayPush.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\nmodule.exports = arrayPush;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arrayReduce.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arrayReduce.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\nmodule.exports = arrayReduce;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_arraySome.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_arraySome.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nmodule.exports = arraySome;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_asciiSize.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_asciiSize.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseProperty = __webpack_require__(/*! ./_baseProperty */ \"./node_modules/_lodash@4.17.15@lodash/_baseProperty.js\");\n\n/**\n * Gets the size of an ASCII `string`.\n *\n * @private\n * @param {string} string The string inspect.\n * @returns {number} Returns the string size.\n */\nvar asciiSize = baseProperty('length');\n\nmodule.exports = asciiSize;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_assignMergeValue.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_assignMergeValue.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ \"./node_modules/_lodash@4.17.15@lodash/_baseAssignValue.js\"),\n    eq = __webpack_require__(/*! ./eq */ \"./node_modules/_lodash@4.17.15@lodash/eq.js\");\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignMergeValue;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_assignValue.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_assignValue.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ \"./node_modules/_lodash@4.17.15@lodash/_baseAssignValue.js\"),\n    eq = __webpack_require__(/*! ./eq */ \"./node_modules/_lodash@4.17.15@lodash/eq.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignValue;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_assocIndexOf.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_assocIndexOf.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar eq = __webpack_require__(/*! ./eq */ \"./node_modules/_lodash@4.17.15@lodash/eq.js\");\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseAssign.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseAssign.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(/*! ./_copyObject */ \"./node_modules/_lodash@4.17.15@lodash/_copyObject.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\");\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\nmodule.exports = baseAssign;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseAssignIn.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseAssignIn.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(/*! ./_copyObject */ \"./node_modules/_lodash@4.17.15@lodash/_copyObject.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/_lodash@4.17.15@lodash/keysIn.js\");\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\nmodule.exports = baseAssignIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseAssignValue.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseAssignValue.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar defineProperty = __webpack_require__(/*! ./_defineProperty */ \"./node_modules/_lodash@4.17.15@lodash/_defineProperty.js\");\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\nmodule.exports = baseAssignValue;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseClone.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseClone.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Stack = __webpack_require__(/*! ./_Stack */ \"./node_modules/_lodash@4.17.15@lodash/_Stack.js\"),\n    arrayEach = __webpack_require__(/*! ./_arrayEach */ \"./node_modules/_lodash@4.17.15@lodash/_arrayEach.js\"),\n    assignValue = __webpack_require__(/*! ./_assignValue */ \"./node_modules/_lodash@4.17.15@lodash/_assignValue.js\"),\n    baseAssign = __webpack_require__(/*! ./_baseAssign */ \"./node_modules/_lodash@4.17.15@lodash/_baseAssign.js\"),\n    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ \"./node_modules/_lodash@4.17.15@lodash/_baseAssignIn.js\"),\n    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ \"./node_modules/_lodash@4.17.15@lodash/_cloneBuffer.js\"),\n    copyArray = __webpack_require__(/*! ./_copyArray */ \"./node_modules/_lodash@4.17.15@lodash/_copyArray.js\"),\n    copySymbols = __webpack_require__(/*! ./_copySymbols */ \"./node_modules/_lodash@4.17.15@lodash/_copySymbols.js\"),\n    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ \"./node_modules/_lodash@4.17.15@lodash/_copySymbolsIn.js\"),\n    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ \"./node_modules/_lodash@4.17.15@lodash/_getAllKeys.js\"),\n    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ \"./node_modules/_lodash@4.17.15@lodash/_getAllKeysIn.js\"),\n    getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/_lodash@4.17.15@lodash/_getTag.js\"),\n    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ \"./node_modules/_lodash@4.17.15@lodash/_initCloneArray.js\"),\n    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ \"./node_modules/_lodash@4.17.15@lodash/_initCloneByTag.js\"),\n    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ \"./node_modules/_lodash@4.17.15@lodash/_initCloneObject.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/_lodash@4.17.15@lodash/isBuffer.js\"),\n    isMap = __webpack_require__(/*! ./isMap */ \"./node_modules/_lodash@4.17.15@lodash/isMap.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    isSet = __webpack_require__(/*! ./isSet */ \"./node_modules/_lodash@4.17.15@lodash/isSet.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\");\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n  } else if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\nmodule.exports = baseClone;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseCreate.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseCreate.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\");\n\n/** Built-in value references. */\nvar objectCreate = Object.create;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\nmodule.exports = baseCreate;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseEach.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseEach.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseForOwn = __webpack_require__(/*! ./_baseForOwn */ \"./node_modules/_lodash@4.17.15@lodash/_baseForOwn.js\"),\n    createBaseEach = __webpack_require__(/*! ./_createBaseEach */ \"./node_modules/_lodash@4.17.15@lodash/_createBaseEach.js\");\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\nmodule.exports = baseEach;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseExtremum.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseExtremum.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/_lodash@4.17.15@lodash/isSymbol.js\");\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !isSymbol(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseExtremum;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseFilter.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseFilter.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseEach = __webpack_require__(/*! ./_baseEach */ \"./node_modules/_lodash@4.17.15@lodash/_baseEach.js\");\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFilter;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseFindIndex.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseFindIndex.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = baseFindIndex;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseFlatten.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseFlatten.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayPush = __webpack_require__(/*! ./_arrayPush */ \"./node_modules/_lodash@4.17.15@lodash/_arrayPush.js\"),\n    isFlattenable = __webpack_require__(/*! ./_isFlattenable */ \"./node_modules/_lodash@4.17.15@lodash/_isFlattenable.js\");\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseFlatten;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseFor.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseFor.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createBaseFor = __webpack_require__(/*! ./_createBaseFor */ \"./node_modules/_lodash@4.17.15@lodash/_createBaseFor.js\");\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\nmodule.exports = baseFor;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseForOwn.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseForOwn.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFor = __webpack_require__(/*! ./_baseFor */ \"./node_modules/_lodash@4.17.15@lodash/_baseFor.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\");\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseGet.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseGet.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar castPath = __webpack_require__(/*! ./_castPath */ \"./node_modules/_lodash@4.17.15@lodash/_castPath.js\"),\n    toKey = __webpack_require__(/*! ./_toKey */ \"./node_modules/_lodash@4.17.15@lodash/_toKey.js\");\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseGetAllKeys.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseGetAllKeys.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayPush = __webpack_require__(/*! ./_arrayPush */ \"./node_modules/_lodash@4.17.15@lodash/_arrayPush.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\");\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\nmodule.exports = baseGetAllKeys;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/_lodash@4.17.15@lodash/_Symbol.js\"),\n    getRawTag = __webpack_require__(/*! ./_getRawTag */ \"./node_modules/_lodash@4.17.15@lodash/_getRawTag.js\"),\n    objectToString = __webpack_require__(/*! ./_objectToString */ \"./node_modules/_lodash@4.17.15@lodash/_objectToString.js\");\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseGt.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseGt.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.gt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is greater than `other`,\n *  else `false`.\n */\nfunction baseGt(value, other) {\n  return value > other;\n}\n\nmodule.exports = baseGt;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseHas.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseHas.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.has` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHas(object, key) {\n  return object != null && hasOwnProperty.call(object, key);\n}\n\nmodule.exports = baseHas;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseHasIn.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseHasIn.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\nmodule.exports = baseHasIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIndexOf.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIndexOf.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ \"./node_modules/_lodash@4.17.15@lodash/_baseFindIndex.js\"),\n    baseIsNaN = __webpack_require__(/*! ./_baseIsNaN */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsNaN.js\"),\n    strictIndexOf = __webpack_require__(/*! ./_strictIndexOf */ \"./node_modules/_lodash@4.17.15@lodash/_strictIndexOf.js\");\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\nmodule.exports = baseIndexOf;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsArguments.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsArguments.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\nmodule.exports = baseIsArguments;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsEqual.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsEqual.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsEqualDeep.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\nmodule.exports = baseIsEqual;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsEqualDeep.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsEqualDeep.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Stack = __webpack_require__(/*! ./_Stack */ \"./node_modules/_lodash@4.17.15@lodash/_Stack.js\"),\n    equalArrays = __webpack_require__(/*! ./_equalArrays */ \"./node_modules/_lodash@4.17.15@lodash/_equalArrays.js\"),\n    equalByTag = __webpack_require__(/*! ./_equalByTag */ \"./node_modules/_lodash@4.17.15@lodash/_equalByTag.js\"),\n    equalObjects = __webpack_require__(/*! ./_equalObjects */ \"./node_modules/_lodash@4.17.15@lodash/_equalObjects.js\"),\n    getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/_lodash@4.17.15@lodash/_getTag.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/_lodash@4.17.15@lodash/isBuffer.js\"),\n    isTypedArray = __webpack_require__(/*! ./isTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/isTypedArray.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\nmodule.exports = baseIsEqualDeep;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsMap.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsMap.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/_lodash@4.17.15@lodash/_getTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]';\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\nmodule.exports = baseIsMap;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsMatch.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsMatch.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Stack = __webpack_require__(/*! ./_Stack */ \"./node_modules/_lodash@4.17.15@lodash/_Stack.js\"),\n    baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsEqual.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsNaN.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsNaN.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\nmodule.exports = baseIsNaN;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsNative.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsNative.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isFunction = __webpack_require__(/*! ./isFunction */ \"./node_modules/_lodash@4.17.15@lodash/isFunction.js\"),\n    isMasked = __webpack_require__(/*! ./_isMasked */ \"./node_modules/_lodash@4.17.15@lodash/_isMasked.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    toSource = __webpack_require__(/*! ./_toSource */ \"./node_modules/_lodash@4.17.15@lodash/_toSource.js\");\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsSet.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsSet.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/_lodash@4.17.15@lodash/_getTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar setTag = '[object Set]';\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\nmodule.exports = baseIsSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIsTypedArray.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIsTypedArray.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\"),\n    isLength = __webpack_require__(/*! ./isLength */ \"./node_modules/_lodash@4.17.15@lodash/isLength.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\nmodule.exports = baseIsTypedArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseMatches = __webpack_require__(/*! ./_baseMatches */ \"./node_modules/_lodash@4.17.15@lodash/_baseMatches.js\"),\n    baseMatchesProperty = __webpack_require__(/*! ./_baseMatchesProperty */ \"./node_modules/_lodash@4.17.15@lodash/_baseMatchesProperty.js\"),\n    identity = __webpack_require__(/*! ./identity */ \"./node_modules/_lodash@4.17.15@lodash/identity.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    property = __webpack_require__(/*! ./property */ \"./node_modules/_lodash@4.17.15@lodash/property.js\");\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\nmodule.exports = baseIteratee;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseKeys.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseKeys.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isPrototype = __webpack_require__(/*! ./_isPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_isPrototype.js\"),\n    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ \"./node_modules/_lodash@4.17.15@lodash/_nativeKeys.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeys;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseKeysIn.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseKeysIn.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    isPrototype = __webpack_require__(/*! ./_isPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_isPrototype.js\"),\n    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ \"./node_modules/_lodash@4.17.15@lodash/_nativeKeysIn.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseKeysIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseLt.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseLt.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\nmodule.exports = baseLt;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseMap.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseMap.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseEach = __webpack_require__(/*! ./_baseEach */ \"./node_modules/_lodash@4.17.15@lodash/_baseEach.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\");\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\nmodule.exports = baseMap;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseMatches.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseMatches.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsMatch = __webpack_require__(/*! ./_baseIsMatch */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsMatch.js\"),\n    getMatchData = __webpack_require__(/*! ./_getMatchData */ \"./node_modules/_lodash@4.17.15@lodash/_getMatchData.js\"),\n    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ \"./node_modules/_lodash@4.17.15@lodash/_matchesStrictComparable.js\");\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\nmodule.exports = baseMatches;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseMatchesProperty.js\":\n/*!*********************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseMatchesProperty.js ***!\n  \\*********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsEqual.js\"),\n    get = __webpack_require__(/*! ./get */ \"./node_modules/_lodash@4.17.15@lodash/get.js\"),\n    hasIn = __webpack_require__(/*! ./hasIn */ \"./node_modules/_lodash@4.17.15@lodash/hasIn.js\"),\n    isKey = __webpack_require__(/*! ./_isKey */ \"./node_modules/_lodash@4.17.15@lodash/_isKey.js\"),\n    isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ \"./node_modules/_lodash@4.17.15@lodash/_isStrictComparable.js\"),\n    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ \"./node_modules/_lodash@4.17.15@lodash/_matchesStrictComparable.js\"),\n    toKey = __webpack_require__(/*! ./_toKey */ \"./node_modules/_lodash@4.17.15@lodash/_toKey.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseMerge.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseMerge.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Stack = __webpack_require__(/*! ./_Stack */ \"./node_modules/_lodash@4.17.15@lodash/_Stack.js\"),\n    assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ \"./node_modules/_lodash@4.17.15@lodash/_assignMergeValue.js\"),\n    baseFor = __webpack_require__(/*! ./_baseFor */ \"./node_modules/_lodash@4.17.15@lodash/_baseFor.js\"),\n    baseMergeDeep = __webpack_require__(/*! ./_baseMergeDeep */ \"./node_modules/_lodash@4.17.15@lodash/_baseMergeDeep.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/_lodash@4.17.15@lodash/keysIn.js\"),\n    safeGet = __webpack_require__(/*! ./_safeGet */ \"./node_modules/_lodash@4.17.15@lodash/_safeGet.js\");\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\nmodule.exports = baseMerge;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseMergeDeep.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseMergeDeep.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ \"./node_modules/_lodash@4.17.15@lodash/_assignMergeValue.js\"),\n    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ \"./node_modules/_lodash@4.17.15@lodash/_cloneBuffer.js\"),\n    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/_cloneTypedArray.js\"),\n    copyArray = __webpack_require__(/*! ./_copyArray */ \"./node_modules/_lodash@4.17.15@lodash/_copyArray.js\"),\n    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ \"./node_modules/_lodash@4.17.15@lodash/_initCloneObject.js\"),\n    isArguments = __webpack_require__(/*! ./isArguments */ \"./node_modules/_lodash@4.17.15@lodash/isArguments.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLikeObject.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/_lodash@4.17.15@lodash/isBuffer.js\"),\n    isFunction = __webpack_require__(/*! ./isFunction */ \"./node_modules/_lodash@4.17.15@lodash/isFunction.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    isPlainObject = __webpack_require__(/*! ./isPlainObject */ \"./node_modules/_lodash@4.17.15@lodash/isPlainObject.js\"),\n    isTypedArray = __webpack_require__(/*! ./isTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/isTypedArray.js\"),\n    safeGet = __webpack_require__(/*! ./_safeGet */ \"./node_modules/_lodash@4.17.15@lodash/_safeGet.js\"),\n    toPlainObject = __webpack_require__(/*! ./toPlainObject */ \"./node_modules/_lodash@4.17.15@lodash/toPlainObject.js\");\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\nmodule.exports = baseMergeDeep;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseOrderBy.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseOrderBy.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayMap = __webpack_require__(/*! ./_arrayMap */ \"./node_modules/_lodash@4.17.15@lodash/_arrayMap.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    baseMap = __webpack_require__(/*! ./_baseMap */ \"./node_modules/_lodash@4.17.15@lodash/_baseMap.js\"),\n    baseSortBy = __webpack_require__(/*! ./_baseSortBy */ \"./node_modules/_lodash@4.17.15@lodash/_baseSortBy.js\"),\n    baseUnary = __webpack_require__(/*! ./_baseUnary */ \"./node_modules/_lodash@4.17.15@lodash/_baseUnary.js\"),\n    compareMultiple = __webpack_require__(/*! ./_compareMultiple */ \"./node_modules/_lodash@4.17.15@lodash/_compareMultiple.js\"),\n    identity = __webpack_require__(/*! ./identity */ \"./node_modules/_lodash@4.17.15@lodash/identity.js\");\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  var index = -1;\n  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\nmodule.exports = baseOrderBy;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_basePick.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_basePick.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar basePickBy = __webpack_require__(/*! ./_basePickBy */ \"./node_modules/_lodash@4.17.15@lodash/_basePickBy.js\"),\n    hasIn = __webpack_require__(/*! ./hasIn */ \"./node_modules/_lodash@4.17.15@lodash/hasIn.js\");\n\n/**\n * The base implementation of `_.pick` without support for individual\n * property identifiers.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @returns {Object} Returns the new object.\n */\nfunction basePick(object, paths) {\n  return basePickBy(object, paths, function(value, path) {\n    return hasIn(object, path);\n  });\n}\n\nmodule.exports = basePick;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_basePickBy.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_basePickBy.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGet = __webpack_require__(/*! ./_baseGet */ \"./node_modules/_lodash@4.17.15@lodash/_baseGet.js\"),\n    baseSet = __webpack_require__(/*! ./_baseSet */ \"./node_modules/_lodash@4.17.15@lodash/_baseSet.js\"),\n    castPath = __webpack_require__(/*! ./_castPath */ \"./node_modules/_lodash@4.17.15@lodash/_castPath.js\");\n\n/**\n * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @param {Function} predicate The function invoked per property.\n * @returns {Object} Returns the new object.\n */\nfunction basePickBy(object, paths, predicate) {\n  var index = -1,\n      length = paths.length,\n      result = {};\n\n  while (++index < length) {\n    var path = paths[index],\n        value = baseGet(object, path);\n\n    if (predicate(value, path)) {\n      baseSet(result, castPath(path, object), value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = basePickBy;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseProperty.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseProperty.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_basePropertyDeep.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_basePropertyDeep.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGet = __webpack_require__(/*! ./_baseGet */ \"./node_modules/_lodash@4.17.15@lodash/_baseGet.js\");\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\nmodule.exports = basePropertyDeep;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseRange.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseRange.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil,\n    nativeMax = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\nmodule.exports = baseRange;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseReduce.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseReduce.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n  eachFunc(collection, function(value, index, collection) {\n    accumulator = initAccum\n      ? (initAccum = false, value)\n      : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\n\nmodule.exports = baseReduce;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseRest.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseRest.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar identity = __webpack_require__(/*! ./identity */ \"./node_modules/_lodash@4.17.15@lodash/identity.js\"),\n    overRest = __webpack_require__(/*! ./_overRest */ \"./node_modules/_lodash@4.17.15@lodash/_overRest.js\"),\n    setToString = __webpack_require__(/*! ./_setToString */ \"./node_modules/_lodash@4.17.15@lodash/_setToString.js\");\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\nmodule.exports = baseRest;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseSet.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseSet.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assignValue = __webpack_require__(/*! ./_assignValue */ \"./node_modules/_lodash@4.17.15@lodash/_assignValue.js\"),\n    castPath = __webpack_require__(/*! ./_castPath */ \"./node_modules/_lodash@4.17.15@lodash/_castPath.js\"),\n    isIndex = __webpack_require__(/*! ./_isIndex */ \"./node_modules/_lodash@4.17.15@lodash/_isIndex.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    toKey = __webpack_require__(/*! ./_toKey */ \"./node_modules/_lodash@4.17.15@lodash/_toKey.js\");\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!isObject(object)) {\n    return object;\n  }\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = toKey(path[index]),\n        newValue = value;\n\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = isObject(objValue)\n          ? objValue\n          : (isIndex(path[index + 1]) ? [] : {});\n      }\n    }\n    assignValue(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\n\nmodule.exports = baseSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseSetToString.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseSetToString.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar constant = __webpack_require__(/*! ./constant */ \"./node_modules/_lodash@4.17.15@lodash/constant.js\"),\n    defineProperty = __webpack_require__(/*! ./_defineProperty */ \"./node_modules/_lodash@4.17.15@lodash/_defineProperty.js\"),\n    identity = __webpack_require__(/*! ./identity */ \"./node_modules/_lodash@4.17.15@lodash/identity.js\");\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\nmodule.exports = baseSetToString;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseSortBy.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseSortBy.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\nmodule.exports = baseSortBy;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseTimes.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseTimes.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\nmodule.exports = baseTimes;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseToString.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseToString.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/_lodash@4.17.15@lodash/_Symbol.js\"),\n    arrayMap = __webpack_require__(/*! ./_arrayMap */ \"./node_modules/_lodash@4.17.15@lodash/_arrayMap.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/_lodash@4.17.15@lodash/isSymbol.js\");\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseUnary.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseUnary.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\nmodule.exports = baseUnary;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseUniq.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseUniq.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar SetCache = __webpack_require__(/*! ./_SetCache */ \"./node_modules/_lodash@4.17.15@lodash/_SetCache.js\"),\n    arrayIncludes = __webpack_require__(/*! ./_arrayIncludes */ \"./node_modules/_lodash@4.17.15@lodash/_arrayIncludes.js\"),\n    arrayIncludesWith = __webpack_require__(/*! ./_arrayIncludesWith */ \"./node_modules/_lodash@4.17.15@lodash/_arrayIncludesWith.js\"),\n    cacheHas = __webpack_require__(/*! ./_cacheHas */ \"./node_modules/_lodash@4.17.15@lodash/_cacheHas.js\"),\n    createSet = __webpack_require__(/*! ./_createSet */ \"./node_modules/_lodash@4.17.15@lodash/_createSet.js\"),\n    setToArray = __webpack_require__(/*! ./_setToArray */ \"./node_modules/_lodash@4.17.15@lodash/_setToArray.js\");\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n */\nfunction baseUniq(array, iteratee, comparator) {\n  var index = -1,\n      includes = arrayIncludes,\n      length = array.length,\n      isCommon = true,\n      result = [],\n      seen = result;\n\n  if (comparator) {\n    isCommon = false;\n    includes = arrayIncludesWith;\n  }\n  else if (length >= LARGE_ARRAY_SIZE) {\n    var set = iteratee ? null : createSet(array);\n    if (set) {\n      return setToArray(set);\n    }\n    isCommon = false;\n    includes = cacheHas;\n    seen = new SetCache;\n  }\n  else {\n    seen = iteratee ? [] : result;\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var seenIndex = seen.length;\n      while (seenIndex--) {\n        if (seen[seenIndex] === computed) {\n          continue outer;\n        }\n      }\n      if (iteratee) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n    else if (!includes(seen, computed, comparator)) {\n      if (seen !== result) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseUniq;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseValues.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseValues.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayMap = __webpack_require__(/*! ./_arrayMap */ \"./node_modules/_lodash@4.17.15@lodash/_arrayMap.js\");\n\n/**\n * The base implementation of `_.values` and `_.valuesIn` which creates an\n * array of `object` property values corresponding to the property names\n * of `props`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} props The property names to get values for.\n * @returns {Object} Returns the array of property values.\n */\nfunction baseValues(object, props) {\n  return arrayMap(props, function(key) {\n    return object[key];\n  });\n}\n\nmodule.exports = baseValues;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_baseZipObject.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_baseZipObject.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n *\n * @private\n * @param {Array} props The property identifiers.\n * @param {Array} values The property values.\n * @param {Function} assignFunc The function to assign values.\n * @returns {Object} Returns the new object.\n */\nfunction baseZipObject(props, values, assignFunc) {\n  var index = -1,\n      length = props.length,\n      valsLength = values.length,\n      result = {};\n\n  while (++index < length) {\n    var value = index < valsLength ? values[index] : undefined;\n    assignFunc(result, props[index], value);\n  }\n  return result;\n}\n\nmodule.exports = baseZipObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_cacheHas.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_cacheHas.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\nmodule.exports = cacheHas;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_castFunction.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_castFunction.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar identity = __webpack_require__(/*! ./identity */ \"./node_modules/_lodash@4.17.15@lodash/identity.js\");\n\n/**\n * Casts `value` to `identity` if it's not a function.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Function} Returns cast function.\n */\nfunction castFunction(value) {\n  return typeof value == 'function' ? value : identity;\n}\n\nmodule.exports = castFunction;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_castPath.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_castPath.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isKey = __webpack_require__(/*! ./_isKey */ \"./node_modules/_lodash@4.17.15@lodash/_isKey.js\"),\n    stringToPath = __webpack_require__(/*! ./_stringToPath */ \"./node_modules/_lodash@4.17.15@lodash/_stringToPath.js\"),\n    toString = __webpack_require__(/*! ./toString */ \"./node_modules/_lodash@4.17.15@lodash/toString.js\");\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_cloneArrayBuffer.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_cloneArrayBuffer.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Uint8Array = __webpack_require__(/*! ./_Uint8Array */ \"./node_modules/_lodash@4.17.15@lodash/_Uint8Array.js\");\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\nmodule.exports = cloneArrayBuffer;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_cloneBuffer.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_cloneBuffer.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/** Detect free variable `exports`. */\nvar freeExports =   true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\nmodule.exports = cloneBuffer;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.42.1@webpack/buildin/module.js */ \"./node_modules/_webpack@4.42.1@webpack/buildin/module.js\")(module)))\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_cloneDataView.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_cloneDataView.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ \"./node_modules/_lodash@4.17.15@lodash/_cloneArrayBuffer.js\");\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\nmodule.exports = cloneDataView;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_cloneRegExp.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_cloneRegExp.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\nmodule.exports = cloneRegExp;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_cloneSymbol.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_cloneSymbol.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/_lodash@4.17.15@lodash/_Symbol.js\");\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\nmodule.exports = cloneSymbol;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_cloneTypedArray.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_cloneTypedArray.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ \"./node_modules/_lodash@4.17.15@lodash/_cloneArrayBuffer.js\");\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\nmodule.exports = cloneTypedArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_compareAscending.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_compareAscending.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/_lodash@4.17.15@lodash/isSymbol.js\");\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\nmodule.exports = compareAscending;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_compareMultiple.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_compareMultiple.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar compareAscending = __webpack_require__(/*! ./_compareAscending */ \"./node_modules/_lodash@4.17.15@lodash/_compareAscending.js\");\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\nmodule.exports = compareMultiple;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_copyArray.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_copyArray.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\nmodule.exports = copyArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_copyObject.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_copyObject.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assignValue = __webpack_require__(/*! ./_assignValue */ \"./node_modules/_lodash@4.17.15@lodash/_assignValue.js\"),\n    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ \"./node_modules/_lodash@4.17.15@lodash/_baseAssignValue.js\");\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\nmodule.exports = copyObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_copySymbols.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_copySymbols.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(/*! ./_copyObject */ \"./node_modules/_lodash@4.17.15@lodash/_copyObject.js\"),\n    getSymbols = __webpack_require__(/*! ./_getSymbols */ \"./node_modules/_lodash@4.17.15@lodash/_getSymbols.js\");\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\nmodule.exports = copySymbols;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_copySymbolsIn.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_copySymbolsIn.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(/*! ./_copyObject */ \"./node_modules/_lodash@4.17.15@lodash/_copyObject.js\"),\n    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ \"./node_modules/_lodash@4.17.15@lodash/_getSymbolsIn.js\");\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\nmodule.exports = copySymbolsIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_coreJsData.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_coreJsData.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_createAssigner.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_createAssigner.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseRest = __webpack_require__(/*! ./_baseRest */ \"./node_modules/_lodash@4.17.15@lodash/_baseRest.js\"),\n    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ \"./node_modules/_lodash@4.17.15@lodash/_isIterateeCall.js\");\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_createBaseEach.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_createBaseEach.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\");\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\nmodule.exports = createBaseEach;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_createBaseFor.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_createBaseFor.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createBaseFor;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_createFind.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_createFind.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\");\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\nmodule.exports = createFind;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_createRange.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_createRange.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseRange = __webpack_require__(/*! ./_baseRange */ \"./node_modules/_lodash@4.17.15@lodash/_baseRange.js\"),\n    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ \"./node_modules/_lodash@4.17.15@lodash/_isIterateeCall.js\"),\n    toFinite = __webpack_require__(/*! ./toFinite */ \"./node_modules/_lodash@4.17.15@lodash/toFinite.js\");\n\n/**\n * Creates a `_.range` or `_.rangeRight` function.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new range function.\n */\nfunction createRange(fromRight) {\n  return function(start, end, step) {\n    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n      end = step = undefined;\n    }\n    // Ensure the sign of `-0` is preserved.\n    start = toFinite(start);\n    if (end === undefined) {\n      end = start;\n      start = 0;\n    } else {\n      end = toFinite(end);\n    }\n    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n    return baseRange(start, end, step, fromRight);\n  };\n}\n\nmodule.exports = createRange;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_createSet.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_createSet.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Set = __webpack_require__(/*! ./_Set */ \"./node_modules/_lodash@4.17.15@lodash/_Set.js\"),\n    noop = __webpack_require__(/*! ./noop */ \"./node_modules/_lodash@4.17.15@lodash/noop.js\"),\n    setToArray = __webpack_require__(/*! ./_setToArray */ \"./node_modules/_lodash@4.17.15@lodash/_setToArray.js\");\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Creates a set object of `values`.\n *\n * @private\n * @param {Array} values The values to add to the set.\n * @returns {Object} Returns the new set.\n */\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n  return new Set(values);\n};\n\nmodule.exports = createSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_defineProperty.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_defineProperty.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\");\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\nmodule.exports = defineProperty;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_equalArrays.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_equalArrays.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar SetCache = __webpack_require__(/*! ./_SetCache */ \"./node_modules/_lodash@4.17.15@lodash/_SetCache.js\"),\n    arraySome = __webpack_require__(/*! ./_arraySome */ \"./node_modules/_lodash@4.17.15@lodash/_arraySome.js\"),\n    cacheHas = __webpack_require__(/*! ./_cacheHas */ \"./node_modules/_lodash@4.17.15@lodash/_cacheHas.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalArrays;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_equalByTag.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_equalByTag.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/_lodash@4.17.15@lodash/_Symbol.js\"),\n    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ \"./node_modules/_lodash@4.17.15@lodash/_Uint8Array.js\"),\n    eq = __webpack_require__(/*! ./eq */ \"./node_modules/_lodash@4.17.15@lodash/eq.js\"),\n    equalArrays = __webpack_require__(/*! ./_equalArrays */ \"./node_modules/_lodash@4.17.15@lodash/_equalArrays.js\"),\n    mapToArray = __webpack_require__(/*! ./_mapToArray */ \"./node_modules/_lodash@4.17.15@lodash/_mapToArray.js\"),\n    setToArray = __webpack_require__(/*! ./_setToArray */ \"./node_modules/_lodash@4.17.15@lodash/_setToArray.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]';\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_equalObjects.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_equalObjects.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getAllKeys = __webpack_require__(/*! ./_getAllKeys */ \"./node_modules/_lodash@4.17.15@lodash/_getAllKeys.js\");\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\nmodule.exports = equalObjects;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_flatRest.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_flatRest.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar flatten = __webpack_require__(/*! ./flatten */ \"./node_modules/_lodash@4.17.15@lodash/flatten.js\"),\n    overRest = __webpack_require__(/*! ./_overRest */ \"./node_modules/_lodash@4.17.15@lodash/_overRest.js\"),\n    setToString = __webpack_require__(/*! ./_setToString */ \"./node_modules/_lodash@4.17.15@lodash/_setToString.js\");\n\n/**\n * A specialized version of `baseRest` which flattens the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @returns {Function} Returns the new function.\n */\nfunction flatRest(func) {\n  return setToString(overRest(func, undefined, flatten), func + '');\n}\n\nmodule.exports = flatRest;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_freeGlobal.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_freeGlobal.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.42.1@webpack/buildin/global.js */ \"./node_modules/_webpack@4.42.1@webpack/buildin/global.js\")))\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getAllKeys.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getAllKeys.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetAllKeys.js\"),\n    getSymbols = __webpack_require__(/*! ./_getSymbols */ \"./node_modules/_lodash@4.17.15@lodash/_getSymbols.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\");\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\nmodule.exports = getAllKeys;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getAllKeysIn.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getAllKeysIn.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetAllKeys.js\"),\n    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ \"./node_modules/_lodash@4.17.15@lodash/_getSymbolsIn.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/_lodash@4.17.15@lodash/keysIn.js\");\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\nmodule.exports = getAllKeysIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getMapData.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getMapData.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isKeyable = __webpack_require__(/*! ./_isKeyable */ \"./node_modules/_lodash@4.17.15@lodash/_isKeyable.js\");\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getMatchData.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getMatchData.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ \"./node_modules/_lodash@4.17.15@lodash/_isStrictComparable.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\");\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\nmodule.exports = getMatchData;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getNative.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsNative = __webpack_require__(/*! ./_baseIsNative */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsNative.js\"),\n    getValue = __webpack_require__(/*! ./_getValue */ \"./node_modules/_lodash@4.17.15@lodash/_getValue.js\");\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getPrototype.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getPrototype.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar overArg = __webpack_require__(/*! ./_overArg */ \"./node_modules/_lodash@4.17.15@lodash/_overArg.js\");\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getRawTag.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getRawTag.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/_lodash@4.17.15@lodash/_Symbol.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getSymbols.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getSymbols.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayFilter = __webpack_require__(/*! ./_arrayFilter */ \"./node_modules/_lodash@4.17.15@lodash/_arrayFilter.js\"),\n    stubArray = __webpack_require__(/*! ./stubArray */ \"./node_modules/_lodash@4.17.15@lodash/stubArray.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\nmodule.exports = getSymbols;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getSymbolsIn.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getSymbolsIn.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayPush = __webpack_require__(/*! ./_arrayPush */ \"./node_modules/_lodash@4.17.15@lodash/_arrayPush.js\"),\n    getPrototype = __webpack_require__(/*! ./_getPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_getPrototype.js\"),\n    getSymbols = __webpack_require__(/*! ./_getSymbols */ \"./node_modules/_lodash@4.17.15@lodash/_getSymbols.js\"),\n    stubArray = __webpack_require__(/*! ./stubArray */ \"./node_modules/_lodash@4.17.15@lodash/stubArray.js\");\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\nmodule.exports = getSymbolsIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getTag.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getTag.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DataView = __webpack_require__(/*! ./_DataView */ \"./node_modules/_lodash@4.17.15@lodash/_DataView.js\"),\n    Map = __webpack_require__(/*! ./_Map */ \"./node_modules/_lodash@4.17.15@lodash/_Map.js\"),\n    Promise = __webpack_require__(/*! ./_Promise */ \"./node_modules/_lodash@4.17.15@lodash/_Promise.js\"),\n    Set = __webpack_require__(/*! ./_Set */ \"./node_modules/_lodash@4.17.15@lodash/_Set.js\"),\n    WeakMap = __webpack_require__(/*! ./_WeakMap */ \"./node_modules/_lodash@4.17.15@lodash/_WeakMap.js\"),\n    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\"),\n    toSource = __webpack_require__(/*! ./_toSource */ \"./node_modules/_lodash@4.17.15@lodash/_toSource.js\");\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    setTag = '[object Set]',\n    weakMapTag = '[object WeakMap]';\n\nvar dataViewTag = '[object DataView]';\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\nmodule.exports = getTag;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_getValue.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_getValue.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_hasPath.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_hasPath.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar castPath = __webpack_require__(/*! ./_castPath */ \"./node_modules/_lodash@4.17.15@lodash/_castPath.js\"),\n    isArguments = __webpack_require__(/*! ./isArguments */ \"./node_modules/_lodash@4.17.15@lodash/isArguments.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isIndex = __webpack_require__(/*! ./_isIndex */ \"./node_modules/_lodash@4.17.15@lodash/_isIndex.js\"),\n    isLength = __webpack_require__(/*! ./isLength */ \"./node_modules/_lodash@4.17.15@lodash/isLength.js\"),\n    toKey = __webpack_require__(/*! ./_toKey */ \"./node_modules/_lodash@4.17.15@lodash/_toKey.js\");\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\nmodule.exports = hasPath;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_hasUnicode.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_hasUnicode.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\nmodule.exports = hasUnicode;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_hashClear.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_hashClear.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"./node_modules/_lodash@4.17.15@lodash/_nativeCreate.js\");\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_hashDelete.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_hashDelete.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_hashGet.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_hashGet.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"./node_modules/_lodash@4.17.15@lodash/_nativeCreate.js\");\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_hashHas.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_hashHas.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"./node_modules/_lodash@4.17.15@lodash/_nativeCreate.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_hashSet.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_hashSet.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar nativeCreate = __webpack_require__(/*! ./_nativeCreate */ \"./node_modules/_lodash@4.17.15@lodash/_nativeCreate.js\");\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_initCloneArray.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_initCloneArray.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\nmodule.exports = initCloneArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_initCloneByTag.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_initCloneByTag.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ \"./node_modules/_lodash@4.17.15@lodash/_cloneArrayBuffer.js\"),\n    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ \"./node_modules/_lodash@4.17.15@lodash/_cloneDataView.js\"),\n    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ \"./node_modules/_lodash@4.17.15@lodash/_cloneRegExp.js\"),\n    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ \"./node_modules/_lodash@4.17.15@lodash/_cloneSymbol.js\"),\n    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/_cloneTypedArray.js\");\n\n/** `Object#toString` result references. */\nvar boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\nmodule.exports = initCloneByTag;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_initCloneObject.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_initCloneObject.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseCreate = __webpack_require__(/*! ./_baseCreate */ \"./node_modules/_lodash@4.17.15@lodash/_baseCreate.js\"),\n    getPrototype = __webpack_require__(/*! ./_getPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_getPrototype.js\"),\n    isPrototype = __webpack_require__(/*! ./_isPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_isPrototype.js\");\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\nmodule.exports = initCloneObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isFlattenable.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isFlattenable.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/_lodash@4.17.15@lodash/_Symbol.js\"),\n    isArguments = __webpack_require__(/*! ./isArguments */ \"./node_modules/_lodash@4.17.15@lodash/isArguments.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\");\n\n/** Built-in value references. */\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\nmodule.exports = isFlattenable;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isIndex.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isIndex.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\nmodule.exports = isIndex;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isIterateeCall.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isIterateeCall.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar eq = __webpack_require__(/*! ./eq */ \"./node_modules/_lodash@4.17.15@lodash/eq.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\"),\n    isIndex = __webpack_require__(/*! ./_isIndex */ \"./node_modules/_lodash@4.17.15@lodash/_isIndex.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\");\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isKey.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isKey.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/_lodash@4.17.15@lodash/isSymbol.js\");\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isKeyable.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isKeyable.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isMasked.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isMasked.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar coreJsData = __webpack_require__(/*! ./_coreJsData */ \"./node_modules/_lodash@4.17.15@lodash/_coreJsData.js\");\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isPrototype.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isPrototype.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\nmodule.exports = isPrototype;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_isStrictComparable.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_isStrictComparable.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\");\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\nmodule.exports = isStrictComparable;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_listCacheClear.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_listCacheClear.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_listCacheDelete.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_listCacheDelete.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"./node_modules/_lodash@4.17.15@lodash/_assocIndexOf.js\");\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_listCacheGet.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_listCacheGet.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"./node_modules/_lodash@4.17.15@lodash/_assocIndexOf.js\");\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_listCacheHas.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_listCacheHas.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"./node_modules/_lodash@4.17.15@lodash/_assocIndexOf.js\");\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_listCacheSet.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_listCacheSet.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ \"./node_modules/_lodash@4.17.15@lodash/_assocIndexOf.js\");\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheClear.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_mapCacheClear.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Hash = __webpack_require__(/*! ./_Hash */ \"./node_modules/_lodash@4.17.15@lodash/_Hash.js\"),\n    ListCache = __webpack_require__(/*! ./_ListCache */ \"./node_modules/_lodash@4.17.15@lodash/_ListCache.js\"),\n    Map = __webpack_require__(/*! ./_Map */ \"./node_modules/_lodash@4.17.15@lodash/_Map.js\");\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheDelete.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_mapCacheDelete.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getMapData = __webpack_require__(/*! ./_getMapData */ \"./node_modules/_lodash@4.17.15@lodash/_getMapData.js\");\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheGet.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_mapCacheGet.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getMapData = __webpack_require__(/*! ./_getMapData */ \"./node_modules/_lodash@4.17.15@lodash/_getMapData.js\");\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheHas.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_mapCacheHas.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getMapData = __webpack_require__(/*! ./_getMapData */ \"./node_modules/_lodash@4.17.15@lodash/_getMapData.js\");\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_mapCacheSet.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_mapCacheSet.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getMapData = __webpack_require__(/*! ./_getMapData */ \"./node_modules/_lodash@4.17.15@lodash/_getMapData.js\");\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_mapToArray.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_mapToArray.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\nmodule.exports = mapToArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_matchesStrictComparable.js\":\n/*!*************************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_matchesStrictComparable.js ***!\n  \\*************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\nmodule.exports = matchesStrictComparable;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_memoizeCapped.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_memoizeCapped.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar memoize = __webpack_require__(/*! ./memoize */ \"./node_modules/_lodash@4.17.15@lodash/memoize.js\");\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_nativeCreate.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_nativeCreate.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getNative = __webpack_require__(/*! ./_getNative */ \"./node_modules/_lodash@4.17.15@lodash/_getNative.js\");\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_nativeKeys.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_nativeKeys.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar overArg = __webpack_require__(/*! ./_overArg */ \"./node_modules/_lodash@4.17.15@lodash/_overArg.js\");\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\nmodule.exports = nativeKeys;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_nativeKeysIn.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_nativeKeysIn.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = nativeKeysIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_nodeUtil.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_nodeUtil.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ \"./node_modules/_lodash@4.17.15@lodash/_freeGlobal.js\");\n\n/** Detect free variable `exports`. */\nvar freeExports =   true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\nmodule.exports = nodeUtil;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.42.1@webpack/buildin/module.js */ \"./node_modules/_webpack@4.42.1@webpack/buildin/module.js\")(module)))\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_objectToString.js\":\n/*!****************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_objectToString.js ***!\n  \\****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_overArg.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_overArg.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_overRest.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_overRest.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar apply = __webpack_require__(/*! ./_apply */ \"./node_modules/_lodash@4.17.15@lodash/_apply.js\");\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\nmodule.exports = overRest;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_root.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_root.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar freeGlobal = __webpack_require__(/*! ./_freeGlobal */ \"./node_modules/_lodash@4.17.15@lodash/_freeGlobal.js\");\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_safeGet.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_safeGet.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\nmodule.exports = safeGet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_setCacheAdd.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_setCacheAdd.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\nmodule.exports = setCacheAdd;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_setCacheHas.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_setCacheHas.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\nmodule.exports = setCacheHas;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_setToArray.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_setToArray.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nmodule.exports = setToArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_setToString.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_setToString.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseSetToString = __webpack_require__(/*! ./_baseSetToString */ \"./node_modules/_lodash@4.17.15@lodash/_baseSetToString.js\"),\n    shortOut = __webpack_require__(/*! ./_shortOut */ \"./node_modules/_lodash@4.17.15@lodash/_shortOut.js\");\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\nmodule.exports = setToString;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_shortOut.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_shortOut.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeNow = Date.now;\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\nmodule.exports = shortOut;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_stackClear.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_stackClear.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ListCache = __webpack_require__(/*! ./_ListCache */ \"./node_modules/_lodash@4.17.15@lodash/_ListCache.js\");\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\nmodule.exports = stackClear;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_stackDelete.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_stackDelete.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\nmodule.exports = stackDelete;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_stackGet.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_stackGet.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\nmodule.exports = stackGet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_stackHas.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_stackHas.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\nmodule.exports = stackHas;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_stackSet.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_stackSet.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar ListCache = __webpack_require__(/*! ./_ListCache */ \"./node_modules/_lodash@4.17.15@lodash/_ListCache.js\"),\n    Map = __webpack_require__(/*! ./_Map */ \"./node_modules/_lodash@4.17.15@lodash/_Map.js\"),\n    MapCache = __webpack_require__(/*! ./_MapCache */ \"./node_modules/_lodash@4.17.15@lodash/_MapCache.js\");\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\nmodule.exports = stackSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_strictIndexOf.js\":\n/*!***************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_strictIndexOf.js ***!\n  \\***************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = strictIndexOf;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_stringSize.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_stringSize.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar asciiSize = __webpack_require__(/*! ./_asciiSize */ \"./node_modules/_lodash@4.17.15@lodash/_asciiSize.js\"),\n    hasUnicode = __webpack_require__(/*! ./_hasUnicode */ \"./node_modules/_lodash@4.17.15@lodash/_hasUnicode.js\"),\n    unicodeSize = __webpack_require__(/*! ./_unicodeSize */ \"./node_modules/_lodash@4.17.15@lodash/_unicodeSize.js\");\n\n/**\n * Gets the number of symbols in `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the string size.\n */\nfunction stringSize(string) {\n  return hasUnicode(string)\n    ? unicodeSize(string)\n    : asciiSize(string);\n}\n\nmodule.exports = stringSize;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_stringToPath.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_stringToPath.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ \"./node_modules/_lodash@4.17.15@lodash/_memoizeCapped.js\");\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_toKey.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_toKey.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/_lodash@4.17.15@lodash/isSymbol.js\");\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_toSource.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_toSource.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/_unicodeSize.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/_unicodeSize.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff',\n    rsComboMarksRange = '\\\\u0300-\\\\u036f',\n    reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n    rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n    rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange + ']',\n    rsCombo = '[' + rsComboRange + ']',\n    rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n    rsNonAstral = '[^' + rsAstralRange + ']',\n    rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n    rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n    rsZWJ = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?',\n    rsOptVar = '[' + rsVarRange + ']?',\n    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n    rsSeq = rsOptVar + reOptMod + rsOptJoin,\n    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Gets the size of a Unicode `string`.\n *\n * @private\n * @param {string} string The string inspect.\n * @returns {number} Returns the string size.\n */\nfunction unicodeSize(string) {\n  var result = reUnicode.lastIndex = 0;\n  while (reUnicode.test(string)) {\n    ++result;\n  }\n  return result;\n}\n\nmodule.exports = unicodeSize;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/clone.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/clone.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseClone = __webpack_require__(/*! ./_baseClone */ \"./node_modules/_lodash@4.17.15@lodash/_baseClone.js\");\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = clone;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/cloneDeep.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/cloneDeep.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseClone = __webpack_require__(/*! ./_baseClone */ \"./node_modules/_lodash@4.17.15@lodash/_baseClone.js\");\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\nmodule.exports = cloneDeep;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/constant.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/constant.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\nmodule.exports = constant;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/defaults.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/defaults.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseRest = __webpack_require__(/*! ./_baseRest */ \"./node_modules/_lodash@4.17.15@lodash/_baseRest.js\"),\n    eq = __webpack_require__(/*! ./eq */ \"./node_modules/_lodash@4.17.15@lodash/eq.js\"),\n    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ \"./node_modules/_lodash@4.17.15@lodash/_isIterateeCall.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/_lodash@4.17.15@lodash/keysIn.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar defaults = baseRest(function(object, sources) {\n  object = Object(object);\n\n  var index = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : undefined;\n\n  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n\n  while (++index < length) {\n    var source = sources[index];\n    var props = keysIn(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n\n      if (value === undefined ||\n          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        object[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n});\n\nmodule.exports = defaults;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/each.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/each.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(/*! ./forEach */ \"./node_modules/_lodash@4.17.15@lodash/forEach.js\");\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/eq.js\":\n/*!***************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/eq.js ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/filter.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/filter.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayFilter = __webpack_require__(/*! ./_arrayFilter */ \"./node_modules/_lodash@4.17.15@lodash/_arrayFilter.js\"),\n    baseFilter = __webpack_require__(/*! ./_baseFilter */ \"./node_modules/_lodash@4.17.15@lodash/_baseFilter.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\");\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = filter;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/find.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/find.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createFind = __webpack_require__(/*! ./_createFind */ \"./node_modules/_lodash@4.17.15@lodash/_createFind.js\"),\n    findIndex = __webpack_require__(/*! ./findIndex */ \"./node_modules/_lodash@4.17.15@lodash/findIndex.js\");\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\nmodule.exports = find;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/findIndex.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/findIndex.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ \"./node_modules/_lodash@4.17.15@lodash/_baseFindIndex.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    toInteger = __webpack_require__(/*! ./toInteger */ \"./node_modules/_lodash@4.17.15@lodash/toInteger.js\");\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\nmodule.exports = findIndex;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/flatten.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/flatten.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFlatten = __webpack_require__(/*! ./_baseFlatten */ \"./node_modules/_lodash@4.17.15@lodash/_baseFlatten.js\");\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? baseFlatten(array, 1) : [];\n}\n\nmodule.exports = flatten;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/forEach.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/forEach.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayEach = __webpack_require__(/*! ./_arrayEach */ \"./node_modules/_lodash@4.17.15@lodash/_arrayEach.js\"),\n    baseEach = __webpack_require__(/*! ./_baseEach */ \"./node_modules/_lodash@4.17.15@lodash/_baseEach.js\"),\n    castFunction = __webpack_require__(/*! ./_castFunction */ \"./node_modules/_lodash@4.17.15@lodash/_castFunction.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\");\n\n/**\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\n * The iteratee is invoked with three arguments: (value, index|key, collection).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\n * or `_.forOwn` for object iteration.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias each\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n * @see _.forEachRight\n * @example\n *\n * _.forEach([1, 2], function(value) {\n *   console.log(value);\n * });\n * // => Logs `1` then `2`.\n *\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n */\nfunction forEach(collection, iteratee) {\n  var func = isArray(collection) ? arrayEach : baseEach;\n  return func(collection, castFunction(iteratee));\n}\n\nmodule.exports = forEach;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/forIn.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/forIn.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFor = __webpack_require__(/*! ./_baseFor */ \"./node_modules/_lodash@4.17.15@lodash/_baseFor.js\"),\n    castFunction = __webpack_require__(/*! ./_castFunction */ \"./node_modules/_lodash@4.17.15@lodash/_castFunction.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/_lodash@4.17.15@lodash/keysIn.js\");\n\n/**\n * Iterates over own and inherited enumerable string keyed properties of an\n * object and invokes `iteratee` for each property. The iteratee is invoked\n * with three arguments: (value, key, object). Iteratee functions may exit\n * iteration early by explicitly returning `false`.\n *\n * @static\n * @memberOf _\n * @since 0.3.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns `object`.\n * @see _.forInRight\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.forIn(new Foo, function(value, key) {\n *   console.log(key);\n * });\n * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n */\nfunction forIn(object, iteratee) {\n  return object == null\n    ? object\n    : baseFor(object, castFunction(iteratee), keysIn);\n}\n\nmodule.exports = forIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/get.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/get.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGet = __webpack_require__(/*! ./_baseGet */ \"./node_modules/_lodash@4.17.15@lodash/_baseGet.js\");\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/has.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/has.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseHas = __webpack_require__(/*! ./_baseHas */ \"./node_modules/_lodash@4.17.15@lodash/_baseHas.js\"),\n    hasPath = __webpack_require__(/*! ./_hasPath */ \"./node_modules/_lodash@4.17.15@lodash/_hasPath.js\");\n\n/**\n * Checks if `path` is a direct property of `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = { 'a': { 'b': 2 } };\n * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.has(object, 'a');\n * // => true\n *\n * _.has(object, 'a.b');\n * // => true\n *\n * _.has(object, ['a', 'b']);\n * // => true\n *\n * _.has(other, 'a');\n * // => false\n */\nfunction has(object, path) {\n  return object != null && hasPath(object, path, baseHas);\n}\n\nmodule.exports = has;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/hasIn.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/hasIn.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseHasIn = __webpack_require__(/*! ./_baseHasIn */ \"./node_modules/_lodash@4.17.15@lodash/_baseHasIn.js\"),\n    hasPath = __webpack_require__(/*! ./_hasPath */ \"./node_modules/_lodash@4.17.15@lodash/_hasPath.js\");\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\nmodule.exports = hasIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/identity.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/identity.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isArguments.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isArguments.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsArguments.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\nmodule.exports = isArguments;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isArray.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isArrayLike.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isFunction = __webpack_require__(/*! ./isFunction */ \"./node_modules/_lodash@4.17.15@lodash/isFunction.js\"),\n    isLength = __webpack_require__(/*! ./isLength */ \"./node_modules/_lodash@4.17.15@lodash/isLength.js\");\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\nmodule.exports = isArrayLike;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isArrayLikeObject.js\":\n/*!******************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isArrayLikeObject.js ***!\n  \\******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\nmodule.exports = isArrayLikeObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isBuffer.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isBuffer.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(module) {var root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\"),\n    stubFalse = __webpack_require__(/*! ./stubFalse */ \"./node_modules/_lodash@4.17.15@lodash/stubFalse.js\");\n\n/** Detect free variable `exports`. */\nvar freeExports =   true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\nmodule.exports = isBuffer;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.42.1@webpack/buildin/module.js */ \"./node_modules/_webpack@4.42.1@webpack/buildin/module.js\")(module)))\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isEmpty.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isEmpty.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseKeys = __webpack_require__(/*! ./_baseKeys */ \"./node_modules/_lodash@4.17.15@lodash/_baseKeys.js\"),\n    getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/_lodash@4.17.15@lodash/_getTag.js\"),\n    isArguments = __webpack_require__(/*! ./isArguments */ \"./node_modules/_lodash@4.17.15@lodash/isArguments.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/_lodash@4.17.15@lodash/isBuffer.js\"),\n    isPrototype = __webpack_require__(/*! ./_isPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_isPrototype.js\"),\n    isTypedArray = __webpack_require__(/*! ./isTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/isTypedArray.js\");\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if `value` is an empty object, collection, map, or set.\n *\n * Objects are considered empty if they have no own enumerable string keyed\n * properties.\n *\n * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n * jQuery-like collections are considered empty if they have a `length` of `0`.\n * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n * @example\n *\n * _.isEmpty(null);\n * // => true\n *\n * _.isEmpty(true);\n * // => true\n *\n * _.isEmpty(1);\n * // => true\n *\n * _.isEmpty([1, 2, 3]);\n * // => false\n *\n * _.isEmpty({ 'a': 1 });\n * // => false\n */\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  if (isArrayLike(value) &&\n      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n        isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n    return !value.length;\n  }\n  var tag = getTag(value);\n  if (tag == mapTag || tag == setTag) {\n    return !value.size;\n  }\n  if (isPrototype(value)) {\n    return !baseKeys(value).length;\n  }\n  for (var key in value) {\n    if (hasOwnProperty.call(value, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = isEmpty;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isFunction.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isFunction.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\");\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isLength.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isLength.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isMap.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isMap.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsMap = __webpack_require__(/*! ./_baseIsMap */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsMap.js\"),\n    baseUnary = __webpack_require__(/*! ./_baseUnary */ \"./node_modules/_lodash@4.17.15@lodash/_baseUnary.js\"),\n    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ \"./node_modules/_lodash@4.17.15@lodash/_nodeUtil.js\");\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\nmodule.exports = isMap;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isObject.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isObjectLike.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isPlainObject.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isPlainObject.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\"),\n    getPrototype = __webpack_require__(/*! ./_getPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_getPrototype.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isSet.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isSet.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsSet = __webpack_require__(/*! ./_baseIsSet */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsSet.js\"),\n    baseUnary = __webpack_require__(/*! ./_baseUnary */ \"./node_modules/_lodash@4.17.15@lodash/_baseUnary.js\"),\n    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ \"./node_modules/_lodash@4.17.15@lodash/_nodeUtil.js\");\n\n/* Node.js helper references. */\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\nmodule.exports = isSet;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isString.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isString.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n}\n\nmodule.exports = isString;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isSymbol.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isSymbol.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/_lodash@4.17.15@lodash/_baseGetTag.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/_lodash@4.17.15@lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isTypedArray.js\":\n/*!*************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isTypedArray.js ***!\n  \\*************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/_baseIsTypedArray.js\"),\n    baseUnary = __webpack_require__(/*! ./_baseUnary */ \"./node_modules/_lodash@4.17.15@lodash/_baseUnary.js\"),\n    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ \"./node_modules/_lodash@4.17.15@lodash/_nodeUtil.js\");\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\nmodule.exports = isTypedArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/isUndefined.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/isUndefined.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Checks if `value` is `undefined`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n * @example\n *\n * _.isUndefined(void 0);\n * // => true\n *\n * _.isUndefined(null);\n * // => false\n */\nfunction isUndefined(value) {\n  return value === undefined;\n}\n\nmodule.exports = isUndefined;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/keys.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/keys.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ \"./node_modules/_lodash@4.17.15@lodash/_arrayLikeKeys.js\"),\n    baseKeys = __webpack_require__(/*! ./_baseKeys */ \"./node_modules/_lodash@4.17.15@lodash/_baseKeys.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\");\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nmodule.exports = keys;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/keysIn.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/keysIn.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ \"./node_modules/_lodash@4.17.15@lodash/_arrayLikeKeys.js\"),\n    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ \"./node_modules/_lodash@4.17.15@lodash/_baseKeysIn.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\");\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = keysIn;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/last.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/last.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\nmodule.exports = last;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/map.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/map.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayMap = __webpack_require__(/*! ./_arrayMap */ \"./node_modules/_lodash@4.17.15@lodash/_arrayMap.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    baseMap = __webpack_require__(/*! ./_baseMap */ \"./node_modules/_lodash@4.17.15@lodash/_baseMap.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\");\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = isArray(collection) ? arrayMap : baseMap;\n  return func(collection, baseIteratee(iteratee, 3));\n}\n\nmodule.exports = map;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/mapValues.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/mapValues.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ \"./node_modules/_lodash@4.17.15@lodash/_baseAssignValue.js\"),\n    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ \"./node_modules/_lodash@4.17.15@lodash/_baseForOwn.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\");\n\n/**\n * Creates an object with the same keys as `object` and values generated\n * by running each own enumerable string keyed property of `object` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapKeys\n * @example\n *\n * var users = {\n *   'fred':    { 'user': 'fred',    'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n *\n * _.mapValues(users, function(o) { return o.age; });\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n *\n * // The `_.property` iteratee shorthand.\n * _.mapValues(users, 'age');\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n */\nfunction mapValues(object, iteratee) {\n  var result = {};\n  iteratee = baseIteratee(iteratee, 3);\n\n  baseForOwn(object, function(value, key, object) {\n    baseAssignValue(result, key, iteratee(value, key, object));\n  });\n  return result;\n}\n\nmodule.exports = mapValues;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/max.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/max.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseExtremum = __webpack_require__(/*! ./_baseExtremum */ \"./node_modules/_lodash@4.17.15@lodash/_baseExtremum.js\"),\n    baseGt = __webpack_require__(/*! ./_baseGt */ \"./node_modules/_lodash@4.17.15@lodash/_baseGt.js\"),\n    identity = __webpack_require__(/*! ./identity */ \"./node_modules/_lodash@4.17.15@lodash/identity.js\");\n\n/**\n * Computes the maximum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the maximum value.\n * @example\n *\n * _.max([4, 2, 8, 6]);\n * // => 8\n *\n * _.max([]);\n * // => undefined\n */\nfunction max(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseGt)\n    : undefined;\n}\n\nmodule.exports = max;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/memoize.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/memoize.js ***!\n  \\********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar MapCache = __webpack_require__(/*! ./_MapCache */ \"./node_modules/_lodash@4.17.15@lodash/_MapCache.js\");\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/merge.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/merge.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseMerge = __webpack_require__(/*! ./_baseMerge */ \"./node_modules/_lodash@4.17.15@lodash/_baseMerge.js\"),\n    createAssigner = __webpack_require__(/*! ./_createAssigner */ \"./node_modules/_lodash@4.17.15@lodash/_createAssigner.js\");\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\nmodule.exports = merge;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/min.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/min.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseExtremum = __webpack_require__(/*! ./_baseExtremum */ \"./node_modules/_lodash@4.17.15@lodash/_baseExtremum.js\"),\n    baseLt = __webpack_require__(/*! ./_baseLt */ \"./node_modules/_lodash@4.17.15@lodash/_baseLt.js\"),\n    identity = __webpack_require__(/*! ./identity */ \"./node_modules/_lodash@4.17.15@lodash/identity.js\");\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? baseExtremum(array, identity, baseLt)\n    : undefined;\n}\n\nmodule.exports = min;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/minBy.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/minBy.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseExtremum = __webpack_require__(/*! ./_baseExtremum */ \"./node_modules/_lodash@4.17.15@lodash/_baseExtremum.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    baseLt = __webpack_require__(/*! ./_baseLt */ \"./node_modules/_lodash@4.17.15@lodash/_baseLt.js\");\n\n/**\n * This method is like `_.min` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * the value is ranked. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Math\n * @param {Array} array The array to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * var objects = [{ 'n': 1 }, { 'n': 2 }];\n *\n * _.minBy(objects, function(o) { return o.n; });\n * // => { 'n': 1 }\n *\n * // The `_.property` iteratee shorthand.\n * _.minBy(objects, 'n');\n * // => { 'n': 1 }\n */\nfunction minBy(array, iteratee) {\n  return (array && array.length)\n    ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt)\n    : undefined;\n}\n\nmodule.exports = minBy;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/noop.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/noop.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nmodule.exports = noop;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/now.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/now.js ***!\n  \\****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar root = __webpack_require__(/*! ./_root */ \"./node_modules/_lodash@4.17.15@lodash/_root.js\");\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/pick.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/pick.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar basePick = __webpack_require__(/*! ./_basePick */ \"./node_modules/_lodash@4.17.15@lodash/_basePick.js\"),\n    flatRest = __webpack_require__(/*! ./_flatRest */ \"./node_modules/_lodash@4.17.15@lodash/_flatRest.js\");\n\n/**\n * Creates an object composed of the picked `object` properties.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The source object.\n * @param {...(string|string[])} [paths] The property paths to pick.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\n *\n * _.pick(object, ['a', 'c']);\n * // => { 'a': 1, 'c': 3 }\n */\nvar pick = flatRest(function(object, paths) {\n  return object == null ? {} : basePick(object, paths);\n});\n\nmodule.exports = pick;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/property.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/property.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseProperty = __webpack_require__(/*! ./_baseProperty */ \"./node_modules/_lodash@4.17.15@lodash/_baseProperty.js\"),\n    basePropertyDeep = __webpack_require__(/*! ./_basePropertyDeep */ \"./node_modules/_lodash@4.17.15@lodash/_basePropertyDeep.js\"),\n    isKey = __webpack_require__(/*! ./_isKey */ \"./node_modules/_lodash@4.17.15@lodash/_isKey.js\"),\n    toKey = __webpack_require__(/*! ./_toKey */ \"./node_modules/_lodash@4.17.15@lodash/_toKey.js\");\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = property;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/range.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/range.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar createRange = __webpack_require__(/*! ./_createRange */ \"./node_modules/_lodash@4.17.15@lodash/_createRange.js\");\n\n/**\n * Creates an array of numbers (positive and/or negative) progressing from\n * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n * `start` is specified without an `end` or `step`. If `end` is not specified,\n * it's set to `start` with `start` then set to `0`.\n *\n * **Note:** JavaScript follows the IEEE-754 standard for resolving\n * floating-point values which can produce unexpected results.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {number} [start=0] The start of the range.\n * @param {number} end The end of the range.\n * @param {number} [step=1] The value to increment or decrement by.\n * @returns {Array} Returns the range of numbers.\n * @see _.inRange, _.rangeRight\n * @example\n *\n * _.range(4);\n * // => [0, 1, 2, 3]\n *\n * _.range(-4);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 5);\n * // => [1, 2, 3, 4]\n *\n * _.range(0, 20, 5);\n * // => [0, 5, 10, 15]\n *\n * _.range(0, -4, -1);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 4, 0);\n * // => [1, 1, 1]\n *\n * _.range(0);\n * // => []\n */\nvar range = createRange();\n\nmodule.exports = range;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/reduce.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/reduce.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayReduce = __webpack_require__(/*! ./_arrayReduce */ \"./node_modules/_lodash@4.17.15@lodash/_arrayReduce.js\"),\n    baseEach = __webpack_require__(/*! ./_baseEach */ \"./node_modules/_lodash@4.17.15@lodash/_baseEach.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    baseReduce = __webpack_require__(/*! ./_baseReduce */ \"./node_modules/_lodash@4.17.15@lodash/_baseReduce.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\");\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */\nfunction reduce(collection, iteratee, accumulator) {\n  var func = isArray(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3;\n\n  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n}\n\nmodule.exports = reduce;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/size.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/size.js ***!\n  \\*****************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseKeys = __webpack_require__(/*! ./_baseKeys */ \"./node_modules/_lodash@4.17.15@lodash/_baseKeys.js\"),\n    getTag = __webpack_require__(/*! ./_getTag */ \"./node_modules/_lodash@4.17.15@lodash/_getTag.js\"),\n    isArrayLike = __webpack_require__(/*! ./isArrayLike */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLike.js\"),\n    isString = __webpack_require__(/*! ./isString */ \"./node_modules/_lodash@4.17.15@lodash/isString.js\"),\n    stringSize = __webpack_require__(/*! ./_stringSize */ \"./node_modules/_lodash@4.17.15@lodash/_stringSize.js\");\n\n/** `Object#toString` result references. */\nvar mapTag = '[object Map]',\n    setTag = '[object Set]';\n\n/**\n * Gets the size of `collection` by returning its length for array-like\n * values or the number of own enumerable string keyed properties for objects.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @returns {number} Returns the collection size.\n * @example\n *\n * _.size([1, 2, 3]);\n * // => 3\n *\n * _.size({ 'a': 1, 'b': 2 });\n * // => 2\n *\n * _.size('pebbles');\n * // => 7\n */\nfunction size(collection) {\n  if (collection == null) {\n    return 0;\n  }\n  if (isArrayLike(collection)) {\n    return isString(collection) ? stringSize(collection) : collection.length;\n  }\n  var tag = getTag(collection);\n  if (tag == mapTag || tag == setTag) {\n    return collection.size;\n  }\n  return baseKeys(collection).length;\n}\n\nmodule.exports = size;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/sortBy.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/sortBy.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFlatten = __webpack_require__(/*! ./_baseFlatten */ \"./node_modules/_lodash@4.17.15@lodash/_baseFlatten.js\"),\n    baseOrderBy = __webpack_require__(/*! ./_baseOrderBy */ \"./node_modules/_lodash@4.17.15@lodash/_baseOrderBy.js\"),\n    baseRest = __webpack_require__(/*! ./_baseRest */ \"./node_modules/_lodash@4.17.15@lodash/_baseRest.js\"),\n    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ \"./node_modules/_lodash@4.17.15@lodash/_isIterateeCall.js\");\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\nmodule.exports = sortBy;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/stubArray.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/stubArray.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\nmodule.exports = stubArray;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/stubFalse.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/stubFalse.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = stubFalse;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/toFinite.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/toFinite.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toNumber = __webpack_require__(/*! ./toNumber */ \"./node_modules/_lodash@4.17.15@lodash/toNumber.js\");\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\nmodule.exports = toFinite;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/toInteger.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/toInteger.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toFinite = __webpack_require__(/*! ./toFinite */ \"./node_modules/_lodash@4.17.15@lodash/toFinite.js\");\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\nmodule.exports = toInteger;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/toNumber.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/toNumber.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    isSymbol = __webpack_require__(/*! ./isSymbol */ \"./node_modules/_lodash@4.17.15@lodash/isSymbol.js\");\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/toPlainObject.js\":\n/*!**************************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/toPlainObject.js ***!\n  \\**************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar copyObject = __webpack_require__(/*! ./_copyObject */ \"./node_modules/_lodash@4.17.15@lodash/_copyObject.js\"),\n    keysIn = __webpack_require__(/*! ./keysIn */ \"./node_modules/_lodash@4.17.15@lodash/keysIn.js\");\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\nmodule.exports = toPlainObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/toString.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/toString.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseToString = __webpack_require__(/*! ./_baseToString */ \"./node_modules/_lodash@4.17.15@lodash/_baseToString.js\");\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/transform.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/transform.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar arrayEach = __webpack_require__(/*! ./_arrayEach */ \"./node_modules/_lodash@4.17.15@lodash/_arrayEach.js\"),\n    baseCreate = __webpack_require__(/*! ./_baseCreate */ \"./node_modules/_lodash@4.17.15@lodash/_baseCreate.js\"),\n    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ \"./node_modules/_lodash@4.17.15@lodash/_baseForOwn.js\"),\n    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ \"./node_modules/_lodash@4.17.15@lodash/_baseIteratee.js\"),\n    getPrototype = __webpack_require__(/*! ./_getPrototype */ \"./node_modules/_lodash@4.17.15@lodash/_getPrototype.js\"),\n    isArray = __webpack_require__(/*! ./isArray */ \"./node_modules/_lodash@4.17.15@lodash/isArray.js\"),\n    isBuffer = __webpack_require__(/*! ./isBuffer */ \"./node_modules/_lodash@4.17.15@lodash/isBuffer.js\"),\n    isFunction = __webpack_require__(/*! ./isFunction */ \"./node_modules/_lodash@4.17.15@lodash/isFunction.js\"),\n    isObject = __webpack_require__(/*! ./isObject */ \"./node_modules/_lodash@4.17.15@lodash/isObject.js\"),\n    isTypedArray = __webpack_require__(/*! ./isTypedArray */ \"./node_modules/_lodash@4.17.15@lodash/isTypedArray.js\");\n\n/**\n * An alternative to `_.reduce`; this method transforms `object` to a new\n * `accumulator` object which is the result of running each of its own\n * enumerable string keyed properties thru `iteratee`, with each invocation\n * potentially mutating the `accumulator` object. If `accumulator` is not\n * provided, a new object with the same `[[Prototype]]` will be used. The\n * iteratee is invoked with four arguments: (accumulator, value, key, object).\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @static\n * @memberOf _\n * @since 1.3.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The custom accumulator value.\n * @returns {*} Returns the accumulated value.\n * @example\n *\n * _.transform([2, 3, 4], function(result, n) {\n *   result.push(n *= n);\n *   return n % 2 == 0;\n * }, []);\n * // => [4, 9]\n *\n * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] }\n */\nfunction transform(object, iteratee, accumulator) {\n  var isArr = isArray(object),\n      isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n  iteratee = baseIteratee(iteratee, 4);\n  if (accumulator == null) {\n    var Ctor = object && object.constructor;\n    if (isArrLike) {\n      accumulator = isArr ? new Ctor : [];\n    }\n    else if (isObject(object)) {\n      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n    }\n    else {\n      accumulator = {};\n    }\n  }\n  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n    return iteratee(accumulator, value, index, object);\n  });\n  return accumulator;\n}\n\nmodule.exports = transform;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/union.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/union.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseFlatten = __webpack_require__(/*! ./_baseFlatten */ \"./node_modules/_lodash@4.17.15@lodash/_baseFlatten.js\"),\n    baseRest = __webpack_require__(/*! ./_baseRest */ \"./node_modules/_lodash@4.17.15@lodash/_baseRest.js\"),\n    baseUniq = __webpack_require__(/*! ./_baseUniq */ \"./node_modules/_lodash@4.17.15@lodash/_baseUniq.js\"),\n    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ \"./node_modules/_lodash@4.17.15@lodash/isArrayLikeObject.js\");\n\n/**\n * Creates an array of unique values, in order, from all given arrays using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of combined values.\n * @example\n *\n * _.union([2], [1, 2]);\n * // => [2, 1]\n */\nvar union = baseRest(function(arrays) {\n  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n});\n\nmodule.exports = union;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/uniqueId.js\":\n/*!*********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/uniqueId.js ***!\n  \\*********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toString = __webpack_require__(/*! ./toString */ \"./node_modules/_lodash@4.17.15@lodash/toString.js\");\n\n/** Used to generate unique IDs. */\nvar idCounter = 0;\n\n/**\n * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {string} [prefix=''] The value to prefix the ID with.\n * @returns {string} Returns the unique ID.\n * @example\n *\n * _.uniqueId('contact_');\n * // => 'contact_104'\n *\n * _.uniqueId();\n * // => '105'\n */\nfunction uniqueId(prefix) {\n  var id = ++idCounter;\n  return toString(prefix) + id;\n}\n\nmodule.exports = uniqueId;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/values.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/values.js ***!\n  \\*******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar baseValues = __webpack_require__(/*! ./_baseValues */ \"./node_modules/_lodash@4.17.15@lodash/_baseValues.js\"),\n    keys = __webpack_require__(/*! ./keys */ \"./node_modules/_lodash@4.17.15@lodash/keys.js\");\n\n/**\n * Creates an array of the own enumerable string keyed property values of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property values.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.values(new Foo);\n * // => [1, 2] (iteration order is not guaranteed)\n *\n * _.values('hi');\n * // => ['h', 'i']\n */\nfunction values(object) {\n  return object == null ? [] : baseValues(object, keys(object));\n}\n\nmodule.exports = values;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_lodash@4.17.15@lodash/zipObject.js\":\n/*!**********************************************************!*\\\n  !*** ./node_modules/_lodash@4.17.15@lodash/zipObject.js ***!\n  \\**********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar assignValue = __webpack_require__(/*! ./_assignValue */ \"./node_modules/_lodash@4.17.15@lodash/_assignValue.js\"),\n    baseZipObject = __webpack_require__(/*! ./_baseZipObject */ \"./node_modules/_lodash@4.17.15@lodash/_baseZipObject.js\");\n\n/**\n * This method is like `_.fromPairs` except that it accepts two arrays,\n * one of property identifiers and one of corresponding values.\n *\n * @static\n * @memberOf _\n * @since 0.4.0\n * @category Array\n * @param {Array} [props=[]] The property identifiers.\n * @param {Array} [values=[]] The property values.\n * @returns {Object} Returns the new object.\n * @example\n *\n * _.zipObject(['a', 'b'], [1, 2]);\n * // => { 'a': 1, 'b': 2 }\n */\nfunction zipObject(props, values) {\n  return baseZipObject(props || [], values || [], assignValue);\n}\n\nmodule.exports = zipObject;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_parse-svg-path@0.1.2@parse-svg-path/index.js\":\n/*!********************************************************************!*\\\n  !*** ./node_modules/_parse-svg-path@0.1.2@parse-svg-path/index.js ***!\n  \\********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/_point-at-length@1.1.0@point-at-length/index.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_point-at-length@1.1.0@point-at-length/index.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar parse = __webpack_require__(/*! parse-svg-path */ \"./node_modules/_parse-svg-path@0.1.2@parse-svg-path/index.js\");\r\nvar isarray = __webpack_require__(/*! isarray */ \"./node_modules/_isarray@0.0.1@isarray/index.js\");\r\nvar abs = __webpack_require__(/*! abs-svg-path */ \"./node_modules/_abs-svg-path@0.1.1@abs-svg-path/index.js\");\r\n\r\nmodule.exports = Points;\r\n\r\nfunction Points (path) {\r\n    if (!(this instanceof Points)) return new Points(path);\r\n    this._path = isarray(path) ? path : parse(path);\r\n    this._path = abs(this._path);\r\n    this._path = zvhToL(this._path);\r\n    this._path = longhand(this._path);\r\n}\r\n\r\nPoints.prototype.at = function (pos, opts) {\r\n    return this._walk(pos, opts).pos;\r\n};\r\n\r\nPoints.prototype.length = function () {\r\n    return this._walk(null).length;\r\n};\r\n\r\nPoints.prototype._walk = function (pos, opts) {\r\n    var cur = [ 0, 0 ];\r\n    var prev = [ 0, 0, 0 ];\r\n    var p0 = [ 0, 0 ];\r\n    var len = 0;\r\n\r\n    for (var i = 0; i < this._path.length; i++) {\r\n        var p = this._path[i];\r\n        if (p[0] === 'M') {\r\n            cur[0] = p[1];\r\n            cur[1] = p[2];\r\n            if (pos === 0) {\r\n                return { length: len, pos: cur };\r\n            }\r\n        }\r\n        else if (p[0] === 'C') {\r\n            prev[0] = p0[0] = cur[0];\r\n            prev[1] = p0[1] = cur[1];\r\n            prev[2] = len;\r\n\r\n            var n = 100;\r\n            for (var j = 0; j <= n; j++) {\r\n                var t = j / n;\r\n                var x = xof_C(p, t);\r\n                var y = yof_C(p, t);\r\n                len += dist(cur[0], cur[1], x, y);\r\n\r\n                cur[0] = x;\r\n                cur[1] = y;\r\n\r\n                if (typeof pos === 'number' && len >= pos) {\r\n                    var dv = (len - pos) / (len - prev[2]);\r\n\r\n                    var npos = [\r\n                        cur[0] * (1 - dv) + prev[0] * dv,\r\n                        cur[1] * (1 - dv) + prev[1] * dv\r\n                    ];\r\n                    return { length: len, pos: npos };\r\n                }\r\n                prev[0] = cur[0];\r\n                prev[1] = cur[1];\r\n                prev[2] = len;\r\n            }\r\n        }\r\n        else if (p[0] === 'Q') {\r\n            prev[0] = p0[0] = cur[0];\r\n            prev[1] = p0[1] = cur[1];\r\n            prev[2] = len;\r\n\r\n            var n = 100;\r\n            for (var j = 0; j <= n; j++) {\r\n                var t = j / n;\r\n                var x = xof_Q(p, t);\r\n                var y = yof_Q(p, t);\r\n                len += dist(cur[0], cur[1], x, y);\r\n\r\n                cur[0] = x;\r\n                cur[1] = y;\r\n\r\n                if (typeof pos === 'number' && len >= pos) {\r\n                    var dv = (len - pos) / (len - prev[2]);\r\n\r\n                    var npos = [\r\n                        cur[0] * (1 - dv) + prev[0] * dv,\r\n                        cur[1] * (1 - dv) + prev[1] * dv\r\n                    ];\r\n                    return { length: len, pos: npos };\r\n                }\r\n                prev[0] = cur[0];\r\n                prev[1] = cur[1];\r\n                prev[2] = len;\r\n            }\r\n        }\r\n        else if (p[0] === 'L') {\r\n            prev[0] = cur[0];\r\n            prev[1] = cur[1];\r\n            prev[2] = len;\r\n\r\n            len   += dist(cur[0], cur[1], p[1], p[2]);\r\n            cur[0] = p[1];\r\n            cur[1] = p[2];\r\n\r\n            if (typeof pos === 'number' && len >= pos) {\r\n                var dv = (len - pos) / (len - prev[2]);\r\n                var npos = [\r\n                    cur[0] * (1 - dv) + prev[0] * dv,\r\n                    cur[1] * (1 - dv) + prev[1] * dv\r\n                ];\r\n                return { length: len, pos: npos };\r\n            }\r\n            prev[0] = cur[0];\r\n            prev[1] = cur[1];\r\n            prev[2] = len;\r\n        }\r\n    }\r\n\r\n    return { length: len, pos: cur };\r\n    function xof_C (p, t) {\r\n        return Math.pow((1-t), 3) * p0[0]\r\n            + 3 * Math.pow((1-t), 2) * t * p[1]\r\n            + 3 * (1-t) * Math.pow(t, 2) * p[3]\r\n            + Math.pow(t, 3) * p[5]\r\n        ;\r\n    }\r\n    function yof_C (p, t) {\r\n        return Math.pow((1-t), 3) * p0[1]\r\n            + 3 * Math.pow((1-t), 2) * t * p[2]\r\n            + 3 * (1-t) * Math.pow(t, 2) * p[4]\r\n            + Math.pow(t, 3) * p[6]\r\n        ;\r\n    }\r\n\r\n    function xof_Q (p, t) {\r\n        return Math.pow((1-t), 2) * p0[0]\r\n            + 2 * (1-t) * t * p[1]\r\n            + Math.pow(t, 2) * p[3]\r\n        ;\r\n    }\r\n    function yof_Q (p, t) {\r\n        return Math.pow((1-t), 2) * p0[1]\r\n            + 2 * (1-t) * t * p[2]\r\n            + Math.pow(t, 2) * p[4]\r\n        ;\r\n    }\r\n};\r\n\r\nfunction dist (ax, ay, bx, by) {\r\n    var x = ax - bx;\r\n    var y = ay - by;\r\n    return Math.sqrt(x*x + y*y);\r\n}\r\n\r\n// Expand shorthand curve commands to full versions; mutates the path in place for efficiency\r\n// Requires commands have already been converted to absolute versions\r\nfunction longhand(path){\r\n    var prev,x1=0,y1=0;\r\n    var conversion = { S:{to:'C',x:3}, T:{to:'Q',x:1} };\r\n    for(var i=0, len=path.length; i<len; i++){\r\n        var cmd = path[i];\r\n        var convert = conversion[cmd[0]];\r\n\r\n        if (convert) {\r\n            cmd[0] = convert.to;\r\n            if (prev) {\r\n                if (prev[0] === convert.to) {\r\n                    x1 = 2*prev[convert.x+2]-prev[convert.x  ];\r\n                    y1 = 2*prev[convert.x+3]-prev[convert.x+1];\r\n                } else {\r\n                    x1 = prev[prev.length-2];\r\n                    y1 = prev[prev.length-1];\r\n                }\r\n            }\r\n            cmd.splice(1,0,x1,y1);\r\n        }\r\n        prev=cmd;\r\n    }\r\n    return path;\r\n}\r\n\r\n// Convert 'Z', 'V' and 'H' segments to 'L' segments\r\nfunction zvhToL(path){\r\n    var ret = [];\r\n    var startPoint = ['L',0,0];\r\n    var last_point;\r\n\r\n    for(var i=0, len=path.length; i<len; i++){\r\n        var pt = path[i];\r\n        switch(pt[0]){\r\n            case 'M':\r\n                startPoint = ['L', pt[1], pt[2]];\r\n                ret.push(pt);\r\n                break;\r\n            case 'Z':\r\n                ret.push(startPoint);\r\n                break;\r\n            case 'H':\r\n                last_point = ret[ret.length - 1] || ['L',0,0];\r\n                ret.push( ['L', pt[1], last_point[last_point.length - 1]] );\r\n                break;\r\n            case 'V':\r\n                last_point = ret[ret.length - 1] || ['L',0,0];\r\n                ret.push( ['L', last_point[last_point.length - 2], pt[1]] );\r\n                break;\r\n            default:\r\n                ret.push(pt);\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\n\n/***/ }),\n\n/***/ \"./node_modules/_regression@2.0.1@regression/dist/regression.js\":\n/*!**********************************************************************!*\\\n  !*** ./node_modules/_regression@2.0.1@regression/dist/regression.js ***!\n  \\**********************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var mod; }\n})(this, function (module) {\n  'use strict';\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  function _toConsumableArray(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n        arr2[i] = arr[i];\n      }\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  }\n\n  var DEFAULT_OPTIONS = { order: 2, precision: 2, period: null };\n\n  /**\n  * Determine the coefficient of determination (r^2) of a fit from the observations\n  * and predictions.\n  *\n  * @param {Array<Array<number>>} data - Pairs of observed x-y values\n  * @param {Array<Array<number>>} results - Pairs of observed predicted x-y values\n  *\n  * @return {number} - The r^2 value, or NaN if one cannot be calculated.\n  */\n  function determinationCoefficient(data, results) {\n    var predictions = [];\n    var observations = [];\n\n    data.forEach(function (d, i) {\n      if (d[1] !== null) {\n        observations.push(d);\n        predictions.push(results[i]);\n      }\n    });\n\n    var sum = observations.reduce(function (a, observation) {\n      return a + observation[1];\n    }, 0);\n    var mean = sum / observations.length;\n\n    var ssyy = observations.reduce(function (a, observation) {\n      var difference = observation[1] - mean;\n      return a + difference * difference;\n    }, 0);\n\n    var sse = observations.reduce(function (accum, observation, index) {\n      var prediction = predictions[index];\n      var residual = observation[1] - prediction[1];\n      return accum + residual * residual;\n    }, 0);\n\n    return 1 - sse / ssyy;\n  }\n\n  /**\n  * Determine the solution of a system of linear equations A * x = b using\n  * Gaussian elimination.\n  *\n  * @param {Array<Array<number>>} input - A 2-d matrix of data in row-major form [ A | b ]\n  * @param {number} order - How many degrees to solve for\n  *\n  * @return {Array<number>} - Vector of normalized solution coefficients matrix (x)\n  */\n  function gaussianElimination(input, order) {\n    var matrix = input;\n    var n = input.length - 1;\n    var coefficients = [order];\n\n    for (var i = 0; i < n; i++) {\n      var maxrow = i;\n      for (var j = i + 1; j < n; j++) {\n        if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][maxrow])) {\n          maxrow = j;\n        }\n      }\n\n      for (var k = i; k < n + 1; k++) {\n        var tmp = matrix[k][i];\n        matrix[k][i] = matrix[k][maxrow];\n        matrix[k][maxrow] = tmp;\n      }\n\n      for (var _j = i + 1; _j < n; _j++) {\n        for (var _k = n; _k >= i; _k--) {\n          matrix[_k][_j] -= matrix[_k][i] * matrix[i][_j] / matrix[i][i];\n        }\n      }\n    }\n\n    for (var _j2 = n - 1; _j2 >= 0; _j2--) {\n      var total = 0;\n      for (var _k2 = _j2 + 1; _k2 < n; _k2++) {\n        total += matrix[_k2][_j2] * coefficients[_k2];\n      }\n\n      coefficients[_j2] = (matrix[n][_j2] - total) / matrix[_j2][_j2];\n    }\n\n    return coefficients;\n  }\n\n  /**\n  * Round a number to a precision, specificed in number of decimal places\n  *\n  * @param {number} number - The number to round\n  * @param {number} precision - The number of decimal places to round to:\n  *                             > 0 means decimals, < 0 means powers of 10\n  *\n  *\n  * @return {numbr} - The number, rounded\n  */\n  function round(number, precision) {\n    var factor = Math.pow(10, precision);\n    return Math.round(number * factor) / factor;\n  }\n\n  /**\n  * The set of all fitting methods\n  *\n  * @namespace\n  */\n  var methods = {\n    linear: function linear(data, options) {\n      var sum = [0, 0, 0, 0, 0];\n      var len = 0;\n\n      for (var n = 0; n < data.length; n++) {\n        if (data[n][1] !== null) {\n          len++;\n          sum[0] += data[n][0];\n          sum[1] += data[n][1];\n          sum[2] += data[n][0] * data[n][0];\n          sum[3] += data[n][0] * data[n][1];\n          sum[4] += data[n][1] * data[n][1];\n        }\n      }\n\n      var run = len * sum[2] - sum[0] * sum[0];\n      var rise = len * sum[3] - sum[0] * sum[1];\n      var gradient = run === 0 ? 0 : round(rise / run, options.precision);\n      var intercept = round(sum[1] / len - gradient * sum[0] / len, options.precision);\n\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(gradient * x + intercept, options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      return {\n        points: points,\n        predict: predict,\n        equation: [gradient, intercept],\n        r2: round(determinationCoefficient(data, points), options.precision),\n        string: intercept === 0 ? 'y = ' + gradient + 'x' : 'y = ' + gradient + 'x + ' + intercept\n      };\n    },\n    exponential: function exponential(data, options) {\n      var sum = [0, 0, 0, 0, 0, 0];\n\n      for (var n = 0; n < data.length; n++) {\n        if (data[n][1] !== null) {\n          sum[0] += data[n][0];\n          sum[1] += data[n][1];\n          sum[2] += data[n][0] * data[n][0] * data[n][1];\n          sum[3] += data[n][1] * Math.log(data[n][1]);\n          sum[4] += data[n][0] * data[n][1] * Math.log(data[n][1]);\n          sum[5] += data[n][0] * data[n][1];\n        }\n      }\n\n      var denominator = sum[1] * sum[2] - sum[5] * sum[5];\n      var a = Math.exp((sum[2] * sum[3] - sum[5] * sum[4]) / denominator);\n      var b = (sum[1] * sum[4] - sum[5] * sum[3]) / denominator;\n      var coeffA = round(a, options.precision);\n      var coeffB = round(b, options.precision);\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(coeffA * Math.exp(coeffB * x), options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      return {\n        points: points,\n        predict: predict,\n        equation: [coeffA, coeffB],\n        string: 'y = ' + coeffA + 'e^(' + coeffB + 'x)',\n        r2: round(determinationCoefficient(data, points), options.precision)\n      };\n    },\n    logarithmic: function logarithmic(data, options) {\n      var sum = [0, 0, 0, 0];\n      var len = data.length;\n\n      for (var n = 0; n < len; n++) {\n        if (data[n][1] !== null) {\n          sum[0] += Math.log(data[n][0]);\n          sum[1] += data[n][1] * Math.log(data[n][0]);\n          sum[2] += data[n][1];\n          sum[3] += Math.pow(Math.log(data[n][0]), 2);\n        }\n      }\n\n      var a = (len * sum[1] - sum[2] * sum[0]) / (len * sum[3] - sum[0] * sum[0]);\n      var coeffB = round(a, options.precision);\n      var coeffA = round((sum[2] - coeffB * sum[0]) / len, options.precision);\n\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(round(coeffA + coeffB * Math.log(x), options.precision), options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      return {\n        points: points,\n        predict: predict,\n        equation: [coeffA, coeffB],\n        string: 'y = ' + coeffA + ' + ' + coeffB + ' ln(x)',\n        r2: round(determinationCoefficient(data, points), options.precision)\n      };\n    },\n    power: function power(data, options) {\n      var sum = [0, 0, 0, 0, 0];\n      var len = data.length;\n\n      for (var n = 0; n < len; n++) {\n        if (data[n][1] !== null) {\n          sum[0] += Math.log(data[n][0]);\n          sum[1] += Math.log(data[n][1]) * Math.log(data[n][0]);\n          sum[2] += Math.log(data[n][1]);\n          sum[3] += Math.pow(Math.log(data[n][0]), 2);\n        }\n      }\n\n      var b = (len * sum[1] - sum[0] * sum[2]) / (len * sum[3] - Math.pow(sum[0], 2));\n      var a = (sum[2] - b * sum[0]) / len;\n      var coeffA = round(Math.exp(a), options.precision);\n      var coeffB = round(b, options.precision);\n\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(round(coeffA * Math.pow(x, coeffB), options.precision), options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      return {\n        points: points,\n        predict: predict,\n        equation: [coeffA, coeffB],\n        string: 'y = ' + coeffA + 'x^' + coeffB,\n        r2: round(determinationCoefficient(data, points), options.precision)\n      };\n    },\n    polynomial: function polynomial(data, options) {\n      var lhs = [];\n      var rhs = [];\n      var a = 0;\n      var b = 0;\n      var len = data.length;\n      var k = options.order + 1;\n\n      for (var i = 0; i < k; i++) {\n        for (var l = 0; l < len; l++) {\n          if (data[l][1] !== null) {\n            a += Math.pow(data[l][0], i) * data[l][1];\n          }\n        }\n\n        lhs.push(a);\n        a = 0;\n\n        var c = [];\n        for (var j = 0; j < k; j++) {\n          for (var _l = 0; _l < len; _l++) {\n            if (data[_l][1] !== null) {\n              b += Math.pow(data[_l][0], i + j);\n            }\n          }\n          c.push(b);\n          b = 0;\n        }\n        rhs.push(c);\n      }\n      rhs.push(lhs);\n\n      var coefficients = gaussianElimination(rhs, k).map(function (v) {\n        return round(v, options.precision);\n      });\n\n      var predict = function predict(x) {\n        return [round(x, options.precision), round(coefficients.reduce(function (sum, coeff, power) {\n          return sum + coeff * Math.pow(x, power);\n        }, 0), options.precision)];\n      };\n\n      var points = data.map(function (point) {\n        return predict(point[0]);\n      });\n\n      var string = 'y = ';\n      for (var _i = coefficients.length - 1; _i >= 0; _i--) {\n        if (_i > 1) {\n          string += coefficients[_i] + 'x^' + _i + ' + ';\n        } else if (_i === 1) {\n          string += coefficients[_i] + 'x + ';\n        } else {\n          string += coefficients[_i];\n        }\n      }\n\n      return {\n        string: string,\n        points: points,\n        predict: predict,\n        equation: [].concat(_toConsumableArray(coefficients)).reverse(),\n        r2: round(determinationCoefficient(data, points), options.precision)\n      };\n    }\n  };\n\n  function createWrapper() {\n    var reduce = function reduce(accumulator, name) {\n      return _extends({\n        _round: round\n      }, accumulator, _defineProperty({}, name, function (data, supplied) {\n        return methods[name](data, _extends({}, DEFAULT_OPTIONS, supplied));\n      }));\n    };\n\n    return Object.keys(methods).reduce(reduce, {});\n  }\n\n  module.exports = createWrapper();\n});\n\n\n/***/ }),\n\n/***/ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\":\n/*!***********************************************************************************************!*\\\n  !*** ./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js ***!\n  \\***********************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n!function(t,r){ true?r(exports):undefined}(this,function(t){\"use strict\";function r(t){if(0===t.length)return 0;for(var r,n=t[0],e=0,a=1;a<t.length;a++)r=n+t[a],Math.abs(n)>=Math.abs(t[a])?e+=n-r+t[a]:e+=t[a]-r+n,n=r;return n+e}function g(t){if(0===t.length)throw new Error(\"mean requires at least one data point\");return r(t)/t.length}function n(t,r){var n,e,a=g(t),o=0;if(2===r)for(e=0;e<t.length;e++)o+=(n=t[e]-a)*n;else for(e=0;e<t.length;e++)o+=Math.pow(t[e]-a,r);return o}function e(t){if(0===t.length)throw new Error(\"variance requires at least one data point\");return n(t,2)/t.length}function a(t){if(1===t.length)return 0;var r=e(t);return Math.sqrt(r)}function o(t){if(0===t.length)throw new Error(\"mode requires at least one data point\");if(1===t.length)return t[0];for(var r=t[0],n=NaN,e=0,a=1,o=1;o<t.length+1;o++)t[o]!==r?(e<a&&(e=a,n=r),a=1,r=t[o]):a++;return n}function f(t){return t.slice().sort(function(t,r){return t-r})}function u(t){if(0===t.length)throw new Error(\"min requires at least one data point\");for(var r=t[0],n=1;n<t.length;n++)t[n]<r&&(r=t[n]);return r}function h(t){if(0===t.length)throw new Error(\"max requires at least one data point\");for(var r=t[0],n=1;n<t.length;n++)t[n]>r&&(r=t[n]);return r}function i(t,r){var n=t.length*r;if(0===t.length)throw new Error(\"quantile requires at least one data point.\");if(r<0||1<r)throw new Error(\"quantiles must be between 0 and 1\");return 1===r?t[t.length-1]:0===r?t[0]:n%1!=0?t[Math.ceil(n)-1]:t.length%2==0?(t[n-1]+t[n])/2:t[n]}function c(t,r,n,e){for(n=n||0,e=e||t.length-1;n<e;){if(600<e-n){var a=e-n+1,o=r-n+1,i=Math.log(a),u=.5*Math.exp(2*i/3),h=.5*Math.sqrt(i*u*(a-u)/a);o-a/2<0&&(h*=-1),c(t,r,Math.max(n,Math.floor(r-o*u/a+h)),Math.min(e,Math.floor(r+(a-o)*u/a+h)))}var f=t[r],s=n,l=e;for(p(t,n,r),t[e]>f&&p(t,n,e);s<l;){for(p(t,s,l),s++,l--;t[s]<f;)s++;for(;t[l]>f;)l--}t[n]===f?p(t,n,l):p(t,++l,e),l<=r&&(n=l+1),r<=l&&(e=l-1)}}function p(t,r,n){var e=t[r];t[r]=t[n],t[n]=e}function s(t,r){var n=t.slice();if(Array.isArray(r)){!function(t,r){for(var n=[0],e=0;e<r.length;e++)n.push(w(t.length,r[e]));n.push(t.length-1),n.sort(v);var a=[0,n.length-1];for(;a.length;){var o=Math.ceil(a.pop()),i=Math.floor(a.pop());if(!(o-i<=1)){var u=Math.floor((i+o)/2);l(t,n[u],n[i],n[o]),a.push(i,u,u,o)}}}(n,r);for(var e=[],a=0;a<r.length;a++)e[a]=i(n,r[a]);return e}return l(n,w(n.length,r),0,n.length-1),i(n,r)}function l(t,r,n,e){r%1==0?c(t,r,n,e):(c(t,r=Math.floor(r),n,e),c(t,r+1,r+1,e))}function v(t,r){return t-r}function w(t,r){var n=t*r;return 1===r?t-1:0===r?0:n%1!=0?Math.ceil(n)-1:t%2==0?n-.5:n}function M(t,r){if(r<t[0])return 0;if(r>t[t.length-1])return 1;var n=function(t,r){var n=0,e=0,a=t.length;for(;e<a;)r<=t[n=e+a>>>1]?a=n:e=-~n;return e}(t,r);if(t[n]!==r)return n/t.length;n++;var e=function(t,r){var n=0,e=0,a=t.length;for(;e<a;)r>=t[n=e+a>>>1]?e=-~n:a=n;return e}(t,r);if(e===n)return n/t.length;var a=e-n+1;return a*(e+n)/2/a/t.length}function m(t){var r=s(t,.75),n=s(t,.25);if(\"number\"==typeof r&&\"number\"==typeof n)return r-n}function d(t){return+s(t,.5)}function b(t){for(var r=d(t),n=[],e=0;e<t.length;e++)n.push(Math.abs(t[e]-r));return d(n)}function q(t,r){r=r||Math.random;for(var n,e,a=t.length;0<a;)e=Math.floor(r()*a--),n=t[a],t[a]=t[e],t[e]=n;return t}function E(t,r){return q(t.slice().slice(),r)}function y(t){for(var r,n=0,e=0;e<t.length;e++)0!==e&&t[e]===r||(r=t[e],n++);return n}function S(t,r){for(var n=[],e=0;e<t;e++){for(var a=[],o=0;o<r;o++)a.push(0);n.push(a)}return n}function x(t,r,n,e){var a;if(0<t){var o=(n[r]-n[t-1])/(r-t+1);a=e[r]-e[t-1]-(r-t+1)*o*o}else a=e[r]-n[r]*n[r]/(r+1);return a<0?0:a}function P(t,r,n,e,a,o,i){if(!(r<t)){var u=Math.floor((t+r)/2);e[n][u]=e[n-1][u-1],a[n][u]=u;var h=n;n<t&&(h=Math.max(h,a[n][t-1]||0)),h=Math.max(h,a[n-1][u]||0);var f,s,l,c=u-1;r<e.length-1&&(c=Math.min(c,a[n][r+1]||0));for(var g=c;h<=g&&!((f=x(g,u,o,i))+e[n-1][h-1]>=e[n][u]);--g)(s=x(h,u,o,i)+e[n-1][h-1])<e[n][u]&&(e[n][u]=s,a[n][u]=h),h++,(l=f+e[n-1][g-1])<e[n][u]&&(e[n][u]=l,a[n][u]=g);P(t,u-1,n,e,a,o,i),P(u+1,r,n,e,a,o,i)}}function k(t,r){if(t.length!==r.length)throw new Error(\"sampleCovariance requires samples with equal lengths\");if(t.length<2)throw new Error(\"sampleCovariance requires at least two data points in each sample\");for(var n=g(t),e=g(r),a=0,o=0;o<t.length;o++)a+=(t[o]-n)*(r[o]-e);return a/(t.length-1)}function I(t){if(t.length<2)throw new Error(\"sampleVariance requires at least two data points\");return n(t,2)/(t.length-1)}function D(t){var r=I(t);return Math.sqrt(r)}function C(t,r,n,e){return(t*r+n*e)/(r+e)}function T(t){if(0===t.length)throw new Error(\"rootMeanSquare requires at least one data point\");for(var r=0,n=0;n<t.length;n++)r+=Math.pow(t[n],2);return Math.sqrt(r/t.length)}function _(){this.totalCount=0,this.data={}}function F(){this.weights=[],this.bias=0}_.prototype.train=function(t,r){for(var n in this.data[r]||(this.data[r]={}),t){var e=t[n];void 0===this.data[r][n]&&(this.data[r][n]={}),void 0===this.data[r][n][e]&&(this.data[r][n][e]=0),this.data[r][n][e]++}this.totalCount++},_.prototype.score=function(t){var r,n={};for(var e in t){var a=t[e];for(r in this.data)n[r]={},this.data[r][e]?n[r][e+\"_\"+a]=(this.data[r][e][a]||0)/this.totalCount:n[r][e+\"_\"+a]=0}var o={};for(r in n)for(var i in o[r]=0,n[r])o[r]+=n[r][i];return o},F.prototype.predict=function(t){if(t.length!==this.weights.length)return null;for(var r=0,n=0;n<this.weights.length;n++)r+=this.weights[n]*t[n];return 0<(r+=this.bias)?1:0},F.prototype.train=function(t,r){if(0!==r&&1!==r)return null;t.length!==this.weights.length&&(this.weights=t,this.bias=1);var n=this.predict(t);if(n!==r){for(var e=r-n,a=0;a<this.weights.length;a++)this.weights[a]+=e*t[a];this.bias+=e}return this};var N=1e-4;function R(t){if(t<0)throw new Error(\"factorial requires a non-negative value\");if(Math.floor(t)!==t)throw new Error(\"factorial requires an integer input\");for(var r=1,n=2;n<=t;n++)r*=n;return r}var A=[.9999999999999971,57.15623566586292,-59.59796035547549,14.136097974741746,-.4919138160976202,3399464998481189e-20,4652362892704858e-20,-9837447530487956e-20,.0001580887032249125,-.00021026444172410488,.00021743961811521265,-.0001643181065367639,8441822398385275e-20,-26190838401581408e-21,36899182659531625e-22],z=Math.log(Math.sqrt(2*Math.PI));var V={1:{.995:0,.99:0,.975:0,.95:0,.9:.02,.5:.45,.1:2.71,.05:3.84,.025:5.02,.01:6.63,.005:7.88},2:{.995:.01,.99:.02,.975:.05,.95:.1,.9:.21,.5:1.39,.1:4.61,.05:5.99,.025:7.38,.01:9.21,.005:10.6},3:{.995:.07,.99:.11,.975:.22,.95:.35,.9:.58,.5:2.37,.1:6.25,.05:7.81,.025:9.35,.01:11.34,.005:12.84},4:{.995:.21,.99:.3,.975:.48,.95:.71,.9:1.06,.5:3.36,.1:7.78,.05:9.49,.025:11.14,.01:13.28,.005:14.86},5:{.995:.41,.99:.55,.975:.83,.95:1.15,.9:1.61,.5:4.35,.1:9.24,.05:11.07,.025:12.83,.01:15.09,.005:16.75},6:{.995:.68,.99:.87,.975:1.24,.95:1.64,.9:2.2,.5:5.35,.1:10.65,.05:12.59,.025:14.45,.01:16.81,.005:18.55},7:{.995:.99,.99:1.25,.975:1.69,.95:2.17,.9:2.83,.5:6.35,.1:12.02,.05:14.07,.025:16.01,.01:18.48,.005:20.28},8:{.995:1.34,.99:1.65,.975:2.18,.95:2.73,.9:3.49,.5:7.34,.1:13.36,.05:15.51,.025:17.53,.01:20.09,.005:21.96},9:{.995:1.73,.99:2.09,.975:2.7,.95:3.33,.9:4.17,.5:8.34,.1:14.68,.05:16.92,.025:19.02,.01:21.67,.005:23.59},10:{.995:2.16,.99:2.56,.975:3.25,.95:3.94,.9:4.87,.5:9.34,.1:15.99,.05:18.31,.025:20.48,.01:23.21,.005:25.19},11:{.995:2.6,.99:3.05,.975:3.82,.95:4.57,.9:5.58,.5:10.34,.1:17.28,.05:19.68,.025:21.92,.01:24.72,.005:26.76},12:{.995:3.07,.99:3.57,.975:4.4,.95:5.23,.9:6.3,.5:11.34,.1:18.55,.05:21.03,.025:23.34,.01:26.22,.005:28.3},13:{.995:3.57,.99:4.11,.975:5.01,.95:5.89,.9:7.04,.5:12.34,.1:19.81,.05:22.36,.025:24.74,.01:27.69,.005:29.82},14:{.995:4.07,.99:4.66,.975:5.63,.95:6.57,.9:7.79,.5:13.34,.1:21.06,.05:23.68,.025:26.12,.01:29.14,.005:31.32},15:{.995:4.6,.99:5.23,.975:6.27,.95:7.26,.9:8.55,.5:14.34,.1:22.31,.05:25,.025:27.49,.01:30.58,.005:32.8},16:{.995:5.14,.99:5.81,.975:6.91,.95:7.96,.9:9.31,.5:15.34,.1:23.54,.05:26.3,.025:28.85,.01:32,.005:34.27},17:{.995:5.7,.99:6.41,.975:7.56,.95:8.67,.9:10.09,.5:16.34,.1:24.77,.05:27.59,.025:30.19,.01:33.41,.005:35.72},18:{.995:6.26,.99:7.01,.975:8.23,.95:9.39,.9:10.87,.5:17.34,.1:25.99,.05:28.87,.025:31.53,.01:34.81,.005:37.16},19:{.995:6.84,.99:7.63,.975:8.91,.95:10.12,.9:11.65,.5:18.34,.1:27.2,.05:30.14,.025:32.85,.01:36.19,.005:38.58},20:{.995:7.43,.99:8.26,.975:9.59,.95:10.85,.9:12.44,.5:19.34,.1:28.41,.05:31.41,.025:34.17,.01:37.57,.005:40},21:{.995:8.03,.99:8.9,.975:10.28,.95:11.59,.9:13.24,.5:20.34,.1:29.62,.05:32.67,.025:35.48,.01:38.93,.005:41.4},22:{.995:8.64,.99:9.54,.975:10.98,.95:12.34,.9:14.04,.5:21.34,.1:30.81,.05:33.92,.025:36.78,.01:40.29,.005:42.8},23:{.995:9.26,.99:10.2,.975:11.69,.95:13.09,.9:14.85,.5:22.34,.1:32.01,.05:35.17,.025:38.08,.01:41.64,.005:44.18},24:{.995:9.89,.99:10.86,.975:12.4,.95:13.85,.9:15.66,.5:23.34,.1:33.2,.05:36.42,.025:39.36,.01:42.98,.005:45.56},25:{.995:10.52,.99:11.52,.975:13.12,.95:14.61,.9:16.47,.5:24.34,.1:34.28,.05:37.65,.025:40.65,.01:44.31,.005:46.93},26:{.995:11.16,.99:12.2,.975:13.84,.95:15.38,.9:17.29,.5:25.34,.1:35.56,.05:38.89,.025:41.92,.01:45.64,.005:48.29},27:{.995:11.81,.99:12.88,.975:14.57,.95:16.15,.9:18.11,.5:26.34,.1:36.74,.05:40.11,.025:43.19,.01:46.96,.005:49.65},28:{.995:12.46,.99:13.57,.975:15.31,.95:16.93,.9:18.94,.5:27.34,.1:37.92,.05:41.34,.025:44.46,.01:48.28,.005:50.99},29:{.995:13.12,.99:14.26,.975:16.05,.95:17.71,.9:19.77,.5:28.34,.1:39.09,.05:42.56,.025:45.72,.01:49.59,.005:52.34},30:{.995:13.79,.99:14.95,.975:16.79,.95:18.49,.9:20.6,.5:29.34,.1:40.26,.05:43.77,.025:46.98,.01:50.89,.005:53.67},40:{.995:20.71,.99:22.16,.975:24.43,.95:26.51,.9:29.05,.5:39.34,.1:51.81,.05:55.76,.025:59.34,.01:63.69,.005:66.77},50:{.995:27.99,.99:29.71,.975:32.36,.95:34.76,.9:37.69,.5:49.33,.1:63.17,.05:67.5,.025:71.42,.01:76.15,.005:79.49},60:{.995:35.53,.99:37.48,.975:40.48,.95:43.19,.9:46.46,.5:59.33,.1:74.4,.05:79.08,.025:83.3,.01:88.38,.005:91.95},70:{.995:43.28,.99:45.44,.975:48.76,.95:51.74,.9:55.33,.5:69.33,.1:85.53,.05:90.53,.025:95.02,.01:100.42,.005:104.22},80:{.995:51.17,.99:53.54,.975:57.15,.95:60.39,.9:64.28,.5:79.33,.1:96.58,.05:101.88,.025:106.63,.01:112.33,.005:116.32},90:{.995:59.2,.99:61.75,.975:65.65,.95:69.13,.9:73.29,.5:89.33,.1:107.57,.05:113.14,.025:118.14,.01:124.12,.005:128.3},100:{.995:67.33,.99:70.06,.975:74.22,.95:77.93,.9:82.36,.5:99.33,.1:118.5,.05:124.34,.025:129.56,.01:135.81,.005:140.17}};var j=Math.sqrt(2*Math.PI),B={gaussian:function(t){return Math.exp(-.5*t*t)/j}},K={nrd:function(t){var r=D(t),n=m(t);return\"number\"==typeof n&&(r=Math.min(r,n/1.34)),1.06*r*Math.pow(t.length,-.2)}};function O(e,t,r){var a,o;if(void 0===t)a=B.gaussian;else if(\"string\"==typeof t){if(!B[t])throw new Error('Unknown kernel \"'+t+'\"');a=B[t]}else a=t;if(void 0===r)o=K.nrd(e);else if(\"string\"==typeof r){if(!K[r])throw new Error('Unknown bandwidth method \"'+r+'\"');o=K[r](e)}else o=r;return function(t){var r=0,n=0;for(r=0;r<e.length;r++)n+=a((t-e[r])/o);return n/o/e.length}}var U=Math.sqrt(2*Math.PI);function G(t){for(var r=t,n=t,e=1;e<15;e++)r+=n*=t*t/(2*e+1);return Math.round(1e4*(.5+r/U*Math.exp(-t*t/2)))/1e4}for(var H=[],L=0;L<=3.09;L+=.01)H.push(G(L));function W(t){var r=1/(1+.5*Math.abs(t)),n=r*Math.exp(-Math.pow(t,2)-1.26551223+1.00002368*r+.37409196*Math.pow(r,2)+.09678418*Math.pow(r,3)-.18628806*Math.pow(r,4)+.27886807*Math.pow(r,5)-1.13520398*Math.pow(r,6)+1.48851587*Math.pow(r,7)-.82215223*Math.pow(r,8)+.17087277*Math.pow(r,9));return 0<=t?1-n:n-1}function J(t){var r=8*(Math.PI-3)/(3*Math.PI*(4-Math.PI)),n=Math.sqrt(Math.sqrt(Math.pow(2/(Math.PI*r)+Math.log(1-t*t)/2,2)-Math.log(1-t*t)/r)-(2/(Math.PI*r)+Math.log(1-t*t)/2));return 0<=t?n:-n}function Q(t){if(\"number\"==typeof t)return t<0?-1:0===t?0:1;throw new TypeError(\"not a number\")}t.linearRegression=function(t){var r,n,e=t.length;if(1===e)n=t[r=0][1];else{for(var a,o,i,u=0,h=0,f=0,s=0,l=0;l<e;l++)u+=o=(a=t[l])[0],h+=i=a[1],f+=o*o,s+=o*i;n=h/e-(r=(e*s-u*h)/(e*f-u*u))*u/e}return{m:r,b:n}},t.linearRegressionLine=function(r){return function(t){return r.b+r.m*t}},t.standardDeviation=a,t.rSquared=function(t,r){if(t.length<2)return 1;for(var n,e=0,a=0;a<t.length;a++)e+=t[a][1];n=e/t.length;for(var o=0,i=0;i<t.length;i++)o+=Math.pow(n-t[i][1],2);for(var u=0,h=0;h<t.length;h++)u+=Math.pow(t[h][1]-r(t[h][0]),2);return 1-u/o},t.mode=function(t){return o(f(t))},t.modeFast=function(t){for(var r,n=new Map,e=0,a=0;a<t.length;a++){var o=n.get(t[a]);void 0===o?o=1:o++,e<o&&(r=t[a],e=o),n.set(t[a],o)}if(0===e)throw new Error(\"mode requires at last one data point\");return r},t.modeSorted=o,t.min=u,t.max=h,t.extent=function(t){if(0===t.length)throw new Error(\"extent requires at least one data point\");for(var r=t[0],n=t[0],e=1;e<t.length;e++)t[e]>n&&(n=t[e]),t[e]<r&&(r=t[e]);return[r,n]},t.minSorted=function(t){return t[0]},t.maxSorted=function(t){return t[t.length-1]},t.extentSorted=function(t){return[t[0],t[t.length-1]]},t.sum=r,t.sumSimple=function(t){for(var r=0,n=0;n<t.length;n++)r+=t[n];return r},t.product=function(t){for(var r=1,n=0;n<t.length;n++)r*=t[n];return r},t.quantile=s,t.quantileSorted=i,t.quantileRank=function(t,r){return M(f(t),r)},t.quantileRankSorted=M,t.interquartileRange=m,t.iqr=m,t.medianAbsoluteDeviation=b,t.mad=b,t.chunk=function(t,r){var n=[];if(r<1)throw new Error(\"chunk size must be a positive number\");if(Math.floor(r)!==r)throw new Error(\"chunk size must be an integer\");for(var e=0;e<t.length;e+=r)n.push(t.slice(e,e+r));return n},t.sampleWithReplacement=function(t,r,n){if(0===t.length)return[];n=n||Math.random;for(var e=t.length,a=[],o=0;o<r;o++){var i=Math.floor(n()*e);a.push(t[i])}return a},t.shuffle=E,t.shuffleInPlace=q,t.sample=function(t,r,n){return E(t,n).slice(0,r)},t.ckmeans=function(t,r){if(r>t.length)throw new Error(\"cannot generate more classes than there are data values\");var n=f(t);if(1===y(n))return[n];var e=S(r,n.length),a=S(r,n.length);!function(t,r,n){for(var e,a=r[0].length,o=t[Math.floor(a/2)],i=[],u=[],h=0;h<a;++h)e=t[h]-o,0===h?(i.push(e),u.push(e*e)):(i.push(i[h-1]+e),u.push(u[h-1]+e*e)),r[0][h]=x(0,h,i,u),n[0][h]=0;for(var f=1;f<r.length;++f)P(f<r.length-1?f:a-1,a-1,f,r,n,i,u)}(n,e,a);for(var o=[],i=a[0].length-1,u=a.length-1;0<=u;u--){var h=a[u][i];o[u]=n.slice(h,i+1),0<u&&(i=h-1)}return o},t.uniqueCountSorted=y,t.sumNthPowerDeviations=n,t.equalIntervalBreaks=function(t,r){if(t.length<2)return t;for(var n=u(t),e=h(t),a=[n],o=(e-n)/r,i=1;i<r;i++)a.push(a[0]+o*i);return a.push(e),a},t.sampleCovariance=k,t.sampleCorrelation=function(t,r){return k(t,r)/D(t)/D(r)},t.sampleVariance=I,t.sampleStandardDeviation=D,t.sampleSkewness=function(t){if(t.length<3)throw new Error(\"sampleSkewness requires at least three data points\");for(var r,n=g(t),e=0,a=0,o=0;o<t.length;o++)e+=(r=t[o]-n)*r,a+=r*r*r;var i=t.length-1,u=Math.sqrt(e/i),h=t.length;return h*a/((h-1)*(h-2)*Math.pow(u,3))},t.sampleKurtosis=function(t){var r=t.length;if(r<4)throw new Error(\"sampleKurtosis requires at least four data points\");for(var n,e=g(t),a=0,o=0,i=0;i<r;i++)a+=(n=t[i]-e)*n,o+=n*n*n*n;return(r-1)/((r-2)*(r-3))*(r*(r+1)*o/(a*a)-3*(r-1))},t.permutationsHeap=function(t){for(var r=new Array(t.length),n=[t.slice()],e=0;e<t.length;e++)r[e]=0;for(e=0;e<t.length;)if(r[e]<e){var a=0;e%2!=0&&(a=r[e]);var o=t[a];t[a]=t[e],t[e]=o,n.push(t.slice()),r[e]++,e=0}else r[e]=0,e++;return n},t.combinations=function t(r,n){var e,a,o,i,u=[];for(e=0;e<r.length;e++)if(1===n)u.push([r[e]]);else for(o=t(r.slice(e+1,r.length),n-1),a=0;a<o.length;a++)(i=o[a]).unshift(r[e]),u.push(i);return u},t.combinationsReplacement=function t(r,n){for(var e=[],a=0;a<r.length;a++)if(1===n)e.push([r[a]]);else for(var o=t(r.slice(a,r.length),n-1),i=0;i<o.length;i++)e.push([r[a]].concat(o[i]));return e},t.addToMean=function(t,r,n){return t+(n-t)/(r+1)},t.combineMeans=C,t.combineVariances=function(t,r,n,e,a,o){var i=C(r,n,a,o);return(n*(t+Math.pow(r-i,2))+o*(e+Math.pow(a-i,2)))/(n+o)},t.geometricMean=function(t){if(0===t.length)throw new Error(\"geometricMean requires at least one data point\");for(var r=1,n=0;n<t.length;n++){if(t[n]<=0)throw new Error(\"geometricMean requires only positive numbers as input\");r*=t[n]}return Math.pow(r,1/t.length)},t.harmonicMean=function(t){if(0===t.length)throw new Error(\"harmonicMean requires at least one data point\");for(var r=0,n=0;n<t.length;n++){if(t[n]<=0)throw new Error(\"harmonicMean requires only positive numbers as input\");r+=1/t[n]}return t.length/r},t.average=g,t.mean=g,t.median=d,t.medianSorted=function(t){return i(t,.5)},t.subtractFromMean=function(t,r,n){return(t*r-n)/(r-1)},t.rootMeanSquare=T,t.rms=T,t.variance=e,t.tTest=function(t,r){return(g(t)-r)/(a(t)/Math.sqrt(t.length))},t.tTestTwoSample=function(t,r,n){var e=t.length,a=r.length;if(!e||!a)return null;n||(n=0);var o=g(t),i=g(r),u=I(t),h=I(r);if(\"number\"==typeof o&&\"number\"==typeof i&&\"number\"==typeof u&&\"number\"==typeof h){var f=((e-1)*u+(a-1)*h)/(e+a-2);return(o-i-n)/Math.sqrt(f*(1/e+1/a))}},t.BayesianClassifier=_,t.bayesian=_,t.PerceptronModel=F,t.perceptron=F,t.epsilon=N,t.factorial=R,t.gamma=function t(r){if(\"number\"==typeof(n=r)&&isFinite(n)&&Math.floor(n)===n)return r<=0?NaN:R(r-1);var n;if(--r<0)return Math.PI/(Math.sin(Math.PI*-r)*t(-r));var e=r+.25;return Math.pow(r/Math.E,r)*Math.sqrt(2*Math.PI*(r+1/6))*(1+1/144/Math.pow(e,2)-1/12960/Math.pow(e,3)-257/207360/Math.pow(e,4)-52/2612736/Math.pow(e,5)+5741173/9405849600/Math.pow(e,6)+37529/18811699200/Math.pow(e,7))},t.gammaln=function(t){if(t<=0)return 1/0;t--;for(var r=A[0],n=1;n<15;n++)r+=A[n]/(t+n);var e=5.2421875+t;return z+Math.log(r)-e+(t+.5)*Math.log(e)},t.bernoulliDistribution=function(t){if(t<0||1<t)throw new Error(\"bernoulliDistribution requires probability to be between 0 and 1 inclusive\");return[1-t,t]},t.binomialDistribution=function(t,r){if(!(r<0||1<r||t<=0||t%1!=0)){for(var n=0,e=0,a=[],o=1;a[n]=o*Math.pow(r,n)*Math.pow(1-r,t-n),e+=a[n],o=o*(t-++n+1)/n,e<1-N;);return a}},t.poissonDistribution=function(t){if(!(t<=0)){for(var r=0,n=0,e=[],a=1;e[r]=Math.exp(-t)*Math.pow(t,r)/a,n+=e[r],a*=++r,n<1-N;);return e}},t.chiSquaredDistributionTable=V,t.chiSquaredGoodnessOfFit=function(t,r,n){for(var e,a,o=0,i=r(g(t)),u=[],h=[],f=0;f<t.length;f++)void 0===u[t[f]]&&(u[t[f]]=0),u[t[f]]++;for(f=0;f<u.length;f++)void 0===u[f]&&(u[f]=0);for(a in i)a in u&&(h[+a]=i[a]*t.length);for(a=h.length-1;0<=a;a--)h[a]<3&&(h[a-1]+=h[a],h.pop(),u[a-1]+=u[a],u.pop());for(a=0;a<u.length;a++)o+=Math.pow(u[a]-h[a],2)/h[a];return e=u.length-1-1,V[e][n]<o},t.kernelDensityEstimation=O,t.kde=O,t.zScore=function(t,r,n){return(t-r)/n},t.cumulativeStdNormalProbability=function(t){var r=Math.abs(t),n=Math.min(Math.round(100*r),H.length-1);return 0<=t?H[n]:+(1-H[n]).toFixed(4)},t.standardNormalTable=H,t.errorFunction=W,t.erf=W,t.inverseErrorFunction=J,t.probit=function(t){return 0===t?t=N:1<=t&&(t=1-N),Math.sqrt(2)*J(2*t-1)},t.permutationTest=function(t,r,n,e){if(void 0===e&&(e=1e4),void 0===n&&(n=\"two_side\"),\"two_side\"!==n&&\"greater\"!==n&&\"less\"!==n)throw new Error(\"`alternative` must be either 'two_side', 'greater', or 'less'\");for(var a=g(t)-g(r),o=new Array(e),i=t.concat(r),u=Math.floor(i.length/2),h=0;h<e;h++){q(i);var f=i.slice(0,u),s=i.slice(u,i.length),l=g(f)-g(s);o[h]=l}var c=0;if(\"two_side\"===n)for(h=0;h<=e;h++)Math.abs(o[h])>=Math.abs(a)&&(c+=1);else if(\"greater\"===n)for(h=0;h<=e;h++)o[h]>=a&&(c+=1);else for(h=0;h<=e;h++)o[h]<=a&&(c+=1);return c/e},t.bisect=function(t,r,n,e,a){if(\"function\"!=typeof t)throw new TypeError(\"func must be a function\");for(var o=0;o<e;o++){var i=(r+n)/2;if(0===t(i)||Math.abs((n-r)/2)<a)return i;Q(t(i))===Q(t(r))?r=i:n=i}throw new Error(\"maximum number of iterations exceeded\")},t.quickselect=c,t.sign=Q,t.numericSort=f,Object.defineProperty(t,\"__esModule\",{value:!0})});\n//# sourceMappingURL=simple-statistics.min.js.map\n\n\n/***/ }),\n\n/***/ \"./node_modules/_topojson-client@3.1.0@topojson-client/dist/topojson-client.js\":\n/*!*************************************************************************************!*\\\n  !*** ./node_modules/_topojson-client@3.1.0@topojson-client/dist/topojson-client.js ***!\n  \\*************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n// https://github.com/topojson/topojson-client v3.1.0 Copyright 2019 Mike Bostock\n(function (global, factory) {\n true ? factory(exports) :\nundefined;\n}(this, function (exports) { 'use strict';\n\nfunction identity(x) {\n  return x;\n}\n\nfunction transform(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n\nfunction bbox(topology) {\n  var t = transform(topology.transform), key,\n      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n  function bboxPoint(p) {\n    p = t(p);\n    if (p[0] < x0) x0 = p[0];\n    if (p[0] > x1) x1 = p[0];\n    if (p[1] < y0) y0 = p[1];\n    if (p[1] > y1) y1 = p[1];\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  topology.arcs.forEach(function(arc) {\n    var i = -1, n = arc.length, p;\n    while (++i < n) {\n      p = t(arc[i], i);\n      if (p[0] < x0) x0 = p[0];\n      if (p[0] > x1) x1 = p[0];\n      if (p[1] < y0) y0 = p[1];\n      if (p[1] > y1) y1 = p[1];\n    }\n  });\n\n  for (key in topology.objects) {\n    bboxGeometry(topology.objects[key]);\n  }\n\n  return [x0, y0, x1, y1];\n}\n\nfunction reverse(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n\nfunction feature(topology, o) {\n  if (typeof o === \"string\") o = topology.objects[o];\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature$1(topology, o); })}\n      : feature$1(topology, o);\n}\n\nfunction feature$1(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nfunction object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n\nfunction stitch(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n    else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n  return fragments;\n}\n\nfunction mesh(topology) {\n  return object(topology, meshArcs.apply(this, arguments));\n}\n\nfunction meshArcs(topology, object, filter) {\n  var arcs, i, n;\n  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);\n  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n  return {type: \"MultiLineString\", arcs: stitch(topology, arcs)};\n}\n\nfunction extractArcs(topology, object, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n\n  return arcs;\n}\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nfunction merge(topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n}\n\nfunction mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"Polygon\": extract(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function(ring) {\n      ring.forEach(function(arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n  }\n\n  polygons.forEach(function(polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function(polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function(polygons) {\n      var arcs = [], n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function(polygon) {\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    }).filter(function(arcs) {\n      return arcs.length > 0;\n    })\n  };\n}\n\nfunction bisect(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n}\n\nfunction neighbors(objects) {\n  var indexesByArc = {}, // arc index -> array of object indexes\n      neighbors = objects.map(function() { return []; });\n\n  function line(arcs, i) {\n    arcs.forEach(function(a) {\n      if (a < 0) a = ~a;\n      var o = indexesByArc[a];\n      if (o) o.push(i);\n      else indexesByArc[a] = [i];\n    });\n  }\n\n  function polygon(arcs, i) {\n    arcs.forEach(function(arc) { line(arc, i); });\n  }\n\n  function geometry(o, i) {\n    if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n  }\n\n  var geometryType = {\n    LineString: line,\n    MultiLineString: polygon,\n    Polygon: polygon,\n    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n  };\n\n  objects.forEach(geometry);\n\n  for (var i in indexesByArc) {\n    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n      for (var k = j + 1; k < m; ++k) {\n        var ij = indexes[j], ik = indexes[k], n;\n        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n      }\n    }\n  }\n\n  return neighbors;\n}\n\nfunction untransform(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2,\n        n = input.length,\n        output = new Array(n),\n        x1 = Math.round((input[0] - dx) / kx),\n        y1 = Math.round((input[1] - dy) / ky);\n    output[0] = x1 - x0, x0 = x1;\n    output[1] = y1 - y0, y0 = y1;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n\nfunction quantize(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be ≥2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}\n\nexports.bbox = bbox;\nexports.feature = feature;\nexports.merge = merge;\nexports.mergeArcs = mergeArcs;\nexports.mesh = mesh;\nexports.meshArcs = meshArcs;\nexports.neighbors = neighbors;\nexports.quantize = quantize;\nexports.transform = transform;\nexports.untransform = untransform;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n}));\n\n\n/***/ }),\n\n/***/ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\":\n/*!***************************************************!*\\\n  !*** ./node_modules/_tslib@1.11.1@tslib/tslib.js ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __spreadArrays;\r\nvar __await;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\nvar __makeTemplateObject;\r\nvar __importStar;\r\nvar __importDefault;\r\nvar __classPrivateFieldGet;\r\nvar __classPrivateFieldSet;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (true) {\r\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function (exports) { factory(createExporter(root, createExporter(exports))); }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    }\r\n    else {}\r\n    function createExporter(exports, previous) {\r\n        if (exports !== root) {\r\n            if (typeof Object.create === \"function\") {\r\n                Object.defineProperty(exports, \"__esModule\", { value: true });\r\n            }\r\n            else {\r\n                exports.__esModule = true;\r\n            }\r\n        }\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __exportStar = function (m, exports) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    };\r\n\r\n    __values = function (o) {\r\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n        if (m) return m.call(o);\r\n        if (o && typeof o.length === \"number\") return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    __spreadArrays = function () {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    };\r\n\r\n    __await = function (v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    };\r\n\r\n    __makeTemplateObject = function (cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    __importStar = function (mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n        result[\"default\"] = mod;\r\n        return result;\r\n    };\r\n\r\n    __importDefault = function (mod) {\r\n        return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n    };\r\n\r\n    __classPrivateFieldGet = function (receiver, privateMap) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to get private field on non-instance\");\r\n        }\r\n        return privateMap.get(receiver);\r\n    };\r\n\r\n    __classPrivateFieldSet = function (receiver, privateMap, value) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to set private field on non-instance\");\r\n        }\r\n        privateMap.set(receiver, value);\r\n        return value;\r\n    }\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__spreadArrays\", __spreadArrays);\r\n    exporter(\"__await\", __await);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n    exporter(\"__makeTemplateObject\", __makeTemplateObject);\r\n    exporter(\"__importStar\", __importStar);\r\n    exporter(\"__importDefault\", __importDefault);\r\n    exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet);\r\n    exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet);\r\n});\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../_webpack@4.42.1@webpack/buildin/global.js */ \"./node_modules/_webpack@4.42.1@webpack/buildin/global.js\")))\n\n/***/ }),\n\n/***/ \"./node_modules/_webpack@4.42.1@webpack/buildin/global.js\":\n/*!***********************************!*\\\n  !*** (webpack)/buildin/global.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n\n/***/ \"./node_modules/_webpack@4.42.1@webpack/buildin/module.js\":\n/*!***********************************!*\\\n  !*** (webpack)/buildin/module.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/_wolfy87-eventemitter@5.2.9@wolfy87-eventemitter/EventEmitter.js\":\n/*!***************************************************************************************!*\\\n  !*** ./node_modules/_wolfy87-eventemitter@5.2.9@wolfy87-eventemitter/EventEmitter.js ***!\n  \\***************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * EventEmitter v5.2.9 - git.io/ee\n * Unlicense - http://unlicense.org/\n * Oliver Caldwell - https://oli.me.uk/\n * @preserve\n */\n\n;(function (exports) {\n    'use strict';\n\n    /**\n     * Class for managing events.\n     * Can be extended to provide event functionality in other classes.\n     *\n     * @class EventEmitter Manages event registering and emitting.\n     */\n    function EventEmitter() {}\n\n    // Shortcuts to improve speed and size\n    var proto = EventEmitter.prototype;\n    var originalGlobalValue = exports.EventEmitter;\n\n    /**\n     * Finds the index of the listener for the event in its storage array.\n     *\n     * @param {Function[]} listeners Array of listeners to search through.\n     * @param {Function} listener Method to look for.\n     * @return {Number} Index of the specified listener, -1 if not found\n     * @api private\n     */\n    function indexOfListener(listeners, listener) {\n        var i = listeners.length;\n        while (i--) {\n            if (listeners[i].listener === listener) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Alias a method while keeping the context correct, to allow for overwriting of target method.\n     *\n     * @param {String} name The name of the target method.\n     * @return {Function} The aliased method\n     * @api private\n     */\n    function alias(name) {\n        return function aliasClosure() {\n            return this[name].apply(this, arguments);\n        };\n    }\n\n    /**\n     * Returns the listener array for the specified event.\n     * Will initialise the event object and listener arrays if required.\n     * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.\n     * Each property in the object response is an array of listener functions.\n     *\n     * @param {String|RegExp} evt Name of the event to return the listeners from.\n     * @return {Function[]|Object} All listener functions for the event.\n     */\n    proto.getListeners = function getListeners(evt) {\n        var events = this._getEvents();\n        var response;\n        var key;\n\n        // Return a concatenated array of all matching events if\n        // the selector is a regular expression.\n        if (evt instanceof RegExp) {\n            response = {};\n            for (key in events) {\n                if (events.hasOwnProperty(key) && evt.test(key)) {\n                    response[key] = events[key];\n                }\n            }\n        }\n        else {\n            response = events[evt] || (events[evt] = []);\n        }\n\n        return response;\n    };\n\n    /**\n     * Takes a list of listener objects and flattens it into a list of listener functions.\n     *\n     * @param {Object[]} listeners Raw listener objects.\n     * @return {Function[]} Just the listener functions.\n     */\n    proto.flattenListeners = function flattenListeners(listeners) {\n        var flatListeners = [];\n        var i;\n\n        for (i = 0; i < listeners.length; i += 1) {\n            flatListeners.push(listeners[i].listener);\n        }\n\n        return flatListeners;\n    };\n\n    /**\n     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.\n     *\n     * @param {String|RegExp} evt Name of the event to return the listeners from.\n     * @return {Object} All listener functions for an event in an object.\n     */\n    proto.getListenersAsObject = function getListenersAsObject(evt) {\n        var listeners = this.getListeners(evt);\n        var response;\n\n        if (listeners instanceof Array) {\n            response = {};\n            response[evt] = listeners;\n        }\n\n        return response || listeners;\n    };\n\n    function isValidListener (listener) {\n        if (typeof listener === 'function' || listener instanceof RegExp) {\n            return true\n        } else if (listener && typeof listener === 'object') {\n            return isValidListener(listener.listener)\n        } else {\n            return false\n        }\n    }\n\n    /**\n     * Adds a listener function to the specified event.\n     * The listener will not be added if it is a duplicate.\n     * If the listener returns true then it will be removed after it is called.\n     * If you pass a regular expression as the event name then the listener will be added to all events that match it.\n     *\n     * @param {String|RegExp} evt Name of the event to attach the listener to.\n     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.addListener = function addListener(evt, listener) {\n        if (!isValidListener(listener)) {\n            throw new TypeError('listener must be a function');\n        }\n\n        var listeners = this.getListenersAsObject(evt);\n        var listenerIsWrapped = typeof listener === 'object';\n        var key;\n\n        for (key in listeners) {\n            if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {\n                listeners[key].push(listenerIsWrapped ? listener : {\n                    listener: listener,\n                    once: false\n                });\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Alias of addListener\n     */\n    proto.on = alias('addListener');\n\n    /**\n     * Semi-alias of addListener. It will add a listener that will be\n     * automatically removed after its first execution.\n     *\n     * @param {String|RegExp} evt Name of the event to attach the listener to.\n     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.addOnceListener = function addOnceListener(evt, listener) {\n        return this.addListener(evt, {\n            listener: listener,\n            once: true\n        });\n    };\n\n    /**\n     * Alias of addOnceListener.\n     */\n    proto.once = alias('addOnceListener');\n\n    /**\n     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.\n     * You need to tell it what event names should be matched by a regex.\n     *\n     * @param {String} evt Name of the event to create.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.defineEvent = function defineEvent(evt) {\n        this.getListeners(evt);\n        return this;\n    };\n\n    /**\n     * Uses defineEvent to define multiple events.\n     *\n     * @param {String[]} evts An array of event names to define.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.defineEvents = function defineEvents(evts) {\n        for (var i = 0; i < evts.length; i += 1) {\n            this.defineEvent(evts[i]);\n        }\n        return this;\n    };\n\n    /**\n     * Removes a listener function from the specified event.\n     * When passed a regular expression as the event name, it will remove the listener from all events that match it.\n     *\n     * @param {String|RegExp} evt Name of the event to remove the listener from.\n     * @param {Function} listener Method to remove from the event.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.removeListener = function removeListener(evt, listener) {\n        var listeners = this.getListenersAsObject(evt);\n        var index;\n        var key;\n\n        for (key in listeners) {\n            if (listeners.hasOwnProperty(key)) {\n                index = indexOfListener(listeners[key], listener);\n\n                if (index !== -1) {\n                    listeners[key].splice(index, 1);\n                }\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Alias of removeListener\n     */\n    proto.off = alias('removeListener');\n\n    /**\n     * Adds listeners in bulk using the manipulateListeners method.\n     * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.\n     * You can also pass it a regular expression to add the array of listeners to all events that match it.\n     * Yeah, this function does quite a bit. That's probably a bad thing.\n     *\n     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.\n     * @param {Function[]} [listeners] An optional array of listener functions to add.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.addListeners = function addListeners(evt, listeners) {\n        // Pass through to manipulateListeners\n        return this.manipulateListeners(false, evt, listeners);\n    };\n\n    /**\n     * Removes listeners in bulk using the manipulateListeners method.\n     * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n     * You can also pass it an event name and an array of listeners to be removed.\n     * You can also pass it a regular expression to remove the listeners from all events that match it.\n     *\n     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.\n     * @param {Function[]} [listeners] An optional array of listener functions to remove.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.removeListeners = function removeListeners(evt, listeners) {\n        // Pass through to manipulateListeners\n        return this.manipulateListeners(true, evt, listeners);\n    };\n\n    /**\n     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.\n     * The first argument will determine if the listeners are removed (true) or added (false).\n     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.\n     * You can also pass it an event name and an array of listeners to be added/removed.\n     * You can also pass it a regular expression to manipulate the listeners of all events that match it.\n     *\n     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.\n     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.\n     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {\n        var i;\n        var value;\n        var single = remove ? this.removeListener : this.addListener;\n        var multiple = remove ? this.removeListeners : this.addListeners;\n\n        // If evt is an object then pass each of its properties to this method\n        if (typeof evt === 'object' && !(evt instanceof RegExp)) {\n            for (i in evt) {\n                if (evt.hasOwnProperty(i) && (value = evt[i])) {\n                    // Pass the single listener straight through to the singular method\n                    if (typeof value === 'function') {\n                        single.call(this, i, value);\n                    }\n                    else {\n                        // Otherwise pass back to the multiple function\n                        multiple.call(this, i, value);\n                    }\n                }\n            }\n        }\n        else {\n            // So evt must be a string\n            // And listeners must be an array of listeners\n            // Loop over it and pass each one to the multiple method\n            i = listeners.length;\n            while (i--) {\n                single.call(this, evt, listeners[i]);\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Removes all listeners from a specified event.\n     * If you do not specify an event then all listeners will be removed.\n     * That means every event will be emptied.\n     * You can also pass a regex to remove all events that match it.\n     *\n     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.removeEvent = function removeEvent(evt) {\n        var type = typeof evt;\n        var events = this._getEvents();\n        var key;\n\n        // Remove different things depending on the state of evt\n        if (type === 'string') {\n            // Remove all listeners for the specified event\n            delete events[evt];\n        }\n        else if (evt instanceof RegExp) {\n            // Remove all events matching the regex.\n            for (key in events) {\n                if (events.hasOwnProperty(key) && evt.test(key)) {\n                    delete events[key];\n                }\n            }\n        }\n        else {\n            // Remove all listeners in all events\n            delete this._events;\n        }\n\n        return this;\n    };\n\n    /**\n     * Alias of removeEvent.\n     *\n     * Added to mirror the node API.\n     */\n    proto.removeAllListeners = alias('removeEvent');\n\n    /**\n     * Emits an event of your choice.\n     * When emitted, every listener attached to that event will be executed.\n     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.\n     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.\n     * So they will not arrive within the array on the other side, they will be separate.\n     * You can also pass a regular expression to emit to all events that match it.\n     *\n     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n     * @param {Array} [args] Optional array of arguments to be passed to each listener.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.emitEvent = function emitEvent(evt, args) {\n        var listenersMap = this.getListenersAsObject(evt);\n        var listeners;\n        var listener;\n        var i;\n        var key;\n        var response;\n\n        for (key in listenersMap) {\n            if (listenersMap.hasOwnProperty(key)) {\n                listeners = listenersMap[key].slice(0);\n\n                for (i = 0; i < listeners.length; i++) {\n                    // If the listener returns true then it shall be removed from the event\n                    // The function is executed either with a basic call or an apply if there is an args array\n                    listener = listeners[i];\n\n                    if (listener.once === true) {\n                        this.removeListener(evt, listener.listener);\n                    }\n\n                    response = listener.listener.apply(this, args || []);\n\n                    if (response === this._getOnceReturnValue()) {\n                        this.removeListener(evt, listener.listener);\n                    }\n                }\n            }\n        }\n\n        return this;\n    };\n\n    /**\n     * Alias of emitEvent\n     */\n    proto.trigger = alias('emitEvent');\n\n    /**\n     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.\n     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.\n     *\n     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.\n     * @param {...*} Optional additional arguments to be passed to each listener.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.emit = function emit(evt) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return this.emitEvent(evt, args);\n    };\n\n    /**\n     * Sets the current value to check against when executing listeners. If a\n     * listeners return value matches the one set here then it will be removed\n     * after execution. This value defaults to true.\n     *\n     * @param {*} value The new value to check for when executing listeners.\n     * @return {Object} Current instance of EventEmitter for chaining.\n     */\n    proto.setOnceReturnValue = function setOnceReturnValue(value) {\n        this._onceReturnValue = value;\n        return this;\n    };\n\n    /**\n     * Fetches the current value to check against when executing listeners. If\n     * the listeners return value matches this one then it should be removed\n     * automatically. It will return true by default.\n     *\n     * @return {*|Boolean} The current value to check for or the default, true.\n     * @api private\n     */\n    proto._getOnceReturnValue = function _getOnceReturnValue() {\n        if (this.hasOwnProperty('_onceReturnValue')) {\n            return this._onceReturnValue;\n        }\n        else {\n            return true;\n        }\n    };\n\n    /**\n     * Fetches the events object and creates one if required.\n     *\n     * @return {Object} The events storage object.\n     * @api private\n     */\n    proto._getEvents = function _getEvents() {\n        return this._events || (this._events = {});\n    };\n\n    /**\n     * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.\n     *\n     * @return {Function} Non conflicting EventEmitter class.\n     */\n    EventEmitter.noConflict = function noConflict() {\n        exports.EventEmitter = originalGlobalValue;\n        return EventEmitter;\n    };\n\n    // Expose the class either via AMD, CommonJS or the global object\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n            return EventEmitter;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    else {}\n}(typeof window !== 'undefined' ? window : this || {}));\n\n\n/***/ }),\n\n/***/ \"./src/api/geo.ts\":\n/*!************************!*\\\n  !*** ./src/api/geo.ts ***!\n  \\************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3_geo_1 = __webpack_require__(/*! d3-geo */ \"./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js\");\nvar d3_geo_projection_1 = __webpack_require__(/*! d3-geo-projection */ \"./node_modules/_d3-geo-projection@2.1.2@d3-geo-projection/build/d3-geo-projection.js\");\nvar view_1 = __webpack_require__(/*! ../view */ \"./src/view.ts\");\nvar get_geo_projection_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/get-geo-projection */ \"./src/util/get-geo-projection.ts\"));\nvar api = {\n    // geo maintain\n    geoArea: function (feature) {\n        return d3_geo_1.geoArea(feature);\n    },\n    geoAreaByName: function (name) {\n        return d3_geo_1.geoArea(this.geoFeatureByName(name));\n    },\n    geoCentroid: function (feature) {\n        return d3_geo_1.geoCentroid(feature);\n    },\n    geoCentroidByName: function (name) {\n        return d3_geo_1.geoCentroid(this.geoFeatureByName(name));\n    },\n    geoDistance: function (p1, p2) {\n        return d3_geo_1.geoDistance(p1, p2);\n    },\n    geoLength: function (feature) {\n        return d3_geo_1.geoLength(feature);\n    },\n    geoLengthByName: function (name) {\n        return d3_geo_1.geoLength(this.geoFeatureByName(name));\n    },\n    geoContains: function (feature, position /* [longitude, latitude] */) {\n        return d3_geo_1.geoContains(feature, position);\n    },\n    geoFeatureByName: function (name) {\n        var rows = this.rows;\n        var result;\n        rows.some(function (feature) {\n            if (feature.name === name) {\n                result = feature;\n                return true;\n            }\n            return false;\n        });\n        return result;\n    },\n    geoFeatureByPosition: function (position) {\n        var rows = this.rows;\n        var result;\n        rows.some(function (feature) {\n            if (d3_geo_1.geoContains(feature, position)) {\n                result = feature;\n                return true;\n            }\n            return false;\n        });\n        return result;\n    },\n    geoNameByPosition: function (position) {\n        var feature = this.geoFeatureByPosition(position);\n        if (feature) {\n            return feature.name;\n        }\n    },\n    // projection\n    // export getGeoProjection for custom used.\n    getGeoProjection: get_geo_projection_1.default,\n    geoProject: function (feature, projection, exportRaw) {\n        projection = get_geo_projection_1.default(projection, exportRaw);\n        return d3_geo_projection_1.geoProject(feature, projection);\n    },\n    geoProjectByName: function (name, projection, exportRaw) {\n        projection = get_geo_projection_1.default(projection, exportRaw);\n        return d3_geo_projection_1.geoProject(this.geoFeatureByName(name), projection);\n    },\n    geoProjectPosition: function (position, projection, exportRaw) {\n        var func = get_geo_projection_1.default(projection, exportRaw);\n        return func(position);\n    },\n    geoProjectInvert: function (position /* [x, y] */, projection, exportRaw) {\n        var func = get_geo_projection_1.default(projection, exportRaw);\n        return func.invert(position);\n    },\n};\nutil_1.assign(view_1.View.prototype, api);\n\n\n/***/ }),\n\n/***/ \"./src/api/hierarchy.ts\":\n/*!******************************!*\\\n  !*** ./src/api/hierarchy.ts ***!\n  \\******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar view_1 = __webpack_require__(/*! ../view */ \"./src/view.ts\");\nutil_1.assign(view_1.View.prototype, {\n    getAllNodes: function () {\n        var nodes = [];\n        var root = this.root;\n        if (root && root.each) {\n            // d3-hierarchy\n            root.each(function (node) {\n                nodes.push(node);\n            });\n        }\n        else if (root && root.eachNode) {\n            // @antv/hierarchy\n            root.eachNode(function (node) {\n                nodes.push(node);\n            });\n        }\n        return nodes;\n    },\n    getAllLinks: function () {\n        var links = [];\n        var nodes = [this.root];\n        var node;\n        while ((node = nodes.pop())) {\n            var children = node.children;\n            if (children) {\n                children.forEach(function (child) {\n                    links.push({\n                        source: node,\n                        target: child,\n                    });\n                    nodes.push(child);\n                });\n            }\n        }\n        return links;\n    },\n});\nutil_1.assign(view_1.View.prototype, {\n    getAllEdges: view_1.View.prototype.getAllLinks,\n});\n\n\n/***/ }),\n\n/***/ \"./src/api/partition.ts\":\n/*!******************************!*\\\n  !*** ./src/api/partition.ts ***!\n  \\******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar view_1 = __webpack_require__(/*! ../view */ \"./src/view.ts\");\nutil_1.assign(view_1.View.prototype, {\n    partition: function (group_by, order_by) {\n        if (order_by === void 0) { order_by = []; }\n        return partition_1.default(this.rows, group_by, order_by);\n    },\n    group: function (group_by, order_by) {\n        if (order_by === void 0) { order_by = []; }\n        var groups = this.partition(group_by, order_by);\n        return util_1.values(groups);\n    },\n    groups: function (group_by, order_by) {\n        if (order_by === void 0) { order_by = []; }\n        return this.group(group_by, order_by);\n    },\n});\n\n\n/***/ }),\n\n/***/ \"./src/api/statistics.ts\":\n/*!*******************************!*\\\n  !*** ./src/api/statistics.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar simpleStatistics = tslib_1.__importStar(__webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar view_1 = __webpack_require__(/*! ../view */ \"./src/view.ts\");\nvar p_by_fraction_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/p-by-fraction */ \"./src/util/p-by-fraction.ts\"));\nvar constants_1 = tslib_1.__importDefault(__webpack_require__(/*! ../constants */ \"./src/constants.ts\"));\nvar STATISTICS_METHODS = constants_1.default.STATISTICS_METHODS;\nfunction getColumnValues(view, column) {\n    var values = view.getColumn(column);\n    if (util_1.isArray(values) && util_1.isArray(values[0])) {\n        values = util_1.flattenDeep(values);\n    }\n    return values;\n}\n// statistics\nSTATISTICS_METHODS.forEach(function (method) {\n    // @ts-ignore;\n    view_1.View.prototype[method] = function (column) {\n        // @ts-ignore\n        return simpleStatistics[method](getColumnValues(this, column));\n    };\n});\nvar quantile = simpleStatistics.quantile;\nutil_1.assign(view_1.View.prototype, {\n    average: view_1.View.prototype.mean,\n    quantile: function (column, p) {\n        return quantile(getColumnValues(this, column), p);\n    },\n    quantiles: function (column, pArr) {\n        var columnArr = getColumnValues(this, column);\n        return pArr.map(function (p) { return quantile(columnArr, p); });\n    },\n    quantilesByFraction: function (column, fraction) {\n        return this.quantiles(column, p_by_fraction_1.default(fraction));\n    },\n    range: function (column) {\n        return [this.min(column), this.max(column)];\n    },\n    extent: function (column) {\n        // alias\n        return this.range(column);\n    },\n});\n\n\n/***/ }),\n\n/***/ \"./src/connector/default.ts\":\n/*!**********************************!*\\\n  !*** ./src/connector/default.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\ndata_set_1.DataSet.registerConnector('default', function (data, dataSet) {\n    var view;\n    if (util_1.isString(data)) {\n        view = dataSet.getView(data);\n    }\n    else {\n        view = data;\n    }\n    if (!view) {\n        throw new TypeError('Invalid dataView');\n    }\n    return util_1.deepMix([], view.rows);\n});\n\n\n/***/ }),\n\n/***/ \"./src/connector/dsv.ts\":\n/*!******************************!*\\\n  !*** ./src/connector/dsv.ts ***!\n  \\******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3_dsv_1 = __webpack_require__(/*! d3-dsv */ \"./node_modules/_d3-dsv@1.2.0@d3-dsv/dist/d3-dsv.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\ndata_set_1.DataSet.registerConnector('dsv', function (str, options) {\n    if (options === void 0) { options = {}; }\n    var delimiter = options.delimiter || ',';\n    if (!util_1.isString(delimiter)) {\n        throw new TypeError('Invalid delimiter: must be a string!');\n    }\n    return d3_dsv_1.dsvFormat(delimiter).parse(str);\n});\ndata_set_1.DataSet.registerConnector('csv', function (str) {\n    return d3_dsv_1.csvParse(str);\n});\ndata_set_1.DataSet.registerConnector('tsv', function (str) {\n    return d3_dsv_1.tsvParse(str);\n});\n\n\n/***/ }),\n\n/***/ \"./src/connector/geo-graticule.ts\":\n/*!****************************************!*\\\n  !*** ./src/connector/geo-graticule.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar d3_geo_1 = __webpack_require__(/*! d3-geo */ \"./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nfunction connector(_options, dataView) {\n    dataView.dataType = 'geo-graticule';\n    var data = d3_geo_1.geoGraticule().lines();\n    data.map(function (row, index) {\n        row.index = \"\" + index;\n        return row;\n    });\n    dataView.rows = data;\n    return data;\n}\nexports.default = connector;\ndata_set_1.DataSet.registerConnector('geo-graticule', connector);\n\n\n/***/ }),\n\n/***/ \"./src/connector/geojson.ts\":\n/*!**********************************!*\\\n  !*** ./src/connector/geojson.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar point_at_length_1 = tslib_1.__importDefault(__webpack_require__(/*! point-at-length */ \"./node_modules/_point-at-length@1.1.0@point-at-length/index.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3_geo_1 = __webpack_require__(/*! d3-geo */ \"./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar geoPathGenerator = d3_geo_1.geoPath();\nfunction GeoJSONConnector(data, _options, dataView) {\n    dataView.dataType = data_set_1.DataSet.CONSTANTS.GEO;\n    var features = util_1.deepMix([], data.features);\n    // pre-process\n    features.forEach(function (feature) {\n        feature.name = feature.properties.name;\n        feature.longitude = [];\n        feature.latitude = [];\n        var pathData = (feature.pathData = geoPathGenerator(feature));\n        var points = point_at_length_1.default(pathData);\n        points._path.forEach(function (point) {\n            feature.longitude.push(point[1]);\n            feature.latitude.push(point[2]);\n        });\n        var centroid = geoPathGenerator.centroid(feature);\n        feature.centroidX = centroid[0];\n        feature.centroidY = centroid[1];\n    });\n    // dataView.origin = features;\n    return features;\n}\ndata_set_1.DataSet.registerConnector('geo', GeoJSONConnector);\ndata_set_1.DataSet.registerConnector('geojson', GeoJSONConnector);\ndata_set_1.DataSet.registerConnector('GeoJSON', GeoJSONConnector);\nexports.default = GeoJSONConnector;\n\n\n/***/ }),\n\n/***/ \"./src/connector/graph.ts\":\n/*!********************************!*\\\n  !*** ./src/connector/graph.ts ***!\n  \\********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {\n    nodes: function (d) {\n        // optional\n        return d.nodes;\n    },\n    edges: function (d) {\n        // optional\n        return d.edges;\n    },\n};\nfunction connector(data, options, dataView) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    dataView.dataType = data_set_1.DataSet.CONSTANTS.GRAPH;\n    var nodes = options.nodes, edges = options.edges;\n    if (nodes && !util_1.isFunction(nodes)) {\n        throw new TypeError('Invalid nodes: must be a function!');\n    }\n    if (edges && !util_1.isFunction(edges)) {\n        throw new TypeError('Invalid edges: must be a function!');\n    }\n    // @ts-ignore\n    dataView.rows = dataView.graph = {\n        nodes: nodes(data),\n        edges: edges(data),\n    };\n    util_1.assign(dataView, dataView.graph);\n    return dataView.rows;\n}\ndata_set_1.DataSet.registerConnector('graph', connector);\ndata_set_1.DataSet.registerConnector('diagram', connector);\n\n\n/***/ }),\n\n/***/ \"./src/connector/hexjson.ts\":\n/*!**********************************!*\\\n  !*** ./src/connector/hexjson.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3_hexjson_1 = __webpack_require__(/*! d3-hexjson */ \"./node_modules/_d3-hexjson@1.1.0@d3-hexjson/build/d3-hexjson.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {\n    width: 1,\n    height: 1,\n};\nfunction processRow(row) {\n    row.cx = row.x;\n    row.cy = row.y;\n    row.x = [];\n    row.y = [];\n    row.vertices.forEach(function (v) {\n        row.x.push(v.x + row.cx);\n        row.y.push(v.y + row.cy);\n    });\n    return row;\n}\nfunction HexJSONConnector(data, options, dataView) {\n    dataView.dataType = data_set_1.DataSet.CONSTANTS.HEX;\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var width = options.width, height = options.height;\n    var HexJSON = util_1.deepMix([], data);\n    dataView._HexJSON = HexJSON;\n    var grid = (dataView._GridHexJSON = d3_hexjson_1.getGridForHexJSON(HexJSON));\n    var rows = (dataView.rows = d3_hexjson_1.renderHexJSON(HexJSON, width, height).map(processRow));\n    dataView._gridRows = d3_hexjson_1.renderHexJSON(grid, width, height).map(processRow);\n    return rows;\n}\ndata_set_1.DataSet.registerConnector('hex', HexJSONConnector);\ndata_set_1.DataSet.registerConnector('hexjson', HexJSONConnector);\ndata_set_1.DataSet.registerConnector('hex-json', HexJSONConnector);\ndata_set_1.DataSet.registerConnector('HexJSON', HexJSONConnector);\nexports.default = HexJSONConnector;\n\n\n/***/ }),\n\n/***/ \"./src/connector/hierarchy.ts\":\n/*!************************************!*\\\n  !*** ./src/connector/hierarchy.ts ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3_hierarchy_1 = __webpack_require__(/*! d3-hierarchy */ \"./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nfunction connector(data, options, dataView) {\n    dataView.dataType = data_set_1.DataSet.CONSTANTS.HIERARCHY;\n    var children = options && options.children ? options.children : null;\n    if (children && !util_1.isFunction(children)) {\n        throw new TypeError('Invalid children: must be a function!');\n    }\n    if (!options.pureData) {\n        // @ts-ignore\n        dataView.rows = dataView.root = d3_hierarchy_1.hierarchy(data, children);\n    }\n    else {\n        dataView.rows = dataView.root = data;\n    }\n    return data;\n}\ndata_set_1.DataSet.registerConnector('hierarchy', connector);\ndata_set_1.DataSet.registerConnector('tree', connector);\n\n\n/***/ }),\n\n/***/ \"./src/connector/topojson.ts\":\n/*!***********************************!*\\\n  !*** ./src/connector/topojson.ts ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar topojson_client_1 = __webpack_require__(/*! topojson-client */ \"./node_modules/_topojson-client@3.1.0@topojson-client/dist/topojson-client.js\");\nvar geojson_1 = tslib_1.__importDefault(__webpack_require__(/*! ./geojson */ \"./src/connector/geojson.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nfunction TopoJSONConnector(data, options, dataView) {\n    var object = options.object;\n    if (!util_1.isString(object)) {\n        throw new TypeError('Invalid object: must be a string!');\n    }\n    var geoData = topojson_client_1.feature(data, data.objects[object]);\n    return geojson_1.default(geoData, undefined, dataView);\n}\ndata_set_1.DataSet.registerConnector('topojson', TopoJSONConnector);\ndata_set_1.DataSet.registerConnector('TopoJSON', TopoJSONConnector);\n\n\n/***/ }),\n\n/***/ \"./src/constants.ts\":\n/*!**************************!*\\\n  !*** ./src/constants.ts ***!\n  \\**************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = {\n    HIERARCHY: 'hierarchy',\n    GEO: 'geo',\n    HEX: 'hex',\n    GRAPH: 'graph',\n    TABLE: 'table',\n    GEO_GRATICULE: 'geo-graticule',\n    STATISTICS_METHODS: [\n        'max',\n        'mean',\n        'median',\n        'min',\n        'mode',\n        'product',\n        'standardDeviation',\n        'sum',\n        'sumSimple',\n        'variance',\n    ],\n};\n\n\n/***/ }),\n\n/***/ \"./src/data-set.ts\":\n/*!*************************!*\\\n  !*** ./src/data-set.ts ***!\n  \\*************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar wolfy87_eventemitter_1 = tslib_1.__importDefault(__webpack_require__(/*! wolfy87-eventemitter */ \"./node_modules/_wolfy87-eventemitter@5.2.9@wolfy87-eventemitter/EventEmitter.js\"));\nvar view_1 = __webpack_require__(/*! ./view */ \"./src/view.ts\");\nvar constants_1 = tslib_1.__importDefault(__webpack_require__(/*! ./constants */ \"./src/constants.ts\"));\n/**\n * 数据集\n * @public\n */\nvar DataSet = /** @class */ (function (_super) {\n    tslib_1.__extends(DataSet, _super);\n    /**\n     * @param initialProps - 初始状态\n     */\n    function DataSet(initialProps) {\n        if (initialProps === void 0) { initialProps = { state: {} }; }\n        var _this = _super.call(this) || this;\n        /**\n         * 否是 DataSet\n         */\n        _this.isDataSet = true;\n        _this._onChangeTimer = null;\n        /**\n         * 所有挂在数据集上的数据视图（key-value 对）\n         */\n        _this.views = {};\n        /**\n         * 存储数据集上的状态量（key-value 对）\n         */\n        _this.state = {};\n        // assign(me, initialProps);\n        _this.state = initialProps.state;\n        return _this;\n    }\n    /**\n     * 注册一个数据连接函数，注册后所有数据视图都可以使用 name 来引用这个数据连接函数，从而接入某种数据源。\n     * @param name - 类型\n     * @param connector - 解析逻辑\n     */\n    DataSet.registerConnector = function (name, connector) {\n        DataSet.connectors[name] = connector;\n    };\n    DataSet.getConnector = function (name) {\n        return DataSet.connectors[name] || DataSet.connectors.default;\n    };\n    /**\n     * 注册一个数据处理函数，注册后所有数据视图都可以使用 name 来引用这个数据处理函数，从而进行某种数据处理\n     * @param name - transform 类型\n     * @param transform - transform逻辑\n     */\n    DataSet.registerTransform = function (name, transform) {\n        DataSet.transforms[name] = transform;\n    };\n    DataSet.getTransform = function (name) {\n        return DataSet.transforms[name] || DataSet.transforms.default;\n    };\n    DataSet.prototype._getUniqueViewName = function () {\n        var name = util_1.uniqueId('view_');\n        while (this.views[name]) {\n            name = util_1.uniqueId('view_');\n        }\n        return name;\n    };\n    DataSet.prototype.createView = function (name, options) {\n        if (util_1.isNil(name)) {\n            name = this._getUniqueViewName();\n        }\n        if (util_1.isObject(name)) {\n            options = name;\n            name = this._getUniqueViewName();\n        }\n        if (this.views[name]) {\n            throw new Error(\"data view exists: \" + name);\n        }\n        var view = new view_1.View(this, options);\n        this.views[name] = view;\n        return view;\n    };\n    /**\n     * 返回 name 对应的数据视图实例\n     * @param name - name\n     */\n    DataSet.prototype.getView = function (name) {\n        return this.views[name];\n    };\n    /**\n     * 设置 name 对应的数据视图实例为 dv\n     * @param name - 名称\n     * @param view - data view\n     */\n    DataSet.prototype.setView = function (name, view) {\n        this.views[name] = view;\n    };\n    /**\n     * 设置状态量 name 的值为 value\n     * @param name - 状态名\n     * @param value - 值\n     */\n    DataSet.prototype.setState = function (name, value) {\n        var _this = this;\n        this.state[name] = value;\n        if (this._onChangeTimer) {\n            window.clearTimeout(this._onChangeTimer);\n            this._onChangeTimer = null;\n        }\n        this._onChangeTimer = window.setTimeout(function () {\n            _this.emit('statechange', name, value);\n        }, 16); // execute after one frame\n    };\n    /**\n     * 常量，譬如 DataSet.CONSTANTS.HIERARCHY 是树形结构的名称\n     */\n    DataSet.CONSTANTS = constants_1.default;\n    /**\n     * 注册的 Connector（key-value 对）\n     */\n    DataSet.connectors = {};\n    /**\n     * 已注册的 Transform（key-value 对）\n     */\n    DataSet.transforms = {};\n    DataSet.DataSet = DataSet;\n    DataSet.DataView = view_1.View; // alias\n    DataSet.View = view_1.View;\n    DataSet.version = '____DATASET_VERSION____';\n    return DataSet;\n}(wolfy87_eventemitter_1.default));\nexports.DataSet = DataSet;\n// @ts-ignore\nutil_1.assign(DataSet, constants_1.default);\n// @ts-ignore\nutil_1.assign(DataSet.prototype, {\n    view: DataSet.prototype.createView,\n});\nview_1.View.DataSet = DataSet;\n\n\n/***/ }),\n\n/***/ \"./src/index.ts\":\n/*!**********************!*\\\n  !*** ./src/index.ts ***!\n  \\**********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// extra APIs\n__webpack_require__(/*! ./api/geo */ \"./src/api/geo.ts\");\n__webpack_require__(/*! ./api/hierarchy */ \"./src/api/hierarchy.ts\");\n__webpack_require__(/*! ./api/partition */ \"./src/api/partition.ts\");\n__webpack_require__(/*! ./api/statistics */ \"./src/api/statistics.ts\");\n// connectors\n__webpack_require__(/*! ./connector/default */ \"./src/connector/default.ts\");\n__webpack_require__(/*! ./connector/dsv */ \"./src/connector/dsv.ts\");\n__webpack_require__(/*! ./connector/geo-graticule */ \"./src/connector/geo-graticule.ts\");\n__webpack_require__(/*! ./connector/geojson */ \"./src/connector/geojson.ts\");\n__webpack_require__(/*! ./connector/graph */ \"./src/connector/graph.ts\");\n__webpack_require__(/*! ./connector/hexjson */ \"./src/connector/hexjson.ts\");\n__webpack_require__(/*! ./connector/hierarchy */ \"./src/connector/hierarchy.ts\");\n__webpack_require__(/*! ./connector/topojson */ \"./src/connector/topojson.ts\");\n// transforms\n// static\n__webpack_require__(/*! ./transform/default */ \"./src/transform/default.ts\");\n__webpack_require__(/*! ./transform/filter */ \"./src/transform/filter.ts\");\n__webpack_require__(/*! ./transform/fold */ \"./src/transform/fold.ts\");\n__webpack_require__(/*! ./transform/map */ \"./src/transform/map.ts\");\n__webpack_require__(/*! ./transform/partition */ \"./src/transform/partition.ts\");\n__webpack_require__(/*! ./transform/percent */ \"./src/transform/percent.ts\");\n__webpack_require__(/*! ./transform/pick */ \"./src/transform/pick.ts\");\n__webpack_require__(/*! ./transform/proportion */ \"./src/transform/proportion.ts\");\n__webpack_require__(/*! ./transform/rename */ \"./src/transform/rename.ts\");\n__webpack_require__(/*! ./transform/reverse */ \"./src/transform/reverse.ts\");\n__webpack_require__(/*! ./transform/sort */ \"./src/transform/sort.ts\");\n__webpack_require__(/*! ./transform/sort-by */ \"./src/transform/sort-by.ts\");\n__webpack_require__(/*! ./transform/subset */ \"./src/transform/subset.ts\");\n// imputation\n__webpack_require__(/*! ./transform/fill-rows */ \"./src/transform/fill-rows.ts\");\n__webpack_require__(/*! ./transform/impute */ \"./src/transform/impute.ts\");\n// statistics\n__webpack_require__(/*! ./transform/aggregate */ \"./src/transform/aggregate.ts\");\n// regression\n__webpack_require__(/*! ./transform/regression */ \"./src/transform/regression.ts\");\n// KDE\n__webpack_require__(/*! ./transform/kde */ \"./src/transform/kde.ts\");\n// binning\n__webpack_require__(/*! ./transform/bin/hexagon */ \"./src/transform/bin/hexagon.ts\");\n__webpack_require__(/*! ./transform/bin/histogram */ \"./src/transform/bin/histogram.ts\");\n__webpack_require__(/*! ./transform/bin/quantile */ \"./src/transform/bin/quantile.ts\");\n__webpack_require__(/*! ./transform/bin/rectangle */ \"./src/transform/bin/rectangle.ts\");\n// geo\n__webpack_require__(/*! ./transform/geo/centroid */ \"./src/transform/geo/centroid.ts\");\n__webpack_require__(/*! ./transform/geo/projection */ \"./src/transform/geo/projection.ts\");\n__webpack_require__(/*! ./transform/geo/region */ \"./src/transform/geo/region.ts\");\n// diagram\n__webpack_require__(/*! ./transform/diagram/arc */ \"./src/transform/diagram/arc.ts\");\n__webpack_require__(/*! ./transform/diagram/dagre */ \"./src/transform/diagram/dagre.ts\");\n__webpack_require__(/*! ./transform/diagram/sankey */ \"./src/transform/diagram/sankey.ts\");\n__webpack_require__(/*! ./transform/diagram/voronoi */ \"./src/transform/diagram/voronoi.ts\");\n// hierarchy\n__webpack_require__(/*! ./transform/hierarchy/cluster */ \"./src/transform/hierarchy/cluster.ts\");\n__webpack_require__(/*! ./transform/hierarchy/compact-box */ \"./src/transform/hierarchy/compact-box.ts\");\n__webpack_require__(/*! ./transform/hierarchy/dendrogram */ \"./src/transform/hierarchy/dendrogram.ts\");\n__webpack_require__(/*! ./transform/hierarchy/indented */ \"./src/transform/hierarchy/indented.ts\");\n__webpack_require__(/*! ./transform/hierarchy/pack */ \"./src/transform/hierarchy/pack.ts\");\n__webpack_require__(/*! ./transform/hierarchy/partition */ \"./src/transform/hierarchy/partition.ts\");\n__webpack_require__(/*! ./transform/hierarchy/tree */ \"./src/transform/hierarchy/tree.ts\");\n__webpack_require__(/*! ./transform/hierarchy/treemap */ \"./src/transform/hierarchy/treemap.ts\");\n// tag cloud\n__webpack_require__(/*! ./transform/tag-cloud */ \"./src/transform/tag-cloud.ts\");\n// waffle\n__webpack_require__(/*! ./transform/waffle */ \"./src/transform/waffle.ts\");\n// kernel smoothing\n__webpack_require__(/*! ./transform/kernel-smooth/density */ \"./src/transform/kernel-smooth/density.ts\");\n__webpack_require__(/*! ./transform/kernel-smooth/regression */ \"./src/transform/kernel-smooth/regression.ts\");\nvar data_set_1 = __webpack_require__(/*! ./data-set */ \"./src/data-set.ts\");\nmodule.exports = data_set_1.DataSet;\n\n\n/***/ }),\n\n/***/ \"./src/transform/aggregate.ts\":\n/*!************************************!*\\\n  !*** ./src/transform/aggregate.ts ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar simpleStatistics = tslib_1.__importStar(__webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\"));\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar registerTransform = data_set_1.DataSet.registerTransform;\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    as: [],\n    fields: [],\n    groupBy: [],\n    operations: [],\n};\nvar DEFAULT_OPERATION = 'count';\nvar aggregates = {\n    count: function (data) {\n        return data.length;\n    },\n    distinct: function (data, field) {\n        var values = util_1.uniq(data.map(function (row) { return row[field]; }));\n        return values.length;\n    },\n};\ndata_set_1.DataSet.CONSTANTS.STATISTICS_METHODS.forEach(function (method) {\n    aggregates[method] = function (data, field) {\n        var values = data.map(function (row) { return row[field]; });\n        if (util_1.isArray(values) && util_1.isArray(values[0])) {\n            values = util_1.flattenDeep(values);\n        }\n        // @ts-ignore\n        return simpleStatistics[method](values);\n    };\n});\naggregates.average = aggregates.mean;\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    if (!util_1.isArray(fields)) {\n        throw new TypeError('Invalid fields: it must be an array with one or more strings!');\n    }\n    var outputNames = options.as || [];\n    if (util_1.isString(outputNames)) {\n        outputNames = [outputNames];\n    }\n    var operations = options.operations;\n    if (util_1.isString(operations)) {\n        operations = [operations];\n    }\n    var DEFAULT_OPERATIONS = [DEFAULT_OPERATION];\n    if (!util_1.isArray(operations) || !operations.length) {\n        console.warn('operations is not defined, will use [ \"count\" ] directly.');\n        operations = DEFAULT_OPERATIONS;\n        outputNames = operations;\n    }\n    if (!(operations.length === 1 && operations[0] === DEFAULT_OPERATION)) {\n        if (operations.length !== fields.length) {\n            throw new TypeError(\"Invalid operations: it's length must be the same as fields!\");\n        }\n        if (outputNames.length !== fields.length) {\n            throw new TypeError(\"Invalid as: it's length must be the same as fields!\");\n        }\n    }\n    var groups = partition_1.default(dataView.rows, options.groupBy);\n    var results = [];\n    util_1.forIn(groups, function (group) {\n        var result = group[0];\n        operations.forEach(function (operation, i) {\n            var outputName = outputNames[i];\n            var field = fields[i];\n            result[outputName] = aggregates[operation](group, field);\n        });\n        results.push(result);\n    });\n    dataView.rows = results;\n}\nregisterTransform('aggregate', transform);\nregisterTransform('summary', transform);\nexports.default = {\n    VALID_AGGREGATES: util_1.keys(aggregates),\n};\n\n\n/***/ }),\n\n/***/ \"./src/transform/bin/hexagon.ts\":\n/*!**************************************!*\\\n  !*** ./src/transform/bin/hexagon.ts ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'y', 'count'],\n    bins: [30, 30],\n    offset: [0, 0],\n    sizeByCount: false,\n};\nvar SQRT3 = Math.sqrt(3);\nvar THIRD_PI = Math.PI / 3;\nvar ANGLES = [0, THIRD_PI, 2 * THIRD_PI, 3 * THIRD_PI, 4 * THIRD_PI, 5 * THIRD_PI];\nfunction distance(x0, y0, x1, y1) {\n    return Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1));\n}\nfunction nearestBinsCenters(value, scale, offset) {\n    var temp = value - offset;\n    scale = scale / 2;\n    var div = Math.floor(temp / scale);\n    var rounded = scale * (div + (Math.abs(div % 2) === 1 ? 1 : 0));\n    var roundedScaled = scale * (div + (Math.abs(div % 2) === 1 ? 0 : 1));\n    return [rounded + offset, roundedScaled + offset];\n}\nfunction generateBins(points, binWidth, offset) {\n    if (binWidth === void 0) { binWidth = [1, 1]; }\n    if (offset === void 0) { offset = [0, 0]; }\n    // processing aligned data\n    var bins = {};\n    var _a = tslib_1.__read(binWidth, 2), binWidthX = _a[0], binWidthY = _a[1];\n    var _b = tslib_1.__read(offset, 2), offsetX = _b[0], offsetY = _b[1];\n    points.forEach(function (point) {\n        var _a, _b;\n        var _c = tslib_1.__read(point, 2), x = _c[0], y = _c[1];\n        // step3.1: nearest two centers\n        var _d = tslib_1.__read(nearestBinsCenters(x, binWidthX, offsetX), 2), xRounded = _d[0], xRoundedScaled = _d[1];\n        var _e = tslib_1.__read(nearestBinsCenters(y, binWidthY, offsetY), 2), yRounded = _e[0], yRoundedScaled = _e[1];\n        // step3.2: compare distances\n        var d1 = distance(x, y, xRounded, yRounded);\n        var d2 = distance(x, y, xRoundedScaled, yRoundedScaled);\n        var binKey;\n        var binX;\n        var binY;\n        if (d1 < d2) {\n            binKey = \"x\" + xRounded + \"y\" + yRounded;\n            _a = tslib_1.__read([xRounded, yRounded], 2), binX = _a[0], binY = _a[1];\n        }\n        else {\n            binKey = \"x\" + xRoundedScaled + \"y\" + yRoundedScaled;\n            _b = tslib_1.__read([xRoundedScaled, yRoundedScaled], 2), binX = _b[0], binY = _b[1];\n        }\n        bins[binKey] = bins[binKey] || {\n            x: binX,\n            y: binY,\n            count: 0,\n        };\n        bins[binKey].count++;\n    });\n    return bins;\n}\nfunction transform(dataView, options) {\n    // step1: get binWidth, etc.\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    if (!util_1.isArray(fields) || fields.length !== 2) {\n        throw new TypeError('Invalid fields: it must be an array with 2 strings!');\n    }\n    var _a = tslib_1.__read(fields, 2), fieldX = _a[0], fieldY = _a[1];\n    var rangeFieldX = dataView.range(fieldX);\n    var rangeFieldY = dataView.range(fieldY);\n    var widthX = rangeFieldX[1] - rangeFieldX[0];\n    var widthY = rangeFieldY[1] - rangeFieldY[0];\n    var binWidth = options.binWidth || [];\n    if (binWidth.length !== 2) {\n        var _b = tslib_1.__read(options.bins, 2), binsX = _b[0], binsY = _b[1];\n        if (binsX <= 0 || binsY <= 0) {\n            throw new TypeError('Invalid bins: must be an array with two positive numbers (e.g. [ 30, 30 ])!');\n        }\n        binWidth = [widthX / binsX, widthY / binsY];\n    }\n    // step2: align scale (squash Y)\n    /*\n     * binWidthX / binWidthY should be Math.sqrt3 / 1.5\n     * -: binWidthX |: binWidthY\n     *           3\n     *           |\n     *   4       |        2\n     *           |\n     *           |\n     *   5----------------1\n     *\n     *           0\n     */\n    var _c = tslib_1.__read(options.offset, 2), offsetX = _c[0], offsetY = _c[1];\n    var yScale = (3 * binWidth[0]) / (SQRT3 * binWidth[1]);\n    // const yScale = binWidth[0] / (SQRT3 * binWidth[1]);\n    var points = dataView.rows.map(function (row) { return [row[fieldX], yScale * row[fieldY]]; });\n    // step3: binning\n    var bins = generateBins(points, [binWidth[0], yScale * binWidth[1]], [offsetX, yScale * offsetY]);\n    // step4: restore scale (for Y)\n    var _d = tslib_1.__read(options.as, 3), asX = _d[0], asY = _d[1], asCount = _d[2];\n    if (!asX || !asY || !asCount) {\n        throw new TypeError('Invalid as: it must be an array with three elements (e.g. [ \"x\", \"y\", \"count\" ])!');\n    }\n    var radius = binWidth[0] / SQRT3;\n    var hexagonPoints = ANGLES.map(function (angle) { return [Math.sin(angle) * radius, -Math.cos(angle) * radius]; });\n    var result = [];\n    var maxCount = 0;\n    if (options.sizeByCount) {\n        util_1.forIn(bins, function (bin) {\n            if (bin.count > maxCount) {\n                maxCount = bin.count;\n            }\n        });\n    }\n    util_1.forIn(bins, function (bin) {\n        var x = bin.x, y = bin.y, count = bin.count;\n        var row = {};\n        row[asCount] = count;\n        if (options.sizeByCount) {\n            row[asX] = hexagonPoints.map(function (p) { return x + (bin.count / maxCount) * p[0]; });\n            row[asY] = hexagonPoints.map(function (p) { return (y + (bin.count / maxCount) * p[1]) / yScale; });\n        }\n        else {\n            row[asX] = hexagonPoints.map(function (p) { return x + p[0]; });\n            row[asY] = hexagonPoints.map(function (p) { return (y + p[1]) / yScale; });\n        }\n        result.push(row);\n    });\n    dataView.rows = result;\n}\ndata_set_1.DataSet.registerTransform('bin.hexagon', transform);\ndata_set_1.DataSet.registerTransform('bin.hex', transform);\ndata_set_1.DataSet.registerTransform('hexbin', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/bin/histogram.ts\":\n/*!****************************************!*\\\n  !*** ./src/transform/bin/histogram.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'count'],\n    bins: 30,\n    offset: 0,\n    groupBy: [],\n};\nfunction nearestBin(value, scale, offset) {\n    var temp = value - offset;\n    var div = Math.floor(temp / scale);\n    return [div * scale + offset, (div + 1) * scale + offset];\n}\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var field = option_parser_1.getField(options);\n    if (dataView.rows.length === 0) {\n        return;\n    }\n    var range = dataView.range(field);\n    var width = range[1] - range[0];\n    var binWidth = options.binWidth;\n    if (!binWidth) {\n        var bins = options.bins;\n        if (bins <= 0) {\n            throw new TypeError('Invalid bins: it must be a positive number!');\n        }\n        binWidth = width / bins;\n    }\n    var offset = options.offset % binWidth;\n    // grouping\n    var rows = [];\n    var groupBy = options.groupBy;\n    var groups = partition_1.default(dataView.rows, groupBy);\n    util_1.forIn(groups, function (group) {\n        var bins = {};\n        var column = group.map(function (row) { return row[field]; });\n        column.forEach(function (value) {\n            var _a = tslib_1.__read(nearestBin(value, binWidth, offset), 2), x0 = _a[0], x1 = _a[1];\n            var binKey = x0 + \"-\" + x1;\n            bins[binKey] = bins[binKey] || {\n                x0: x0,\n                x1: x1,\n                count: 0,\n            };\n            bins[binKey].count++;\n        });\n        var _a = tslib_1.__read(options.as, 2), asX = _a[0], asCount = _a[1];\n        if (!asX || !asCount) {\n            throw new TypeError('Invalid as: it must be an array with 2 elements (e.g. [ \"x\", \"count\" ])!');\n        }\n        var meta = util_1.pick(group[0], groupBy);\n        util_1.forIn(bins, function (bin) {\n            var row = util_1.assign({}, meta);\n            row[asX] = [bin.x0, bin.x1];\n            row[asCount] = bin.count;\n            rows.push(row);\n        });\n    });\n    dataView.rows = rows;\n}\ndata_set_1.DataSet.registerTransform('bin.histogram', transform);\ndata_set_1.DataSet.registerTransform('bin.dot', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/bin/quantile.ts\":\n/*!***************************************!*\\\n  !*** ./src/transform/bin/quantile.ts ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar simple_statistics_1 = __webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/partition */ \"./src/util/partition.ts\"));\nvar p_by_fraction_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/p-by-fraction */ \"./src/util/p-by-fraction.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar registerTransform = data_set_1.DataSet.registerTransform;\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    as: '_bin',\n    groupBy: [],\n    fraction: 4,\n};\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var field = option_parser_1.getField(options);\n    var as = options.as;\n    if (!util_1.isString(as)) {\n        throw new TypeError('Invalid as: it must be a string (e.g. \"_bin\")!');\n    }\n    var pArray = options.p;\n    var fraction = options.fraction;\n    if (!util_1.isArray(pArray) || pArray.length === 0) {\n        pArray = p_by_fraction_1.default(fraction);\n    }\n    var rows = dataView.rows;\n    var groupBy = options.groupBy;\n    var groups = partition_1.default(rows, groupBy);\n    var result = [];\n    util_1.forIn(groups, function (group) {\n        // const resultRow = pick(group[0], groupBy);\n        var resultRow = group[0];\n        var binningColumn = group.map(function (row) { return row[field]; });\n        var quantiles = pArray.map(function (p) { return simple_statistics_1.quantile(binningColumn, p); });\n        resultRow[as] = quantiles;\n        result.push(resultRow);\n    });\n    dataView.rows = result;\n}\nregisterTransform('bin.quantile', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/bin/rectangle.ts\":\n/*!****************************************!*\\\n  !*** ./src/transform/bin/rectangle.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar registerTransform = data_set_1.DataSet.registerTransform;\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'y', 'count'],\n    bins: [30, 30],\n    offset: [0, 0],\n    sizeByCount: false,\n};\nfunction nearestBin(value, scale, offset) {\n    var temp = value - offset;\n    var div = Math.floor(temp / scale);\n    return [div * scale + offset, (div + 1) * scale + offset];\n}\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var _a = tslib_1.__read(option_parser_1.getFields(options), 2), fieldX = _a[0], fieldY = _a[1];\n    if (!fieldX || !fieldY) {\n        throw new TypeError('Invalid fields: must be an array with 2 strings!');\n    }\n    var rangeFieldX = dataView.range(fieldX);\n    var rangeFieldY = dataView.range(fieldY);\n    var widthX = rangeFieldX[1] - rangeFieldX[0];\n    var widthY = rangeFieldY[1] - rangeFieldY[0];\n    var binWidth = options.binWidth || [];\n    if (binWidth.length !== 2) {\n        var _b = tslib_1.__read(options.bins, 2), binsX = _b[0], binsY = _b[1];\n        if (binsX <= 0 || binsY <= 0) {\n            throw new TypeError('Invalid bins: must be an array with 2 positive numbers (e.g. [ 30, 30 ])!');\n        }\n        binWidth = [widthX / binsX, widthY / binsY];\n    }\n    var points = dataView.rows.map(function (row) { return [row[fieldX], row[fieldY]]; });\n    var bins = {};\n    var _c = tslib_1.__read(options.offset, 2), offsetX = _c[0], offsetY = _c[1];\n    points.forEach(function (point) {\n        var _a = tslib_1.__read(nearestBin(point[0], binWidth[0], offsetX), 2), x0 = _a[0], x1 = _a[1];\n        var _b = tslib_1.__read(nearestBin(point[1], binWidth[1], offsetY), 2), y0 = _b[0], y1 = _b[1];\n        var binKey = x0 + \"-\" + x1 + \"-\" + y0 + \"-\" + y1;\n        bins[binKey] = bins[binKey] || {\n            x0: x0,\n            x1: x1,\n            y0: y0,\n            y1: y1,\n            count: 0,\n        };\n        bins[binKey].count++;\n    });\n    var rows = [];\n    var _d = tslib_1.__read(options.as, 3), asX = _d[0], asY = _d[1], asCount = _d[2];\n    if (!asX || !asY || !asCount) {\n        throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ \"x\", \"y\", \"count\" ])!');\n    }\n    /* points\n     * 3---2\n     * |   |\n     * 0---1\n     */\n    if (!options.sizeByCount) {\n        util_1.forIn(bins, function (bin) {\n            var row = {};\n            row[asX] = [bin.x0, bin.x1, bin.x1, bin.x0];\n            row[asY] = [bin.y0, bin.y0, bin.y1, bin.y1];\n            row[asCount] = bin.count;\n            rows.push(row);\n        });\n    }\n    else {\n        var maxCount_1 = 0;\n        util_1.forIn(bins, function (bin) {\n            if (bin.count > maxCount_1) {\n                maxCount_1 = bin.count;\n            }\n        });\n        util_1.forIn(bins, function (bin) {\n            var x0 = bin.x0, x1 = bin.x1, y0 = bin.y0, y1 = bin.y1, count = bin.count;\n            var scale = count / maxCount_1;\n            var _a = tslib_1.__read([(x0 + x1) / 2, (y0 + y1) / 2], 2), cx = _a[0], cy = _a[1];\n            var rx = ((x1 - x0) * scale) / 2;\n            var ry = ((y1 - y0) * scale) / 2;\n            var x01 = cx - rx;\n            var x11 = cx + rx;\n            var y01 = cy - ry;\n            var y11 = cy + ry;\n            var row = {};\n            row[asX] = [x01, x11, x11, x01];\n            row[asY] = [y01, y01, y11, y11];\n            row[asCount] = count;\n            rows.push(row);\n        });\n    }\n    dataView.rows = rows;\n}\nregisterTransform('bin.rectangle', transform);\nregisterTransform('bin.rect', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/default.ts\":\n/*!**********************************!*\\\n  !*** ./src/transform/default.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\ndata_set_1.DataSet.registerTransform('default', function (dataView) {\n    return dataView;\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/diagram/arc.ts\":\n/*!**************************************!*\\\n  !*** ./src/transform/diagram/arc.ts ***!\n  \\**************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * for Arc Diagram (edges without weight) / Chord Diagram (edges with source and target weight)\n * graph data required (nodes, edges)\n */\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {\n    y: 0,\n    thickness: 0.05,\n    weight: false,\n    marginRatio: 0.1,\n    id: function (node) { return node.id; },\n    source: function (edge) { return edge.source; },\n    target: function (edge) { return edge.target; },\n    sourceWeight: function (edge) { return edge.value || 1; },\n    targetWeight: function (edge) { return edge.value || 1; },\n    sortBy: null,\n};\nfunction _nodesFromEdges(edges, options, map) {\n    if (map === void 0) { map = {}; }\n    edges.forEach(function (edge) {\n        var sId = options.edgeSource(edge);\n        var tId = options.edgeTarget(edge);\n        if (!map[sId]) {\n            map[sId] = {\n                id: sId,\n            };\n        }\n        if (!map[tId]) {\n            map[tId] = {\n                id: tId,\n            };\n        }\n    });\n    return util_1.values(map);\n}\nfunction _processGraph(nodeById, edges, options) {\n    util_1.forIn(nodeById, function (node, id) {\n        // in edges, out edges\n        node.inEdges = edges.filter(function (edge) { return \"\" + options.target(edge) === \"\" + id; });\n        node.outEdges = edges.filter(function (edge) { return \"\" + options.source(edge) === \"\" + id; });\n        // frequency\n        node.edges = node.outEdges.concat(node.inEdges);\n        node.frequency = node.edges.length;\n        // weight\n        node.value = 0;\n        node.inEdges.forEach(function (edge) {\n            node.value += options.targetWeight(edge);\n        });\n        node.outEdges.forEach(function (edge) {\n            node.value += options.sourceWeight(edge);\n        });\n    });\n}\nfunction _sortNodes(nodes, options) {\n    var sortMethods = {\n        weight: function (a, b) { return b.value - a.value; },\n        frequency: function (a, b) { return b.frequency - a.frequency; },\n        id: function (a, b) { return (\"\" + options.id(a)).localeCompare(\"\" + options.id(b)); },\n    };\n    var method = sortMethods[options.sortBy];\n    if (!method && util_1.isFunction(options.sortBy)) {\n        method = options.sortBy;\n    }\n    if (method) {\n        nodes.sort(method);\n    }\n}\nfunction _layoutNodes(nodes, options) {\n    var len = nodes.length;\n    if (!len) {\n        throw new TypeError(\"Invalid nodes: it's empty!\");\n    }\n    if (options.weight) {\n        var marginRatio_1 = options.marginRatio;\n        if (marginRatio_1 < 0 || marginRatio_1 >= 1) {\n            throw new TypeError('Invalid marginRatio: it must be in range [0, 1)!');\n        }\n        var margin_1 = marginRatio_1 / (2 * len);\n        var thickness_1 = options.thickness;\n        if (thickness_1 <= 0 || thickness_1 >= 1) {\n            throw new TypeError('Invalid thickness: it must be in range (0, 1)!');\n        }\n        var totalValue_1 = 0;\n        nodes.forEach(function (node) {\n            totalValue_1 += node.value;\n        });\n        nodes.forEach(function (node) {\n            node.weight = node.value / totalValue_1;\n            node.width = node.weight * (1 - marginRatio_1);\n            node.height = thickness_1;\n        });\n        nodes.forEach(function (node, index) {\n            // x\n            var deltaX = 0;\n            for (var i = index - 1; i >= 0; i--) {\n                deltaX += nodes[i].width + 2 * margin_1;\n            }\n            var minX = (node.minX = margin_1 + deltaX);\n            var maxX = (node.maxX = node.minX + node.width);\n            var minY = (node.minY = options.y - thickness_1 / 2);\n            var maxY = (node.maxY = minY + thickness_1);\n            node.x = [minX, maxX, maxX, minX];\n            node.y = [minY, minY, maxY, maxY];\n            /* points\n             * 3---2\n             * |   |\n             * 0---1\n             */\n            // node.x = minX + 0.5 * node.width;\n            // node.y = options.y;\n        });\n    }\n    else {\n        var deltaX_1 = 1 / len;\n        nodes.forEach(function (node, index) {\n            node.x = (index + 0.5) * deltaX_1;\n            node.y = options.y;\n        });\n    }\n}\nfunction _locatingEdges(nodeById, edges, options) {\n    if (options.weight) {\n        var valueById_1 = {};\n        util_1.forIn(nodeById, function (node, id) {\n            valueById_1[id] = node.value;\n        });\n        edges.forEach(function (edge) {\n            var sId = options.source(edge);\n            var tId = options.target(edge);\n            var sNode = nodeById[sId];\n            var tNode = nodeById[tId];\n            if (sNode && tNode) {\n                var sValue = valueById_1[sId];\n                var currentSValue = options.sourceWeight(edge);\n                var sStart = sNode.minX + ((sNode.value - sValue) / sNode.value) * sNode.width;\n                var sEnd = sStart + (currentSValue / sNode.value) * sNode.width;\n                valueById_1[sId] -= currentSValue;\n                var tValue = valueById_1[tId];\n                var currentTValue = options.targetWeight(edge);\n                var tStart = tNode.minX + ((tNode.value - tValue) / tNode.value) * tNode.width;\n                var tEnd = tStart + (currentTValue / tNode.value) * tNode.width;\n                valueById_1[tId] -= currentTValue;\n                var y = options.y;\n                edge.x = [sStart, sEnd, tStart, tEnd];\n                edge.y = [y, y, y, y];\n            }\n        });\n    }\n    else {\n        edges.forEach(function (edge) {\n            var sNode = nodeById[options.source(edge)];\n            var tNode = nodeById[options.target(edge)];\n            if (sNode && tNode) {\n                edge.x = [sNode.x, tNode.x];\n                edge.y = [sNode.y, tNode.y];\n            }\n        });\n    }\n}\nfunction transform(dv, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var nodeById = {};\n    var nodes = dv.nodes;\n    var edges = dv.edges;\n    if (!util_1.isArray(nodes) || nodes.length === 0) {\n        nodes = _nodesFromEdges(edges, options, nodeById);\n    }\n    nodes.forEach(function (node) {\n        var id = options.id(node);\n        nodeById[id] = node;\n    });\n    _processGraph(nodeById, edges, options);\n    _sortNodes(nodes, options);\n    _layoutNodes(nodes, options);\n    _locatingEdges(nodeById, edges, options);\n    dv.nodes = nodes;\n    dv.edges = edges;\n}\ndata_set_1.DataSet.registerTransform('diagram.arc', transform);\ndata_set_1.DataSet.registerTransform('arc', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/diagram/dagre.ts\":\n/*!****************************************!*\\\n  !*** ./src/transform/diagram/dagre.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\n/*\n * for DAG\n * graph data required (nodes, edges)\n */\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar dagre_1 = tslib_1.__importDefault(__webpack_require__(/*! dagre */ \"./node_modules/_dagre@0.8.5@dagre/index.js\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {\n    // nodeId: node => node.index,\n    rankdir: 'TB',\n    align: 'TB',\n    nodesep: 50,\n    edgesep: 10,\n    ranksep: 50,\n    source: function (edge) { return edge.source; },\n    target: function (edge) { return edge.target; },\n};\nfunction transform(dv, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var g = new dagre_1.default.graphlib.Graph();\n    // Set an object for the graph label\n    g.setGraph({});\n    // Default to assigning a new object as a label for each new edge.\n    g.setDefaultEdgeLabel(function () {\n        return {};\n    });\n    dv.nodes.forEach(function (node) {\n        var nodeId = options.nodeId ? options.nodeId(node) : node.id;\n        if (!node.height && !node.width) {\n            node.height = node.width = options.edgesep;\n        }\n        g.setNode(nodeId, node);\n    });\n    dv.edges.forEach(function (edge) {\n        g.setEdge(options.source(edge), options.target(edge));\n    });\n    dagre_1.default.layout(g);\n    var nodes = [];\n    var edges = [];\n    g.nodes().forEach(function (node) {\n        var n = g.node(node);\n        var x = n.x, y = n.y, height = n.height, width = n.width;\n        /* points\n         * 3---2\n         * |   |\n         * 0---1\n         */\n        // @ts-ignore\n        n.x = [x - width / 2, x + width / 2, x + width / 2, x - width / 2];\n        // @ts-ignore\n        n.y = [y + height / 2, y + height / 2, y - height / 2, y - height / 2];\n        nodes.push(n);\n    });\n    g.edges().forEach(function (edge) {\n        var points = g.edge(edge).points;\n        var e = {};\n        e.x = points.map(function (p) { return p.x; });\n        e.y = points.map(function (p) { return p.y; });\n        edges.push(e);\n    });\n    dv.nodes = nodes;\n    dv.edges = edges;\n}\ndata_set_1.DataSet.registerTransform('diagram.dagre', transform);\ndata_set_1.DataSet.registerTransform('dagre', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/diagram/sankey.ts\":\n/*!*****************************************!*\\\n  !*** ./src/transform/diagram/sankey.ts ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * for Sankey Diagram\n * graph data required (nodes, edges)\n */\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3_sankey_1 = __webpack_require__(/*! d3-sankey */ \"./node_modules/_d3-sankey@0.9.1@d3-sankey/dist/d3-sankey.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar ALIGN_METHOD = {\n    sankeyLeft: d3_sankey_1.sankeyLeft,\n    sankeyRight: d3_sankey_1.sankeyRight,\n    sankeyCenter: d3_sankey_1.sankeyCenter,\n    sankeyJustify: d3_sankey_1.sankeyJustify,\n};\nvar DEFAULT_OPTIONS = {\n    // nodeId: node => node.index,\n    value: function (node) { return node.value; },\n    source: function (edge) { return edge.source; },\n    target: function (edge) { return edge.target; },\n    nodeAlign: 'sankeyJustify',\n    nodeWidth: 0.02,\n    nodePadding: 0.02,\n    sort: undefined,\n};\nfunction transform(dv, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var nodeAlign = null;\n    if (util_1.isString(options.nodeAlign)) {\n        nodeAlign = ALIGN_METHOD[options.nodeAlign];\n    }\n    else if (util_1.isFunction(options.nodeAlign)) {\n        nodeAlign = options.nodeAlign;\n    }\n    var sankeyProcessor = d3_sankey_1.sankey()\n        .nodeSort(options.sort)\n        .links(function (d) { return d.edges; })\n        .nodeWidth(options.nodeWidth)\n        .nodePadding(options.nodePadding)\n        .extent([\n        [0, 0],\n        [1, 1],\n    ]);\n    if (util_1.isFunction(options.nodeId)) {\n        sankeyProcessor.nodeId(options.nodeId);\n    }\n    if (nodeAlign) {\n        sankeyProcessor.nodeAlign(nodeAlign);\n    }\n    // TODO:\n    // @ts-ignore\n    sankeyProcessor(dv);\n    // post process (x, y), etc.\n    dv.nodes.forEach(function (node) {\n        var x0 = node.x0, x1 = node.x1, y0 = node.y0, y1 = node.y1;\n        /* points\n         * 3---2\n         * |   |\n         * 0---1\n         */\n        node.x = [x0, x1, x1, x0];\n        node.y = [y0, y0, y1, y1];\n    });\n    dv.edges.forEach(function (edge) {\n        var source = edge.source, target = edge.target;\n        var sx = source.x1;\n        var tx = target.x0;\n        edge.x = [sx, sx, tx, tx];\n        var offset = edge.width / 2;\n        edge.y = [edge.y0 + offset, edge.y0 - offset, edge.y1 + offset, edge.y1 - offset];\n    });\n}\ndata_set_1.DataSet.registerTransform('diagram.sankey', transform);\ndata_set_1.DataSet.registerTransform('sankey', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/diagram/voronoi.ts\":\n/*!******************************************!*\\\n  !*** ./src/transform/diagram/voronoi.ts ***!\n  \\******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar d3Voronoi = tslib_1.__importStar(__webpack_require__(/*! d3-voronoi */ \"./node_modules/_d3-voronoi@1.1.4@d3-voronoi/dist/d3-voronoi.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar registerTransform = data_set_1.DataSet.registerTransform;\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    // fields: [ 'x', 'y' ] // field x and field y, required\n    // extend: [[x0, y0], [x1, y1]], // optional\n    // size: [width, height], // optional\n    as: ['_x', '_y'],\n};\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: must be an array with two strings!');\n    }\n    var xField = as[0];\n    var yField = as[1];\n    var fields = option_parser_1.getFields(options);\n    if (!util_1.isArray(fields) || fields.length !== 2) {\n        throw new TypeError('Invalid fields: must be an array with two strings!');\n    }\n    var x = fields[0];\n    var y = fields[1];\n    var rows = dataView.rows;\n    var data = rows.map(function (row) { return [row[x], row[y]]; });\n    var voronoi = d3Voronoi.voronoi();\n    if (options.extend) {\n        voronoi.extent(options.extend);\n    }\n    if (options.size) {\n        voronoi.size(options.size);\n    }\n    var polygons = voronoi(data).polygons();\n    rows.forEach(function (row, i) {\n        var polygon = polygons[i].filter(function (point) { return !!point; }); // some points are null\n        row[xField] = polygon.map(function (point) { return point[0]; });\n        row[yField] = polygon.map(function (point) { return point[1]; });\n    });\n}\nregisterTransform('diagram.voronoi', transform);\nregisterTransform('voronoi', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/fill-rows.ts\":\n/*!************************************!*\\\n  !*** ./src/transform/fill-rows.ts ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {\n    fillBy: 'group',\n    groupBy: [],\n    orderBy: [],\n};\nfunction arrayDifference(arr1, arr2) {\n    // arrayDifference([1, 1, 1, 2], [1, 2]) => [1, 1]\n    var shadow = arr1.map(function (item) { return item; }); // shadow copy\n    arr2.forEach(function (item) {\n        var index = shadow.indexOf(item);\n        if (index > -1) {\n            shadow.splice(index, 1);\n        }\n    });\n    return shadow;\n}\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var rows = dataView.rows;\n    var groupBy = options.groupBy;\n    var orderBy = options.orderBy;\n    var groups = partition_1.default(rows, groupBy, orderBy);\n    var maxLength = 0;\n    var referenceGroup = [];\n    util_1.forIn(groups, function (group) {\n        if (group.length > maxLength) {\n            maxLength = group.length;\n            referenceGroup = group;\n        }\n    });\n    var referenceOrderByKeys = [];\n    var referenceRowByOrderByKey = {};\n    referenceGroup.forEach(function (row) {\n        var key = orderBy.map(function (col) { return row[col]; }).join('-');\n        referenceOrderByKeys.push(key);\n        referenceRowByOrderByKey[key] = row;\n    });\n    if (options.fillBy === 'order') {\n        var first_1 = referenceGroup[0];\n        var allOrderByKeys_1 = [];\n        var rowByOrderByKey_1 = {};\n        rows.forEach(function (row) {\n            var key = orderBy.map(function (col) { return row[col]; }).join('-');\n            if (allOrderByKeys_1.indexOf(key) === -1) {\n                allOrderByKeys_1.push(key);\n                rowByOrderByKey_1[key] = row;\n            }\n        });\n        var _missingOrderByKeys = arrayDifference(allOrderByKeys_1, referenceOrderByKeys);\n        _missingOrderByKeys.forEach(function (key) {\n            var row = {};\n            groupBy.forEach(function (col) {\n                row[col] = first_1[col];\n            });\n            orderBy.forEach(function (col) {\n                row[col] = rowByOrderByKey_1[key][col];\n            });\n            rows.push(row);\n            referenceGroup.push(row);\n            referenceOrderByKeys.push(key);\n            referenceRowByOrderByKey[key] = row;\n        });\n        maxLength = referenceGroup.length;\n    }\n    util_1.forIn(groups, function (group) {\n        if (group !== referenceGroup && group.length < maxLength) {\n            var first_2 = group[0];\n            // missing orderBy keys\n            var orderByKeys_1 = [];\n            group.forEach(function (row) {\n                orderByKeys_1.push(orderBy.map(function (col) { return row[col]; }).join('-'));\n            });\n            var missingOrderByKeys = arrayDifference(referenceOrderByKeys, orderByKeys_1);\n            missingOrderByKeys.some(function (key, i) {\n                if (i >= maxLength - group.length) {\n                    // group length overflow\n                    return true;\n                }\n                var referenceRow = referenceRowByOrderByKey[key];\n                var row = {};\n                groupBy.forEach(function (col) {\n                    row[col] = first_2[col];\n                });\n                orderBy.forEach(function (col) {\n                    row[col] = referenceRow[col];\n                });\n                rows.push(row);\n                return false;\n            });\n        }\n    });\n}\ndata_set_1.DataSet.registerTransform('fill-rows', transform);\ndata_set_1.DataSet.registerTransform('fillRows', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/filter.ts\":\n/*!*********************************!*\\\n  !*** ./src/transform/filter.ts ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nfunction defaultCallback(row) {\n    return !!row;\n}\ndata_set_1.DataSet.registerTransform('filter', function (dataView, options) {\n    dataView.rows = dataView.rows.filter(options.callback || defaultCallback);\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/fold.ts\":\n/*!*******************************!*\\\n  !*** ./src/transform/fold.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    fields: [],\n    key: 'key',\n    retains: [],\n    value: 'value',\n};\ndata_set_1.DataSet.registerTransform('fold', function (dataView, options) {\n    var columns = dataView.getColumnNames();\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    if (fields.length === 0) {\n        console.warn('warning: option fields is not specified, will fold all columns.');\n        fields = columns;\n    }\n    var key = options.key;\n    var value = options.value;\n    var retains = options.retains;\n    if (!retains || retains.length === 0) {\n        retains = util_1.difference(columns, fields);\n    }\n    var resultRows = [];\n    dataView.rows.forEach(function (row) {\n        fields.forEach(function (field) {\n            var resultRow = util_1.pick(row, retains);\n            resultRow[key] = field;\n            resultRow[value] = row[field];\n            resultRows.push(resultRow);\n        });\n    });\n    dataView.rows = resultRows;\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/geo/centroid.ts\":\n/*!***************************************!*\\\n  !*** ./src/transform/geo/centroid.ts ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar registerTransform = data_set_1.DataSet.registerTransform;\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    // field: 'name', // required\n    // geoView: view, // required\n    // geoDataView: view, // alias\n    as: ['_centroid_x', '_centroid_y'],\n};\nfunction transform(view, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var field = option_parser_1.getField(options);\n    // @ts-ignore\n    var geoView = options.geoView || options.geoDataView; // alias\n    if (util_1.isString(geoView) && view.dataSet) {\n        geoView = view.dataSet.getView(geoView);\n    }\n    if (!geoView || geoView.dataType !== 'geo') {\n        throw new TypeError('Invalid geoView: must be a DataView of GEO dataType!');\n    }\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"cX\", \"cY\" ])!');\n    }\n    var centroidX = as[0];\n    var centroidY = as[1];\n    view.rows.forEach(function (row) {\n        var feature = geoView.geoFeatureByName(row[field]);\n        if (feature) {\n            if (geoView._projectedAs) {\n                row[centroidX] = feature[geoView._projectedAs[2]];\n                row[centroidY] = feature[geoView._projectedAs[3]];\n            }\n            else {\n                row[centroidX] = feature.centroidX;\n                row[centroidY] = feature.centroidY;\n            }\n        }\n    });\n}\nregisterTransform('geo.centroid', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/geo/projection.ts\":\n/*!*****************************************!*\\\n  !*** ./src/transform/geo/projection.ts ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3_geo_1 = __webpack_require__(/*! d3-geo */ \"./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js\");\nvar point_at_length_1 = tslib_1.__importDefault(__webpack_require__(/*! point-at-length */ \"./node_modules/_point-at-length@1.1.0@point-at-length/index.js\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar registerTransform = data_set_1.DataSet.registerTransform;\nvar get_geo_projection_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/get-geo-projection */ \"./src/util/get-geo-projection.ts\"));\nvar DEFAULT_OPTIONS = {\n    // projection: '', // default to null\n    as: ['_x', '_y', '_centroid_x', '_centroid_y'],\n};\nfunction transform(dataView, options) {\n    if (dataView.dataType !== 'geo' && dataView.dataType !== 'geo-graticule') {\n        throw new TypeError('Invalid dataView: this transform is for Geo data only!');\n    }\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var projection = options.projection;\n    if (!projection) {\n        throw new TypeError('Invalid projection!');\n    }\n    projection = get_geo_projection_1.default(projection);\n    // @ts-ignore;\n    var geoPathGenerator = d3_geo_1.geoPath(projection);\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 4) {\n        throw new TypeError('Invalid as: it must be an array with 4 strings (e.g. [ \"x\", \"y\", \"cX\", \"cY\" ])!');\n    }\n    dataView._projectedAs = as;\n    var _a = tslib_1.__read(as, 4), lonField = _a[0], latField = _a[1], centroidX = _a[2], centroidY = _a[3];\n    dataView.rows.forEach(function (row) {\n        row[lonField] = [];\n        row[latField] = [];\n        var pathData = geoPathGenerator(row);\n        if (pathData) {\n            // TODO projection returns null\n            var points = point_at_length_1.default(pathData);\n            points._path.forEach(function (point) {\n                row[lonField].push(point[1]);\n                row[latField].push(point[2]);\n            });\n            var centroid = geoPathGenerator.centroid(row);\n            row[centroidX] = centroid[0];\n            row[centroidY] = centroid[1];\n        }\n    });\n    dataView.rows = dataView.rows.filter(function (row) { return row[lonField].length !== 0; });\n}\nregisterTransform('geo.projection', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/geo/region.ts\":\n/*!*************************************!*\\\n  !*** ./src/transform/geo/region.ts ***!\n  \\*************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar registerTransform = data_set_1.DataSet.registerTransform;\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    // field: 'name', // required\n    // geoView: view, // required\n    // geoDataView: view, // alias\n    as: ['_x', '_y'],\n};\nfunction transform(view, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var field = option_parser_1.getField(options);\n    // @ts-ignore\n    var geoView = options.geoView || options.geoDataView; // alias\n    if (util_1.isString(geoView)) {\n        geoView = view.dataSet.getView(geoView);\n    }\n    if (!geoView || geoView.dataType !== 'geo') {\n        throw new TypeError('Invalid geoView: must be a DataView of GEO dataType!');\n    }\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n    }\n    var lonField = as[0];\n    var latField = as[1];\n    view.rows.forEach(function (row) {\n        var feature = geoView.geoFeatureByName(row[field]);\n        if (feature) {\n            if (geoView._projectedAs) {\n                row[lonField] = feature[geoView._projectedAs[0]];\n                row[latField] = feature[geoView._projectedAs[1]];\n            }\n            else {\n                row[lonField] = feature.longitude;\n                row[latField] = feature.latitude;\n            }\n        }\n    });\n}\nregisterTransform('geo.region', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/cluster.ts\":\n/*!********************************************!*\\\n  !*** ./src/transform/hierarchy/cluster.ts ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar d3Hierarchy = tslib_1.__importStar(__webpack_require__(/*! d3-hierarchy */ \"./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    field: 'value',\n    size: [1, 1],\n    nodeSize: null,\n    separation: null,\n    as: ['x', 'y'],\n};\nfunction transform(dataView, options) {\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY || !dataView.root) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    var root = dataView.root;\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n    }\n    var field = undefined;\n    try {\n        field = option_parser_1.getField(options);\n    }\n    catch (e) {\n        console.warn(e);\n    }\n    if (field) {\n        root.sum(function (d) { return d[field]; });\n    }\n    var clusterLayout = d3Hierarchy.cluster();\n    clusterLayout.size(options.size);\n    if (options.nodeSize) {\n        clusterLayout.nodeSize(options.nodeSize);\n    }\n    if (options.separation) {\n        clusterLayout.separation(options.separation);\n    }\n    clusterLayout(root);\n    var x = as[0];\n    var y = as[1];\n    root.each(function (node) {\n        node[x] = node.x;\n        node[y] = node.y;\n    });\n}\ndata_set_1.DataSet.registerTransform('hierarchy.cluster', transform);\ndata_set_1.DataSet.registerTransform('dendrogram', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/compact-box.ts\":\n/*!************************************************!*\\\n  !*** ./src/transform/hierarchy/compact-box.ts ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar hierarchy_1 = tslib_1.__importDefault(__webpack_require__(/*! @antv/hierarchy */ \"./node_modules/_@antv_hierarchy@0.6.2@@antv/hierarchy/build/hierarchy.js\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {};\nfunction transform(dataView, options) {\n    var root = dataView.root;\n    options = Object.assign({}, DEFAULT_OPTIONS, options);\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    dataView.root = hierarchy_1.default.compactBox(root, options);\n}\ndata_set_1.DataSet.registerTransform('hierarchy.compact-box', transform);\ndata_set_1.DataSet.registerTransform('compact-box-tree', transform);\ndata_set_1.DataSet.registerTransform('non-layered-tidy-tree', transform);\ndata_set_1.DataSet.registerTransform('mindmap-logical', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/dendrogram.ts\":\n/*!***********************************************!*\\\n  !*** ./src/transform/hierarchy/dendrogram.ts ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar hierarchy_1 = tslib_1.__importDefault(__webpack_require__(/*! @antv/hierarchy */ \"./node_modules/_@antv_hierarchy@0.6.2@@antv/hierarchy/build/hierarchy.js\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {};\nfunction transform(dataView, options) {\n    var root = dataView.root;\n    options = Object.assign({}, DEFAULT_OPTIONS, options);\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    dataView.root = hierarchy_1.default.dendrogram(root, options);\n}\ndata_set_1.DataSet.registerTransform('hierarchy.dendrogram', transform);\ndata_set_1.DataSet.registerTransform('dendrogram', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/indented.ts\":\n/*!*********************************************!*\\\n  !*** ./src/transform/hierarchy/indented.ts ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar hierarchy_1 = tslib_1.__importDefault(__webpack_require__(/*! @antv/hierarchy */ \"./node_modules/_@antv_hierarchy@0.6.2@@antv/hierarchy/build/hierarchy.js\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {};\nfunction transform(dataView, options) {\n    var root = dataView.root;\n    options = Object.assign({}, DEFAULT_OPTIONS, options);\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    dataView.root = hierarchy_1.default.indented(root, options);\n}\ndata_set_1.DataSet.registerTransform('hierarchy.indented', transform);\ndata_set_1.DataSet.registerTransform('indented-tree', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/pack.ts\":\n/*!*****************************************!*\\\n  !*** ./src/transform/hierarchy/pack.ts ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3Hierarchy = tslib_1.__importStar(__webpack_require__(/*! d3-hierarchy */ \"./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    field: 'value',\n    size: [1, 1],\n    padding: 0,\n    as: ['x', 'y', 'r'],\n};\nfunction transform(dataView, options) {\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    var root = dataView.root;\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 3) {\n        throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ \"x\", \"y\", \"r\" ])!');\n    }\n    var field;\n    try {\n        field = option_parser_1.getField(options);\n    }\n    catch (e) {\n        console.warn(e);\n    }\n    if (field) {\n        root.sum(function (d) { return d[field]; }).sort(function (a, b) { return b[field] - a[field]; });\n    }\n    var packLayout = d3Hierarchy.pack();\n    packLayout.size(options.size);\n    if (options.padding) {\n        packLayout.padding(options.padding);\n    }\n    packLayout(root);\n    var x = as[0];\n    var y = as[1];\n    var r = as[2];\n    root.each(function (node) {\n        node[x] = node.x;\n        node[y] = node.y;\n        node[r] = node.r;\n    });\n}\ndata_set_1.DataSet.registerTransform('hierarchy.pack', transform);\ndata_set_1.DataSet.registerTransform('hierarchy.circle-packing', transform);\ndata_set_1.DataSet.registerTransform('circle-packing', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/partition.ts\":\n/*!**********************************************!*\\\n  !*** ./src/transform/hierarchy/partition.ts ***!\n  \\**********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar d3Hierarchy = tslib_1.__importStar(__webpack_require__(/*! d3-hierarchy */ \"./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    field: 'value',\n    size: [1, 1],\n    round: false,\n    // ratio: 1.618033988749895, // golden ratio\n    padding: 0,\n    sort: true,\n    as: ['x', 'y'],\n};\nfunction transform(dataView, options) {\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    var root = dataView.root;\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n    }\n    var field;\n    try {\n        field = option_parser_1.getField(options);\n    }\n    catch (e) {\n        console.warn(e);\n    }\n    if (field) {\n        root.sum(function (d) { return d[field]; });\n    }\n    var partitionLayout = d3Hierarchy.partition();\n    partitionLayout\n        .size(options.size)\n        .round(options.round)\n        .padding(options.padding);\n    partitionLayout(root);\n    /*\n     * points:\n     *   3  2\n     *   0  1\n     */\n    var x = as[0];\n    var y = as[1];\n    root.each(function (node) {\n        node[x] = [node.x0, node.x1, node.x1, node.x0];\n        node[y] = [node.y1, node.y1, node.y0, node.y0];\n        ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {\n            if (as.indexOf(prop) === -1) {\n                delete node[prop];\n            }\n        });\n    });\n}\ndata_set_1.DataSet.registerTransform('hierarchy.partition', transform);\ndata_set_1.DataSet.registerTransform('adjacency', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/tree.ts\":\n/*!*****************************************!*\\\n  !*** ./src/transform/hierarchy/tree.ts ***!\n  \\*****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar d3Hierarchy = tslib_1.__importStar(__webpack_require__(/*! d3-hierarchy */ \"./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    field: 'value',\n    size: [1, 1],\n    nodeSize: null,\n    separation: null,\n    as: ['x', 'y'],\n};\nfunction transform(dataView, options) {\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    var root = dataView.root;\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n    }\n    var field;\n    try {\n        field = option_parser_1.getField(options);\n    }\n    catch (e) {\n        console.warn(e);\n    }\n    if (field) {\n        root.sum(function (d) { return d[field]; });\n    }\n    var treeLayout = d3Hierarchy.tree();\n    treeLayout.size(options.size);\n    if (options.nodeSize) {\n        treeLayout.nodeSize(options.nodeSize);\n    }\n    if (options.separation) {\n        treeLayout.separation(options.separation);\n    }\n    treeLayout(root);\n    var x = as[0];\n    var y = as[1];\n    root.each(function (node) {\n        node[x] = node.x;\n        node[y] = node.y;\n    });\n}\ndata_set_1.DataSet.registerTransform('hierarchy.tree', transform);\ndata_set_1.DataSet.registerTransform('tree', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/hierarchy/treemap.ts\":\n/*!********************************************!*\\\n  !*** ./src/transform/hierarchy/treemap.ts ***!\n  \\********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar d3Hierarchy = tslib_1.__importStar(__webpack_require__(/*! d3-hierarchy */ \"./node_modules/_d3-hierarchy@1.1.9@d3-hierarchy/dist/d3-hierarchy.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    field: 'value',\n    tile: 'treemapSquarify',\n    size: [1, 1],\n    round: false,\n    // ratio: 1.618033988749895, // golden ratio\n    padding: 0,\n    paddingInner: 0,\n    paddingOuter: 0,\n    paddingTop: 0,\n    paddingRight: 0,\n    paddingBottom: 0,\n    paddingLeft: 0,\n    as: ['x', 'y'],\n};\nfunction transform(dataView, options) {\n    if (dataView.dataType !== data_set_1.DataSet.CONSTANTS.HIERARCHY) {\n        throw new TypeError('Invalid DataView: This transform is for Hierarchy data only!');\n    }\n    var root = dataView.root;\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 2) {\n        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n    }\n    var field;\n    try {\n        field = option_parser_1.getField(options);\n    }\n    catch (e) {\n        console.warn(e);\n    }\n    if (field) {\n        root.sum(function (d) { return d[field]; });\n    }\n    var treemapLayout = d3Hierarchy.treemap();\n    treemapLayout\n        .tile(d3Hierarchy[options.tile])\n        .size(options.size)\n        .round(options.round)\n        .padding(options.padding)\n        .paddingInner(options.paddingInner)\n        .paddingOuter(options.paddingOuter)\n        .paddingTop(options.paddingTop)\n        .paddingRight(options.paddingRight)\n        .paddingBottom(options.paddingBottom)\n        .paddingLeft(options.paddingLeft);\n    treemapLayout(root);\n    /*\n     * points:\n     *   3  2\n     *   0  1\n     */\n    var x = as[0];\n    var y = as[1];\n    root.each(function (node) {\n        node[x] = [node.x0, node.x1, node.x1, node.x0];\n        node[y] = [node.y1, node.y1, node.y0, node.y0];\n        ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {\n            if (as.indexOf(prop) === -1) {\n                delete node[prop];\n            }\n        });\n    });\n}\ndata_set_1.DataSet.registerTransform('hierarchy.treemap', transform);\ndata_set_1.DataSet.registerTransform('treemap', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/impute.ts\":\n/*!*********************************!*\\\n  !*** ./src/transform/impute.ts ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar simpleStatistics = tslib_1.__importStar(__webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\"));\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    // field: '', // required\n    // method: 'value', // required\n    // value: 10, // required if (method === 'value')\n    groupBy: [],\n};\nfunction notUndefinedValues(values) {\n    return values.filter(function (value) { return !util_1.isUndefined(value); });\n}\nvar STATISTICS_METHODS = ['mean', 'median', 'max', 'min'];\nvar imputations = {};\nSTATISTICS_METHODS.forEach(function (method) {\n    // @ts-ignore\n    imputations[method] = function (row, values) { return simpleStatistics[method](values); };\n});\nimputations.value = function (_row, _values, value) { return value; };\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var field = option_parser_1.getField(options);\n    var method = options.method;\n    if (!method) {\n        throw new TypeError('Invalid method!');\n    }\n    if (method === 'value' && !util_1.has(options, 'value')) {\n        throw new TypeError('Invalid value: it is nil.');\n    }\n    var column = notUndefinedValues(dataView.getColumn(field));\n    var groups = partition_1.default(dataView.rows, options.groupBy);\n    util_1.forIn(groups, function (group) {\n        var fieldValues = notUndefinedValues(group.map(function (row) { return row[field]; }));\n        if (fieldValues.length === 0) {\n            fieldValues = column;\n        }\n        group.forEach(function (row) {\n            if (util_1.isUndefined(row[field])) {\n                if (util_1.isFunction(method)) {\n                    row[field] = method(row, fieldValues, options.value, group);\n                }\n                else if (util_1.isString(method)) {\n                    row[field] = imputations[method](row, fieldValues, options.value);\n                }\n                else {\n                    throw new TypeError(\"Invalid method: must be a function or one of \" + STATISTICS_METHODS.join(', '));\n                }\n            }\n        });\n    });\n}\ndata_set_1.DataSet.registerTransform('impute', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/kde.ts\":\n/*!******************************!*\\\n  !*** ./src/transform/kde.ts ***!\n  \\******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\n/*\n * kernel density estimation\n */\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar get_series_values_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/get-series-values */ \"./src/util/get-series-values.ts\"));\nvar kernel_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/kernel */ \"./src/util/kernel.ts\"));\nvar bandwidth = tslib_1.__importStar(__webpack_require__(/*! ../util/bandwidth */ \"./src/util/bandwidth.ts\"));\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar simple_statistics_1 = __webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\");\nvar DEFAULT_OPTIONS = {\n    minSize: 0.01,\n    as: ['key', 'y', 'size'],\n    // fields: [ 'y1', 'y2' ], // required, one or more fields\n    extent: [],\n    method: 'gaussian',\n    bandwidth: 'nrd',\n    step: 0,\n    groupBy: [],\n};\nvar KERNEL_METHODS = util_1.keys(kernel_1.default);\nvar BANDWIDTH_METHODS = util_1.keys(bandwidth);\nfunction transform(dv, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    if (!util_1.isArray(fields) || fields.length < 1) {\n        throw new TypeError('invalid fields: must be an array of at least 1 strings!');\n    }\n    var as = options.as;\n    if (!util_1.isArray(as) || as.length !== 3) {\n        throw new TypeError('invalid as: must be an array of 3 strings!');\n    }\n    var method = options.method;\n    if (util_1.isString(method)) {\n        if (KERNEL_METHODS.indexOf(method) === -1) {\n            throw new TypeError(\"invalid method: \" + method + \". Must be one of \" + KERNEL_METHODS.join(', '));\n        }\n        method = kernel_1.default[method];\n    }\n    if (!util_1.isFunction(method)) {\n        throw new TypeError('invalid method: kernel method must be a function!');\n    }\n    var extent = options.extent;\n    if (!util_1.isArray(extent) || extent.length === 0) {\n        var rangeArr_1 = [];\n        util_1.each(fields, function (field) {\n            var range = dv.range(field);\n            rangeArr_1 = rangeArr_1.concat(range);\n        });\n        extent = [Math.min.apply(Math, tslib_1.__spread(rangeArr_1)), Math.max.apply(Math, tslib_1.__spread(rangeArr_1))];\n    }\n    var bw = options.bandwidth;\n    if (util_1.isString(bw) && bandwidth[bw]) {\n        bw = bandwidth[bw](dv.getColumn(fields[0]));\n    }\n    else if (util_1.isFunction(bw)) {\n        bw = bw(dv.getColumn(fields[0]));\n    }\n    else if (!util_1.isNumber(bw) || bw <= 0) {\n        bw = bandwidth.nrd(dv.getColumn(fields[0]));\n    }\n    var seriesValues = get_series_values_1.default(extent, options.step ? options.step : bw);\n    var result = [];\n    var groupBy = options.groupBy;\n    var groups = partition_1.default(dv.rows, groupBy);\n    util_1.forIn(groups, function (group) {\n        var probalityDensityFunctionByField = {};\n        util_1.each(fields, function (field) {\n            var row = util_1.pick(group[0], groupBy);\n            probalityDensityFunctionByField[field] = simple_statistics_1.kernelDensityEstimation(group.map(function (item) { return item[field]; }), method, bw);\n            var _a = tslib_1.__read(as, 3), key = _a[0], y = _a[1], size = _a[2];\n            row[key] = field;\n            row[y] = [];\n            row[size] = [];\n            util_1.each(seriesValues, function (yValue) {\n                var sizeValue = probalityDensityFunctionByField[field](yValue);\n                if (sizeValue >= options.minSize) {\n                    row[y].push(yValue);\n                    row[size].push(sizeValue);\n                }\n            });\n            result.push(row);\n        });\n    });\n    dv.rows = result;\n}\ndata_set_1.DataSet.registerTransform('kernel-density-estimation', transform);\ndata_set_1.DataSet.registerTransform('kde', transform);\ndata_set_1.DataSet.registerTransform('KDE', transform);\nexports.default = {\n    KERNEL_METHODS: KERNEL_METHODS,\n    BANDWIDTH_METHODS: BANDWIDTH_METHODS,\n};\n\n\n/***/ }),\n\n/***/ \"./src/transform/kernel-smooth/density.ts\":\n/*!************************************************!*\\\n  !*** ./src/transform/kernel-smooth/density.ts ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\n/*\n * @reference: https://github.com/Planeshifter/kernel-smooth/blob/master/lib/index.js\n */\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar get_series_values_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/get-series-values */ \"./src/util/get-series-values.ts\"));\nvar kernel_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/kernel */ \"./src/util/kernel.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar bandwidth_1 = __webpack_require__(/*! ../../util/bandwidth */ \"./src/util/bandwidth.ts\");\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'y', 'z'],\n    // fields: [ 'x', 'y' ], // required, one or two fields\n    method: 'gaussian',\n};\nvar KERNEL_METHODS = util_1.keys(kernel_1.default);\nfunction transform(dv, options) {\n    var _a, _b;\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    if (!util_1.isArray(fields) || fields.length !== 2) {\n        throw new TypeError('invalid fields: must be an array of 2 strings!');\n    }\n    var _c = tslib_1.__read(options.as, 3), asX = _c[0], asY = _c[1], asZ = _c[2];\n    if (!util_1.isString(asX) || !util_1.isString(asY) || !util_1.isString(asZ)) {\n        throw new TypeError('invalid as: must be an array of 3 strings!');\n    }\n    var method;\n    if (util_1.isString(options.method)) {\n        if (KERNEL_METHODS.indexOf(options.method) === -1) {\n            throw new TypeError(\"invalid method: \" + options.method + \". Must be one of \" + KERNEL_METHODS.join(', '));\n        }\n        method = kernel_1.default[options.method];\n    }\n    var _d = tslib_1.__read(fields, 2), xField = _d[0], yField = _d[1];\n    var extent = options.extent, bandwidth = options.bandwidth;\n    var extentX;\n    var extentY;\n    if (extent && Array.isArray(extent) && Array.isArray(extent[0]) && Array.isArray(extent[1])) {\n        _a = tslib_1.__read(extent, 2), extentX = _a[0], extentY = _a[1];\n    }\n    else {\n        extentX = dv.range(xField);\n        extentY = dv.range(yField);\n    }\n    var bwX, bwY;\n    if (bandwidth &&\n        Array.isArray(bandwidth) &&\n        bandwidth.slice(0, 2).every(util_1.isNumber) &&\n        bandwidth.slice(0, 2).every(function (item) { return item > 0; })) {\n        _b = tslib_1.__read(bandwidth, 2), bwX = _b[0], bwY = _b[1];\n    }\n    else {\n        bwX = bandwidth_1.silverman(dv.getColumn(xField));\n        bwY = bandwidth_1.silverman(dv.getColumn(yField));\n    }\n    var seriesValuesX = get_series_values_1.default(extentX, bwX);\n    var seriesValuesY = get_series_values_1.default(extentY, bwY);\n    var count = dv.rows.length;\n    var result = [];\n    for (var i = 0; i < seriesValuesX.length; i++) {\n        for (var j = 0; j < seriesValuesY.length; j++) {\n            var sum = 0;\n            var x = seriesValuesX[i];\n            var y = seriesValuesY[j];\n            for (var k = 0; k < count; k++) {\n                sum += method((x - dv.rows[k][xField]) / bwX) * method((y - dv.rows[k][yField]) / bwY);\n            }\n            var z = (1 / (count * bwX * bwY)) * sum;\n            var row = {};\n            row[asX] = x;\n            row[asY] = y;\n            row[asZ] = z;\n            result.push(row);\n        }\n    }\n    dv.rows = result;\n}\ndata_set_1.DataSet.registerTransform('kernel-smooth.density', transform);\ndata_set_1.DataSet.registerTransform('kernel.density', transform);\nexports.default = {\n    KERNEL_METHODS: KERNEL_METHODS,\n};\n\n\n/***/ }),\n\n/***/ \"./src/transform/kernel-smooth/regression.ts\":\n/*!***************************************************!*\\\n  !*** ./src/transform/kernel-smooth/regression.ts ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\n/*\n * @reference: https://github.com/Planeshifter/kernel-smooth/blob/master/lib/index.js\n */\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar get_series_values_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/get-series-values */ \"./src/util/get-series-values.ts\"));\nvar kernel_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../util/kernel */ \"./src/util/kernel.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../../data-set */ \"./src/data-set.ts\");\nvar simple_statistics_1 = __webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\");\nvar option_parser_1 = __webpack_require__(/*! ../../util/option-parser */ \"./src/util/option-parser.ts\");\nvar bandwidth_1 = __webpack_require__(/*! ../../util/bandwidth */ \"./src/util/bandwidth.ts\");\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'y'],\n    // fields: [ 'x', 'y' ], // required, one or two fields\n    method: 'gaussian',\n};\nvar KERNEL_METHODS = util_1.keys(kernel_1.default);\n// calculates weight for i-th obs\nfunction weight(kernel, bandwidth, x_0, x_i) {\n    var arg = (x_i - x_0) / bandwidth;\n    return kernel(arg);\n}\n// calculates weight for i-th obs when p > 1\n// function weight_vectors(kernel, bandwidth, x_0, x_i) {\n//   const arg = enclideanDistance(x_i, x_0) / bandwidth;\n//   return kernel(arg);\n// }\nfunction vectorize(fun) {\n    return function (x) {\n        if (!util_1.isArray(x)) {\n            return fun(x);\n        }\n        return x.map(function (x) {\n            return fun(x);\n        });\n    };\n}\nfunction transform(dv, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    if (!util_1.isArray(fields) || !(fields.length === 1 || fields.length === 2)) {\n        throw new TypeError('invalid fields: must be an array of 1 or 2 strings!');\n    }\n    var _a = tslib_1.__read(options.as, 2), asX = _a[0], asY = _a[1];\n    if (!util_1.isString(asX) || !util_1.isString(asY)) {\n        throw new TypeError('invalid as: must be an array of 2 strings!');\n    }\n    var func;\n    var method = options.method;\n    if (util_1.isString(method)) {\n        if (KERNEL_METHODS.indexOf(method) === -1) {\n            throw new TypeError(\"invalid method: \" + method + \". Must be one of \" + KERNEL_METHODS.join(', '));\n        }\n        func = kernel_1.default[method];\n    }\n    var _b = tslib_1.__read(fields, 2), xField = _b[0], yField = _b[1];\n    var xs = dv.getColumn(xField);\n    var extent = options.extent;\n    if (extent || !util_1.isArray(extent)) {\n        extent = dv.range(xField);\n    }\n    var bandwidth = options.bandwidth;\n    if (!bandwidth || !util_1.isNumber(bandwidth) || bandwidth <= 0) {\n        bandwidth = bandwidth_1.silverman(xs);\n    }\n    var seriesValues = get_series_values_1.default(extent, bandwidth);\n    var xCount = xs.length;\n    var weightFunc = weight.bind(null, func, bandwidth);\n    var kernelSmoother;\n    if (util_1.isNil(yField)) {\n        // KDE\n        kernelSmoother = vectorize(function (x) {\n            var weights = xs.map(function (x_i) { return weightFunc(x, x_i); });\n            var num = simple_statistics_1.sum(weights);\n            var denom = xCount * bandwidth;\n            if (!num || !denom)\n                return 0;\n            return num / denom;\n        });\n    }\n    else {\n        // kernel regression smoothing\n        var ys_1 = dv.getColumn(yField);\n        kernelSmoother = vectorize(function (x) {\n            var weights = xs.map(function (x_i) { return weightFunc(x, x_i); });\n            var num = simple_statistics_1.sum(weights.map(function (w, i) { return w * ys_1[i]; }));\n            var denom = simple_statistics_1.sum(weights);\n            if (!num || !denom)\n                return 0;\n            return num / denom;\n        });\n    }\n    var result = seriesValues.map(function (x) {\n        var row = {};\n        row[asX] = x;\n        row[asY] = kernelSmoother(x);\n        return row;\n    });\n    dv.rows = result;\n}\ndata_set_1.DataSet.registerTransform('kernel-smooth.regression', transform);\ndata_set_1.DataSet.registerTransform('kernel.regression', transform);\nexports.default = {\n    KERNEL_METHODS: KERNEL_METHODS,\n};\n\n\n/***/ }),\n\n/***/ \"./src/transform/map.ts\":\n/*!******************************!*\\\n  !*** ./src/transform/map.ts ***!\n  \\******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nfunction defaultCallback(row) {\n    return row;\n}\ndata_set_1.DataSet.registerTransform('map', function (dataView, options) {\n    dataView.rows = dataView.rows.map(options.callback || defaultCallback);\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/partition.ts\":\n/*!************************************!*\\\n  !*** ./src/transform/partition.ts ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar DEFAULT_OPTIONS = {\n    groupBy: [],\n    orderBy: [],\n};\ndata_set_1.DataSet.registerTransform('partition', function (dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    // TODO: rows 是否都只能是数组\n    // @ts-ignore;\n    dataView.rows = partition_1.default(dataView.rows, options.groupBy, options.orderBy);\n});\nfunction group(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    dataView.rows = util_1.values(partition_1.default(dataView.rows, options.groupBy, options.orderBy));\n}\ndata_set_1.DataSet.registerTransform('group', group);\ndata_set_1.DataSet.registerTransform('groups', group);\n\n\n/***/ }),\n\n/***/ \"./src/transform/percent.ts\":\n/*!**********************************!*\\\n  !*** ./src/transform/percent.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar simple_statistics_1 = __webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    // field: 'y', // required\n    // dimension: 'x', // required\n    groupBy: [],\n    as: '_percent',\n};\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var field = option_parser_1.getField(options);\n    var dimension = options.dimension, groupBy = options.groupBy;\n    var as = options.as;\n    if (!util_1.isString(dimension)) {\n        throw new TypeError('Invalid dimension: must be a string!');\n    }\n    if (util_1.isArray(as)) {\n        console.warn('Invalid as: must be a string, will use the first element of the array specified.');\n        as = as[0];\n    }\n    if (!util_1.isString(as)) {\n        throw new TypeError('Invalid as: must be a string!');\n    }\n    var rows = dataView.rows;\n    var result = [];\n    var groups = partition_1.default(rows, groupBy);\n    util_1.forIn(groups, function (group) {\n        var totalSum = simple_statistics_1.sum(group.map(function (row) { return row[field]; }));\n        if (totalSum === 0) {\n            console.warn(\"Invalid data: total sum of field \" + field + \" is 0!\");\n        }\n        var innerGroups = partition_1.default(group, [dimension]);\n        util_1.forIn(innerGroups, function (innerGroup) {\n            var innerSum = simple_statistics_1.sum(innerGroup.map(function (row) { return row[field]; }));\n            // const resultRow = pick(innerGroup[0], union(groupBy, [ dimension ]));\n            var resultRow = innerGroup[0];\n            // FIXME in case dimension and field is the same\n            var dimensionValue = resultRow[dimension];\n            resultRow[field] = innerSum;\n            resultRow[dimension] = dimensionValue;\n            if (totalSum === 0) {\n                resultRow[as] = 0;\n            }\n            else {\n                resultRow[as] = innerSum / totalSum;\n            }\n            result.push(resultRow);\n        });\n    });\n    dataView.rows = result;\n}\ndata_set_1.DataSet.registerTransform('percent', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/pick.ts\":\n/*!*******************************!*\\\n  !*** ./src/transform/pick.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\ndata_set_1.DataSet.registerTransform('pick', function (dataView, options) {\n    var columns = option_parser_1.getFields(options, dataView.getColumnNames());\n    dataView.rows = dataView.rows.map(function (row) { return util_1.pick(row, columns); });\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/proportion.ts\":\n/*!*************************************!*\\\n  !*** ./src/transform/proportion.ts ***!\n  \\*************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    // field: 'y', // required\n    // dimension: 'x', // required\n    groupBy: [],\n    as: '_proportion',\n};\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var field = option_parser_1.getField(options);\n    var dimension = options.dimension;\n    var groupBy = options.groupBy;\n    var as = options.as;\n    if (!util_1.isString(dimension)) {\n        throw new TypeError('Invalid dimension: must be a string!');\n    }\n    if (util_1.isArray(as)) {\n        console.warn('Invalid as: must be a string, will use the first element of the array specified.');\n        as = as[0];\n    }\n    if (!util_1.isString(as)) {\n        throw new TypeError('Invalid as: must be a string!');\n    }\n    var rows = dataView.rows;\n    var result = [];\n    var groups = partition_1.default(rows, groupBy);\n    util_1.forIn(groups, function (group) {\n        var totalCount = group.length;\n        var innerGroups = partition_1.default(group, [dimension]);\n        util_1.forIn(innerGroups, function (innerGroup) {\n            var innerCount = innerGroup.length;\n            // const resultRow = pick(innerGroup[0], union(groupBy, [ dimension ]));\n            var resultRow = innerGroup[0];\n            // FIXME in case dimension and field is the same\n            var dimensionValue = resultRow[dimension];\n            resultRow[field] = innerCount;\n            resultRow[dimension] = dimensionValue;\n            resultRow[as] = innerCount / totalCount;\n            result.push(resultRow);\n        });\n    });\n    dataView.rows = result;\n}\ndata_set_1.DataSet.registerTransform('proportion', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/regression.ts\":\n/*!*************************************!*\\\n  !*** ./src/transform/regression.ts ***!\n  \\*************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar regression_1 = tslib_1.__importDefault(__webpack_require__(/*! regression */ \"./node_modules/_regression@2.0.1@regression/dist/regression.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar get_series_values_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/get-series-values */ \"./src/util/get-series-values.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar bandwidth_1 = __webpack_require__(/*! ../util/bandwidth */ \"./src/util/bandwidth.ts\");\nvar DEFAULT_OPTIONS = {\n    as: ['x', 'y'],\n    // fields: [ 'x', 'y' ], // required two fields\n    method: 'linear',\n    // extent: [], // extent to execute regression function, default: [ min(x), max(x) ]\n    // bandwidth: 1, // bandWidth to execute regression function\n    order: 2,\n    precision: 2,\n};\nvar REGRESSION_METHODS = ['linear', 'exponential', 'logarithmic', 'power', 'polynomial'];\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    if (!util_1.isArray(fields) || fields.length !== 2) {\n        throw new TypeError('invalid fields: must be an array of 2 strings.');\n    }\n    var _a = tslib_1.__read(fields, 2), xField = _a[0], yField = _a[1];\n    var method = options.method;\n    if (REGRESSION_METHODS.indexOf(method) === -1) {\n        throw new TypeError(\"invalid method: \" + method + \". Must be one of \" + REGRESSION_METHODS.join(', '));\n    }\n    var points = dataView.rows.map(function (row) { return [row[xField], row[yField]]; });\n    var regressionResult = regression_1.default[method](points, options);\n    var extent = options.extent;\n    if (!util_1.isArray(extent) || extent.length !== 2) {\n        extent = dataView.range(xField);\n    }\n    var bandwidth = options.bandwidth;\n    if (!util_1.isNumber(bandwidth) || bandwidth <= 0) {\n        bandwidth = bandwidth_1.silverman(dataView.getColumn(xField));\n    }\n    var valuesToPredict = get_series_values_1.default(extent, bandwidth);\n    var result = [];\n    var _b = tslib_1.__read(options.as, 2), asX = _b[0], asY = _b[1];\n    valuesToPredict.forEach(function (value) {\n        var row = {};\n        var _a = tslib_1.__read(regressionResult.predict(value), 2), x = _a[0], y = _a[1];\n        row[asX] = x;\n        row[asY] = y;\n        if (isFinite(y)) {\n            result.push(row);\n        }\n    });\n    dataView.rows = result;\n}\ndata_set_1.DataSet.registerTransform('regression', transform);\nexports.default = {\n    REGRESSION_METHODS: REGRESSION_METHODS,\n};\n\n\n/***/ }),\n\n/***/ \"./src/transform/rename.ts\":\n/*!*********************************!*\\\n  !*** ./src/transform/rename.ts ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nfunction transform(dataView, options) {\n    var map = options.map || {};\n    var cleanMap = {};\n    if (util_1.isPlainObject(map)) {\n        util_1.forIn(map, function (value, key) {\n            if (util_1.isString(value) && util_1.isString(key)) {\n                cleanMap[key] = value;\n            }\n        });\n    }\n    dataView.rows.forEach(function (row) {\n        util_1.forIn(cleanMap, function (newKey, key) {\n            var temp = row[key];\n            delete row[key];\n            row[newKey] = temp;\n        });\n    });\n}\ndata_set_1.DataSet.registerTransform('rename', transform);\ndata_set_1.DataSet.registerTransform('rename-fields', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/reverse.ts\":\n/*!**********************************!*\\\n  !*** ./src/transform/reverse.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\ndata_set_1.DataSet.registerTransform('reverse', function (dataView) {\n    dataView.rows.reverse();\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/sort-by.ts\":\n/*!**********************************!*\\\n  !*** ./src/transform/sort-by.ts ***!\n  \\**********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\n/*\n * options: {\n *   type: 'sort-by',\n *   fields: [],\n *   order: 'ASC' // 'DESC'\n * }\n */\nvar VALID_ORDERS = ['ASC', 'DESC'];\nfunction transform(dataView, options) {\n    var fields = option_parser_1.getFields(options, [dataView.getColumnName(0)]);\n    if (!util_1.isArray(fields)) {\n        throw new TypeError('Invalid fields: must be an array with strings!');\n    }\n    dataView.rows = util_1.sortBy(dataView.rows, fields);\n    var order = options.order;\n    if (order && VALID_ORDERS.indexOf(order) === -1) {\n        throw new TypeError(\"Invalid order: \" + order + \" must be one of \" + VALID_ORDERS.join(', '));\n    }\n    else if (order === 'DESC') {\n        dataView.rows.reverse();\n    }\n}\ndata_set_1.DataSet.registerTransform('sort-by', transform);\ndata_set_1.DataSet.registerTransform('sortBy', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/sort.ts\":\n/*!*******************************!*\\\n  !*** ./src/transform/sort.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\ndata_set_1.DataSet.registerTransform('sort', function (dataView, options) {\n    var columnName = dataView.getColumnName(0);\n    dataView.rows.sort(options.callback || (function (a, b) { return a[columnName] - b[columnName]; }));\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/subset.ts\":\n/*!*********************************!*\\\n  !*** ./src/transform/subset.ts ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\ndata_set_1.DataSet.registerTransform('subset', function (dataView, options) {\n    var startIndex = options.startRowIndex || 0;\n    var endIndex = options.endRowIndex || dataView.rows.length - 1;\n    var columns = option_parser_1.getFields(options, dataView.getColumnNames());\n    dataView.rows = dataView.getSubset(startIndex, endIndex, columns);\n});\n\n\n/***/ }),\n\n/***/ \"./src/transform/tag-cloud.ts\":\n/*!************************************!*\\\n  !*** ./src/transform/tag-cloud.ts ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar tag_cloud_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/tag-cloud */ \"./src/util/tag-cloud.ts\"));\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    fields: ['text', 'value'],\n    font: function () { return 'serif'; },\n    padding: 1,\n    size: [500, 500],\n    spiral: 'archimedean',\n    // timeInterval: Infinity // max execute time\n    timeInterval: 500,\n};\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var layout = tag_cloud_1.default();\n    ['font', 'fontSize', 'padding', 'rotate', 'size', 'spiral', 'timeInterval'].forEach(function (key) {\n        // @ts-ignore\n        if (options[key]) {\n            // @ts-ignore\n            layout[key](options[key]);\n        }\n    });\n    var fields = option_parser_1.getFields(options);\n    var _a = tslib_1.__read(fields, 2), text = _a[0], value = _a[1];\n    if (!util_1.isString(text) || !util_1.isString(value)) {\n        throw new TypeError('Invalid fields: must be an array with 2 strings (e.g. [ \"text\", \"value\" ])!');\n    }\n    var words = dataView.rows.map(function (row) {\n        row.text = row[text];\n        row.value = row[value];\n        return row;\n    });\n    layout.words(words);\n    if (options.imageMask) {\n        layout.createMask(options.imageMask);\n    }\n    var result = layout.start();\n    var tags = result._tags;\n    var bounds = result._bounds;\n    tags.forEach(function (tag) {\n        tag.x += options.size[0] / 2;\n        tag.y += options.size[1] / 2;\n    });\n    var _b = tslib_1.__read(options.size, 2), w = _b[0], h = _b[1];\n    var hasImage = result.hasImage;\n    tags.push({\n        text: '',\n        value: 0,\n        x: hasImage ? 0 : bounds[0].x,\n        y: hasImage ? 0 : bounds[0].y,\n        opacity: 0,\n    });\n    tags.push({\n        text: '',\n        value: 0,\n        x: hasImage ? w : bounds[1].x,\n        y: hasImage ? h : bounds[1].y,\n        opacity: 0,\n    });\n    dataView.rows = tags;\n    dataView._tagCloud = result;\n}\ndata_set_1.DataSet.registerTransform('tag-cloud', transform);\ndata_set_1.DataSet.registerTransform('word-cloud', transform);\n\n\n/***/ }),\n\n/***/ \"./src/transform/waffle.ts\":\n/*!*********************************!*\\\n  !*** ./src/transform/waffle.ts ***!\n  \\*********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar simple_statistics_1 = __webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\");\nvar partition_1 = tslib_1.__importDefault(__webpack_require__(/*! ../util/partition */ \"./src/util/partition.ts\"));\nvar data_set_1 = __webpack_require__(/*! ../data-set */ \"./src/data-set.ts\");\nvar option_parser_1 = __webpack_require__(/*! ../util/option-parser */ \"./src/util/option-parser.ts\");\nvar DEFAULT_OPTIONS = {\n    fields: ['name', 'value'],\n    rows: 5,\n    size: [1, 1],\n    scale: 1,\n    groupBy: [],\n    maxCount: 1000,\n    gapRatio: 0.1,\n    as: ['x', 'y'],\n};\nfunction transform(dataView, options) {\n    options = util_1.assign({}, DEFAULT_OPTIONS, options);\n    var fields = option_parser_1.getFields(options);\n    var _a = tslib_1.__read(fields, 2), nameField = _a[0], valueField = _a[1];\n    var _b = tslib_1.__read(options.as, 2), asX = _b[0], asY = _b[1];\n    var groupBy = options.groupBy;\n    var groups = partition_1.default(dataView.rows, groupBy);\n    var groupKeys = util_1.keys(groups);\n    var _c = tslib_1.__read(options.size, 2), width = _c[0], height = _c[1];\n    var maxCount = options.maxCount;\n    var groupCount = groupKeys.length;\n    var partHeight = height / groupCount;\n    var rows = options.rows;\n    var gapRatio = options.gapRatio;\n    var result = [];\n    var scale = options.scale;\n    var currentGroupIndex = 0;\n    var wStep = 0;\n    // getting suitable scale and width step\n    util_1.forIn(groups, function (group) {\n        var totalValue = simple_statistics_1.sum(util_1.map(group, function (row) { return row[valueField]; }));\n        var cols = Math.ceil((totalValue * scale) / rows);\n        if (totalValue * scale > maxCount) {\n            scale = maxCount / totalValue;\n            cols = Math.ceil((totalValue * scale) / rows);\n        }\n        wStep = width / cols;\n    });\n    // distributing values into grid\n    util_1.forIn(groups, function (group) {\n        var heightRange = [currentGroupIndex * partHeight, (currentGroupIndex + 1) * partHeight];\n        var h = heightRange[1] - heightRange[0];\n        var hStep = (h * (1 - gapRatio)) / rows;\n        var currentCol = 0;\n        var currentRow = 0;\n        util_1.each(group, function (row) {\n            var value = row[valueField];\n            var count = Math.round(value * scale);\n            for (var i = 0; i < count; i++) {\n                if (currentRow === rows) {\n                    currentRow = 0;\n                    currentCol++;\n                }\n                var resultRow = util_1.pick(row, [nameField, valueField].concat(groupBy));\n                resultRow[asX] = currentCol * wStep + wStep / 2;\n                resultRow[asY] = currentRow * hStep + hStep / 2 + heightRange[0];\n                resultRow._wStep = wStep;\n                resultRow._hStep = hStep;\n                currentRow++;\n                result.push(resultRow);\n            }\n        });\n        currentGroupIndex += 1;\n    });\n    dataView.rows = result;\n}\ndata_set_1.DataSet.registerTransform('waffle', transform);\n\n\n/***/ }),\n\n/***/ \"./src/util/bandwidth.ts\":\n/*!*******************************!*\\\n  !*** ./src/util/bandwidth.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar simple_statistics_1 = __webpack_require__(/*! simple-statistics */ \"./node_modules/_simple-statistics@6.1.1@simple-statistics/dist/simple-statistics.min.js\");\nfunction silverman(arr) {\n    var stdev = simple_statistics_1.standardDeviation(arr);\n    var num = 4 * Math.pow(stdev, 5);\n    var denom = 3 * arr.length;\n    return Math.pow(num / denom, 0.2);\n}\nexports.silverman = silverman;\nfunction nrd(arr) {\n    var s = simple_statistics_1.standardDeviation(arr);\n    var iqr = simple_statistics_1.interquartileRange(arr);\n    if (typeof iqr === 'number') {\n        s = Math.min(s, iqr / 1.34);\n    }\n    return 1.06 * s * Math.pow(arr.length, -0.2);\n}\nexports.nrd = nrd;\n\n\n/***/ }),\n\n/***/ \"./src/util/get-geo-projection.ts\":\n/*!****************************************!*\\\n  !*** ./src/util/get-geo-projection.ts ***!\n  \\****************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar d3Geo = tslib_1.__importStar(__webpack_require__(/*! d3-geo */ \"./node_modules/_d3-geo@1.6.4@d3-geo/build/d3-geo.js\"));\nvar d3GeoProjection = tslib_1.__importStar(__webpack_require__(/*! d3-geo-projection */ \"./node_modules/_d3-geo-projection@2.1.2@d3-geo-projection/build/d3-geo-projection.js\"));\nvar d3CompositeProjection = tslib_1.__importStar(__webpack_require__(/*! d3-composite-projections */ \"./node_modules/_d3-composite-projections@1.3.2@d3-composite-projections/d3-composite-projections.js\"));\n/*\n * getGeoProjection\n *\n * @param {string|function} projection  projection name or projection function\n * @param {boolean} [exportRaw = false] - whether return the raw projection or not\n * */\nexports.default = (function (projection, exportRaw) {\n    if (exportRaw === void 0) { exportRaw = false; }\n    if (util_1.isFunction(projection)) {\n        return exportRaw ? projection : projection();\n    }\n    if (util_1.isString(projection)) {\n        // @ts-ignore\n        if (d3Geo[projection]) {\n            // @ts-ignore\n            return exportRaw ? d3Geo[projection] : d3Geo[projection]();\n        }\n        if (d3GeoProjection[projection]) {\n            return exportRaw ? d3GeoProjection[projection] : d3GeoProjection[projection]();\n        }\n        if (d3CompositeProjection[projection]) {\n            return exportRaw ? d3CompositeProjection[projection] : d3CompositeProjection[projection]();\n        }\n    }\n    return null;\n});\n\n\n/***/ }),\n\n/***/ \"./src/util/get-series-values.ts\":\n/*!***************************************!*\\\n  !*** ./src/util/get-series-values.ts ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nexports.default = (function (extent, bw) {\n    var bandwidth = bw || 1;\n    var _a = tslib_1.__read(extent, 2), min = _a[0], max = _a[1];\n    var values = [];\n    var tmp = min;\n    while (tmp < max) {\n        values.push(tmp);\n        tmp += bandwidth;\n    }\n    values.push(max);\n    return values;\n});\n\n\n/***/ }),\n\n/***/ \"./src/util/kernel.ts\":\n/*!****************************!*\\\n  !*** ./src/util/kernel.ts ***!\n  \\****************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * @reference: https://github.com/jasondavies/science.js/blob/master/src/stats/kernel.js\n * @reference: https://github.com/Planeshifter/kernel-smooth/blob/master/lib/index.js#L16\n */\nfunction uniform(u) {\n    return Math.abs(u) <= 1 ? 0.5 : 0;\n}\nfunction tricubed(u) {\n    var abs = 1 - Math.pow(Math.abs(u), 3);\n    return Math.pow(abs, 3);\n}\nexports.default = {\n    boxcar: uniform,\n    cosine: function (u) {\n        if (Math.abs(u) <= 1) {\n            return (Math.PI / 4) * Math.cos((Math.PI / 2) * u);\n        }\n        return 0;\n    },\n    epanechnikov: function (u) {\n        return Math.abs(u) < 1 ? 0.75 * (1 - u * u) : 0;\n    },\n    gaussian: function (u) {\n        // return 1 / Math.sqrt(2 * Math.PI) * Math.exp(-0.5 * u * u);\n        return 0.3989422804 * Math.exp(-0.5 * u * u);\n    },\n    quartic: function (u) {\n        if (Math.abs(u) < 1) {\n            var tmp = 1 - u * u;\n            return (15 / 16) * tmp * tmp;\n        }\n        return 0;\n    },\n    triangular: function (u) {\n        var abs = Math.abs(u);\n        return abs < 1 ? 1 - abs : 0;\n    },\n    tricube: function (u) {\n        return Math.abs(u) < 1 ? (70 / 81) * tricubed(u) : 0;\n    },\n    triweight: function (u) {\n        if (Math.abs(u) < 1) {\n            var tmp = 1 - u * u;\n            return (35 / 32) * tmp * tmp * tmp;\n        }\n        return 0;\n    },\n    uniform: uniform,\n};\n\n\n/***/ }),\n\n/***/ \"./src/util/option-parser.ts\":\n/*!***********************************!*\\\n  !*** ./src/util/option-parser.ts ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar INVALID_FIELD_ERR_MSG = 'Invalid field: it must be a string!';\nvar INVALID_FIELDS_ERR_MSG = 'Invalid fields: it must be an array!';\nfunction getField(options, defaultField) {\n    var field = options.field, fields = options.fields;\n    if (util_1.isString(field)) {\n        return field;\n    }\n    if (util_1.isArray(field)) {\n        console.warn(INVALID_FIELD_ERR_MSG);\n        return field[0];\n    }\n    console.warn(INVALID_FIELD_ERR_MSG + \" will try to get fields instead.\");\n    if (util_1.isString(fields)) {\n        return fields;\n    }\n    if (util_1.isArray(fields) && fields.length) {\n        return fields[0];\n    }\n    if (defaultField) {\n        return defaultField;\n    }\n    throw new TypeError(INVALID_FIELD_ERR_MSG);\n}\nexports.getField = getField;\nfunction getFields(options, defaultFields) {\n    var field = options.field, fields = options.fields;\n    if (util_1.isArray(fields)) {\n        return fields;\n    }\n    if (util_1.isString(fields)) {\n        console.warn(INVALID_FIELDS_ERR_MSG);\n        return [fields];\n    }\n    console.warn(INVALID_FIELDS_ERR_MSG + \" will try to get field instead.\");\n    if (util_1.isString(field)) {\n        console.warn(INVALID_FIELDS_ERR_MSG);\n        return [field];\n    }\n    if (util_1.isArray(field) && field.length) {\n        console.warn(INVALID_FIELDS_ERR_MSG);\n        return field;\n    }\n    if (defaultFields) {\n        return defaultFields;\n    }\n    throw new TypeError(INVALID_FIELDS_ERR_MSG);\n}\nexports.getFields = getFields;\n\n\n/***/ }),\n\n/***/ \"./src/util/p-by-fraction.ts\":\n/*!***********************************!*\\\n  !*** ./src/util/p-by-fraction.ts ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = (function (fraction) {\n    var step = 1 / fraction;\n    var pArr = [];\n    for (var i = 0; i <= 1; i = i + step) {\n        pArr.push(i);\n    }\n    return pArr;\n});\n\n\n/***/ }),\n\n/***/ \"./src/util/partition.ts\":\n/*!*******************************!*\\\n  !*** ./src/util/partition.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nvar simple_sort_by_1 = tslib_1.__importDefault(__webpack_require__(/*! ./simple-sort-by */ \"./src/util/simple-sort-by.ts\"));\nexports.default = (function (rows, group_by, order_by) {\n    if (order_by === void 0) { order_by = []; }\n    var newRows = rows;\n    if (order_by && order_by.length) {\n        newRows = simple_sort_by_1.default(rows, order_by);\n    }\n    var groupingFn;\n    if (util_1.isFunction(group_by)) {\n        groupingFn = group_by;\n    }\n    else if (util_1.isArray(group_by)) {\n        groupingFn = function (row) { return \"_\" + group_by.map(function (col) { return row[col]; }).join('-'); };\n        // NOTE: Object.keys({'b': 'b', '2': '2', '1': '1', 'a': 'a'}) => [ '1', '2', 'b', 'a' ]\n        // that is why we have to add a prefix\n    }\n    else if (util_1.isString(group_by)) {\n        groupingFn = function (row) { return \"_\" + row[group_by]; };\n    }\n    var groups = util_1.groupBy(newRows, groupingFn);\n    return groups;\n});\n\n\n/***/ }),\n\n/***/ \"./src/util/simple-sort-by.ts\":\n/*!************************************!*\\\n  !*** ./src/util/simple-sort-by.ts ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nfunction sortBy(arr, keys) {\n    if (keys === void 0) { keys = []; }\n    var comparer = undefined;\n    if (util_1.isFunction(keys)) {\n        comparer = keys;\n    }\n    else if (util_1.isArray(keys)) {\n        comparer = function (a, b) {\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                if (a[key] < b[key]) {\n                    return -1;\n                }\n                if (a[key] > b[key]) {\n                    return 1;\n                }\n            }\n            return 0;\n        };\n    }\n    else if (util_1.isString(keys)) {\n        comparer = function (a, b) {\n            if (a[keys] < b[keys]) {\n                return -1;\n            }\n            if (a[keys] > b[keys]) {\n                return 1;\n            }\n            return 0;\n        };\n    }\n    return arr.sort(comparer);\n}\nexports.default = sortBy;\n\n\n/***/ }),\n\n/***/ \"./src/util/tag-cloud.ts\":\n/*!*******************************!*\\\n  !*** ./src/util/tag-cloud.ts ***!\n  \\*******************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/*\n * Synchronous version of d3-cloud\n */\n// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\n/* eslint-disable no-return-assign, no-cond-assign */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar cloudRadians = Math.PI / 180, cw = (1 << 11) >> 5, ch = 1 << 11;\nfunction cloudText(d) {\n    return d.text;\n}\nfunction cloudFont() {\n    return 'serif';\n}\nfunction cloudFontNormal() {\n    return 'normal';\n}\nfunction cloudFontSize(d) {\n    return d.value;\n}\nfunction cloudRotate() {\n    return ~~(Math.random() * 2) * 90;\n}\nfunction cloudPadding() {\n    return 1;\n}\n// Fetches a monochrome sprite bitmap for the specified text.\n// Load in batches for speed.\nfunction cloudSprite(contextAndRatio, d, data, di) {\n    if (d.sprite)\n        return;\n    var c = contextAndRatio.context, ratio = contextAndRatio.ratio;\n    c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n    var x = 0, y = 0, maxh = 0;\n    var n = data.length;\n    --di;\n    while (++di < n) {\n        d = data[di];\n        c.save();\n        c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;\n        var w = c.measureText(d.text + 'm').width * ratio, h = d.size << 1;\n        if (d.rotate) {\n            var sr = Math.sin(d.rotate * cloudRadians), cr = Math.cos(d.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;\n            w = ((Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5) << 5;\n            h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n        }\n        else {\n            w = ((w + 0x1f) >> 5) << 5;\n        }\n        if (h > maxh)\n            maxh = h;\n        if (x + w >= cw << 5) {\n            x = 0;\n            y += maxh;\n            maxh = 0;\n        }\n        if (y + h >= ch)\n            break;\n        c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n        if (d.rotate)\n            c.rotate(d.rotate * cloudRadians);\n        c.fillText(d.text, 0, 0);\n        if (d.padding) {\n            c.lineWidth = 2 * d.padding;\n            c.strokeText(d.text, 0, 0);\n        }\n        c.restore();\n        d.width = w;\n        d.height = h;\n        d.xoff = x;\n        d.yoff = y;\n        d.x1 = w >> 1;\n        d.y1 = h >> 1;\n        d.x0 = -d.x1;\n        d.y0 = -d.y1;\n        d.hasText = true;\n        x += w;\n    }\n    var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];\n    while (--di >= 0) {\n        d = data[di];\n        if (!d.hasText)\n            continue;\n        var w = d.width, w32 = w >> 5;\n        var h = d.y1 - d.y0;\n        // Zero the buffer\n        for (var i = 0; i < h * w32; i++)\n            sprite[i] = 0;\n        x = d.xoff;\n        if (x == null)\n            return;\n        y = d.yoff;\n        var seen = 0, seenRow = -1;\n        for (var j = 0; j < h; j++) {\n            for (var i = 0; i < w; i++) {\n                var k = w32 * j + (i >> 5), m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;\n                sprite[k] |= m;\n                seen |= m;\n            }\n            if (seen)\n                seenRow = j;\n            else {\n                d.y0++;\n                h--;\n                j--;\n                y++;\n            }\n        }\n        d.y1 = d.y0 + seenRow;\n        d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n    }\n}\n// Use mask-based collision detection.\nfunction cloudCollide(tag, board, sw) {\n    sw >>= 5;\n    var sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 0x7f, msx = 32 - sx, h = tag.y1 - tag.y0;\n    var x = (tag.y + tag.y0) * sw + (lx >> 5), last;\n    for (var j = 0; j < h; j++) {\n        last = 0;\n        for (var i = 0; i <= w; i++) {\n            if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i])\n                return true;\n        }\n        x += sw;\n    }\n    return false;\n}\nfunction cloudBounds(bounds, d) {\n    var b0 = bounds[0], b1 = bounds[1];\n    if (d.x + d.x0 < b0.x)\n        b0.x = d.x + d.x0;\n    if (d.y + d.y0 < b0.y)\n        b0.y = d.y + d.y0;\n    if (d.x + d.x1 > b1.x)\n        b1.x = d.x + d.x1;\n    if (d.y + d.y1 > b1.y)\n        b1.y = d.y + d.y1;\n}\nfunction collideRects(a, b) {\n    return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\n}\nfunction archimedeanSpiral(size) {\n    var e = size[0] / size[1];\n    return function (t) {\n        return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];\n    };\n}\nfunction rectangularSpiral(size) {\n    var dy = 4, dx = (dy * size[0]) / size[1];\n    var x = 0, y = 0;\n    return function (t) {\n        var sign = t < 0 ? -1 : 1;\n        // See triangular numbers: T_n = n * (n + 1) / 2.\n        switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {\n            case 0:\n                x += dx;\n                break;\n            case 1:\n                y += dy;\n                break;\n            case 2:\n                x -= dx;\n                break;\n            default:\n                y -= dy;\n                break;\n        }\n        return [x, y];\n    };\n}\n// TODO reuse arrays?\nfunction zeroArray(n) {\n    var a = [];\n    var i = -1;\n    while (++i < n)\n        a[i] = 0;\n    return a;\n}\nfunction cloudCanvas() {\n    return document.createElement('canvas');\n}\nfunction functor(d) {\n    return typeof d === 'function'\n        ? d\n        : function () {\n            return d;\n        };\n}\nvar spirals = {\n    archimedean: archimedeanSpiral,\n    rectangular: rectangularSpiral,\n};\nfunction default_1() {\n    var size = [256, 256], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontStyle = cloudFontNormal, fontWeight = cloudFontNormal, rotate = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, words = [], timeInterval = Infinity, random = Math.random, canvas = cloudCanvas;\n    var cloud = {};\n    cloud.canvas = function (_) {\n        return arguments.length ? ((canvas = functor(_)), cloud) : canvas;\n    };\n    cloud.start = function () {\n        var _a = tslib_1.__read(size, 2), width = _a[0], height = _a[1];\n        var contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]), n = words.length, tags = [], data = words\n            .map(function (d, i) {\n            d.text = text.call(this, d, i);\n            d.font = font.call(this, d, i);\n            d.style = fontStyle.call(this, d, i);\n            d.weight = fontWeight.call(this, d, i);\n            d.rotate = rotate.call(this, d, i);\n            d.size = ~~fontSize.call(this, d, i);\n            d.padding = padding.call(this, d, i);\n            return d;\n        })\n            .sort(function (a, b) {\n            return b.size - a.size;\n        });\n        var i = -1, bounds = !cloud.board\n            ? null\n            : [\n                {\n                    x: 0,\n                    y: 0,\n                },\n                {\n                    x: width,\n                    y: height,\n                },\n            ];\n        step();\n        function step() {\n            var start = Date.now();\n            while (Date.now() - start < timeInterval && ++i < n) {\n                var d = data[i];\n                d.x = (width * (random() + 0.5)) >> 1;\n                d.y = (height * (random() + 0.5)) >> 1;\n                cloudSprite(contextAndRatio, d, data, i);\n                if (d.hasText && place(board, d, bounds)) {\n                    tags.push(d);\n                    if (bounds) {\n                        if (!cloud.hasImage) {\n                            // update bounds if image mask not set\n                            cloudBounds(bounds, d);\n                        }\n                    }\n                    else {\n                        bounds = [\n                            { x: d.x + d.x0, y: d.y + d.y0 },\n                            { x: d.x + d.x1, y: d.y + d.y1 },\n                        ];\n                    }\n                    // Temporary hack\n                    d.x -= size[0] >> 1;\n                    d.y -= size[1] >> 1;\n                }\n            }\n            cloud._tags = tags;\n            cloud._bounds = bounds;\n        }\n        return cloud;\n    };\n    function getContext(canvas) {\n        canvas.width = canvas.height = 1;\n        var ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);\n        canvas.width = (cw << 5) / ratio;\n        canvas.height = ch / ratio;\n        var context = canvas.getContext('2d');\n        context.fillStyle = context.strokeStyle = 'red';\n        context.textAlign = 'center';\n        return { context: context, ratio: ratio };\n    }\n    function place(board, tag, bounds) {\n        // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],\n        var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), s = spiral(size), dt = random() < 0.5 ? 1 : -1;\n        var dxdy, t = -dt, dx, dy;\n        while ((dxdy = s((t += dt)))) {\n            dx = ~~dxdy[0];\n            dy = ~~dxdy[1];\n            if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)\n                break;\n            tag.x = startX + dx;\n            tag.y = startY + dy;\n            if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1])\n                continue;\n            // TODO only check for collisions within current bounds.\n            if (!bounds || !cloudCollide(tag, board, size[0])) {\n                if (!bounds || collideRects(tag, bounds)) {\n                    var sprite = tag.sprite, w = tag.width >> 5, sw = size[0] >> 5, lx = tag.x - (w << 4), sx = lx & 0x7f, msx = 32 - sx, h = tag.y1 - tag.y0;\n                    var last = void 0, x = (tag.y + tag.y0) * sw + (lx >> 5);\n                    for (var j = 0; j < h; j++) {\n                        last = 0;\n                        for (var i = 0; i <= w; i++) {\n                            board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n                        }\n                        x += sw;\n                    }\n                    delete tag.sprite;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    cloud.createMask = function (img) {\n        var can = document.createElement('canvas');\n        var _a = tslib_1.__read(size, 2), width = _a[0], height = _a[1];\n        var w32 = width >> 5;\n        var board = zeroArray((width >> 5) * height);\n        can.width = width;\n        can.height = height;\n        var cxt = can.getContext('2d');\n        cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);\n        var imageData = cxt.getImageData(0, 0, width, height).data;\n        for (var j = 0; j < height; j++) {\n            for (var i = 0; i < width; i++) {\n                var k = w32 * j + (i >> 5);\n                var tmp = (j * width + i) << 2;\n                var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;\n                var m = flag ? 1 << (31 - (i % 32)) : 0;\n                board[k] |= m;\n            }\n        }\n        cloud.board = board;\n        cloud.hasImage = true;\n    };\n    cloud.timeInterval = function (_) {\n        return arguments.length ? ((timeInterval = _ == null ? Infinity : _), cloud) : timeInterval;\n    };\n    cloud.words = function (_) {\n        return arguments.length ? ((words = _), cloud) : words;\n    };\n    cloud.size = function (_) {\n        return arguments.length ? ((size = [+_[0], +_[1]]), cloud) : size;\n    };\n    cloud.font = function (_) {\n        return arguments.length ? ((font = functor(_)), cloud) : font;\n    };\n    cloud.fontStyle = function (_) {\n        return arguments.length ? ((fontStyle = functor(_)), cloud) : fontStyle;\n    };\n    cloud.fontWeight = function (_) {\n        return arguments.length ? ((fontWeight = functor(_)), cloud) : fontWeight;\n    };\n    cloud.rotate = function (_) {\n        return arguments.length ? ((rotate = functor(_)), cloud) : rotate;\n    };\n    cloud.text = function (_) {\n        return arguments.length ? ((text = functor(_)), cloud) : text;\n    };\n    cloud.spiral = function (_) {\n        return arguments.length ? ((spiral = spirals[_] || _), cloud) : spiral;\n    };\n    cloud.fontSize = function (_) {\n        return arguments.length ? ((fontSize = functor(_)), cloud) : fontSize;\n    };\n    cloud.padding = function (_) {\n        return arguments.length ? ((padding = functor(_)), cloud) : padding;\n    };\n    cloud.random = function (_) {\n        return arguments.length ? ((random = _), cloud) : random;\n    };\n    return cloud;\n}\nexports.default = default_1;\n\n\n/***/ }),\n\n/***/ \"./src/view.ts\":\n/*!*********************!*\\\n  !*** ./src/view.ts ***!\n  \\*********************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/_tslib@1.11.1@tslib/tslib.js\");\nvar wolfy87_eventemitter_1 = tslib_1.__importDefault(__webpack_require__(/*! wolfy87-eventemitter */ \"./node_modules/_wolfy87-eventemitter@5.2.9@wolfy87-eventemitter/EventEmitter.js\"));\nvar util_1 = __webpack_require__(/*! @antv/util */ \"./node_modules/_@antv_util@2.0.7@@antv/util/lib/index.js\");\nfunction cloneOptions(options) {\n    var result = {};\n    util_1.forIn(options, function (value, key) {\n        if (util_1.isObject(value) && value.isView) {\n            result[key] = value;\n        }\n        else if (util_1.isArray(value)) {\n            result[key] = value.concat([]);\n        }\n        else if (util_1.isPlainObject(value)) {\n            result[key] = util_1.clone(value);\n        }\n        else {\n            result[key] = value;\n        }\n    });\n    return result;\n}\n/**\n * 数据视图\n * @public\n */\nvar View = /** @class */ (function (_super) {\n    tslib_1.__extends(View, _super);\n    function View(dataSet, options) {\n        var _this = _super.call(this) || this;\n        /**\n         * 是否是View\n         */\n        _this.isView = true;\n        /**\n         * 是否是View\n         */\n        _this.isDataView = true; // alias\n        /**\n         *\n         */\n        _this.watchingStates = null;\n        /**\n         * 数据视图类型\n         */\n        _this.dataType = 'table';\n        /**\n         * 已应用的 transform\n         */\n        _this.transforms = [];\n        /**\n         * 原始数据\n         */\n        _this.origin = [];\n        /**\n         * 存储处理后的数据\n         */\n        _this.rows = [];\n        if (dataSet && dataSet.isDataSet) {\n            _this.dataSet = dataSet;\n        }\n        else {\n            _this.dataSet = null;\n            options = dataSet;\n        }\n        _this.loose = !_this.dataSet;\n        // TODO:\n        // assign(me, options);\n        if (options) {\n            _this.watchingStates = options.watchingStates;\n        }\n        if (!_this.loose) {\n            var watchingStates_1 = _this.watchingStates;\n            dataSet.on('statechange', function (name) {\n                if (util_1.isArray(watchingStates_1)) {\n                    if (watchingStates_1.indexOf(name) > -1) {\n                        _this._reExecute();\n                    }\n                }\n                else {\n                    _this._reExecute();\n                }\n            });\n        }\n        return _this;\n    }\n    View.prototype._parseStateExpression = function (expr) {\n        var dataSet = this.dataSet;\n        if (dataSet === null)\n            return undefined;\n        var matched = /^\\$state\\.(\\w+)/.exec(expr);\n        if (matched) {\n            return dataSet.state[matched[1]];\n        }\n        return expr;\n    };\n    View.prototype._preparseOptions = function (options) {\n        var _this = this;\n        var optionsCloned = cloneOptions(options);\n        if (this.loose) {\n            return optionsCloned;\n        }\n        util_1.forIn(optionsCloned, function (value, key) {\n            if (util_1.isString(value) && /^\\$state\\./.test(value)) {\n                optionsCloned[key] = _this._parseStateExpression(value);\n            }\n        });\n        return optionsCloned;\n    };\n    // connectors\n    View.prototype._prepareSource = function (source, options) {\n        // warning me.origin is protected\n        this._source = { source: source, options: options };\n        if (!options) {\n            if (source instanceof View || util_1.isString(source)) {\n                this.origin = View.DataSet.getConnector('default')(source, this.dataSet);\n            }\n            else if (util_1.isArray(source)) {\n                // TODO branch: if source is like ['dataview1', 'dataview2']\n                this.origin = source;\n            }\n            else if (util_1.isObject(source) && source.type) {\n                var opts = this._preparseOptions(source); // connector without source\n                this.origin = View.DataSet.getConnector(opts.type)(opts, this);\n            }\n            else {\n                throw new TypeError('Invalid source');\n            }\n        }\n        else {\n            var opts = this._preparseOptions(options);\n            this.origin = View.DataSet.getConnector(opts.type)(source, opts, this);\n        }\n        this.rows = util_1.deepMix([], this.origin);\n        return this;\n    };\n    View.prototype.source = function (source, options) {\n        this._prepareSource(source, options)._reExecuteTransforms();\n        this.trigger('change', []);\n        return this;\n    };\n    /**\n     *  执行数据处理数据。执行完这个函数后，transform 会被存储\n     * @param options - 某种类型的transform\n     */\n    View.prototype.transform = function (options) {\n        if (options && options.type) {\n            this.transforms.push(options);\n            this._executeTransform(options);\n        }\n        return this;\n    };\n    View.prototype._executeTransform = function (options) {\n        options = this._preparseOptions(options);\n        var transform = View.DataSet.getTransform(options.type);\n        transform(this, options);\n    };\n    View.prototype._reExecuteTransforms = function () {\n        var _this = this;\n        this.transforms.forEach(function (options) {\n            _this._executeTransform(options);\n        });\n    };\n    View.prototype.addRow = function (row) {\n        this.rows.push(row);\n    };\n    View.prototype.removeRow = function (index) {\n        this.rows.splice(index, 1);\n    };\n    View.prototype.updateRow = function (index, newRow) {\n        util_1.assign(this.rows[index], newRow);\n    };\n    View.prototype.findRows = function (query) {\n        return this.rows.filter(function (row) { return util_1.isMatch(row, query); });\n    };\n    View.prototype.findRow = function (query) {\n        return util_1.find(this.rows, query);\n    };\n    // columns\n    View.prototype.getColumnNames = function () {\n        var firstRow = this.rows[0];\n        if (firstRow) {\n            return util_1.keys(firstRow);\n        }\n        return [];\n    };\n    View.prototype.getColumnName = function (index) {\n        return this.getColumnNames()[index];\n    };\n    View.prototype.getColumnIndex = function (columnName) {\n        var columnNames = this.getColumnNames();\n        return columnNames.indexOf(columnName);\n    };\n    View.prototype.getColumn = function (columnName) {\n        return this.rows.map(function (row) { return row[columnName]; });\n    };\n    View.prototype.getColumnData = function (columnName) {\n        return this.getColumn(columnName);\n    };\n    // data process\n    View.prototype.getSubset = function (startRowIndex, endRowIndex, columnNames) {\n        var subset = [];\n        for (var i = startRowIndex; i <= endRowIndex; i++) {\n            subset.push(util_1.pick(this.rows[i], columnNames));\n        }\n        return subset;\n    };\n    View.prototype.toString = function (prettyPrint) {\n        if (prettyPrint === void 0) { prettyPrint = false; }\n        if (prettyPrint) {\n            return JSON.stringify(this.rows, null, 2);\n        }\n        return JSON.stringify(this.rows);\n    };\n    View.prototype._reExecute = function () {\n        var _a = this._source, source = _a.source, options = _a.options;\n        this._prepareSource(source, options);\n        this._reExecuteTransforms();\n        this.trigger('change', []);\n    };\n    return View;\n}(wolfy87_eventemitter_1.default));\nexports.View = View;\n\n\n/***/ })\n\n/******/ });\n});\n//# sourceMappingURL=data-set.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFudHYvZGF0YS1zZXQvYnVpbGQvZGF0YS1zZXQuanM/NzEwNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNLEVBS3dCO0FBQzlCLENBQUM7QUFDRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0NBQWdDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxrQkFBa0I7QUFDbEY7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQ0FBaUM7QUFDbEYsd0hBQXdILG1CQUFtQixFQUFFO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEIsRUFBRTtBQUMvRCx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtEQUErRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEVBQUU7QUFDUixDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7O0FBR3BDO0FBQ0E7QUFDQSxpRUFBaUU7O0FBRWpFLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpELGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUEsK0NBQStDLDBEQUEwRCwyQ0FBMkMsaUNBQWlDOztBQUVyTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBLFdBQVc7O0FBRVg7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQSxlQUFlOztBQUVmO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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Q0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVELGdDQUFnQyxFQUFFO0FBQ2xDOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDJCQUEyQixFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakMsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLFNBQVM7QUFDcEYsa0VBQWtFLFNBQVM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCLENBQUM7QUFDRDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FB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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7QUFDakQsaURBQWlEO0FBQ2pELGlEQUFpRDtBQUNqRCxpREFBaUQ7O0FBRWpELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCw2Q0FBNkMsR0FBRztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxzQkFBc0I7QUFDckU7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsMkxBQTJMO0FBQzNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFvSCxXQUFXO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGdEQUFnRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdDQUFnQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdDQUFnQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSkFBc0o7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLCtEQUErRCxFQUFFO0FBQ2hILHdDQUF3QyxnQkFBZ0IsRUFBRTtBQUMxRCxzQ0FBc0MsY0FBYyxFQUFFO0FBQ3RELDJDQUEyQyxtQkFBbUIsRUFBRTtBQUNoRSx5Q0FBeUMsaUJBQWlCO0FBQzFELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsT0FBTztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGlEQUFpRCxFQUFFO0FBQ2xJLDRGQUE0RixtREFBbUQsRUFBRTtBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdEQUFnRDtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxnREFBZ0QsaUNBQWlDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx1Q0FBdUM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0NBQWdDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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b0JBQW9CO0FBQ3BCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHdDQUF3QztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1DQUFtQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsUUFBUTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrR0FBK0c7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWEsRUFBRTtBQUM1RDtBQUNBLDJDQUEyQyxzQkFBc0I7QUFDakU7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQsOEhBQThILE9BQU87QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0QkFBNEIsZUFBZSxFQUFFLEVBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRCQUE0QixlQUFlLEVBQUUsRUFBRTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1Riw4QkFBOEIsRUFBRTtBQUN2SCx1RkFBdUYsOEJBQThCLEVBQUU7QUFDdkg7QUFDQTtBQUNBLHVEQUF1RCxTQUFTLGdEQUFnRCxFQUFFO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdDQUFnQyx5QkFBeUIsRUFBRTtBQUMzRCw2QkFBNkIsc0JBQXNCLEVBQUU7QUFDckQsZ0NBQWdDLHlCQUF5QixFQUFFO0FBQzNELDhCQUE4Qix1QkFBdUIsRUFBRTtBQUN2RCxtQ0FBbUMsNEJBQTRCLEVBQUU7QUFDakUsaUNBQWlDLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QixzQ0FBc0MsRUFBRTtBQUMxRyx5Q0FBeUMscUJBQXFCLHNDQUFzQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQixFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELHVDQUF1QyxFQUFFO0FBQ3pDLGlDQUFpQyxZQUFZO0FBQzdDLG9DQUFvQyxFQUFFO0FBQ3RDLG9DQUFvQyxZQUFZO0FBQ2hELHVDQUF1QyxFQUFFO0FBQ3pDLGtDQUFrQyxZQUFZO0FBQzlDLHFDQUFxQyxFQUFFO0FBQ3ZDLHVDQUF1QyxZQUFZO0FBQ25ELDBDQUEwQyxFQUFFO0FBQzVDLHFDQUFxQyxZQUFZO0FBQ2pELHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5QkFBeUIsZ0JBQWdCLEVBQUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1KQUFtSjtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUNBQW1DO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFFBQVE7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUNBQWlDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFELDhIQUE4SCxPQUFPO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCLGVBQWUsRUFBRSxFQUFFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0QkFBNEIsZUFBZSxFQUFFLEVBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsOEJBQThCLEVBQUU7QUFDdkgsdUZBQXVGLDhCQUE4QixFQUFFO0FBQ3ZIO0FBQ0E7QUFDQSx1REFBdUQsU0FBUyxnREFBZ0QsRUFBRTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsdUNBQXVDLEVBQUU7QUFDekMsaUNBQWlDLFlBQVk7QUFDN0Msb0NBQW9DLEVBQUU7QUFDdEMsb0NBQW9DLFlBQVk7QUFDaEQsdUNBQXVDLEVBQUU7QUFDekMsa0NBQWtDLFlBQVk7QUFDOUMscUNBQXFDLEVBQUU7QUFDdkMsdUNBQXVDLFlBQVk7QUFDbkQsMENBQTBDLEVBQUU7QUFDNUMscUNBQXFDLFlBQVk7QUFDakQsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QixnQkFBZ0IsRUFBRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUpBQW1KO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG9DQUFvQyxLQUFLLEVBQUU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnRUFBZ0U7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsT0FBTztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjO0FBQ2hFLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFNBQVM7QUFDakIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxQ0FBcUMsRUFBRTtBQUNuRjtBQUNBLDRDQUE0QywrQkFBK0IsRUFBRTtBQUM3RTtBQUNBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MseUJBQXlCLEVBQUU7QUFDbkUsc0NBQXNDLHlCQUF5QixFQUFFO0FBQ2pFLHlDQUF5Qyx5QkFBeUIsRUFBRTtBQUNwRSx5Q0FBeUMseUJBQXlCLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRCQUE0QixFQUFFO0FBQy9ELGdDQUFnQywyQkFBMkIsRUFBRTtBQUM3RCxpQ0FBaUMsNEJBQTRCLEVBQUU7QUFDL0Qsd0RBQXdELG1EQUFtRDtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLE9BQU87QUFDdkU7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0EsNENBQTRDLDRCQUE0QixFQUFFO0FBQzFFLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdCQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwwQ0FBMEMsRUFBRTtBQUMzRztBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEUsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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QUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNEQUFzRCxpQkFBaUIsRUFBRTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGVBQWUsRUFBRTtBQUN4RDtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUgsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCw2Q0FBNkMsdUJBQXVCLEVBQUU7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsMEJBQTBCLEVBQUU7QUFDeEU7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWMsRUFBRTtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsV0FBVztBQUMvRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxxQkFBcUIsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHFCQUFxQixFQUFFO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZUFBZSwyQ0FBMkM7QUFDMUQsR0FBRztBQUNIO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsYUFBYTtBQUN4QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsYUFBYTtBQUN4QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE1BQU07QUFDakIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDOztBQUVBOztBQUVBLDRCQUE0Qjs7QUFFNUIsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxPQUFP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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUIsVUFBVSxHQUFHO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBEQUEwRCxtQkFBbUIsRUFBRTtBQUMvRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsbUJBQW1CLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRCw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNENBQTRDLEVBQUU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw4REFBOEQsRUFBRTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMENBQTBDLEVBQUU7QUFDbkcsdURBQXVELHFEQUFxRCxFQUFFO0FBQzlHO0FBQ0E7QUFDQSx1REFBdUQsaUJBQWlCLEVBQUU7QUFDMUUsdURBQXVELDRCQUE0QixFQUFFO0FBQ3JGO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsbUJBQW1CLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbUJBQW1CLEVBQUU7QUFDM0UsaURBQWlELHVEQUF1RCxFQUFFO0FBQzFHO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG1DQUFtQyxFQUFFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxtQ0FBbUMsRUFBRTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFD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LDZDQUE2Qyx3QkFBd0IsRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPOztBQUVQLFVBQVU7QUFDVixDQUFDO0FBQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFudHYvZGF0YS1zZXQvYnVpbGQvZGF0YS1zZXQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJEYXRhU2V0XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkRhdGFTZXRcIl0gPSBmYWN0b3J5KCk7XG59KSh3aW5kb3csIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC50c1wiKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfaGllcmFyY2h5QDAuNi4yQEBhbnR2L2hpZXJhcmNoeS9idWlsZC9oaWVyYXJjaHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl9oaWVyYXJjaHlAMC42LjJAQGFudHYvaGllcmFyY2h5L2J1aWxkL2hpZXJhcmNoeS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHJ1ZSlcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSB7fVxufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA1KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhc3NpZ246IGFzc2lnblxufTtcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoaWVyYXJjaHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgTGF5b3V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGF5b3V0KHJvb3QsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICBtZS5vcHRpb25zID0gb3B0aW9ucztcbiAgICBtZS5yb290Tm9kZSA9IGhpZXJhcmNoeShyb290LCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMYXlvdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5leGVjdXRlID0gZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BsZWFzZSBvdmVycmlkZSB0aGlzIG1ldGhvZCcpO1xuICB9O1xuXG4gIHJldHVybiBMYXlvdXQ7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHNlcGFyYXRlVHJlZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBWQUxJRF9ESVJFQ1RJT05TID0gWydMUicsIC8vIGxlZnQgdG8gcmlnaHRcbidSTCcsIC8vIHJpZ2h0IHRvIGxlZnRcbidUQicsIC8vIHRvcCB0byBib3R0b21cbidCVCcsIC8vIGJvdHRvbSB0byB0b3BcbidIJywgLy8gaG9yaXpvbnRhbFxuJ1YnIC8vIHZlcnRpY2FsXG5dO1xudmFyIEhPUklaT05UQUxfRElSRUNUSU9OUyA9IFsnTFInLCAnUkwnLCAnSCddO1xuXG52YXIgaXNIb3Jpem9udGFsID0gZnVuY3Rpb24gaXNIb3Jpem9udGFsKGRpcmVjdGlvbikge1xuICByZXR1cm4gSE9SSVpPTlRBTF9ESVJFQ1RJT05TLmluZGV4T2YoZGlyZWN0aW9uKSA+IC0xO1xufTtcblxudmFyIERFRkFVTFRfRElSRUNUSU9OID0gVkFMSURfRElSRUNUSU9OU1swXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgb3B0aW9ucywgbGF5b3V0QWxncml0aG0pIHtcbiAgdmFyIGRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uIHx8IERFRkFVTFRfRElSRUNUSU9OO1xuICBvcHRpb25zLmlzSG9yaXpvbnRhbCA9IGlzSG9yaXpvbnRhbChkaXJlY3Rpb24pO1xuXG4gIGlmIChkaXJlY3Rpb24gJiYgVkFMSURfRElSRUNUSU9OUy5pbmRleE9mKGRpcmVjdGlvbikgPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgZGlyZWN0aW9uOiBcIiArIGRpcmVjdGlvbik7XG4gIH1cblxuICBpZiAoZGlyZWN0aW9uID09PSBWQUxJRF9ESVJFQ1RJT05TWzBdKSB7XG4gICAgLy8gTFJcbiAgICBsYXlvdXRBbGdyaXRobShyb290LCBvcHRpb25zKTtcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFZBTElEX0RJUkVDVElPTlNbMV0pIHtcbiAgICAvLyBSTFxuICAgIGxheW91dEFsZ3JpdGhtKHJvb3QsIG9wdGlvbnMpO1xuICAgIHJvb3QucmlnaHQybGVmdCgpO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gVkFMSURfRElSRUNUSU9OU1syXSkge1xuICAgIC8vIFRCXG4gICAgbGF5b3V0QWxncml0aG0ocm9vdCwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBWQUxJRF9ESVJFQ1RJT05TWzNdKSB7XG4gICAgLy8gQlRcbiAgICBsYXlvdXRBbGdyaXRobShyb290LCBvcHRpb25zKTtcbiAgICByb290LmJvdHRvbTJ0b3AoKTtcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFZBTElEX0RJUkVDVElPTlNbNF0gfHwgZGlyZWN0aW9uID09PSBWQUxJRF9ESVJFQ1RJT05TWzVdKSB7XG4gICAgLy8gSCBvciBWXG4gICAgLy8gc2VwYXJhdGUgaW50byBsZWZ0IGFuZCByaWdodCB0cmVlc1xuICAgIHZhciBfc2VwYXJhdGVUcmVlID0gc2VwYXJhdGVUcmVlKHJvb3QsIG9wdGlvbnMpLFxuICAgICAgICBsZWZ0ID0gX3NlcGFyYXRlVHJlZS5sZWZ0LFxuICAgICAgICByaWdodCA9IF9zZXBhcmF0ZVRyZWUucmlnaHQ7IC8vIGRvIGxheW91dCBmb3IgbGVmdCBhbmQgcmlnaHQgdHJlZXNcblxuXG4gICAgbGF5b3V0QWxncml0aG0obGVmdCwgb3B0aW9ucyk7XG4gICAgbGF5b3V0QWxncml0aG0ocmlnaHQsIG9wdGlvbnMpO1xuICAgIG9wdGlvbnMuaXNIb3Jpem9udGFsID8gbGVmdC5yaWdodDJsZWZ0KCkgOiBsZWZ0LmJvdHRvbTJ0b3AoKTsgLy8gY29tYmluZSBsZWZ0IGFuZCByaWdodCB0cmVlc1xuXG4gICAgcmlnaHQudHJhbnNsYXRlKGxlZnQueCAtIHJpZ2h0LngsIGxlZnQueSAtIHJpZ2h0LnkpOyAvLyB0cmFuc2xhdGUgcm9vdFxuXG4gICAgcm9vdC54ID0gbGVmdC54O1xuICAgIHJvb3QueSA9IHJpZ2h0Lnk7XG4gICAgdmFyIGJiID0gcm9vdC5nZXRCb3VuZGluZ0JveCgpO1xuXG4gICAgaWYgKG9wdGlvbnMuaXNIb3Jpem9udGFsKSB7XG4gICAgICBpZiAoYmIudG9wIDwgMCkge1xuICAgICAgICByb290LnRyYW5zbGF0ZSgwLCAtYmIudG9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGJiLmxlZnQgPCAwKSB7XG4gICAgICAgIHJvb3QudHJhbnNsYXRlKC1iYi5sZWZ0LCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gZml4ZWQgcm9vdCBwb3NpdGlvbiwgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG5cblxuICB2YXIgZml4ZWRSb290ID0gb3B0aW9ucy5maXhlZFJvb3Q7XG4gIGlmIChmaXhlZFJvb3QgPT09IHVuZGVmaW5lZCkgZml4ZWRSb290ID0gdHJ1ZTtcblxuICBpZiAoZml4ZWRSb290KSB7XG4gICAgcm9vdC50cmFuc2xhdGUoLShyb290LnggKyByb290LndpZHRoIC8gMiArIHJvb3QuaGdhcCksIC0ocm9vdC55ICsgcm9vdC5oZWlnaHQgLyAyICsgcm9vdC52Z2FwKSk7XG4gIH1cblxuICByZXR1cm4gcm9vdDtcbn07XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgUEVNID0gMTg7XG52YXIgREVGQVVMVF9IRUlHSFQgPSBQRU0gKiAyO1xudmFyIERFRkFVTFRfR0FQID0gUEVNO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgZ2V0SWQ6IGZ1bmN0aW9uIGdldElkKGQpIHtcbiAgICByZXR1cm4gZC5pZCB8fCBkLm5hbWU7XG4gIH0sXG4gIGdldEhHYXA6IGZ1bmN0aW9uIGdldEhHYXAoZCkge1xuICAgIHJldHVybiBkLmhnYXAgfHwgREVGQVVMVF9HQVA7XG4gIH0sXG4gIGdldFZHYXA6IGZ1bmN0aW9uIGdldFZHYXAoZCkge1xuICAgIHJldHVybiBkLnZnYXAgfHwgREVGQVVMVF9HQVA7XG4gIH0sXG4gIGdldENoaWxkcmVuOiBmdW5jdGlvbiBnZXRDaGlsZHJlbihkKSB7XG4gICAgcmV0dXJuIGQuY2hpbGRyZW47XG4gIH0sXG4gIGdldEhlaWdodDogZnVuY3Rpb24gZ2V0SGVpZ2h0KGQpIHtcbiAgICByZXR1cm4gZC5oZWlnaHQgfHwgREVGQVVMVF9IRUlHSFQ7XG4gIH0sXG4gIGdldFdpZHRoOiBmdW5jdGlvbiBnZXRXaWR0aChkKSB7XG4gICAgdmFyIG5hbWUgPSBkLm5hbWUgfHwgJyAnO1xuICAgIHJldHVybiBkLndpZHRoIHx8IG5hbWUuc3BsaXQoJycpLmxlbmd0aCAqIFBFTTsgLy8gRklYTUUgRE8gTk9UIGdldCB3aWR0aCBsaWtlIHRoaXNcbiAgfVxufTtcblxuZnVuY3Rpb24gTm9kZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBtZSA9IHRoaXM7XG4gIG1lLnZnYXAgPSBtZS5oZ2FwID0gMDtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBOb2RlKSByZXR1cm4gZGF0YTtcbiAgbWUuZGF0YSA9IGRhdGE7XG4gIC8qXG4gICAqIEdhcHM6IGZpbGxpbmcgc3BhY2UgYmV0d2VlbiBub2Rlc1xuICAgKiAoeCwgeSkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiB8ICAgICAgICAgICAgdmdhcCAgICAgICAgICAgIHxcbiAgICogfCAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLSAgICBoXG4gICAqIHwgaCB8ICAgICAgICAgICAgICAgICAgICB8ICAgZVxuICAgKiB8IGcgfCAgICAgICAgICAgICAgICAgICAgfCAgIGlcbiAgICogfCBhIHwgICAgICAgICAgICAgICAgICAgIHwgICBnXG4gICAqIHwgcCB8ICAgICAgICAgICAgICAgICAgICB8ICAgaFxuICAgKiB8ICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAgIHRcbiAgICogfCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAqICAtLS0tLS0tLS0tLXdpZHRoLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBoZ2FwID0gb3B0aW9ucy5nZXRIR2FwKGRhdGEpO1xuICB2YXIgdmdhcCA9IG9wdGlvbnMuZ2V0VkdhcChkYXRhKTtcbiAgbWUud2lkdGggPSBvcHRpb25zLmdldFdpZHRoKGRhdGEpO1xuICBtZS5oZWlnaHQgPSBvcHRpb25zLmdldEhlaWdodChkYXRhKTtcbiAgbWUuaWQgPSBvcHRpb25zLmdldElkKGRhdGEpO1xuICBtZS54ID0gbWUueSA9IDA7XG4gIG1lLmRlcHRoID0gMDtcblxuICBpZiAoIW1lLmNoaWxkcmVuKSB7XG4gICAgbWUuY2hpbGRyZW4gPSBbXTtcbiAgfVxuXG4gIG1lLmFkZEdhcChoZ2FwLCB2Z2FwKTtcbiAgcmV0dXJuIG1lO1xufVxuXG51dGlsLmFzc2lnbihOb2RlLnByb3RvdHlwZSwge1xuICBpc1Jvb3Q6IGZ1bmN0aW9uIGlzUm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZXB0aCA9PT0gMDtcbiAgfSxcbiAgaXNMZWFmOiBmdW5jdGlvbiBpc0xlYWYoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuICB9LFxuICBhZGRHYXA6IGZ1bmN0aW9uIGFkZEdhcChoZ2FwLCB2Z2FwKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICBtZS5oZ2FwICs9IGhnYXA7XG4gICAgbWUudmdhcCArPSB2Z2FwO1xuICAgIG1lLndpZHRoICs9IDIgKiBoZ2FwO1xuICAgIG1lLmhlaWdodCArPSAyICogdmdhcDtcbiAgfSxcbiAgZWFjaE5vZGU6IGZ1bmN0aW9uIGVhY2hOb2RlKGNhbGxiYWNrKSB7XG4gICAgLy8gRGVwdGggRmlyc3QgdHJhdmVyc2VcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBub2RlcyA9IFttZV07XG4gICAgdmFyIGN1cnJlbnQ7XG5cbiAgICB3aGlsZSAoY3VycmVudCA9IG5vZGVzLnBvcCgpKSB7XG4gICAgICBjYWxsYmFjayhjdXJyZW50KTtcbiAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGN1cnJlbnQuY2hpbGRyZW4pO1xuICAgIH1cbiAgfSxcbiAgREZUcmF2ZXJzZTogZnVuY3Rpb24gREZUcmF2ZXJzZShjYWxsYmFjaykge1xuICAgIC8vIERlcHRoIEZpcnN0IHRyYXZlcnNlXG4gICAgdGhpcy5lYWNoTm9kZShjYWxsYmFjayk7XG4gIH0sXG4gIEJGVHJhdmVyc2U6IGZ1bmN0aW9uIEJGVHJhdmVyc2UoY2FsbGJhY2spIHtcbiAgICAvLyBCcmVhZHRoIEZpcnN0IHRyYXZlcnNlXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgbm9kZXMgPSBbbWVdO1xuICAgIHZhciBjdXJyZW50O1xuXG4gICAgd2hpbGUgKGN1cnJlbnQgPSBub2Rlcy5zaGlmdCgpKSB7XG4gICAgICBjYWxsYmFjayhjdXJyZW50KTtcbiAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGN1cnJlbnQuY2hpbGRyZW4pO1xuICAgIH1cbiAgfSxcbiAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KCkge1xuICAgIC8vIEJCb3ggZm9yIGp1c3Qgb25lIHRyZWUgbm9kZVxuICAgIHZhciBiYiA9IHtcbiAgICAgIGxlZnQ6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICB0b3A6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdGhpcy5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgYmIubGVmdCA9IE1hdGgubWluKGJiLmxlZnQsIG5vZGUueCk7XG4gICAgICBiYi50b3AgPSBNYXRoLm1pbihiYi50b3AsIG5vZGUueSk7XG4gICAgICBiYi53aWR0aCA9IE1hdGgubWF4KGJiLndpZHRoLCBub2RlLnggKyBub2RlLndpZHRoKTtcbiAgICAgIGJiLmhlaWdodCA9IE1hdGgubWF4KGJiLmhlaWdodCwgbm9kZS55ICsgbm9kZS5oZWlnaHQpO1xuICAgIH0pO1xuICAgIHJldHVybiBiYjtcbiAgfSxcbiAgLy8gdHJhbnNsYXRlXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24gdHJhbnNsYXRlKHR4LCB0eSkge1xuICAgIGlmICh0eCA9PT0gdm9pZCAwKSB7XG4gICAgICB0eCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHR5ID09PSB2b2lkIDApIHtcbiAgICAgIHR5ID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBub2RlLnggKz0gdHg7XG4gICAgICBub2RlLnkgKz0gdHk7XG4gICAgfSk7XG4gIH0sXG4gIHJpZ2h0MmxlZnQ6IGZ1bmN0aW9uIHJpZ2h0MmxlZnQoKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgYmIgPSBtZS5nZXRCb3VuZGluZ0JveCgpO1xuICAgIG1lLmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBub2RlLnggPSBub2RlLnggLSAobm9kZS54IC0gYmIubGVmdCkgKiAyIC0gbm9kZS53aWR0aDsgLy8gbm9kZS54ID0gLSBub2RlLng7XG4gICAgfSk7XG4gICAgbWUudHJhbnNsYXRlKGJiLndpZHRoLCAwKTtcbiAgfSxcbiAgYm90dG9tMnRvcDogZnVuY3Rpb24gYm90dG9tMnRvcCgpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBiYiA9IG1lLmdldEJvdW5kaW5nQm94KCk7XG4gICAgbWUuZWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIG5vZGUueSA9IG5vZGUueSAtIChub2RlLnkgLSBiYi50b3ApICogMiAtIG5vZGUuaGVpZ2h0OyAvLyBub2RlLnkgPSAtIG5vZGUueTtcbiAgICB9KTtcbiAgICBtZS50cmFuc2xhdGUoMCwgYmIuaGVpZ2h0KTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGhpZXJhcmNoeShkYXRhLCBvcHRpb25zLCBpc29sYXRlZCkge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgb3B0aW9ucyA9IHV0aWwuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICB2YXIgcm9vdCA9IG5ldyBOb2RlKGRhdGEsIG9wdGlvbnMpO1xuICB2YXIgbm9kZXMgPSBbcm9vdF07XG4gIHZhciBub2RlO1xuXG4gIGlmICghaXNvbGF0ZWQgJiYgIWRhdGEuY29sbGFwc2VkKSB7XG4gICAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgICAgaWYgKCFub2RlLmRhdGEuY29sbGFwc2VkKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG9wdGlvbnMuZ2V0Q2hpbGRyZW4obm9kZS5kYXRhKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNoaWxkcmVuID8gY2hpbGRyZW4ubGVuZ3RoIDogMDtcbiAgICAgICAgbm9kZS5jaGlsZHJlbiA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIGlmIChjaGlsZHJlbiAmJiBsZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBuZXcgTm9kZShjaGlsZHJlbltpXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuW2ldID0gY2hpbGQ7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICBjaGlsZC5kZXB0aCA9IG5vZGUuZGVwdGggKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb290O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhpZXJhcmNoeTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoaWVyYXJjaHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCBvcHRpb25zKSB7XG4gIC8vIHNlcGFyYXRlIGludG8gbGVmdCBhbmQgcmlnaHQgdHJlZXNcbiAgdmFyIGxlZnQgPSBoaWVyYXJjaHkocm9vdC5kYXRhLCBvcHRpb25zLCB0cnVlKTsgLy8gcm9vdCBvbmx5XG5cbiAgdmFyIHJpZ2h0ID0gaGllcmFyY2h5KHJvb3QuZGF0YSwgb3B0aW9ucywgdHJ1ZSk7IC8vIHJvb3Qgb25seVxuICAvLyBhdXRvbWF0aWNhbGx5XG5cbiAgdmFyIHRyZWVTaXplID0gcm9vdC5jaGlsZHJlbi5sZW5ndGg7XG4gIHZhciByaWdodFRyZWVTaXplID0gTWF0aC5yb3VuZCh0cmVlU2l6ZSAvIDIpOyAvLyBzZXBhcmF0ZSBsZWZ0IGFuZCByaWdodCB0cmVlIGJ5IG1ldGEgZGF0YVxuXG4gIHZhciBnZXRTaWRlID0gb3B0aW9ucy5nZXRTaWRlIHx8IGZ1bmN0aW9uIChjaGlsZCwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCByaWdodFRyZWVTaXplKSB7XG4gICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZVNpemU7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IHJvb3QuY2hpbGRyZW5baV07XG4gICAgdmFyIHNpZGUgPSBnZXRTaWRlKGNoaWxkLCBpKTtcblxuICAgIGlmIChzaWRlID09PSAncmlnaHQnKSB7XG4gICAgICByaWdodC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cblxuICBsZWZ0LmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKCFub2RlLmlzUm9vdCgpKSB7XG4gICAgICBub2RlLnNpZGUgPSAnbGVmdCc7XG4gICAgfVxuICB9KTtcbiAgcmlnaHQuZWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuaXNSb290KCkpIHtcbiAgICAgIG5vZGUuc2lkZSA9ICdyaWdodCc7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHJpZ2h0OiByaWdodFxuICB9O1xufTtcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoaWVyYXJjaHkgPSB7XG4gIGNvbXBhY3RCb3g6IF9fd2VicGFja19yZXF1aXJlX18oNiksXG4gIGRlbmRyb2dyYW06IF9fd2VicGFja19yZXF1aXJlX18oOSksXG4gIGluZGVudGVkOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSxcbiAgbWluZG1hcDogX193ZWJwYWNrX3JlcXVpcmVfXygxMylcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGhpZXJhcmNoeTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVHJlZUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBub25MYXllcmVkVGlkeVRyZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgZG9UcmVlTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgQ29tcGFjdEJveFRyZWVMYXlvdXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UcmVlTGF5b3V0KSB7XG4gIF9pbmhlcml0c0xvb3NlKENvbXBhY3RCb3hUcmVlTGF5b3V0LCBfVHJlZUxheW91dCk7XG5cbiAgZnVuY3Rpb24gQ29tcGFjdEJveFRyZWVMYXlvdXQoKSB7XG4gICAgcmV0dXJuIF9UcmVlTGF5b3V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDb21wYWN0Qm94VHJlZUxheW91dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmV4ZWN1dGUgPSBmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgcmV0dXJuIGRvVHJlZUxheW91dChtZS5yb290Tm9kZSwgbWUub3B0aW9ucywgbm9uTGF5ZXJlZFRpZHlUcmVlKTtcbiAgfTtcblxuICByZXR1cm4gQ29tcGFjdEJveFRyZWVMYXlvdXQ7XG59KFRyZWVMYXlvdXQpO1xuXG52YXIgREVGQVVMVF9PUFRJT05TID0ge307XG5cbmZ1bmN0aW9uIGNvbXBhY3RCb3hMYXlvdXQocm9vdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gdXRpbC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gIHJldHVybiBuZXcgQ29tcGFjdEJveFRyZWVMYXlvdXQocm9vdCwgb3B0aW9ucykuZXhlY3V0ZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhY3RCb3hMYXlvdXQ7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5mdW5jdGlvbiBfbWl4KGRpc3QsIG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPT0gJ2NvbnN0cnVjdG9yJyAmJiBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkaXN0W2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG4gIH1cbn1cblxudmFyIG1peCA9IGZ1bmN0aW9uIG1peChkaXN0LCBzcmMxLCBzcmMyLCBzcmMzKSB7XG4gIGlmIChzcmMxKSBfbWl4KGRpc3QsIHNyYzEpO1xuICBpZiAoc3JjMikgX21peChkaXN0LCBzcmMyKTtcbiAgaWYgKHNyYzMpIF9taXgoZGlzdCwgc3JjMyk7XG4gIHJldHVybiBkaXN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtaXg7XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyB3cmFwIHRyZWUgbm9kZVxuZnVuY3Rpb24gV3JhcHBlZFRyZWUodywgaCwgeSwgYykge1xuICBpZiAoYyA9PT0gdm9pZCAwKSB7XG4gICAgYyA9IFtdO1xuICB9XG5cbiAgdmFyIG1lID0gdGhpczsgLy8gc2l6ZVxuXG4gIG1lLncgPSB3IHx8IDA7XG4gIG1lLmggPSBoIHx8IDA7IC8vIHBvc2l0aW9uXG5cbiAgbWUueSA9IHkgfHwgMDtcbiAgbWUueCA9IDA7IC8vIGNoaWxkcmVuXG5cbiAgbWUuYyA9IGMgfHwgW107XG4gIG1lLmNzID0gYy5sZW5ndGg7IC8vIG1vZGlmaWVkXG5cbiAgbWUucHJlbGltID0gMDtcbiAgbWUubW9kID0gMDtcbiAgbWUuc2hpZnQgPSAwO1xuICBtZS5jaGFuZ2UgPSAwOyAvLyBsZWZ0L3JpZ2h0IHRyZWVcblxuICBtZS50bCA9IG51bGw7XG4gIG1lLnRyID0gbnVsbDsgLy8gZXh0cmVtZSBsZWZ0L3JpZ2h0IHRyZWVcblxuICBtZS5lbCA9IG51bGw7XG4gIG1lLmVyID0gbnVsbDsgLy8gbW9kaWZpZWQgbGVmdC9yaWdodCB0cmVlXG5cbiAgbWUubXNlbCA9IDA7XG4gIG1lLm1zZXIgPSAwO1xufVxuXG5XcmFwcGVkVHJlZS5mcm9tTm9kZSA9IGZ1bmN0aW9uIChyb290LCBpc0hvcml6b250YWwpIHtcbiAgaWYgKCFyb290KSByZXR1cm4gbnVsbDtcbiAgdmFyIGNoaWxkcmVuID0gW107XG4gIHJvb3QuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBjaGlsZHJlbi5wdXNoKFdyYXBwZWRUcmVlLmZyb21Ob2RlKGNoaWxkLCBpc0hvcml6b250YWwpKTtcbiAgfSk7XG4gIGlmIChpc0hvcml6b250YWwpIHJldHVybiBuZXcgV3JhcHBlZFRyZWUocm9vdC5oZWlnaHQsIHJvb3Qud2lkdGgsIHJvb3QueCwgY2hpbGRyZW4pO1xuICByZXR1cm4gbmV3IFdyYXBwZWRUcmVlKHJvb3Qud2lkdGgsIHJvb3QuaGVpZ2h0LCByb290LnksIGNoaWxkcmVuKTtcbn07IC8vIG5vZGUgdXRpbHNcblxuXG5mdW5jdGlvbiBtb3ZlUmlnaHQobm9kZSwgbW92ZSwgaXNIb3Jpem9udGFsKSB7XG4gIGlmIChpc0hvcml6b250YWwpIHtcbiAgICBub2RlLnkgKz0gbW92ZTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnggKz0gbW92ZTtcbiAgfVxuXG4gIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBtb3ZlUmlnaHQoY2hpbGQsIG1vdmUsIGlzSG9yaXpvbnRhbCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRNaW4obm9kZSwgaXNIb3Jpem9udGFsKSB7XG4gIHZhciByZXMgPSBpc0hvcml6b250YWwgPyBub2RlLnkgOiBub2RlLng7XG4gIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXMgPSBNYXRoLm1pbihnZXRNaW4oY2hpbGQsIGlzSG9yaXpvbnRhbCksIHJlcyk7XG4gIH0pO1xuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUobm9kZSwgaXNIb3Jpem9udGFsKSB7XG4gIHZhciBtaW4gPSBnZXRNaW4obm9kZSwgaXNIb3Jpem9udGFsKTtcbiAgbW92ZVJpZ2h0KG5vZGUsIC1taW4sIGlzSG9yaXpvbnRhbCk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRCYWNrKGNvbnZlcnRlZFxuLyogV3JhcHBlZFRyZWUgKi9cbiwgcm9vdFxuLyogVHJlZU5vZGUgKi9cbiwgaXNIb3Jpem9udGFsKSB7XG4gIGlmIChpc0hvcml6b250YWwpIHtcbiAgICByb290LnkgPSBjb252ZXJ0ZWQueDtcbiAgfSBlbHNlIHtcbiAgICByb290LnggPSBjb252ZXJ0ZWQueDtcbiAgfVxuXG4gIGNvbnZlcnRlZC5jLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgY29udmVydEJhY2soY2hpbGQsIHJvb3QuY2hpbGRyZW5baV0sIGlzSG9yaXpvbnRhbCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsYXllcihub2RlLCBpc0hvcml6b250YWwsIGQpIHtcbiAgaWYgKGQgPT09IHZvaWQgMCkge1xuICAgIGQgPSAwO1xuICB9XG5cbiAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgIG5vZGUueCA9IGQ7XG4gICAgZCArPSBub2RlLndpZHRoO1xuICB9IGVsc2Uge1xuICAgIG5vZGUueSA9IGQ7XG4gICAgZCArPSBub2RlLmhlaWdodDtcbiAgfVxuXG4gIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBsYXllcihjaGlsZCwgaXNIb3Jpem9udGFsLCBkKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBpc0hvcml6b250YWwgPSBvcHRpb25zLmlzSG9yaXpvbnRhbDtcblxuICBmdW5jdGlvbiBmaXJzdFdhbGsodCkge1xuICAgIGlmICh0LmNzID09PSAwKSB7XG4gICAgICBzZXRFeHRyZW1lcyh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmaXJzdFdhbGsodC5jWzBdKTtcbiAgICB2YXIgaWggPSB1cGRhdGVJWUwoYm90dG9tKHQuY1swXS5lbCksIDAsIG51bGwpO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0LmNzOyArK2kpIHtcbiAgICAgIGZpcnN0V2Fsayh0LmNbaV0pO1xuICAgICAgdmFyIG1pbiA9IGJvdHRvbSh0LmNbaV0uZXIpO1xuICAgICAgc2VwYXJhdGUodCwgaSwgaWgpO1xuICAgICAgaWggPSB1cGRhdGVJWUwobWluLCBpLCBpaCk7XG4gICAgfVxuXG4gICAgcG9zaXRpb25Sb290KHQpO1xuICAgIHNldEV4dHJlbWVzKHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0RXh0cmVtZXModCkge1xuICAgIGlmICh0LmNzID09PSAwKSB7XG4gICAgICB0LmVsID0gdDtcbiAgICAgIHQuZXIgPSB0O1xuICAgICAgdC5tc2VsID0gdC5tc2VyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdC5lbCA9IHQuY1swXS5lbDtcbiAgICAgIHQubXNlbCA9IHQuY1swXS5tc2VsO1xuICAgICAgdC5lciA9IHQuY1t0LmNzIC0gMV0uZXI7XG4gICAgICB0Lm1zZXIgPSB0LmNbdC5jcyAtIDFdLm1zZXI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VwYXJhdGUodCwgaSwgaWgpIHtcbiAgICB2YXIgc3IgPSB0LmNbaSAtIDFdO1xuICAgIHZhciBtc3NyID0gc3IubW9kO1xuICAgIHZhciBjbCA9IHQuY1tpXTtcbiAgICB2YXIgbXNjbCA9IGNsLm1vZDtcblxuICAgIHdoaWxlIChzciAhPT0gbnVsbCAmJiBjbCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGJvdHRvbShzcikgPiBpaC5sb3cpIGloID0gaWgubnh0O1xuICAgICAgdmFyIGRpc3QgPSBtc3NyICsgc3IucHJlbGltICsgc3IudyAtIChtc2NsICsgY2wucHJlbGltKTtcblxuICAgICAgaWYgKGRpc3QgPiAwKSB7XG4gICAgICAgIG1zY2wgKz0gZGlzdDtcbiAgICAgICAgbW92ZVN1YnRyZWUodCwgaSwgaWguaW5kZXgsIGRpc3QpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3kgPSBib3R0b20oc3IpO1xuICAgICAgdmFyIGN5ID0gYm90dG9tKGNsKTtcblxuICAgICAgaWYgKHN5IDw9IGN5KSB7XG4gICAgICAgIHNyID0gbmV4dFJpZ2h0Q29udG91cihzcik7XG4gICAgICAgIGlmIChzciAhPT0gbnVsbCkgbXNzciArPSBzci5tb2Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChzeSA+PSBjeSkge1xuICAgICAgICBjbCA9IG5leHRMZWZ0Q29udG91cihjbCk7XG4gICAgICAgIGlmIChjbCAhPT0gbnVsbCkgbXNjbCArPSBjbC5tb2Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzciAmJiAhIWNsKSB7XG4gICAgICBzZXRMZWZ0VGhyZWFkKHQsIGksIGNsLCBtc2NsKTtcbiAgICB9IGVsc2UgaWYgKCEhc3IgJiYgIWNsKSB7XG4gICAgICBzZXRSaWdodFRocmVhZCh0LCBpLCBzciwgbXNzcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZVN1YnRyZWUodCwgaSwgc2ksIGRpc3QpIHtcbiAgICB0LmNbaV0ubW9kICs9IGRpc3Q7XG4gICAgdC5jW2ldLm1zZWwgKz0gZGlzdDtcbiAgICB0LmNbaV0ubXNlciArPSBkaXN0O1xuICAgIGRpc3RyaWJ1dGVFeHRyYSh0LCBpLCBzaSwgZGlzdCk7XG4gIH1cblxuICBmdW5jdGlvbiBuZXh0TGVmdENvbnRvdXIodCkge1xuICAgIHJldHVybiB0LmNzID09PSAwID8gdC50bCA6IHQuY1swXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHRSaWdodENvbnRvdXIodCkge1xuICAgIHJldHVybiB0LmNzID09PSAwID8gdC50ciA6IHQuY1t0LmNzIC0gMV07XG4gIH1cblxuICBmdW5jdGlvbiBib3R0b20odCkge1xuICAgIHJldHVybiB0LnkgKyB0Lmg7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZWZ0VGhyZWFkKHQsIGksIGNsLCBtb2RzdW1jbCkge1xuICAgIHZhciBsaSA9IHQuY1swXS5lbDtcbiAgICBsaS50bCA9IGNsO1xuICAgIHZhciBkaWZmID0gbW9kc3VtY2wgLSBjbC5tb2QgLSB0LmNbMF0ubXNlbDtcbiAgICBsaS5tb2QgKz0gZGlmZjtcbiAgICBsaS5wcmVsaW0gLT0gZGlmZjtcbiAgICB0LmNbMF0uZWwgPSB0LmNbaV0uZWw7XG4gICAgdC5jWzBdLm1zZWwgPSB0LmNbaV0ubXNlbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFJpZ2h0VGhyZWFkKHQsIGksIHNyLCBtb2RzdW1zcikge1xuICAgIHZhciByaSA9IHQuY1tpXS5lcjtcbiAgICByaS50ciA9IHNyO1xuICAgIHZhciBkaWZmID0gbW9kc3Vtc3IgLSBzci5tb2QgLSB0LmNbaV0ubXNlcjtcbiAgICByaS5tb2QgKz0gZGlmZjtcbiAgICByaS5wcmVsaW0gLT0gZGlmZjtcbiAgICB0LmNbaV0uZXIgPSB0LmNbaSAtIDFdLmVyO1xuICAgIHQuY1tpXS5tc2VyID0gdC5jW2kgLSAxXS5tc2VyO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9zaXRpb25Sb290KHQpIHtcbiAgICB0LnByZWxpbSA9ICh0LmNbMF0ucHJlbGltICsgdC5jWzBdLm1vZCArIHQuY1t0LmNzIC0gMV0ubW9kICsgdC5jW3QuY3MgLSAxXS5wcmVsaW0gKyB0LmNbdC5jcyAtIDFdLncpIC8gMiAtIHQudyAvIDI7XG4gIH1cblxuICBmdW5jdGlvbiBzZWNvbmRXYWxrKHQsIG1vZHN1bSkge1xuICAgIG1vZHN1bSArPSB0Lm1vZDtcbiAgICB0LnggPSB0LnByZWxpbSArIG1vZHN1bTtcbiAgICBhZGRDaGlsZFNwYWNpbmcodCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHQuY3M7IGkrKykge1xuICAgICAgc2Vjb25kV2Fsayh0LmNbaV0sIG1vZHN1bSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzdHJpYnV0ZUV4dHJhKHQsIGksIHNpLCBkaXN0KSB7XG4gICAgaWYgKHNpICE9PSBpIC0gMSkge1xuICAgICAgdmFyIG5yID0gaSAtIHNpO1xuICAgICAgdC5jW3NpICsgMV0uc2hpZnQgKz0gZGlzdCAvIG5yO1xuICAgICAgdC5jW2ldLnNoaWZ0IC09IGRpc3QgLyBucjtcbiAgICAgIHQuY1tpXS5jaGFuZ2UgLT0gZGlzdCAtIGRpc3QgLyBucjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRDaGlsZFNwYWNpbmcodCkge1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgbW9kc3VtZGVsdGEgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0LmNzOyBpKyspIHtcbiAgICAgIGQgKz0gdC5jW2ldLnNoaWZ0O1xuICAgICAgbW9kc3VtZGVsdGEgKz0gZCArIHQuY1tpXS5jaGFuZ2U7XG4gICAgICB0LmNbaV0ubW9kICs9IG1vZHN1bWRlbHRhO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUlZTChsb3csIGluZGV4LCBpaCkge1xuICAgIHdoaWxlIChpaCAhPT0gbnVsbCAmJiBsb3cgPj0gaWgubG93KSB7XG4gICAgICBpaCA9IGloLm54dDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbG93OiBsb3csXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBueHQ6IGloXG4gICAgfTtcbiAgfSAvLyBkbyBsYXlvdXRcblxuXG4gIGxheWVyKHJvb3QsIGlzSG9yaXpvbnRhbCk7XG4gIHZhciB3dCA9IFdyYXBwZWRUcmVlLmZyb21Ob2RlKHJvb3QsIGlzSG9yaXpvbnRhbCk7XG4gIGZpcnN0V2Fsayh3dCk7XG4gIHNlY29uZFdhbGsod3QsIDApO1xuICBjb252ZXJ0QmFjayh3dCwgcm9vdCwgaXNIb3Jpem9udGFsKTtcbiAgbm9ybWFsaXplKHJvb3QsIGlzSG9yaXpvbnRhbCk7XG4gIHJldHVybiByb290O1xufTtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVHJlZUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBkZW5kcm9ncmFtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBkb1RyZWVMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBEZW5kcm9ncmFtTGF5b3V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVHJlZUxheW91dCkge1xuICBfaW5oZXJpdHNMb29zZShEZW5kcm9ncmFtTGF5b3V0LCBfVHJlZUxheW91dCk7XG5cbiAgZnVuY3Rpb24gRGVuZHJvZ3JhbUxheW91dCgpIHtcbiAgICByZXR1cm4gX1RyZWVMYXlvdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IERlbmRyb2dyYW1MYXlvdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5leGVjdXRlID0gZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIG1lLnJvb3ROb2RlLndpZHRoID0gMDtcbiAgICByZXR1cm4gZG9UcmVlTGF5b3V0KG1lLnJvb3ROb2RlLCBtZS5vcHRpb25zLCBkZW5kcm9ncmFtKTtcbiAgfTtcblxuICByZXR1cm4gRGVuZHJvZ3JhbUxheW91dDtcbn0oVHJlZUxheW91dCk7XG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7fTtcblxuZnVuY3Rpb24gZGVuZHJvZ3JhbUxheW91dChyb290LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSB1dGlsLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgcmV0dXJuIG5ldyBEZW5kcm9ncmFtTGF5b3V0KHJvb3QsIG9wdGlvbnMpLmV4ZWN1dGUoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZW5kcm9ncmFtTGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIHdyYXAgdHJlZSBub2RlXG4vLyBUT0RPIGNvbnNpZGVyaW5nIHNpemVcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuZnVuY3Rpb24gV3JhcHBlZFRyZWUoaGVpZ2h0LCBjaGlsZHJlbikge1xuICBpZiAoaGVpZ2h0ID09PSB2b2lkIDApIHtcbiAgICBoZWlnaHQgPSAwO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuID09PSB2b2lkIDApIHtcbiAgICBjaGlsZHJlbiA9IFtdO1xuICB9XG5cbiAgdmFyIG1lID0gdGhpcztcbiAgbWUueCA9IG1lLnkgPSAwO1xuICBtZS5sZWZ0Q2hpbGQgPSBtZS5yaWdodENoaWxkID0gbnVsbDtcbiAgbWUuaGVpZ2h0ID0gMDtcbiAgbWUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbn1cblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgaXNIb3Jpem9udGFsOiB0cnVlLFxuICBub2RlU2VwOiAyMCxcbiAgbm9kZVNpemU6IDIwLFxuICByYW5rU2VwOiAyMDAsXG4gIHN1YlRyZWVTZXA6IDEwXG59O1xuXG5mdW5jdGlvbiBjb252ZXJ0QmFjayhjb252ZXJ0ZWRcbi8qIFdyYXBwZWRUcmVlICovXG4sIHJvb3Rcbi8qIFRyZWVOb2RlICovXG4sIGlzSG9yaXpvbnRhbCkge1xuICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgcm9vdC54ID0gY29udmVydGVkLng7XG4gICAgcm9vdC55ID0gY29udmVydGVkLnk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC54ID0gY29udmVydGVkLnk7XG4gICAgcm9vdC55ID0gY29udmVydGVkLng7XG4gIH1cblxuICBjb252ZXJ0ZWQuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICBjb252ZXJ0QmFjayhjaGlsZCwgcm9vdC5jaGlsZHJlbltpXSwgaXNIb3Jpem9udGFsKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIG9wdGlvbnMgPSB1dGlsLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgdmFyIG1heERlcHRoID0gMDtcblxuICBmdW5jdGlvbiB3cmFwcGVkVHJlZUZyb21Ob2RlKG4pIHtcbiAgICBpZiAoIW4pIHJldHVybiBudWxsO1xuICAgIG4ud2lkdGggPSAwO1xuXG4gICAgaWYgKG4uZGVwdGggJiYgbi5kZXB0aCA+IG1heERlcHRoKSB7XG4gICAgICBtYXhEZXB0aCA9IG4uZGVwdGg7IC8vIGdldCB0aGUgbWF4IGRlcHRoXG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gbi5jaGlsZHJlbjtcbiAgICB2YXIgY2hpbGRyZW5Db3VudCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICB2YXIgdCA9IG5ldyBXcmFwcGVkVHJlZShuLmhlaWdodCwgW10pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICB2YXIgY2hpbGRXVCA9IHdyYXBwZWRUcmVlRnJvbU5vZGUoY2hpbGQpO1xuICAgICAgdC5jaGlsZHJlbi5wdXNoKGNoaWxkV1QpO1xuXG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAvLyB0LmxlZnRDaGlsZCA9IGNoaWxkV1QubGVmdENoaWxkID8gY2hpbGRXVC5sZWZ0Q2hpbGQgOiBjaGlsZFdUXG4gICAgICAgIHQubGVmdENoaWxkID0gY2hpbGRXVDtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IGNoaWxkcmVuQ291bnQgLSAxKSB7XG4gICAgICAgIC8vIHQucmlnaHRDaGlsZCA9IGNoaWxkV1QucmlnaHRDaGlsZCA/IGNoaWxkV1QucmlnaHRDaGlsZCA6IGNoaWxkV1RcbiAgICAgICAgdC5yaWdodENoaWxkID0gY2hpbGRXVDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0Lm9yaWdpbk5vZGUgPSBuO1xuICAgIHQuaXNMZWFmID0gbi5pc0xlYWYoKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERyYXdpbmdEZXB0aCh0KSB7XG4gICAgaWYgKHQuaXNMZWFmIHx8IHQuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICB0LmRyYXdpbmdEZXB0aCA9IG1heERlcHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGVwdGhzID0gdC5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBnZXREcmF3aW5nRGVwdGgoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbWluQ2hpbGREZXB0aCA9IE1hdGgubWluLmFwcGx5KG51bGwsIGRlcHRocyk7XG4gICAgICB0LmRyYXdpbmdEZXB0aCA9IG1pbkNoaWxkRGVwdGggLSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0LmRyYXdpbmdEZXB0aDtcbiAgfVxuXG4gIHZhciBwcmV2TGVhZjtcblxuICBmdW5jdGlvbiBwb3NpdGlvbih0KSB7XG4gICAgdC54ID0gdC5kcmF3aW5nRGVwdGggKiBvcHRpb25zLnJhbmtTZXA7XG5cbiAgICBpZiAodC5pc0xlYWYpIHtcbiAgICAgIHQueSA9IDA7XG5cbiAgICAgIGlmIChwcmV2TGVhZikge1xuICAgICAgICB0LnkgPSBwcmV2TGVhZi55ICsgcHJldkxlYWYuaGVpZ2h0ICsgb3B0aW9ucy5ub2RlU2VwO1xuXG4gICAgICAgIGlmICh0Lm9yaWdpbk5vZGUucGFyZW50ICE9PSBwcmV2TGVhZi5vcmlnaW5Ob2RlLnBhcmVudCkge1xuICAgICAgICAgIHQueSArPSBvcHRpb25zLnN1YlRyZWVTZXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldkxlYWYgPSB0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0LmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHBvc2l0aW9uKGNoaWxkKTtcbiAgICAgIH0pO1xuICAgICAgdC55ID0gKHQubGVmdENoaWxkLnkgKyB0LnJpZ2h0Q2hpbGQueSkgLyAyO1xuICAgIH1cbiAgfSAvLyB3cmFwIG5vZGVcblxuXG4gIHZhciB3dCA9IHdyYXBwZWRUcmVlRnJvbU5vZGUocm9vdCk7IC8vIGdldCBkZXB0aCBmb3IgZHJhd2luZ1xuXG4gIGdldERyYXdpbmdEZXB0aCh3dCk7IC8vIGdldCBwb3NpdGlvblxuXG4gIHBvc2l0aW9uKHd0KTsgLy8gZ2V0IHgsIHlcblxuICBjb252ZXJ0QmFjayh3dCwgcm9vdCwgb3B0aW9ucy5pc0hvcml6b250YWwpO1xuICByZXR1cm4gcm9vdDtcbn07XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBUcmVlTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIGluZGVudGVkVHJlZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG52YXIgc2VwYXJhdGVUcmVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgVkFMSURfRElSRUNUSU9OUyA9IFsnTFInLCAvLyBsZWZ0IHRvIHJpZ2h0XG4nUkwnLCAvLyByaWdodCB0byBsZWZ0XG4nSCcgLy8gaG9yaXpvbnRhbFxuXTtcbnZhciBERUZBVUxUX0RJUkVDVElPTiA9IFZBTElEX0RJUkVDVElPTlNbMF07XG5cbnZhciBJbmRlbnRlZExheW91dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RyZWVMYXlvdXQpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW5kZW50ZWRMYXlvdXQsIF9UcmVlTGF5b3V0KTtcblxuICBmdW5jdGlvbiBJbmRlbnRlZExheW91dCgpIHtcbiAgICByZXR1cm4gX1RyZWVMYXlvdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEluZGVudGVkTGF5b3V0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uZXhlY3V0ZSA9IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgb3B0aW9ucyA9IG1lLm9wdGlvbnM7XG4gICAgdmFyIHJvb3QgPSBtZS5yb290Tm9kZTtcbiAgICBvcHRpb25zLmlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgdmFyIGluZGVudCA9IG9wdGlvbnMuaW5kZW50O1xuICAgIHZhciBkaXJlY3Rpb24gPSBvcHRpb25zLmRpcmVjdGlvbiB8fCBERUZBVUxUX0RJUkVDVElPTjtcblxuICAgIGlmIChkaXJlY3Rpb24gJiYgVkFMSURfRElSRUNUSU9OUy5pbmRleE9mKGRpcmVjdGlvbikgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBkaXJlY3Rpb246IFwiICsgZGlyZWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBWQUxJRF9ESVJFQ1RJT05TWzBdKSB7XG4gICAgICAvLyBMUlxuICAgICAgaW5kZW50ZWRUcmVlKHJvb3QsIGluZGVudCk7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFZBTElEX0RJUkVDVElPTlNbMV0pIHtcbiAgICAgIC8vIFJMXG4gICAgICBpbmRlbnRlZFRyZWUocm9vdCwgaW5kZW50KTtcbiAgICAgIHJvb3QucmlnaHQybGVmdCgpO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBWQUxJRF9ESVJFQ1RJT05TWzJdKSB7XG4gICAgICAvLyBIXG4gICAgICAvLyBzZXBhcmF0ZSBpbnRvIGxlZnQgYW5kIHJpZ2h0IHRyZWVzXG4gICAgICB2YXIgX3NlcGFyYXRlVHJlZSA9IHNlcGFyYXRlVHJlZShyb290LCBvcHRpb25zKSxcbiAgICAgICAgICBsZWZ0ID0gX3NlcGFyYXRlVHJlZS5sZWZ0LFxuICAgICAgICAgIHJpZ2h0ID0gX3NlcGFyYXRlVHJlZS5yaWdodDtcblxuICAgICAgaW5kZW50ZWRUcmVlKGxlZnQsIGluZGVudCk7XG4gICAgICBsZWZ0LnJpZ2h0MmxlZnQoKTtcbiAgICAgIGluZGVudGVkVHJlZShyaWdodCwgaW5kZW50KTtcbiAgICAgIHZhciBiYm94ID0gbGVmdC5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgcmlnaHQudHJhbnNsYXRlKGJib3gud2lkdGgsIDApO1xuICAgICAgcm9vdC54ID0gcmlnaHQueCAtIHJvb3Qud2lkdGggLyAyO1xuICAgIH1cblxuICAgIHJldHVybiByb290O1xuICB9O1xuXG4gIHJldHVybiBJbmRlbnRlZExheW91dDtcbn0oVHJlZUxheW91dCk7XG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7fTtcblxuZnVuY3Rpb24gaW5kZW50ZWRMYXlvdXQocm9vdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gdXRpbC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gIHJldHVybiBuZXcgSW5kZW50ZWRMYXlvdXQocm9vdCwgb3B0aW9ucykuZXhlY3V0ZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluZGVudGVkTGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBERUZBVUxUX0lOREVOVCA9IDIwO1xuXG5mdW5jdGlvbiBwb3NpdGlvbk5vZGUobm9kZSwgcHJldmlvdXNOb2RlLCBkeCkge1xuICBub2RlLnggKz0gZHggKiBub2RlLmRlcHRoO1xuICBub2RlLnkgPSBwcmV2aW91c05vZGUgPyBwcmV2aW91c05vZGUueSArIHByZXZpb3VzTm9kZS5oZWlnaHQgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCBpbmRlbnQpIHtcbiAgaWYgKGluZGVudCA9PT0gdm9pZCAwKSB7XG4gICAgaW5kZW50ID0gREVGQVVMVF9JTkRFTlQ7XG4gIH1cblxuICB2YXIgcHJldmlvdXNOb2RlID0gbnVsbDtcbiAgcm9vdC5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgIHBvc2l0aW9uTm9kZShub2RlLCBwcmV2aW91c05vZGUsIGluZGVudCk7XG4gICAgcHJldmlvdXNOb2RlID0gbm9kZTtcbiAgfSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVHJlZUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBtaW5kbWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbnZhciBkb1RyZWVMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBNaW5kbWFwTGF5b3V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVHJlZUxheW91dCkge1xuICBfaW5oZXJpdHNMb29zZShNaW5kbWFwTGF5b3V0LCBfVHJlZUxheW91dCk7XG5cbiAgZnVuY3Rpb24gTWluZG1hcExheW91dCgpIHtcbiAgICByZXR1cm4gX1RyZWVMYXlvdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1pbmRtYXBMYXlvdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5leGVjdXRlID0gZnVuY3Rpb24gZXhlY3V0ZSgpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHJldHVybiBkb1RyZWVMYXlvdXQobWUucm9vdE5vZGUsIG1lLm9wdGlvbnMsIG1pbmRtYXApO1xuICB9O1xuXG4gIHJldHVybiBNaW5kbWFwTGF5b3V0O1xufShUcmVlTGF5b3V0KTtcblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHt9O1xuXG5mdW5jdGlvbiBtaW5kbWFwTGF5b3V0KHJvb3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IHV0aWwuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IE1pbmRtYXBMYXlvdXQocm9vdCwgb3B0aW9ucykuZXhlY3V0ZSgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbmRtYXBMYXlvdXQ7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mdW5jdGlvbiBzZWNvbmRXYWxrKG5vZGUsIG9wdGlvbnMpIHtcbiAgdmFyIHRvdGFsSGVpZ2h0ID0gMDtcblxuICBpZiAoIW5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdG90YWxIZWlnaHQgPSBub2RlLmhlaWdodDtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIHRvdGFsSGVpZ2h0ICs9IHNlY29uZFdhbGsoYywgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cblxuICBub2RlLl9zdWJUcmVlU2VwID0gb3B0aW9ucy5nZXRTdWJUcmVlU2VwKG5vZGUuZGF0YSk7XG4gIG5vZGUudG90YWxIZWlnaHQgPSBNYXRoLm1heChub2RlLmhlaWdodCwgdG90YWxIZWlnaHQpICsgMiAqIG5vZGUuX3N1YlRyZWVTZXA7XG4gIHJldHVybiBub2RlLnRvdGFsSGVpZ2h0O1xufVxuXG5mdW5jdGlvbiB0aGlyZFdhbGsobm9kZSkge1xuICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gIGlmIChsZW4pIHtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICB0aGlyZFdhbGsoYyk7XG4gICAgfSk7XG4gICAgdmFyIGZpcnN0ID0gY2hpbGRyZW5bMF07XG4gICAgdmFyIGxhc3QgPSBjaGlsZHJlbltsZW4gLSAxXTtcbiAgICB2YXIgY2hpbGRyZW5IZWlnaHQgPSBsYXN0LnkgLSBmaXJzdC55ICsgbGFzdC5oZWlnaHQ7XG4gICAgdmFyIGNoaWxkcmVuVG90YWxIZWlnaHQgPSAwO1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBjaGlsZHJlblRvdGFsSGVpZ2h0ICs9IGNoaWxkLnRvdGFsSGVpZ2h0O1xuICAgIH0pO1xuXG4gICAgaWYgKGNoaWxkcmVuSGVpZ2h0ID4gbm9kZS5oZWlnaHQpIHtcbiAgICAgIC8vIOW9k+WtkOiKgueCueaAu+mrmOW6puWkp+S6jueItuiKgueCuemrmOW6plxuICAgICAgbm9kZS55ID0gZmlyc3QueSArIGNoaWxkcmVuSGVpZ2h0IC8gMiAtIG5vZGUuaGVpZ2h0IC8gMjtcbiAgICB9IGVsc2UgaWYgKGNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBub2RlLmhlaWdodCA+IGNoaWxkcmVuVG90YWxIZWlnaHQpIHtcbiAgICAgIC8vIOWkmuS6juS4gOS4quWtkOiKgueCueaIluiAheeItuiKgueCueWkp+S6juaJgOacieWtkOiKgueCueeahOaAu+mrmOW6plxuICAgICAgdmFyIG9mZnNldCA9IG5vZGUueSArIChub2RlLmhlaWdodCAtIGNoaWxkcmVuSGVpZ2h0KSAvIDIgLSBmaXJzdC55O1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICBjLnRyYW5zbGF0ZSgwLCBvZmZzZXQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIOWPquacieS4gOS4quWtkOiKgueCuVxuICAgICAgbm9kZS55ID0gKGZpcnN0LnkgKyBmaXJzdC5oZWlnaHQgLyAyICsgbGFzdC55ICsgbGFzdC5oZWlnaHQgLyAyKSAvIDIgLSBub2RlLmhlaWdodCAvIDI7XG4gICAgfVxuICB9XG59XG5cbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIGdldFN1YlRyZWVTZXA6IGZ1bmN0aW9uIGdldFN1YlRyZWVTZXAoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3QsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIG9wdGlvbnMgPSB1dGlsLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgcm9vdC5wYXJlbnQgPSB7XG4gICAgeDogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgeTogMFxuICB9OyAvLyBmaXJzdCB3YWxrXG5cbiAgcm9vdC5CRlRyYXZlcnNlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbm9kZS54ID0gbm9kZS5wYXJlbnQueCArIG5vZGUucGFyZW50LndpZHRoOyAvLyBzaW1wbHkgZ2V0IHhcbiAgfSk7XG4gIHJvb3QucGFyZW50ID0gbnVsbDsgLy8gc2Vjb25kIHdhbGtcblxuICBzZWNvbmRXYWxrKHJvb3QsIG9wdGlvbnMpOyAvLyBhc3NpZ24gc3ViIHRyZWUgdG90YWxIZWlnaHRcbiAgLy8gYWRqdXN0aW5nXG4gIC8vIHNlcGFyYXRpbmcgbm9kZXNcblxuICByb290LnN0YXJ0WSA9IDA7XG4gIHJvb3QueSA9IHJvb3QudG90YWxIZWlnaHQgLyAyIC0gcm9vdC5oZWlnaHQgLyAyO1xuICByb290LmVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgaWYgKGxlbikge1xuICAgICAgdmFyIGZpcnN0ID0gY2hpbGRyZW5bMF07XG4gICAgICBmaXJzdC5zdGFydFkgPSBub2RlLnN0YXJ0WSArIG5vZGUuX3N1YlRyZWVTZXA7XG5cbiAgICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgICAgZmlyc3QueSA9IG5vZGUueSArIG5vZGUuaGVpZ2h0IC8gMiAtIGZpcnN0LmhlaWdodCAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdC55ID0gZmlyc3Quc3RhcnRZICsgZmlyc3QudG90YWxIZWlnaHQgLyAyIC0gZmlyc3QuaGVpZ2h0IC8gMjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICBjLnN0YXJ0WSA9IGNoaWxkcmVuW2kgLSAxXS5zdGFydFkgKyBjaGlsZHJlbltpIC0gMV0udG90YWxIZWlnaHQ7XG4gICAgICAgICAgYy55ID0gYy5zdGFydFkgKyBjLnRvdGFsSGVpZ2h0IC8gMiAtIGMuaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIHRoaXJkIHdhbGtcblxuICB0aGlyZFdhbGsocm9vdCk7XG59O1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhpZXJhcmNoeS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvYXVnbWVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2F1Z21lbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1peF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9taXggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9taXguanNcIik7XG52YXIgaXNfZnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1mdW5jdGlvbi5qc1wiKTtcbnZhciBhdWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgYyA9IGFyZ3NbMF07XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvYmogPSBhcmdzW2ldO1xuICAgICAgICBpZiAoaXNfZnVuY3Rpb25fMS5kZWZhdWx0KG9iaikpIHtcbiAgICAgICAgICAgIG9iaiA9IG9iai5wcm90b3R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgbWl4XzEuZGVmYXVsdChjLnByb3RvdHlwZSwgb2JqKTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gYXVnbWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1Z21lbnQuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2NhY2hlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2NhY2hlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIGstdiDlrZjlgqhcbiAqL1xudmFyIGRlZmF1bHRfMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBkZWZhdWx0XzEoKSB7XG4gICAgICAgIHRoaXMubWFwID0ge307XG4gICAgfVxuICAgIGRlZmF1bHRfMS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgZGVmYXVsdF8xLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5LCBkZWYpIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLm1hcFtrZXldO1xuICAgICAgICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkID8gZGVmIDogdjtcbiAgICB9O1xuICAgIGRlZmF1bHRfMS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXBba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gICAgZGVmYXVsdF8xLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tYXAgPSB7fTtcbiAgICB9O1xuICAgIGRlZmF1bHRfMS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgdGhpcy5tYXBba2V5XTtcbiAgICB9O1xuICAgIGRlZmF1bHRfMS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubWFwKS5sZW5ndGg7XG4gICAgfTtcbiAgICByZXR1cm4gZGVmYXVsdF8xO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRfMTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9jbGFtcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9jbGFtcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNsYW1wID0gZnVuY3Rpb24gKGEsIG1pbiwgbWF4KSB7XG4gICAgaWYgKGEgPCBtaW4pIHtcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA+IG1heCkge1xuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBjbGFtcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsYW1wLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9jbGVhci1hbmltYXRpb24tZnJhbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2NsZWFyLWFuaW1hdGlvbi1mcmFtZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZXIpIHtcbiAgICB2YXIgbWV0aG9kID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHdpbmRvdy5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIGNsZWFyVGltZW91dDtcbiAgICBtZXRob2QoaGFuZGxlcik7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjYW5jZWxBbmltYXRpb25GcmFtZTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsZWFyLWFuaW1hdGlvbi1mcmFtZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvY2xvbmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvY2xvbmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19hcnJheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LmpzXCIpO1xudmFyIGNsb25lID0gZnVuY3Rpb24gKG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgdmFyIHJzdDtcbiAgICBpZiAoaXNfYXJyYXlfMS5kZWZhdWx0KG9iaikpIHtcbiAgICAgICAgcnN0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmpbaV0gPT09ICdvYmplY3QnICYmIG9ialtpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcnN0W2ldID0gY2xvbmUob2JqW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJzdFtpXSA9IG9ialtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcnN0ID0ge307XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9ialtrXSA9PT0gJ29iamVjdCcgJiYgb2JqW2tdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByc3Rba10gPSBjbG9uZShvYmpba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcnN0W2tdID0gb2JqW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByc3Q7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gY2xvbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbG9uZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvY29udGFpbnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvY29udGFpbnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19hcnJheV9saWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5LWxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS1saWtlLmpzXCIpO1xudmFyIGNvbnRhaW5zID0gZnVuY3Rpb24gKGFyciwgdmFsdWUpIHtcbiAgICBpZiAoIWlzX2FycmF5X2xpa2VfMS5kZWZhdWx0KGFycikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyLmluZGV4T2YodmFsdWUpID4gLTE7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gY29udGFpbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250YWlucy5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZGVib3VuY2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZGVib3VuY2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVib3VuY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZGVlcC1taXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZGVlcC1taXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19hcnJheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LmpzXCIpO1xudmFyIGlzX3BsYWluX29iamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1wbGFpbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1wbGFpbi1vYmplY3QuanNcIik7XG52YXIgTUFYX01JWF9MRVZFTCA9IDU7XG5mdW5jdGlvbiBfZGVlcE1peChkaXN0LCBzcmMsIGxldmVsLCBtYXhMZXZlbCkge1xuICAgIGxldmVsID0gbGV2ZWwgfHwgMDtcbiAgICBtYXhMZXZlbCA9IG1heExldmVsIHx8IE1BWF9NSVhfTEVWRUw7XG4gICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNyY1trZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIGlzX3BsYWluX29iamVjdF8xLmRlZmF1bHQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc19wbGFpbl9vYmplY3RfMS5kZWZhdWx0KGRpc3Rba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdFtrZXldID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA8IG1heExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kZWVwTWl4KGRpc3Rba2V5XSwgdmFsdWUsIGxldmVsICsgMSwgbWF4TGV2ZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzdFtrZXldID0gc3JjW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNfYXJyYXlfMS5kZWZhdWx0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRpc3Rba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgIGRpc3Rba2V5XSA9IGRpc3Rba2V5XS5jb25jYXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRpc3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gdG9kbyDph43lhplcbnZhciBkZWVwTWl4ID0gZnVuY3Rpb24gKHJzdCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIF9kZWVwTWl4KHJzdCwgYXJnc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByc3Q7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVlcE1peDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZXAtbWl4LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9kaWZmZXJlbmNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZGlmZmVyZW5jZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZmlsdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZpbHRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2ZpbHRlci5qc1wiKTtcbnZhciBjb250YWluc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250YWlucyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2NvbnRhaW5zLmpzXCIpO1xuLyoqXG4gKiBGbGF0dGVucyBgYXJyYXlgIGEgc2luZ2xlIGxldmVsIGRlZXAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqIGRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pOyAgLy8gPT4gWzFdXG4gKi9cbnZhciBkaWZmZXJlbmNlID0gZnVuY3Rpb24gKGFyciwgdmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7IHZhbHVlcyA9IFtdOyB9XG4gICAgcmV0dXJuIGZpbHRlcl8xLmRlZmF1bHQoYXJyLCBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICFjb250YWluc18xLmRlZmF1bHQodmFsdWVzLCB2YWx1ZSk7IH0pO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRpZmZlcmVuY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaWZmZXJlbmNlLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9lYWNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZWFjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbnZhciBpc19vYmplY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtb2JqZWN0LmpzXCIpO1xuZnVuY3Rpb24gZWFjaChlbGVtZW50cywgZnVuYykge1xuICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcnN0O1xuICAgIGlmIChpc19hcnJheV8xLmRlZmF1bHQoZWxlbWVudHMpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcnN0ID0gZnVuYyhlbGVtZW50c1tpXSwgaSk7XG4gICAgICAgICAgICBpZiAocnN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzX29iamVjdF8xLmRlZmF1bHQoZWxlbWVudHMpKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50cy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIHJzdCA9IGZ1bmMoZWxlbWVudHNba10sIGspO1xuICAgICAgICAgICAgICAgIGlmIChyc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGVhY2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lYWNoLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9lbmRzLXdpdGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2VuZHMtd2l0aC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19hcnJheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LmpzXCIpO1xudmFyIGlzX3N0cmluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1zdHJpbmcuanNcIik7XG5mdW5jdGlvbiBlbmRzV2l0aChhcnIsIGUpIHtcbiAgICByZXR1cm4gKGlzX2FycmF5XzEuZGVmYXVsdChhcnIpIHx8IGlzX3N0cmluZ18xLmRlZmF1bHQoYXJyKSkgPyBhcnJbYXJyLmxlbmd0aCAtIDFdID09PSBlIDogZmFsc2U7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBlbmRzV2l0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuZHMtd2l0aC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZXZlcnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZXZlcnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICog5Y+q6KaB5pyJ5LiA5Liq5LiN5ruh6Laz5p2h5Lu25bCx6L+U5ZueIGZhbHNlXG4gKiBAcGFyYW0gYXJyXG4gKiBAcGFyYW0gZnVuY1xuICovXG52YXIgZXZlcnkgPSBmdW5jdGlvbiAoYXJyLCBmdW5jKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFmdW5jKGFycltpXSwgaSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV2ZXJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZlcnkuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2V4dGVuZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZXh0ZW5kLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1peF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9taXggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9taXguanNcIik7XG52YXIgaXNfZnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1mdW5jdGlvbi5qc1wiKTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiAoc3ViY2xhc3MsIHN1cGVyY2xhc3MsIG92ZXJyaWRlcywgc3RhdGljT3ZlcnJpZGVzKSB7XG4gICAgLy8g5aaC5p6c5Y+q5o+Q5L6b54i257G75p6E6YCg5Ye95pWw77yM5YiZ6Ieq5Yqo55Sf5oiQ5a2Q57G75p6E6YCg5Ye95pWwXG4gICAgaWYgKCFpc19mdW5jdGlvbl8xLmRlZmF1bHQoc3VwZXJjbGFzcykpIHtcbiAgICAgICAgb3ZlcnJpZGVzID0gc3VwZXJjbGFzcztcbiAgICAgICAgc3VwZXJjbGFzcyA9IHN1YmNsYXNzO1xuICAgICAgICBzdWJjbGFzcyA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB9XG4gICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgP1xuICAgICAgICBmdW5jdGlvbiAocHJvdG8sIGMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHByb3RvLCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSA6XG4gICAgICAgIGZ1bmN0aW9uIChwcm90bywgYykge1xuICAgICAgICAgICAgZnVuY3Rpb24gVG1wKCkgeyB9XG4gICAgICAgICAgICBUbXAucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgICAgICB2YXIgbyA9IG5ldyBUbXAoKTtcbiAgICAgICAgICAgIG8uY29uc3RydWN0b3IgPSBjO1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH07XG4gICAgdmFyIHN1cGVyT2JqID0gY3JlYXRlKHN1cGVyY2xhc3MucHJvdG90eXBlLCBzdWJjbGFzcyk7IC8vIG5ldyBzdXBlcmNsYXNzKCksLy/lrp7kvovljJbniLbnsbvkvZzkuLrlrZDnsbvnmoRwcm90b3R5cGVcbiAgICBzdWJjbGFzcy5wcm90b3R5cGUgPSBtaXhfMS5kZWZhdWx0KHN1cGVyT2JqLCBzdWJjbGFzcy5wcm90b3R5cGUpOyAvLyDmjIflrprlrZDnsbvnmoRwcm90b3R5cGVcbiAgICBzdWJjbGFzcy5zdXBlcmNsYXNzID0gY3JlYXRlKHN1cGVyY2xhc3MucHJvdG90eXBlLCBzdXBlcmNsYXNzKTtcbiAgICBtaXhfMS5kZWZhdWx0KHN1cGVyT2JqLCBvdmVycmlkZXMpO1xuICAgIG1peF8xLmRlZmF1bHQoc3ViY2xhc3MsIHN0YXRpY092ZXJyaWRlcyk7XG4gICAgcmV0dXJuIHN1YmNsYXNzO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4dGVuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVuZC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZmlsdGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9maWx0ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZWFjaF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZWFjaC5qc1wiKTtcbnZhciBpc19hcnJheV9saWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5LWxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS1saWtlLmpzXCIpO1xudmFyIGZpbHRlciA9IGZ1bmN0aW9uIChhcnIsIGZ1bmMpIHtcbiAgICBpZiAoIWlzX2FycmF5X2xpa2VfMS5kZWZhdWx0KGFycikpIHtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGVhY2hfMS5kZWZhdWx0KGFyciwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICBpZiAoZnVuYyh2YWx1ZSwgaW5kZXgpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZmluZC1pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2ZpbmQtaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICBpZiAoZnJvbUluZGV4ID09PSB2b2lkIDApIHsgZnJvbUluZGV4ID0gMDsgfVxuICAgIGZvciAodmFyIGkgPSBmcm9tSW5kZXg7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJbaV0sIGkpKSB7XG4gICAgICAgICAgICAvLyDmib7liLDnu4jmraLlvqrnjq9cbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGZpbmRJbmRleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmQtaW5kZXguanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2ZpbmQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9maW5kLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19mdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1mdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWZ1bmN0aW9uLmpzXCIpO1xudmFyIGlzX21hdGNoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW1hdGNoICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbWF0Y2guanNcIik7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbnZhciBpc19wbGFpbl9vYmplY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtcGxhaW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtcGxhaW4tb2JqZWN0LmpzXCIpO1xuZnVuY3Rpb24gZmluZChhcnIsIHByZWRpY2F0ZSkge1xuICAgIGlmICghaXNfYXJyYXlfMS5kZWZhdWx0KGFycikpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciBfcHJlZGljYXRlO1xuICAgIGlmIChpc19mdW5jdGlvbl8xLmRlZmF1bHQocHJlZGljYXRlKSkge1xuICAgICAgICBfcHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgIH1cbiAgICBpZiAoaXNfcGxhaW5fb2JqZWN0XzEuZGVmYXVsdChwcmVkaWNhdGUpKSB7XG4gICAgICAgIF9wcmVkaWNhdGUgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gaXNfbWF0Y2hfMS5kZWZhdWx0KGEsIHByZWRpY2F0ZSk7IH07XG4gICAgfVxuICAgIGlmIChfcHJlZGljYXRlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoX3ByZWRpY2F0ZShhcnJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGZpbmQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5kLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9maXJzdC12YWx1ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9maXJzdC12YWx1ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX25pbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1uaWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1uaWwuanNcIik7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbnZhciBmaXJzdFZhbHVlID0gZnVuY3Rpb24gKGRhdGEsIG5hbWUpIHtcbiAgICB2YXIgcnN0ID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IGRhdGFbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtuYW1lXTtcbiAgICAgICAgaWYgKCFpc19uaWxfMS5kZWZhdWx0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGlzX2FycmF5XzEuZGVmYXVsdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByc3QgPSB2YWx1ZVswXTsgLy8gdG9kbyDov5nph4zmmK/lkKblupTor6Xkvb/nlKjpgJLlvZLvvIzosIPnlKggZmlyc3RWYWx1ZSBA57ud5LqRXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByc3QgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByc3Q7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZmlyc3RWYWx1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpcnN0LXZhbHVlLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9maXhlZC1iYXNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZml4ZWQtYmFzZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZml4ZWRCYXNlID0gZnVuY3Rpb24gKHYsIGJhc2UpIHtcbiAgICB2YXIgc3RyID0gYmFzZS50b1N0cmluZygpO1xuICAgIHZhciBpbmRleCA9IHN0ci5pbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2KTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IHN0ci5zdWJzdHIoaW5kZXggKyAxKS5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IDIwKSB7XG4gICAgICAgIGxlbmd0aCA9IDIwO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2LnRvRml4ZWQobGVuZ3RoKSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZml4ZWRCYXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWQtYmFzZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZmxhdHRlbi1kZWVwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9mbGF0dGVuLWRlZXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7QXJyYXl9IHJlc3VsdCBUaGUgYXJyYXkgdG8gcmV0dXJuLlxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZsYXR0ZW5EZWVwKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7ICAvLyA9PiBbMSwgMiwgMywgNCwgNV1cbiAqL1xudmFyIGZsYXR0ZW5EZWVwID0gZnVuY3Rpb24gKGFyciwgcmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSB7IHJlc3VsdCA9IFtdOyB9XG4gICAgaWYgKCFpc19hcnJheV8xLmRlZmF1bHQoYXJyKSkge1xuICAgICAgICByZXN1bHQucHVzaChhcnIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5EZWVwKGFycltpXSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZsYXR0ZW5EZWVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmxhdHRlbi1kZWVwLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9mbGF0dGVuLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZmxhdHRlbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmbGF0dGVuKFsxLCBbMiwgWzMsIFs0XV0sIDVdXSk7ICAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gKi9cbnZhciBmbGF0dGVuID0gZnVuY3Rpb24gKGFycikge1xuICAgIGlmICghaXNfYXJyYXlfMS5kZWZhdWx0KGFycikpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgcnN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcnN0ID0gcnN0LmNvbmNhdChhcnJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcnN0O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGZsYXR0ZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mbGF0dGVuLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9mb3ItaW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2Zvci1pbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlYWNoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9lYWNoLmpzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gZWFjaF8xLmRlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3ItaW4uanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2dldC1yYW5nZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ2V0LXJhbmdlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX2FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXkuanNcIik7XG52YXIgZmlsdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZpbHRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2ZpbHRlci5qc1wiKTtcbnZhciBnZXRSYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAvLyDlrZjlnKggTmFOIOaXtu+8jG1pbixtYXgg5Yik5a6a5Lya5Ye66Zeu6aKYXG4gICAgdmFsdWVzID0gZmlsdGVyXzEuZGVmYXVsdCh2YWx1ZXMsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4odik7XG4gICAgfSk7XG4gICAgaWYgKCF2YWx1ZXMubGVuZ3RoKSB7IC8vIOWmguaenOayoeacieaVsOWAvOWImeebtOaOpei/lOWbnjBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNfYXJyYXlfMS5kZWZhdWx0KHZhbHVlc1swXSkpIHtcbiAgICAgICAgdmFyIHRtcCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG1wID0gdG1wLmNvbmNhdCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcyA9IHRtcDtcbiAgICB9XG4gICAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHZhbHVlcyk7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIHZhbHVlcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiBtaW4sXG4gICAgICAgIG1heDogbWF4XG4gICAgfTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRSYW5nZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1yYW5nZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ2V0LXR5cGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ2V0LXR5cGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xudmFyIGdldFR5cGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkucmVwbGFjZSgvXlxcW29iamVjdCAvLCAnJykucmVwbGFjZSgvXSQvLCAnJyk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0VHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC10eXBlLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9nZXQtd3JhcC1iZWhhdmlvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9nZXQtd3JhcC1iZWhhdmlvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiDojrflj5blsIHoo4XnmoTkuovku7ZcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqICAg5a+56LGhXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGFjdGlvbiDkuovku7blkI3np7BcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAgICAg6L+U5Zue5LqL5Lu25aSE55CG5Ye95pWwXG4gKi9cbmZ1bmN0aW9uIGdldFdyYXBCZWhhdmlvcihvYmosIGFjdGlvbikge1xuICAgIHJldHVybiBvYmpbJ193cmFwXycgKyBhY3Rpb25dO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0V3JhcEJlaGF2aW9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXdyYXAtYmVoYXZpb3IuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2dldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX3N0cmluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1zdHJpbmcuanNcIik7XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvZGx2L2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0ga2V5XG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAob2JqLCBrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciBwID0gMDtcbiAgICB2YXIga2V5QXJyID0gaXNfc3RyaW5nXzEuZGVmYXVsdChrZXkpID8ga2V5LnNwbGl0KCcuJykgOiBrZXk7XG4gICAgd2hpbGUgKG9iaiAmJiBwIDwga2V5QXJyLmxlbmd0aCkge1xuICAgICAgICBvYmogPSBvYmpba2V5QXJyW3ArK11dO1xuICAgIH1cbiAgICByZXR1cm4gKG9iaiA9PT0gdW5kZWZpbmVkIHx8IHAgPCBrZXlBcnIubGVuZ3RoKSA/IGRlZmF1bHRWYWx1ZSA6IG9iajtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9ncm91cC1ieS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9ncm91cC1ieS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVhY2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2VhY2guanNcIik7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbnZhciBpc19mdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1mdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWZ1bmN0aW9uLmpzXCIpO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGdyb3VwQnkoZGF0YSwgY29uZGl0aW9uKSB7XG4gICAgaWYgKCFjb25kaXRpb24gfHwgIWlzX2FycmF5XzEuZGVmYXVsdChkYXRhKSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAvLyDlhbzlrrnmlrnms5Xlkowg5a2X56ym5Liy55qE5YaZ5rOVXG4gICAgdmFyIHByZWRpY2F0ZSA9IGlzX2Z1bmN0aW9uXzEuZGVmYXVsdChjb25kaXRpb24pID8gY29uZGl0aW9uIDogZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW1bY29uZGl0aW9uXTsgfTtcbiAgICB2YXIga2V5O1xuICAgIGVhY2hfMS5kZWZhdWx0KGRhdGEsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGtleSA9IHByZWRpY2F0ZShpdGVtKTtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XS5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBbaXRlbV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ3JvdXBCeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3VwLWJ5LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9ncm91cC10by1tYXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2dyb3VwLXRvLW1hcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19hcnJheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LmpzXCIpO1xudmFyIGlzX2Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWZ1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZnVuY3Rpb24uanNcIik7XG52YXIgZ3JvdXBfYnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ3JvdXAtYnkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9ncm91cC1ieS5qc1wiKTtcbnZhciBncm91cFRvTWFwID0gZnVuY3Rpb24gKGRhdGEsIGNvbmRpdGlvbikge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAwOiBkYXRhXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICghaXNfZnVuY3Rpb25fMS5kZWZhdWx0KGNvbmRpdGlvbikpIHtcbiAgICAgICAgdmFyIHBhcmFtc0NvbmRpdGlvbl8xID0gaXNfYXJyYXlfMS5kZWZhdWx0KGNvbmRpdGlvbikgPyBjb25kaXRpb24gOiBjb25kaXRpb24ucmVwbGFjZSgvXFxzKy9nLCAnJykuc3BsaXQoJyonKTtcbiAgICAgICAgY29uZGl0aW9uID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgdmFyIHVuaXF1ZSA9ICdfJzsgLy8g6YG/5YWN5Ye6546w5pWw5a2X5L2c5Li6S2V555qE5oOF5Ya177yM5Lya6L+b6KGM5oyJ54Wn5pWw5a2X55qE5o6S5bqPXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcmFtc0NvbmRpdGlvbl8xLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHVuaXF1ZSArPSByb3dbcGFyYW1zQ29uZGl0aW9uXzFbaV1dICYmIHJvd1twYXJhbXNDb25kaXRpb25fMVtpXV0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmlxdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBncm91cHMgPSBncm91cF9ieV8xLmRlZmF1bHQoZGF0YSwgY29uZGl0aW9uKTtcbiAgICByZXR1cm4gZ3JvdXBzO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdyb3VwVG9NYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncm91cC10by1tYXAuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2dyb3VwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2dyb3VwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ3JvdXBfdG9fbWFwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dyb3VwLXRvLW1hcCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2dyb3VwLXRvLW1hcC5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoZGF0YSwgY29uZGl0aW9uKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgLy8g5rKh5pyJ5p2h5Lu277yM5YiZ6Ieq6Lqr5pS55oiQ5pWw57uEXG4gICAgICAgIHJldHVybiBbZGF0YV07XG4gICAgfVxuICAgIHZhciBncm91cHMgPSBncm91cF90b19tYXBfMS5kZWZhdWx0KGRhdGEsIGNvbmRpdGlvbik7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSBpbiBncm91cHMpIHtcbiAgICAgICAgYXJyYXkucHVzaChncm91cHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3VwLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9oYXMta2V5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaGFzLWtleS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2hhcy5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGhhc18xLmRlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMta2V5LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9oYXMtdmFsdWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2hhcy12YWx1ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250YWluc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250YWlucyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2NvbnRhaW5zLmpzXCIpO1xudmFyIHZhbHVlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi92YWx1ZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi92YWx1ZXMuanNcIik7XG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKG9iaiwgdmFsdWUpIHsgcmV0dXJuIGNvbnRhaW5zXzEuZGVmYXVsdCh2YWx1ZXNfMS5kZWZhdWx0KG9iaiksIHZhbHVlKTsgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXMtdmFsdWUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2hhcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaGFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChvYmosIGtleSkgeyByZXR1cm4gb2JqLmhhc093blByb3BlcnR5KGtleSk7IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9oZWFkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaGVhZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfYXJyYXlfbGlrZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheS1saWtlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXktbGlrZS5qc1wiKTtcbmZ1bmN0aW9uIGhlYWQobykge1xuICAgIGlmIChpc19hcnJheV9saWtlXzEuZGVmYXVsdChvKSkge1xuICAgICAgICByZXR1cm4gb1swXTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGhlYWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pZGVudGl0eS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pZGVudGl0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2OyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkZW50aXR5LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC1vZi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC1vZi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX2FycmF5X2xpa2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXktbGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LWxpa2UuanNcIik7XG52YXIgaW5kZXhPZiA9IGZ1bmN0aW9uIChhcnIsIG9iaikge1xuICAgIGlmICghaXNfYXJyYXlfbGlrZV8xLmRlZmF1bHQoYXJyKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHZhciBtID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgcmV0dXJuIG0uY2FsbChhcnIsIG9iaik7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJbaV0gPT09IG9iaikge1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluZGV4T2Y7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC1vZi5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGFycmF5XG52YXIgY29udGFpbnNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udGFpbnMgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9jb250YWlucy5qc1wiKTtcbmV4cG9ydHMuY29udGFpbnMgPSBjb250YWluc18xLmRlZmF1bHQ7XG5leHBvcnRzLmluY2x1ZGVzID0gY29udGFpbnNfMS5kZWZhdWx0O1xudmFyIGRpZmZlcmVuY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGlmZmVyZW5jZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2RpZmZlcmVuY2UuanNcIik7XG5leHBvcnRzLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlXzEuZGVmYXVsdDtcbnZhciBmaW5kXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZpbmQgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9maW5kLmpzXCIpO1xuZXhwb3J0cy5maW5kID0gZmluZF8xLmRlZmF1bHQ7XG52YXIgZmluZF9pbmRleF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9maW5kLWluZGV4ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZmluZC1pbmRleC5qc1wiKTtcbmV4cG9ydHMuZmluZEluZGV4ID0gZmluZF9pbmRleF8xLmRlZmF1bHQ7XG52YXIgZmlyc3RfdmFsdWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmlyc3QtdmFsdWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9maXJzdC12YWx1ZS5qc1wiKTtcbmV4cG9ydHMuZmlyc3RWYWx1ZSA9IGZpcnN0X3ZhbHVlXzEuZGVmYXVsdDtcbnZhciBmbGF0dGVuXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZsYXR0ZW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9mbGF0dGVuLmpzXCIpO1xuZXhwb3J0cy5mbGF0dGVuID0gZmxhdHRlbl8xLmRlZmF1bHQ7XG52YXIgZmxhdHRlbl9kZWVwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZsYXR0ZW4tZGVlcCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2ZsYXR0ZW4tZGVlcC5qc1wiKTtcbmV4cG9ydHMuZmxhdHRlbkRlZXAgPSBmbGF0dGVuX2RlZXBfMS5kZWZhdWx0O1xudmFyIGdldF9yYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXQtcmFuZ2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9nZXQtcmFuZ2UuanNcIik7XG5leHBvcnRzLmdldFJhbmdlID0gZ2V0X3JhbmdlXzEuZGVmYXVsdDtcbnZhciBwdWxsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3B1bGwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9wdWxsLmpzXCIpO1xuZXhwb3J0cy5wdWxsID0gcHVsbF8xLmRlZmF1bHQ7XG52YXIgcHVsbF9hdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wdWxsLWF0ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcHVsbC1hdC5qc1wiKTtcbmV4cG9ydHMucHVsbEF0ID0gcHVsbF9hdF8xLmRlZmF1bHQ7XG52YXIgcmVkdWNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JlZHVjZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3JlZHVjZS5qc1wiKTtcbmV4cG9ydHMucmVkdWNlID0gcmVkdWNlXzEuZGVmYXVsdDtcbnZhciByZW1vdmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVtb3ZlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcmVtb3ZlLmpzXCIpO1xuZXhwb3J0cy5yZW1vdmUgPSByZW1vdmVfMS5kZWZhdWx0O1xudmFyIHNvcnRfYnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc29ydC1ieSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3NvcnQtYnkuanNcIik7XG5leHBvcnRzLnNvcnRCeSA9IHNvcnRfYnlfMS5kZWZhdWx0O1xudmFyIHVuaW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3VuaW9uICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdW5pb24uanNcIik7XG5leHBvcnRzLnVuaW9uID0gdW5pb25fMS5kZWZhdWx0O1xudmFyIHVuaXFfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdW5pcSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3VuaXEuanNcIik7XG5leHBvcnRzLnVuaXEgPSB1bmlxXzEuZGVmYXVsdDtcbnZhciB2YWx1ZXNfb2Zfa2V5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ZhbHVlcy1vZi1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi92YWx1ZXMtb2Yta2V5LmpzXCIpO1xuZXhwb3J0cy52YWx1ZXNPZktleSA9IHZhbHVlc19vZl9rZXlfMS5kZWZhdWx0O1xudmFyIGhlYWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGVhZCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2hlYWQuanNcIik7XG5leHBvcnRzLmhlYWQgPSBoZWFkXzEuZGVmYXVsdDtcbnZhciBsYXN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xhc3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9sYXN0LmpzXCIpO1xuZXhwb3J0cy5sYXN0ID0gbGFzdF8xLmRlZmF1bHQ7XG52YXIgc3RhcnRzX3dpdGhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3RhcnRzLXdpdGggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9zdGFydHMtd2l0aC5qc1wiKTtcbmV4cG9ydHMuc3RhcnRzV2l0aCA9IHN0YXJ0c193aXRoXzEuZGVmYXVsdDtcbnZhciBlbmRzX3dpdGhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZW5kcy13aXRoICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZW5kcy13aXRoLmpzXCIpO1xuZXhwb3J0cy5lbmRzV2l0aCA9IGVuZHNfd2l0aF8xLmRlZmF1bHQ7XG52YXIgZmlsdGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZpbHRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2ZpbHRlci5qc1wiKTtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyXzEuZGVmYXVsdDtcbnZhciBldmVyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ldmVyeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2V2ZXJ5LmpzXCIpO1xuZXhwb3J0cy5ldmVyeSA9IGV2ZXJ5XzEuZGVmYXVsdDtcbnZhciBzb21lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NvbWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9zb21lLmpzXCIpO1xuZXhwb3J0cy5zb21lID0gc29tZV8xLmRlZmF1bHQ7XG52YXIgZ3JvdXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ3JvdXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9ncm91cC5qc1wiKTtcbmV4cG9ydHMuZ3JvdXAgPSBncm91cF8xLmRlZmF1bHQ7XG52YXIgZ3JvdXBfYnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ3JvdXAtYnkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9ncm91cC1ieS5qc1wiKTtcbmV4cG9ydHMuZ3JvdXBCeSA9IGdyb3VwX2J5XzEuZGVmYXVsdDtcbnZhciBncm91cF90b19tYXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ3JvdXAtdG8tbWFwICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ3JvdXAtdG8tbWFwLmpzXCIpO1xuZXhwb3J0cy5ncm91cFRvTWFwID0gZ3JvdXBfdG9fbWFwXzEuZGVmYXVsdDtcbi8vIGV2ZW50XG52YXIgZ2V0X3dyYXBfYmVoYXZpb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0LXdyYXAtYmVoYXZpb3IgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9nZXQtd3JhcC1iZWhhdmlvci5qc1wiKTtcbmV4cG9ydHMuZ2V0V3JhcEJlaGF2aW9yID0gZ2V0X3dyYXBfYmVoYXZpb3JfMS5kZWZhdWx0O1xudmFyIHdyYXBfYmVoYXZpb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vd3JhcC1iZWhhdmlvciAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3dyYXAtYmVoYXZpb3IuanNcIik7XG5leHBvcnRzLndyYXBCZWhhdmlvciA9IHdyYXBfYmVoYXZpb3JfMS5kZWZhdWx0O1xuLy8gZm9ybWF0XG52YXIgbnVtYmVyMmNvbG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL251bWJlcjJjb2xvciAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL251bWJlcjJjb2xvci5qc1wiKTtcbmV4cG9ydHMubnVtYmVyMmNvbG9yID0gbnVtYmVyMmNvbG9yXzEuZGVmYXVsdDtcbnZhciBwYXJzZV9yYWRpdXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGFyc2UtcmFkaXVzICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcGFyc2UtcmFkaXVzLmpzXCIpO1xuZXhwb3J0cy5wYXJzZVJhZGl1cyA9IHBhcnNlX3JhZGl1c18xLmRlZmF1bHQ7XG4vLyBtYXRoXG52YXIgY2xhbXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2xhbXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9jbGFtcC5qc1wiKTtcbmV4cG9ydHMuY2xhbXAgPSBjbGFtcF8xLmRlZmF1bHQ7XG52YXIgZml4ZWRfYmFzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9maXhlZC1iYXNlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZml4ZWQtYmFzZS5qc1wiKTtcbmV4cG9ydHMuZml4ZWRCYXNlID0gZml4ZWRfYmFzZV8xLmRlZmF1bHQ7XG52YXIgaXNfZGVjaW1hbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1kZWNpbWFsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZGVjaW1hbC5qc1wiKTtcbmV4cG9ydHMuaXNEZWNpbWFsID0gaXNfZGVjaW1hbF8xLmRlZmF1bHQ7XG52YXIgaXNfZXZlbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1ldmVuICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZXZlbi5qc1wiKTtcbmV4cG9ydHMuaXNFdmVuID0gaXNfZXZlbl8xLmRlZmF1bHQ7XG52YXIgaXNfaW50ZWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1pbnRlZ2VyICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtaW50ZWdlci5qc1wiKTtcbmV4cG9ydHMuaXNJbnRlZ2VyID0gaXNfaW50ZWdlcl8xLmRlZmF1bHQ7XG52YXIgaXNfbmVnYXRpdmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbmVnYXRpdmUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1uZWdhdGl2ZS5qc1wiKTtcbmV4cG9ydHMuaXNOZWdhdGl2ZSA9IGlzX25lZ2F0aXZlXzEuZGVmYXVsdDtcbnZhciBpc19udW1iZXJfZXF1YWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbnVtYmVyLWVxdWFsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbnVtYmVyLWVxdWFsLmpzXCIpO1xuZXhwb3J0cy5pc051bWJlckVxdWFsID0gaXNfbnVtYmVyX2VxdWFsXzEuZGVmYXVsdDtcbnZhciBpc19vZGRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtb2RkICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtb2RkLmpzXCIpO1xuZXhwb3J0cy5pc09kZCA9IGlzX29kZF8xLmRlZmF1bHQ7XG52YXIgaXNfcG9zaXRpdmVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtcG9zaXRpdmUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1wb3NpdGl2ZS5qc1wiKTtcbmV4cG9ydHMuaXNQb3NpdGl2ZSA9IGlzX3Bvc2l0aXZlXzEuZGVmYXVsdDtcbnZhciBtYXhfYnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWF4LWJ5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWF4LWJ5LmpzXCIpO1xuZXhwb3J0cy5tYXhCeSA9IG1heF9ieV8xLmRlZmF1bHQ7XG52YXIgbWluX2J5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21pbi1ieSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL21pbi1ieS5qc1wiKTtcbmV4cG9ydHMubWluQnkgPSBtaW5fYnlfMS5kZWZhdWx0O1xudmFyIG1vZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tb2QgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9tb2QuanNcIik7XG5leHBvcnRzLm1vZCA9IG1vZF8xLmRlZmF1bHQ7XG52YXIgdG9fZGVncmVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvLWRlZ3JlZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3RvLWRlZ3JlZS5qc1wiKTtcbmV4cG9ydHMudG9EZWdyZWUgPSB0b19kZWdyZWVfMS5kZWZhdWx0O1xudmFyIHRvX2ludGVnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG8taW50ZWdlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3RvLWludGVnZXIuanNcIik7XG5leHBvcnRzLnRvSW50ZWdlciA9IHRvX2ludGVnZXJfMS5kZWZhdWx0O1xudmFyIHRvX3JhZGlhbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90by1yYWRpYW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90by1yYWRpYW4uanNcIik7XG5leHBvcnRzLnRvUmFkaWFuID0gdG9fcmFkaWFuXzEuZGVmYXVsdDtcbi8vIG9iamVjdFxudmFyIGZvcl9pbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3ItaW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9mb3ItaW4uanNcIik7XG5leHBvcnRzLmZvckluID0gZm9yX2luXzEuZGVmYXVsdDtcbnZhciBoYXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGFzICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaGFzLmpzXCIpO1xuZXhwb3J0cy5oYXMgPSBoYXNfMS5kZWZhdWx0O1xudmFyIGhhc19rZXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaGFzLWtleSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2hhcy1rZXkuanNcIik7XG5leHBvcnRzLmhhc0tleSA9IGhhc19rZXlfMS5kZWZhdWx0O1xudmFyIGhhc192YWx1ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9oYXMtdmFsdWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9oYXMtdmFsdWUuanNcIik7XG5leHBvcnRzLmhhc1ZhbHVlID0gaGFzX3ZhbHVlXzEuZGVmYXVsdDtcbnZhciBrZXlzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2tleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9rZXlzLmpzXCIpO1xuZXhwb3J0cy5rZXlzID0ga2V5c18xLmRlZmF1bHQ7XG52YXIgaXNfbWF0Y2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbWF0Y2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1tYXRjaC5qc1wiKTtcbmV4cG9ydHMuaXNNYXRjaCA9IGlzX21hdGNoXzEuZGVmYXVsdDtcbnZhciB2YWx1ZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdmFsdWVzICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdmFsdWVzLmpzXCIpO1xuZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXNfMS5kZWZhdWx0O1xuLy8gc3RyaW5nXG52YXIgbG93ZXJfY2FzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb3dlci1jYXNlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbG93ZXItY2FzZS5qc1wiKTtcbmV4cG9ydHMubG93ZXJDYXNlID0gbG93ZXJfY2FzZV8xLmRlZmF1bHQ7XG52YXIgbG93ZXJfZmlyc3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG93ZXItZmlyc3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9sb3dlci1maXJzdC5qc1wiKTtcbmV4cG9ydHMubG93ZXJGaXJzdCA9IGxvd2VyX2ZpcnN0XzEuZGVmYXVsdDtcbnZhciBzdWJzdGl0dXRlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N1YnN0aXR1dGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9zdWJzdGl0dXRlLmpzXCIpO1xuZXhwb3J0cy5zdWJzdGl0dXRlID0gc3Vic3RpdHV0ZV8xLmRlZmF1bHQ7XG52YXIgdXBwZXJfY2FzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91cHBlci1jYXNlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdXBwZXItY2FzZS5qc1wiKTtcbmV4cG9ydHMudXBwZXJDYXNlID0gdXBwZXJfY2FzZV8xLmRlZmF1bHQ7XG52YXIgdXBwZXJfZmlyc3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXBwZXItZmlyc3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi91cHBlci1maXJzdC5qc1wiKTtcbmV4cG9ydHMudXBwZXJGaXJzdCA9IHVwcGVyX2ZpcnN0XzEuZGVmYXVsdDtcbi8vIHR5cGVcbnZhciBnZXRfdHlwZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZXQtdHlwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2dldC10eXBlLmpzXCIpO1xuZXhwb3J0cy5nZXRUeXBlID0gZ2V0X3R5cGVfMS5kZWZhdWx0O1xudmFyIGlzX2FyZ3VtZW50c18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcmd1bWVudHMgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcmd1bWVudHMuanNcIik7XG5leHBvcnRzLmlzQXJndW1lbnRzID0gaXNfYXJndW1lbnRzXzEuZGVmYXVsdDtcbnZhciBpc19hcnJheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LmpzXCIpO1xuZXhwb3J0cy5pc0FycmF5ID0gaXNfYXJyYXlfMS5kZWZhdWx0O1xudmFyIGlzX2FycmF5X2xpa2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXktbGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LWxpa2UuanNcIik7XG5leHBvcnRzLmlzQXJyYXlMaWtlID0gaXNfYXJyYXlfbGlrZV8xLmRlZmF1bHQ7XG52YXIgaXNfYm9vbGVhbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1ib29sZWFuICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYm9vbGVhbi5qc1wiKTtcbmV4cG9ydHMuaXNCb29sZWFuID0gaXNfYm9vbGVhbl8xLmRlZmF1bHQ7XG52YXIgaXNfZGF0ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1kYXRlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZGF0ZS5qc1wiKTtcbmV4cG9ydHMuaXNEYXRlID0gaXNfZGF0ZV8xLmRlZmF1bHQ7XG52YXIgaXNfZXJyb3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZXJyb3IgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1lcnJvci5qc1wiKTtcbmV4cG9ydHMuaXNFcnJvciA9IGlzX2Vycm9yXzEuZGVmYXVsdDtcbnZhciBpc19mdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1mdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWZ1bmN0aW9uLmpzXCIpO1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNfZnVuY3Rpb25fMS5kZWZhdWx0O1xudmFyIGlzX2Zpbml0ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1maW5pdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1maW5pdGUuanNcIik7XG5leHBvcnRzLmlzRmluaXRlID0gaXNfZmluaXRlXzEuZGVmYXVsdDtcbnZhciBpc19uaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbmlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbmlsLmpzXCIpO1xuZXhwb3J0cy5pc05pbCA9IGlzX25pbF8xLmRlZmF1bHQ7XG52YXIgaXNfbnVsbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1udWxsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbnVsbC5qc1wiKTtcbmV4cG9ydHMuaXNOdWxsID0gaXNfbnVsbF8xLmRlZmF1bHQ7XG52YXIgaXNfbnVtYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW51bWJlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW51bWJlci5qc1wiKTtcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc19udW1iZXJfMS5kZWZhdWx0O1xudmFyIGlzX29iamVjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1vYmplY3QuanNcIik7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNfb2JqZWN0XzEuZGVmYXVsdDtcbnZhciBpc19vYmplY3RfbGlrZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1vYmplY3QtbGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW9iamVjdC1saWtlLmpzXCIpO1xuZXhwb3J0cy5pc09iamVjdExpa2UgPSBpc19vYmplY3RfbGlrZV8xLmRlZmF1bHQ7XG52YXIgaXNfcGxhaW5fb2JqZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXBsYWluLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXBsYWluLW9iamVjdC5qc1wiKTtcbmV4cG9ydHMuaXNQbGFpbk9iamVjdCA9IGlzX3BsYWluX29iamVjdF8xLmRlZmF1bHQ7XG52YXIgaXNfcHJvdG90eXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXByb3RvdHlwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXByb3RvdHlwZS5qc1wiKTtcbmV4cG9ydHMuaXNQcm90b3R5cGUgPSBpc19wcm90b3R5cGVfMS5kZWZhdWx0O1xudmFyIGlzX3JlZ19leHBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtcmVnLWV4cCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXJlZy1leHAuanNcIik7XG5leHBvcnRzLmlzUmVnRXhwID0gaXNfcmVnX2V4cF8xLmRlZmF1bHQ7XG52YXIgaXNfc3RyaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXN0cmluZy5qc1wiKTtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc19zdHJpbmdfMS5kZWZhdWx0O1xudmFyIGlzX3R5cGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtdHlwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXR5cGUuanNcIik7XG5leHBvcnRzLmlzVHlwZSA9IGlzX3R5cGVfMS5kZWZhdWx0O1xudmFyIGlzX3VuZGVmaW5lZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy11bmRlZmluZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy11bmRlZmluZWQuanNcIik7XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNfdW5kZWZpbmVkXzEuZGVmYXVsdDtcbnZhciBpc19lbGVtZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWVsZW1lbnQgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1lbGVtZW50LmpzXCIpO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc19lbGVtZW50XzEuZGVmYXVsdDtcbnZhciByZXF1ZXN0X2FuaW1hdGlvbl9mcmFtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZXF1ZXN0LWFuaW1hdGlvbi1mcmFtZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3JlcXVlc3QtYW5pbWF0aW9uLWZyYW1lLmpzXCIpO1xuZXhwb3J0cy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1ZXN0X2FuaW1hdGlvbl9mcmFtZV8xLmRlZmF1bHQ7XG52YXIgY2xlYXJfYW5pbWF0aW9uX2ZyYW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NsZWFyLWFuaW1hdGlvbi1mcmFtZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2NsZWFyLWFuaW1hdGlvbi1mcmFtZS5qc1wiKTtcbmV4cG9ydHMuY2xlYXJBbmltYXRpb25GcmFtZSA9IGNsZWFyX2FuaW1hdGlvbl9mcmFtZV8xLmRlZmF1bHQ7XG4vLyBvdGhlclxudmFyIGF1Z21lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXVnbWVudCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2F1Z21lbnQuanNcIik7XG5leHBvcnRzLmF1Z21lbnQgPSBhdWdtZW50XzEuZGVmYXVsdDtcbnZhciBjbG9uZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jbG9uZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2Nsb25lLmpzXCIpO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lXzEuZGVmYXVsdDtcbnZhciBkZWJvdW5jZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kZWJvdW5jZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2RlYm91bmNlLmpzXCIpO1xuZXhwb3J0cy5kZWJvdW5jZSA9IGRlYm91bmNlXzEuZGVmYXVsdDtcbnZhciBtZW1vaXplXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21lbW9pemUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9tZW1vaXplLmpzXCIpO1xuZXhwb3J0cy5tZW1vaXplID0gbWVtb2l6ZV8xLmRlZmF1bHQ7XG52YXIgZGVlcF9taXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGVlcC1taXggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9kZWVwLW1peC5qc1wiKTtcbmV4cG9ydHMuZGVlcE1peCA9IGRlZXBfbWl4XzEuZGVmYXVsdDtcbnZhciBlYWNoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9lYWNoLmpzXCIpO1xuZXhwb3J0cy5lYWNoID0gZWFjaF8xLmRlZmF1bHQ7XG52YXIgZXh0ZW5kXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V4dGVuZCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2V4dGVuZC5qc1wiKTtcbmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kXzEuZGVmYXVsdDtcbnZhciBpbmRleF9vZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbmRleC1vZiAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LW9mLmpzXCIpO1xuZXhwb3J0cy5pbmRleE9mID0gaW5kZXhfb2ZfMS5kZWZhdWx0O1xudmFyIGlzX2VtcHR5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWVtcHR5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZW1wdHkuanNcIik7XG5leHBvcnRzLmlzRW1wdHkgPSBpc19lbXB0eV8xLmRlZmF1bHQ7XG52YXIgaXNfZXF1YWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZXF1YWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1lcXVhbC5qc1wiKTtcbmV4cG9ydHMuaXNFcXVhbCA9IGlzX2VxdWFsXzEuZGVmYXVsdDtcbnZhciBpc19lcXVhbF93aXRoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWVxdWFsLXdpdGggKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1lcXVhbC13aXRoLmpzXCIpO1xuZXhwb3J0cy5pc0VxdWFsV2l0aCA9IGlzX2VxdWFsX3dpdGhfMS5kZWZhdWx0O1xudmFyIG1hcF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tYXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9tYXAuanNcIik7XG5leHBvcnRzLm1hcCA9IG1hcF8xLmRlZmF1bHQ7XG52YXIgbWFwX3ZhbHVlc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tYXAtdmFsdWVzICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWFwLXZhbHVlcy5qc1wiKTtcbmV4cG9ydHMubWFwVmFsdWVzID0gbWFwX3ZhbHVlc18xLmRlZmF1bHQ7XG52YXIgbWl4XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21peCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL21peC5qc1wiKTtcbmV4cG9ydHMubWl4ID0gbWl4XzEuZGVmYXVsdDtcbmV4cG9ydHMuYXNzaWduID0gbWl4XzEuZGVmYXVsdDtcbnZhciBnZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZ2V0LmpzXCIpO1xuZXhwb3J0cy5nZXQgPSBnZXRfMS5kZWZhdWx0O1xudmFyIHNldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9zZXQuanNcIik7XG5leHBvcnRzLnNldCA9IHNldF8xLmRlZmF1bHQ7XG52YXIgcGlja18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9waWNrICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcGljay5qc1wiKTtcbmV4cG9ydHMucGljayA9IHBpY2tfMS5kZWZhdWx0O1xudmFyIHRocm90dGxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Rocm90dGxlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdGhyb3R0bGUuanNcIik7XG5leHBvcnRzLnRocm90dGxlID0gdGhyb3R0bGVfMS5kZWZhdWx0O1xudmFyIHRvX2FycmF5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdG8tYXJyYXkuanNcIik7XG5leHBvcnRzLnRvQXJyYXkgPSB0b19hcnJheV8xLmRlZmF1bHQ7XG52YXIgdG9fc3RyaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3RvLXN0cmluZy5qc1wiKTtcbmV4cG9ydHMudG9TdHJpbmcgPSB0b19zdHJpbmdfMS5kZWZhdWx0O1xudmFyIHVuaXF1ZV9pZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91bmlxdWUtaWQgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi91bmlxdWUtaWQuanNcIik7XG5leHBvcnRzLnVuaXF1ZUlkID0gdW5pcXVlX2lkXzEuZGVmYXVsdDtcbnZhciBub29wXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL25vb3AgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9ub29wLmpzXCIpO1xuZXhwb3J0cy5ub29wID0gbm9vcF8xLmRlZmF1bHQ7XG52YXIgaWRlbnRpdHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaWRlbnRpdHkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pZGVudGl0eS5qc1wiKTtcbmV4cG9ydHMuaWRlbnRpdHkgPSBpZGVudGl0eV8xLmRlZmF1bHQ7XG52YXIgc2l6ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zaXplICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc2l6ZS5qc1wiKTtcbmV4cG9ydHMuc2l6ZSA9IHNpemVfMS5kZWZhdWx0O1xuLy8g5LiN55+l6YGT5Li65LuA5LmI77yM6ZyA6KaB5oqK6L+Z5LiqIGV4cG9ydO+8jOS4jeeEtiB0cyDkvJrmiqXnsbvlnovplJnor69cbnZhciBjYWNoZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jYWNoZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2NhY2hlLmpzXCIpO1xuZXhwb3J0cy5DYWNoZSA9IGNhY2hlXzEuZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcmd1bWVudHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFyZ3VtZW50cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICog5piv5ZCm5piv5Y+C5pWw57G75Z6LXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIOa1i+ivleeahOWAvFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzX3R5cGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtdHlwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXR5cGUuanNcIik7XG52YXIgaXNBcmd1bWVudHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gaXNfdHlwZV8xLmRlZmF1bHQodmFsdWUsICdBcmd1bWVudHMnKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc0FyZ3VtZW50cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWFyZ3VtZW50cy5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXktbGlrZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LWxpa2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLyoqXG4gICAgICogaXNBcnJheUxpa2UoWzEsIDIsIDNdKSA9PiB0cnVlXG4gICAgICogaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbikgPT4gdHJ1ZVxuICAgICAqIGlzQXJyYXlMaWtlKCdhYmMnKSA9PiB0cnVlXG4gICAgICogaXNBcnJheUxpa2UoRnVuY3Rpb24pID0+IGZhbHNlXG4gICAgICovXG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiBpc0Zpbml0ZSh2YWx1ZS5sZW5ndGgpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQXJyYXlMaWtlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtYXJyYXktbGlrZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc190eXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXR5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy10eXBlLmpzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5ID9cbiAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgOlxuICAgICAgICBpc190eXBlXzEuZGVmYXVsdCh2YWx1ZSwgJ0FycmF5Jyk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWFycmF5LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1ib29sZWFuLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYm9vbGVhbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIOaYr+WQpuaYr+W4g+WwlOexu+Wei1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSDmtYvor5XnmoTlgLxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc190eXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXR5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy10eXBlLmpzXCIpO1xudmFyIGlzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBpc190eXBlXzEuZGVmYXVsdCh2YWx1ZSwgJ0Jvb2xlYW4nKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc0Jvb2xlYW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1ib29sZWFuLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1kYXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZGF0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfdHlwZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy10eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtdHlwZS5qc1wiKTtcbnZhciBpc0RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gaXNfdHlwZV8xLmRlZmF1bHQodmFsdWUsICdEYXRlJyk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNEYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZGF0ZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZGVjaW1hbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWRlY2ltYWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX251bWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1udW1iZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1udW1iZXIuanNcIik7XG52YXIgaXNEZWNpbWFsID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBpc19udW1iZXJfMS5kZWZhdWx0KG51bSkgJiYgbnVtICUgMSAhPT0gMDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc0RlY2ltYWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1kZWNpbWFsLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1lbGVtZW50LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZWxlbWVudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIOWIpOaWreaYr+WQpkhUTUzlhYPntKBcbiAqIEByZXR1cm4ge0Jvb2xlYW59IOaYr+WQpkhUTUzlhYPntKBcbiAqL1xudmFyIGlzRWxlbWVudCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gaW5zdGFuY2VvZiBFbGVtZW50IHx8IG8gaW5zdGFuY2VvZiBIVE1MRG9jdW1lbnQ7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNFbGVtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZWxlbWVudC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZW1wdHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZW1wdHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19uaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbmlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbmlsLmpzXCIpO1xudmFyIGlzX2FycmF5X2xpa2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXktbGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LWxpa2UuanNcIik7XG52YXIgZ2V0X3R5cGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ2V0LXR5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9nZXQtdHlwZS5qc1wiKTtcbnZhciBpc19wcm90b3R5cGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtcHJvdG90eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtcHJvdG90eXBlLmpzXCIpO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgICAvKipcbiAgICAgKiBpc0VtcHR5KG51bGwpID0+IHRydWVcbiAgICAgKiBpc0VtcHR5KCkgPT4gdHJ1ZVxuICAgICAqIGlzRW1wdHkodHJ1ZSkgPT4gdHJ1ZVxuICAgICAqIGlzRW1wdHkoMSkgPT4gdHJ1ZVxuICAgICAqIGlzRW1wdHkoWzEsIDIsIDNdKSA9PiBmYWxzZVxuICAgICAqIGlzRW1wdHkoJ2FiYycpID0+IGZhbHNlXG4gICAgICogaXNFbXB0eSh7IGE6IDEgfSkgPT4gZmFsc2VcbiAgICAgKi9cbiAgICBpZiAoaXNfbmlsXzEuZGVmYXVsdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc19hcnJheV9saWtlXzEuZGVmYXVsdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIHZhciB0eXBlID0gZ2V0X3R5cGVfMS5kZWZhdWx0KHZhbHVlKTtcbiAgICBpZiAodHlwZSA9PT0gJ01hcCcgfHwgdHlwZSA9PT0gJ1NldCcpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICAgIH1cbiAgICBpZiAoaXNfcHJvdG90eXBlXzEuZGVmYXVsdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGlzRW1wdHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1lbXB0eS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZXF1YWwtd2l0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWVxdWFsLXdpdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX2Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWZ1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZnVuY3Rpb24uanNcIik7XG52YXIgaXNfZXF1YWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZXF1YWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1lcXVhbC5qc1wiKTtcbi8qKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBpc0dyZWV0aW5nKHZhbHVlKSB7XG4gKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUpIHtcbiAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcob3RoVmFsdWUpKSB7XG4gKiAgICAgcmV0dXJuIHRydWU7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiB2YXIgYXJyYXkgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICpcbiAqIGlzRXF1YWxXaXRoKGFycmF5LCBvdGhlciwgY3VzdG9taXplcik7ICAvLyA9PiB0cnVlXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAodmFsdWUsIG90aGVyLCBmbikge1xuICAgIGlmICghaXNfZnVuY3Rpb25fMS5kZWZhdWx0KGZuKSkge1xuICAgICAgICByZXR1cm4gaXNfZXF1YWxfMS5kZWZhdWx0KHZhbHVlLCBvdGhlcik7XG4gICAgfVxuICAgIHJldHVybiAhIWZuKHZhbHVlLCBvdGhlcik7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWVxdWFsLXdpdGguanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWVxdWFsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWVxdWFsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfb2JqZWN0X2xpa2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtb2JqZWN0LWxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1vYmplY3QtbGlrZS5qc1wiKTtcbnZhciBpc19hcnJheV9saWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5LWxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS1saWtlLmpzXCIpO1xudmFyIGlzX3N0cmluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1zdHJpbmcuanNcIik7XG52YXIgaXNFcXVhbCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3RoZXIpIHtcbiAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlIHx8ICFvdGhlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc19zdHJpbmdfMS5kZWZhdWx0KHZhbHVlKSB8fCBpc19zdHJpbmdfMS5kZWZhdWx0KG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc19hcnJheV9saWtlXzEuZGVmYXVsdCh2YWx1ZSkgfHwgaXNfYXJyYXlfbGlrZV8xLmRlZmF1bHQob3RoZXIpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByc3QgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByc3QgPSBpc0VxdWFsKHZhbHVlW2ldLCBvdGhlcltpXSk7XG4gICAgICAgICAgICBpZiAoIXJzdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByc3Q7XG4gICAgfVxuICAgIGlmIChpc19vYmplY3RfbGlrZV8xLmRlZmF1bHQodmFsdWUpIHx8IGlzX29iamVjdF9saWtlXzEuZGVmYXVsdChvdGhlcikpIHtcbiAgICAgICAgdmFyIHZhbHVlS2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgdmFyIG90aGVyS2V5cyA9IE9iamVjdC5rZXlzKG90aGVyKTtcbiAgICAgICAgaWYgKHZhbHVlS2V5cy5sZW5ndGggIT09IG90aGVyS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnN0ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJzdCA9IGlzRXF1YWwodmFsdWVbdmFsdWVLZXlzW2ldXSwgb3RoZXJbdmFsdWVLZXlzW2ldXSk7XG4gICAgICAgICAgICBpZiAoIXJzdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByc3Q7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc0VxdWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZXF1YWwuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWVycm9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWVycm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIOaYr+WQpuaYr+WPguaVsOexu+Wei1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSDmtYvor5XnmoTlgLxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc190eXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXR5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy10eXBlLmpzXCIpO1xudmFyIGlzRXJyb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gaXNfdHlwZV8xLmRlZmF1bHQodmFsdWUsICdFcnJvcicpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1lcnJvci5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZXZlbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWV2ZW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX251bWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1udW1iZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1udW1iZXIuanNcIik7XG52YXIgaXNFdmVuID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHJldHVybiBpc19udW1iZXJfMS5kZWZhdWx0KG51bSkgJiYgbnVtICUgMiA9PT0gMDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc0V2ZW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1ldmVuLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1maW5pdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWZpbml0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICog5Yik5pat5piv5ZCm5Li65pyJ6ZmQ5pWwXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNfbnVtYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW51bWJlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW51bWJlci5qc1wiKTtcbmZ1bmN0aW9uIGRlZmF1bHRfMSh2YWx1ZSkge1xuICAgIHJldHVybiBpc19udW1iZXJfMS5kZWZhdWx0KHZhbHVlKSAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1maW5pdGUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWZ1bmN0aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWZ1bmN0aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIOaYr+WQpuS4uuWHveaVsFxuICogQHBhcmFtICB7Kn0gZm4g5a+56LGhXG4gKiBAcmV0dXJuIHtCb29sZWFufSAg5piv5ZCm5Ye95pWwXG4gKi9cbnZhciBpc190eXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXR5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy10eXBlLmpzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBpc190eXBlXzEuZGVmYXVsdCh2YWx1ZSwgJ0Z1bmN0aW9uJyk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWZ1bmN0aW9uLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1pbnRlZ2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtaW50ZWdlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfbnVtYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW51bWJlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW51bWJlci5qc1wiKTtcbnZhciBpc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyID8gTnVtYmVyLmlzSW50ZWdlciA6IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gaXNfbnVtYmVyXzEuZGVmYXVsdChudW0pICYmIG51bSAlIDEgPT09IDA7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNJbnRlZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtaW50ZWdlci5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbWF0Y2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbWF0Y2guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19uaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbmlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbmlsLmpzXCIpO1xudmFyIGtleXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4va2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2tleXMuanNcIik7XG5mdW5jdGlvbiBpc01hdGNoKG9iaiwgYXR0cnMpIHtcbiAgICB2YXIgX2tleXMgPSBrZXlzXzEuZGVmYXVsdChhdHRycyk7XG4gICAgdmFyIGxlbmd0aCA9IF9rZXlzLmxlbmd0aDtcbiAgICBpZiAoaXNfbmlsXzEuZGVmYXVsdChvYmopKVxuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBrZXkgPSBfa2V5c1tpXTtcbiAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldIHx8ICEoa2V5IGluIG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGlzTWF0Y2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1tYXRjaC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbmVnYXRpdmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbmVnYXRpdmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19udW1iZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbnVtYmVyICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbnVtYmVyLmpzXCIpO1xudmFyIGlzTmVnYXRpdmUgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgcmV0dXJuIGlzX251bWJlcl8xLmRlZmF1bHQobnVtKSAmJiBudW0gPCAwO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzTmVnYXRpdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1uZWdhdGl2ZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbmlsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1uaWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBpc0Zpbml0ZSxcbnZhciBpc05pbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8qKlxuICAgICAqIGlzTmlsKG51bGwpID0+IHRydWVcbiAgICAgKiBpc05pbCgpID0+IHRydWVcbiAgICAgKi9cbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc05pbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLW5pbC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbnVsbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW51bGwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzTnVsbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc051bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1udWxsLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1udW1iZXItZXF1YWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW51bWJlci1lcXVhbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQUkVDSVNJT04gPSAwLjAwMDAxOyAvLyBudW1iZXJzIGxlc3MgdGhhbiB0aGlzIGlzIGNvbnNpZGVyZWQgYXMgMFxuZnVuY3Rpb24gaXNOdW1iZXJFcXVhbChhLCBiLCBwcmVjaXNpb24pIHtcbiAgICBpZiAocHJlY2lzaW9uID09PSB2b2lkIDApIHsgcHJlY2lzaW9uID0gUFJFQ0lTSU9OOyB9XG4gICAgcmV0dXJuIE1hdGguYWJzKChhIC0gYikpIDwgcHJlY2lzaW9uO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gaXNOdW1iZXJFcXVhbDtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLW51bWJlci1lcXVhbC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbnVtYmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1udW1iZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIOWIpOaWreaYr+WQpuaVsOWtl1xuICogQHJldHVybiB7Qm9vbGVhbn0g5piv5ZCm5pWw5a2XXG4gKi9cbnZhciBpc190eXBlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLXR5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy10eXBlLmpzXCIpO1xudmFyIGlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzX3R5cGVfMS5kZWZhdWx0KHZhbHVlLCAnTnVtYmVyJyk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNOdW1iZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1udW1iZXIuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW9iamVjdC1saWtlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW9iamVjdC1saWtlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNPYmplY3RMaWtlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLyoqXG4gICAgICogaXNPYmplY3RMaWtlKHt9KSA9PiB0cnVlXG4gICAgICogaXNPYmplY3RMaWtlKFsxLCAyLCAzXSkgPT4gdHJ1ZVxuICAgICAqIGlzT2JqZWN0TGlrZShGdW5jdGlvbikgPT4gZmFsc2VcbiAgICAgKiBpc09iamVjdExpa2UobnVsbCkgPT4gZmFsc2VcbiAgICAgKi9cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc09iamVjdExpa2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1vYmplY3QtbGlrZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtb2JqZWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1vYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLyoqXG4gICAgICogaXNPYmplY3Qoe30pID0+IHRydWVcbiAgICAgKiBpc09iamVjdChbMSwgMiwgM10pID0+IHRydWVcbiAgICAgKiBpc09iamVjdChGdW5jdGlvbikgPT4gdHJ1ZVxuICAgICAqIGlzT2JqZWN0KG51bGwpID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbic7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLW9iamVjdC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtb2RkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1vZGQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfbnVtYmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW51bWJlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW51bWJlci5qc1wiKTtcbnZhciBpc09kZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gaXNfbnVtYmVyXzEuZGVmYXVsdChudW0pICYmIG51bSAlIDIgIT09IDA7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNPZGQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1vZGQuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXBsYWluLW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtcGxhaW4tb2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX29iamVjdF9saWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW9iamVjdC1saWtlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtb2JqZWN0LWxpa2UuanNcIik7XG52YXIgaXNfdHlwZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy10eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtdHlwZS5qc1wiKTtcbnZhciBpc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLyoqXG4gICAgICogaXNPYmplY3RMaWtlKG5ldyBGb28pID0+IGZhbHNlXG4gICAgICogaXNPYmplY3RMaWtlKFsxLCAyLCAzXSkgPT4gZmFsc2VcbiAgICAgKiBpc09iamVjdExpa2UoeyB4OiAwLCB5OiAwIH0pID0+IHRydWVcbiAgICAgKiBpc09iamVjdExpa2UoT2JqZWN0LmNyZWF0ZShudWxsKSkgPT4gdHJ1ZVxuICAgICAqL1xuICAgIGlmICghaXNfb2JqZWN0X2xpa2VfMS5kZWZhdWx0KHZhbHVlKSB8fCAhaXNfdHlwZV8xLmRlZmF1bHQodmFsdWUsICdPYmplY3QnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgcHJvdG8gPSB2YWx1ZTtcbiAgICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBwcm90bztcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc1BsYWluT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtcGxhaW4tb2JqZWN0LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1wb3NpdGl2ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1wb3NpdGl2ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX251bWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1udW1iZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1udW1iZXIuanNcIik7XG52YXIgaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICByZXR1cm4gaXNfbnVtYmVyXzEuZGVmYXVsdChudW0pICYmIG51bSA+IDA7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNQb3NpdGl2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXBvc2l0aXZlLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1wcm90b3R5cGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXByb3RvdHlwZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaXNQcm90b3R5cGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9ICh0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG4gICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc1Byb3RvdHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXByb3RvdHlwZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtcmVnLWV4cC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXJlZy1leHAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX3R5cGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtdHlwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXR5cGUuanNcIik7XG52YXIgaXNSZWdFeHAgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIGlzX3R5cGVfMS5kZWZhdWx0KHN0ciwgJ1JlZ0V4cCcpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzUmVnRXhwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtcmVnLWV4cC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtc3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1zdHJpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfdHlwZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy10eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtdHlwZS5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIGlzX3R5cGVfMS5kZWZhdWx0KHN0ciwgJ1N0cmluZycpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1zdHJpbmcuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLXR5cGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy10eXBlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xudmFyIGlzVHlwZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkgeyByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0ICcgKyB0eXBlICsgJ10nOyB9O1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNUeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtdHlwZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtdW5kZWZpbmVkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy11bmRlZmluZWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNVbmRlZmluZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBpc1VuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXVuZGVmaW5lZC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIva2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2tleXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVhY2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2VhY2guanNcIik7XG52YXIgaXNfZnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1mdW5jdGlvbi5qc1wiKTtcbnZhciBrZXlzID0gT2JqZWN0LmtleXMgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBPYmplY3Qua2V5cyhvYmopOyB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBlYWNoXzEuZGVmYXVsdChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmICghKGlzX2Z1bmN0aW9uXzEuZGVmYXVsdChvYmopICYmIGtleSA9PT0gJ3Byb3RvdHlwZScpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBrZXlzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9a2V5cy5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbGFzdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2xhc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX2FycmF5X2xpa2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXktbGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LWxpa2UuanNcIik7XG5mdW5jdGlvbiBsYXN0KG8pIHtcbiAgICBpZiAoaXNfYXJyYXlfbGlrZV8xLmRlZmF1bHQobykpIHtcbiAgICAgICAgdmFyIGFyciA9IG87XG4gICAgICAgIHJldHVybiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gbGFzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhc3QuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2xvd2VyLWNhc2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9sb3dlci1jYXNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0b19zdHJpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdG8tc3RyaW5nLmpzXCIpO1xudmFyIGxvd2VyQ2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gdG9fc3RyaW5nXzEuZGVmYXVsdChzdHIpLnRvTG93ZXJDYXNlKCk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gbG93ZXJDYXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG93ZXItY2FzZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbG93ZXItZmlyc3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbG93ZXItZmlyc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0b19zdHJpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdG8tc3RyaW5nLmpzXCIpO1xudmFyIGxvd2VyRmlyc3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgc3RyID0gdG9fc3RyaW5nXzEuZGVmYXVsdCh2YWx1ZSk7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gbG93ZXJGaXJzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvd2VyLWZpcnN0LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9tYXAtdmFsdWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWFwLXZhbHVlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfbmlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW5pbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW5pbC5qc1wiKTtcbnZhciBpc19vYmplY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtb2JqZWN0LmpzXCIpO1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHY7IH07XG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKG9iamVjdCwgZnVuYykge1xuICAgIGlmIChmdW5jID09PSB2b2lkIDApIHsgZnVuYyA9IGlkZW50aXR5OyB9XG4gICAgdmFyIHIgPSB7fTtcbiAgICBpZiAoaXNfb2JqZWN0XzEuZGVmYXVsdChvYmplY3QpICYmICFpc19uaWxfMS5kZWZhdWx0KG9iamVjdCkpIHtcbiAgICAgICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJba2V5XSA9IGZ1bmMob2JqZWN0W2tleV0sIGtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLXZhbHVlcy5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9tYXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZWFjaF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZWFjaC5qc1wiKTtcbnZhciBpc19hcnJheV9saWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5LWxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS1saWtlLmpzXCIpO1xudmFyIG1hcCA9IGZ1bmN0aW9uIChhcnIsIGZ1bmMpIHtcbiAgICBpZiAoIWlzX2FycmF5X2xpa2VfMS5kZWZhdWx0KGFycikpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZWFjaF8xLmRlZmF1bHQoYXJyLCBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGZ1bmModmFsdWUsIGluZGV4KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBtYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXAuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL21heC1ieS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWF4LWJ5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVhY2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2VhY2guanNcIik7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbnZhciBpc19mdW5jdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1mdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWZ1bmN0aW9uLmpzXCIpO1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAqXG4gKiBtYXhCeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICogLy8gPT4geyAnbic6IDIgfVxuICpcbiAqIG1heEJ5KG9iamVjdHMsICduJyk7XG4gKiAvLyA9PiB7ICduJzogMiB9XG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoYXJyLCBmbikge1xuICAgIGlmICghaXNfYXJyYXlfMS5kZWZhdWx0KGFycikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIG1heCA9IGFyclswXTtcbiAgICB2YXIgbWF4RGF0YTtcbiAgICBpZiAoaXNfZnVuY3Rpb25fMS5kZWZhdWx0KGZuKSkge1xuICAgICAgICBtYXhEYXRhID0gZm4oYXJyWzBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1heERhdGEgPSBhcnJbMF1bZm5dO1xuICAgIH1cbiAgICB2YXIgZGF0YTtcbiAgICBlYWNoXzEuZGVmYXVsdChhcnIsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgaWYgKGlzX2Z1bmN0aW9uXzEuZGVmYXVsdChmbikpIHtcbiAgICAgICAgICAgIGRhdGEgPSBmbih2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHZhbFtmbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEgPiBtYXhEYXRhKSB7XG4gICAgICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgICAgICBtYXhEYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtYXg7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heC1ieS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWVtb2l6ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL21lbW9pemUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX2Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWZ1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZnVuY3Rpb24uanNcIik7XG4vKipcbiAqIF8ubWVtb2l6ZShjYWxDb2xvcik7XG4gKiBfLm1lbW9pemUoY2FsQ29sb3IsICguLi5hcmdzKSA9PiBhcmdzWzBdKTtcbiAqIEBwYXJhbSBmXG4gKiBAcGFyYW0gcmVzb2x2ZXJcbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChmLCByZXNvbHZlcikge1xuICAgIGlmICghaXNfZnVuY3Rpb25fMS5kZWZhdWx0KGYpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIOS9v+eUqOaWueazleaehOmAoCBrZXnvvIzlpoLmnpzkuI3lrZjlnKggcmVzb2x2ZXLvvIzliJnnm7TmjqXlj5bnrKzkuIDkuKrlj4LmlbDkvZzkuLoga2V5XG4gICAgICAgIHZhciBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXTtcbiAgICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG4gICAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBmLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAvLyDnvJPlrZjotbfmnaVcbiAgICAgICAgY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiBtZW1vaXplZDtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVtb2l6ZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbWluLWJ5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9taW4tYnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZWFjaF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZWFjaC5qc1wiKTtcbnZhciBpc19hcnJheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LmpzXCIpO1xudmFyIGlzX2Z1bmN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWZ1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtZnVuY3Rpb24uanNcIik7XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm4geyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICpcbiAqIG1pbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gKiAvLyA9PiB7ICduJzogMSB9XG4gKlxuICogbWluQnkob2JqZWN0cywgJ24nKTtcbiAqIC8vID0+IHsgJ24nOiAxIH1cbiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgaWYgKCFpc19hcnJheV8xLmRlZmF1bHQoYXJyKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgbWluID0gYXJyWzBdO1xuICAgIHZhciBtaW5EYXRhO1xuICAgIGlmIChpc19mdW5jdGlvbl8xLmRlZmF1bHQoZm4pKSB7XG4gICAgICAgIG1pbkRhdGEgPSBmbihhcnJbMF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWluRGF0YSA9IGFyclswXVtmbl07XG4gICAgfVxuICAgIHZhciBkYXRhO1xuICAgIGVhY2hfMS5kZWZhdWx0KGFyciwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBpZiAoaXNfZnVuY3Rpb25fMS5kZWZhdWx0KGZuKSkge1xuICAgICAgICAgICAgZGF0YSA9IGZuKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gdmFsW2ZuXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSA8IG1pbkRhdGEpIHtcbiAgICAgICAgICAgIG1pbiA9IHZhbDtcbiAgICAgICAgICAgIG1pbkRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1pbjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWluLWJ5LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9taXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL21peC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIEZJWE1FOiBNdXRhYmxlIHBhcmFtIHNob3VsZCBiZSBmb3JiaWRkZW4gaW4gc3RhdGljIGxhbmcuXG5mdW5jdGlvbiBfbWl4KGRpc3QsIG9iaikge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPT0gJ2NvbnN0cnVjdG9yJyAmJiBvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkaXN0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1peChkaXN0LCBzcmMxLCBzcmMyLCBzcmMzKSB7XG4gICAgaWYgKHNyYzEpXG4gICAgICAgIF9taXgoZGlzdCwgc3JjMSk7XG4gICAgaWYgKHNyYzIpXG4gICAgICAgIF9taXgoZGlzdCwgc3JjMik7XG4gICAgaWYgKHNyYzMpXG4gICAgICAgIF9taXgoZGlzdCwgc3JjMyk7XG4gICAgcmV0dXJuIGRpc3Q7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBtaXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taXguanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL21vZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbW9kLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1vZCA9IGZ1bmN0aW9uIChuLCBtKSB7XG4gICAgcmV0dXJuICgobiAlIG0pICsgbSkgJSBtO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1vZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvbm9vcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL25vb3AuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uICgpIHsgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub29wLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9udW1iZXIyY29sb3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL251bWJlcjJjb2xvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBudW1Db2xvckNhY2hlID0ge307XG5mdW5jdGlvbiBudW1iZXJUb0NvbG9yKG51bSkge1xuICAgIC8vIOWinuWKoOe8k+WtmFxuICAgIHZhciBjb2xvciA9IG51bUNvbG9yQ2FjaGVbbnVtXTtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICAgIHZhciBzdHIgPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RyLmxlbmd0aDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgc3RyID0gJzAnICsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIGNvbG9yID0gJyMnICsgc3RyO1xuICAgICAgICBudW1Db2xvckNhY2hlW251bV0gPSBjb2xvcjtcbiAgICB9XG4gICAgcmV0dXJuIGNvbG9yO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gbnVtYmVyVG9Db2xvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlcjJjb2xvci5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcGFyc2UtcmFkaXVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9wYXJzZS1yYWRpdXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbmZ1bmN0aW9uIHBhcnNlUmFkaXVzKHJhZGl1cykge1xuICAgIHZhciByMSA9IDAsIHIyID0gMCwgcjMgPSAwLCByNCA9IDA7XG4gICAgaWYgKGlzX2FycmF5XzEuZGVmYXVsdChyYWRpdXMpKSB7XG4gICAgICAgIGlmIChyYWRpdXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IHJhZGl1c1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyYWRpdXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICByMSA9IHIzID0gcmFkaXVzWzBdO1xuICAgICAgICAgICAgcjIgPSByNCA9IHJhZGl1c1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyYWRpdXMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICByMSA9IHJhZGl1c1swXTtcbiAgICAgICAgICAgIHIyID0gcjQgPSByYWRpdXNbMV07XG4gICAgICAgICAgICByMyA9IHJhZGl1c1syXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHIxID0gcmFkaXVzWzBdO1xuICAgICAgICAgICAgcjIgPSByYWRpdXNbMV07XG4gICAgICAgICAgICByMyA9IHJhZGl1c1syXTtcbiAgICAgICAgICAgIHI0ID0gcmFkaXVzWzNdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByMSA9IHIyID0gcjMgPSByNCA9IHJhZGl1cztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjE6IHIxLFxuICAgICAgICByMjogcjIsXG4gICAgICAgIHIzOiByMyxcbiAgICAgICAgcjQ6IHI0XG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlUmFkaXVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtcmFkaXVzLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9waWNrLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcGljay5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZWFjaF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZWFjaC5qc1wiKTtcbnZhciBpc19wbGFpbl9vYmplY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtcGxhaW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtcGxhaW4tb2JqZWN0LmpzXCIpO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAob2JqZWN0LCBrZXlzKSB7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCAhaXNfcGxhaW5fb2JqZWN0XzEuZGVmYXVsdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGVhY2hfMS5kZWZhdWx0KGtleXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGljay5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcHVsbC1hdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3B1bGwtYXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGlzX2FycmF5X2xpa2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXktbGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LWxpa2UuanNcIik7XG52YXIgc3BsaWNlID0gQXJyYXkucHJvdG90eXBlLnNwbGljZTtcbnZhciBwdWxsQXQgPSBmdW5jdGlvbiBwdWxsQXQoYXJyLCBpbmRleGVzKSB7XG4gICAgaWYgKCFpc19hcnJheV9saWtlXzEuZGVmYXVsdChhcnIpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGFyciA/IGluZGV4ZXMubGVuZ3RoIDogMDtcbiAgICB2YXIgbGFzdCA9IGxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBpZiAobGVuZ3RoID09PSBsYXN0IHx8IGluZGV4ICE9PSBwcmV2aW91cykge1xuICAgICAgICAgICAgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFyciwgaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gcHVsbEF0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHVsbC1hdC5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcHVsbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3B1bGwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFyclByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBzcGxpY2UgPSBhcnJQcm90b3R5cGUuc3BsaWNlO1xudmFyIGluZGV4T2YgPSBhcnJQcm90b3R5cGUuaW5kZXhPZjtcbnZhciBwdWxsID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YWx1ZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgdmFyIGZyb21JbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoKGZyb21JbmRleCA9IGluZGV4T2YuY2FsbChhcnIsIHZhbHVlKSkgPiAtMSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoYXJyLCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gcHVsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1bGwuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3JlZHVjZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcmVkdWNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVhY2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2VhY2guanNcIik7XG52YXIgaXNfYXJyYXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS5qc1wiKTtcbnZhciBpc19wbGFpbl9vYmplY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtcGxhaW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtcGxhaW4tb2JqZWN0LmpzXCIpO1xudmFyIHJlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIGZuLCBpbml0KSB7XG4gICAgaWYgKCFpc19hcnJheV8xLmRlZmF1bHQoYXJyKSAmJiAhaXNfcGxhaW5fb2JqZWN0XzEuZGVmYXVsdChhcnIpKSB7XG4gICAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBpbml0O1xuICAgIGVhY2hfMS5kZWZhdWx0KGFyciwgZnVuY3Rpb24gKGRhdGEsIGkpIHtcbiAgICAgICAgcmVzdWx0ID0gZm4ocmVzdWx0LCBkYXRhLCBpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlZHVjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHVjZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcmVtb3ZlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9yZW1vdmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfYXJyYXlfbGlrZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheS1saWtlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXktbGlrZS5qc1wiKTtcbnZhciBwdWxsX2F0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3B1bGwtYXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9wdWxsLWF0LmpzXCIpO1xudmFyIHJlbW92ZSA9IGZ1bmN0aW9uIChhcnIsIHByZWRpY2F0ZSkge1xuICAgIC8qKlxuICAgICAqIGNvbnN0IGFyciA9IFsxLCAyLCAzLCA0XVxuICAgICAqIGNvbnN0IGV2ZW5zID0gcmVtb3ZlKGFyciwgbiA9PiBuICUgMiA9PSAwKVxuICAgICAqIGNvbnNvbGUubG9nKGFycikgLy8gPT4gWzEsIDNdXG4gICAgICogY29uc29sZS5sb2coZXZlbnMpIC8vID0+IFsyLCA0XVxuICAgICAqL1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAoIWlzX2FycmF5X2xpa2VfMS5kZWZhdWx0KGFycikpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuICAgIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyW2ldO1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpLCBhcnIpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVsbF9hdF8xLmRlZmF1bHQoYXJyLCBpbmRleGVzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcmVxdWVzdC1hbmltYXRpb24tZnJhbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvcmVxdWVzdC1hbmltYXRpb24tZnJhbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShmbikge1xuICAgIHZhciBtZXRob2QgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmLCAxNik7XG4gICAgICAgIH07XG4gICAgcmV0dXJuIG1ldGhvZChmbik7XG59XG5leHBvcnRzLmRlZmF1bHQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0LWFuaW1hdGlvbi1mcmFtZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc2V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9zZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfb2JqZWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW9iamVjdC5qc1wiKTtcbnZhciBpc19zdHJpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtc3RyaW5nLmpzXCIpO1xudmFyIGlzX251bWJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1udW1iZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1udW1iZXIuanNcIik7XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvZGx2L2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gKiBAcGFyYW0gb2JqXG4gKiBAcGFyYW0gcGF0aFxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAob2JqLCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBvID0gb2JqO1xuICAgIHZhciBrZXlBcnIgPSBpc19zdHJpbmdfMS5kZWZhdWx0KHBhdGgpID8gcGF0aC5zcGxpdCgnLicpIDogcGF0aDtcbiAgICBrZXlBcnIuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpZHgpIHtcbiAgICAgICAgLy8g5LiN5piv5pyA5ZCO5LiA5LiqXG4gICAgICAgIGlmIChpZHggPCBrZXlBcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgaWYgKCFpc19vYmplY3RfMS5kZWZhdWx0KG9ba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBvW2tleV0gPSBpc19udW1iZXJfMS5kZWZhdWx0KGtleUFycltpZHggKyAxXSkgPyBbXSA6IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbyA9IG9ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9zaXplLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc2l6ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfbmlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLW5pbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLW5pbC5qc1wiKTtcbnZhciBpc19hcnJheV9saWtlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFycmF5LWxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1hcnJheS1saWtlLmpzXCIpO1xuZnVuY3Rpb24gc2l6ZShvKSB7XG4gICAgaWYgKGlzX25pbF8xLmRlZmF1bHQobykpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChpc19hcnJheV9saWtlXzEuZGVmYXVsdChvKSkge1xuICAgICAgICByZXR1cm4gby5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvKS5sZW5ndGg7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBzaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2l6ZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc29tZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3NvbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiDlj6ropoHmnInkuIDkuKrmu6HotrPmnaHku7blsLHov5Tlm54gdHJ1ZVxuICogQHBhcmFtIGFyclxuICogQHBhcmFtIGZ1bmNcbiAqL1xudmFyIHNvbWUgPSBmdW5jdGlvbiAoYXJyLCBmdW5jKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZ1bmMoYXJyW2ldLCBpKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gc29tZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvbWUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3NvcnQtYnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9zb3J0LWJ5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19hcnJheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LmpzXCIpO1xudmFyIGlzX3N0cmluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1zdHJpbmcuanNcIik7XG52YXIgaXNfZnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1mdW5jdGlvbi5qc1wiKTtcbmZ1bmN0aW9uIHNvcnRCeShhcnIsIGtleSkge1xuICAgIHZhciBjb21wYXJlcjtcbiAgICBpZiAoaXNfZnVuY3Rpb25fMS5kZWZhdWx0KGtleSkpIHtcbiAgICAgICAgY29tcGFyZXIgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4ga2V5KGEpIC0ga2V5KGIpOyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGtleXNfMSA9IFtdO1xuICAgICAgICBpZiAoaXNfc3RyaW5nXzEuZGVmYXVsdChrZXkpKSB7XG4gICAgICAgICAgICBrZXlzXzEucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzX2FycmF5XzEuZGVmYXVsdChrZXkpKSB7XG4gICAgICAgICAgICBrZXlzXzEgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcGFyZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzXzEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IGtleXNfMVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoYVtwcm9wXSA+IGJbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhW3Byb3BdIDwgYltwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFyci5zb3J0KGNvbXBhcmVyKTtcbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gc29ydEJ5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ydC1ieS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc3RhcnRzLXdpdGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc3RhcnRzLXdpdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19hcnJheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LmpzXCIpO1xudmFyIGlzX3N0cmluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1zdHJpbmcuanNcIik7XG5mdW5jdGlvbiBzdGFydHNXaXRoKGFyciwgZSkge1xuICAgIHJldHVybiAoaXNfYXJyYXlfMS5kZWZhdWx0KGFycikgfHwgaXNfc3RyaW5nXzEuZGVmYXVsdChhcnIpKSA/IGFyclswXSA9PT0gZSA6IGZhbHNlO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gc3RhcnRzV2l0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXJ0cy13aXRoLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9zdWJzdGl0dXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvc3Vic3RpdHV0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBzdWJzdGl0dXRlKHN0ciwgbykge1xuICAgIGlmICghc3RyIHx8ICFvKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxcXD9cXHsoW157fV0rKVxcfS9nLCBmdW5jdGlvbiAobWF0Y2gsIG5hbWUpIHtcbiAgICAgICAgaWYgKG1hdGNoLmNoYXJBdCgwKSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2guc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChvW25hbWVdID09PSB1bmRlZmluZWQpID8gJycgOiBvW25hbWVdO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gc3Vic3RpdHV0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnN0aXR1dGUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3Rocm90dGxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3Rocm90dGxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGltZW91dCwgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgICBvcHRpb25zID0ge307XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogRGF0ZS5ub3coKTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dClcbiAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciB0aHJvdHRsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCF0aW1lb3V0KVxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHRocm90dGxlZC5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgcHJldmlvdXMgPSAwO1xuICAgICAgICB0aW1lb3V0ID0gY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIHRocm90dGxlZDtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3R0bGUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3RvLWFycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3RvLWFycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaXNfYXJyYXlfbGlrZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheS1saWtlICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtYXJyYXktbGlrZS5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gaXNfYXJyYXlfbGlrZV8xLmRlZmF1bHQodmFsdWUpID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodmFsdWUpIDogW107XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvLWFycmF5LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90by1kZWdyZWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3RvLWRlZ3JlZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBERUdSRUUgPSAxODAgLyBNYXRoLlBJO1xudmFyIHRvRGVncmVlID0gZnVuY3Rpb24gKHJhZGlhbikge1xuICAgIHJldHVybiBERUdSRUUgKiByYWRpYW47XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9EZWdyZWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10by1kZWdyZWUuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3RvLWludGVnZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90by1pbnRlZ2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlSW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG8taW50ZWdlci5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdG8tcmFkaWFuLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90by1yYWRpYW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUkFESUFOID0gTWF0aC5QSSAvIDE4MDtcbnZhciB0b1JhZGlhbiA9IGZ1bmN0aW9uIChkZWdyZWUpIHtcbiAgICByZXR1cm4gUkFESUFOICogZGVncmVlO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvUmFkaWFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG8tcmFkaWFuLmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi90by1zdHJpbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3RvLXN0cmluZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc19uaWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtbmlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaXMtbmlsLmpzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChpc19uaWxfMS5kZWZhdWx0KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10by1zdHJpbmcuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3VuaW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3VuaW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdW5pcV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91bmlxICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdW5pcS5qc1wiKTtcbnZhciB1bmlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXFfMS5kZWZhdWx0KFtdLmNvbmNhdC5hcHBseShbXSwgc291cmNlcykpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHVuaW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dW5pb24uanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3VuaXEuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi91bmlxLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb250YWluc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb250YWlucyAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2NvbnRhaW5zLmpzXCIpO1xudmFyIGVhY2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2VhY2guanNcIik7XG52YXIgdW5pcSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICB2YXIgcmVzdWx0QXJyID0gW107XG4gICAgZWFjaF8xLmRlZmF1bHQoYXJyLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoIWNvbnRhaW5zXzEuZGVmYXVsdChyZXN1bHRBcnIsIGl0ZW0pKSB7XG4gICAgICAgICAgICByZXN1bHRBcnIucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRBcnI7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdW5pcTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVuaXEuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3VuaXF1ZS1pZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdW5pcXVlLWlkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1hcCA9IHt9O1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBwcmVmaXggPSBwcmVmaXggfHwgJ2cnO1xuICAgIGlmICghbWFwW3ByZWZpeF0pIHtcbiAgICAgICAgbWFwW3ByZWZpeF0gPSAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWFwW3ByZWZpeF0gKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHByZWZpeCArIG1hcFtwcmVmaXhdO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmlxdWUtaWQuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3VwcGVyLWNhc2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi91cHBlci1jYXNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0b19zdHJpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdG8tc3RyaW5nLmpzXCIpO1xudmFyIHVwcGVyQ2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gdG9fc3RyaW5nXzEuZGVmYXVsdChzdHIpLnRvVXBwZXJDYXNlKCk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdXBwZXJDYXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBwZXItY2FzZS5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdXBwZXItZmlyc3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdXBwZXItZmlyc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0b19zdHJpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdG8tc3RyaW5nLmpzXCIpO1xudmFyIHVwcGVyRmlyc3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgc3RyID0gdG9fc3RyaW5nXzEuZGVmYXVsdCh2YWx1ZSk7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdXBwZXJGaXJzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVwcGVyLWZpcnN0LmpzLm1hcFxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi92YWx1ZXMtb2Yta2V5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdmFsdWVzLW9mLWtleS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZWFjaF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvZWFjaC5qc1wiKTtcbnZhciBpc19hcnJheV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2lzLWFycmF5LmpzXCIpO1xudmFyIGlzX25pbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pcy1uaWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1uaWwuanNcIik7XG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGRhdGEsIG5hbWUpIHtcbiAgICB2YXIgcnN0ID0gW107XG4gICAgdmFyIHRtcE1hcCA9IHt9O1xuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtuYW1lXTtcbiAgICAgICAgaWYgKCFpc19uaWxfMS5kZWZhdWx0KHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gZmxhdHRlblxuICAgICAgICAgICAgaWYgKCFpc19hcnJheV8xLmRlZmF1bHQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWFjaF8xLmRlZmF1bHQodmFsdWUsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAvLyB1bmlxdWVcbiAgICAgICAgICAgICAgICBpZiAoIXRtcE1hcFt2YWxdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJzdC5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHRtcE1hcFt2YWxdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByc3Q7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbHVlcy1vZi1rZXkuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3ZhbHVlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvdmFsdWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVhY2hfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2VhY2guanNcIik7XG52YXIgaXNfZnVuY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXMtZnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pcy1mdW5jdGlvbi5qc1wiKTtcbi8vIEB0cy1pZ25vcmVcbnZhciB2YWx1ZXMgPSBPYmplY3QudmFsdWVzID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gT2JqZWN0LnZhbHVlcyhvYmopOyB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBlYWNoXzEuZGVmYXVsdChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmICghKGlzX2Z1bmN0aW9uXzEuZGVmYXVsdChvYmopICYmIGtleSA9PT0gJ3Byb3RvdHlwZScpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZhbHVlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbHVlcy5qcy5tYXBcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvd3JhcC1iZWhhdmlvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL3dyYXAtYmVoYXZpb3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiDlsIHoo4Xkuovku7bvvIzkvr/kuo7kvb/nlKjkuIrkuIvmlod0aGlzLOWSjOS+v+S6juino+mZpOS6i+S7tuaXtuS9v+eUqFxuICogQHByb3RlY3RlZFxuICogQHBhcmFtICB7T2JqZWN0fSBvYmogICDlr7nosaFcbiAqIEBwYXJhbSAge1N0cmluZ30gYWN0aW9uIOS6i+S7tuWQjeensFxuICogQHJldHVybiB7RnVuY3Rpb259ICAgICAgICDov5Tlm57kuovku7blpITnkIblh73mlbBcbiAqL1xuZnVuY3Rpb24gd3JhcEJlaGF2aW9yKG9iaiwgYWN0aW9uKSB7XG4gICAgaWYgKG9ialsnX3dyYXBfJyArIGFjdGlvbl0pIHtcbiAgICAgICAgcmV0dXJuIG9ialsnX3dyYXBfJyArIGFjdGlvbl07XG4gICAgfVxuICAgIHZhciBtZXRob2QgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBvYmpbYWN0aW9uXShlKTtcbiAgICB9O1xuICAgIG9ialsnX3dyYXBfJyArIGFjdGlvbl0gPSBtZXRob2Q7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHdyYXBCZWhhdmlvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyYXAtYmVoYXZpb3IuanMubWFwXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19hYnMtc3ZnLXBhdGhAMC4xLjFAYWJzLXN2Zy1wYXRoL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19hYnMtc3ZnLXBhdGhAMC4xLjFAYWJzLXN2Zy1wYXRoL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBhYnNvbHV0aXplXG5cbi8qKlxuICogcmVkZWZpbmUgYHBhdGhgIHdpdGggYWJzb2x1dGUgY29vcmRpbmF0ZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5mdW5jdGlvbiBhYnNvbHV0aXplKHBhdGgpe1xuXHR2YXIgc3RhcnRYID0gMFxuXHR2YXIgc3RhcnRZID0gMFxuXHR2YXIgeCA9IDBcblx0dmFyIHkgPSAwXG5cblx0cmV0dXJuIHBhdGgubWFwKGZ1bmN0aW9uKHNlZyl7XG5cdFx0c2VnID0gc2VnLnNsaWNlKClcblx0XHR2YXIgdHlwZSA9IHNlZ1swXVxuXHRcdHZhciBjb21tYW5kID0gdHlwZS50b1VwcGVyQ2FzZSgpXG5cblx0XHQvLyBpcyByZWxhdGl2ZVxuXHRcdGlmICh0eXBlICE9IGNvbW1hbmQpIHtcblx0XHRcdHNlZ1swXSA9IGNvbW1hbmRcblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRjYXNlICdhJzpcblx0XHRcdFx0XHRzZWdbNl0gKz0geFxuXHRcdFx0XHRcdHNlZ1s3XSArPSB5XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Y2FzZSAndic6XG5cdFx0XHRcdFx0c2VnWzFdICs9IHlcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRjYXNlICdoJzpcblx0XHRcdFx0XHRzZWdbMV0gKz0geFxuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBzZWcubGVuZ3RoOykge1xuXHRcdFx0XHRcdFx0c2VnW2krK10gKz0geFxuXHRcdFx0XHRcdFx0c2VnW2krK10gKz0geVxuXHRcdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgY3Vyc29yIHN0YXRlXG5cdFx0c3dpdGNoIChjb21tYW5kKSB7XG5cdFx0XHRjYXNlICdaJzpcblx0XHRcdFx0eCA9IHN0YXJ0WFxuXHRcdFx0XHR5ID0gc3RhcnRZXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlICdIJzpcblx0XHRcdFx0eCA9IHNlZ1sxXVxuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAnVic6XG5cdFx0XHRcdHkgPSBzZWdbMV1cblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgJ00nOlxuXHRcdFx0XHR4ID0gc3RhcnRYID0gc2VnWzFdXG5cdFx0XHRcdHkgPSBzdGFydFkgPSBzZWdbMl1cblx0XHRcdFx0YnJlYWtcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHggPSBzZWdbc2VnLmxlbmd0aCAtIDJdXG5cdFx0XHRcdHkgPSBzZWdbc2VnLmxlbmd0aCAtIDFdXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ1xuXHR9KVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1hcnJheUAxLjIuNEBkMy1hcnJheS9kaXN0L2QzLWFycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kMy1hcnJheUAxLjIuNEBkMy1hcnJheS9kaXN0L2QzLWFycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtYXJyYXkvIHYxLjIuNCBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgIHRydWUgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiaXNlY3Rvcihjb21wYXJlKSB7XG4gICAgICAgIGlmIChjb21wYXJlLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIGNvbXBhcmUgPSBhc2NlbmRpbmdDb21wYXJhdG9yKGNvbXBhcmUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogZnVuY3Rpb24gKGEsIHgsIGxvLCBoaSkge1xuICAgICAgICAgICAgICAgIGlmIChsbyA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBsbyA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKGhpID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGhpID0gYS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBoaSA9IG1pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJpZ2h0OiBmdW5jdGlvbiAoYSwgeCwgbG8sIGhpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGxvID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoaGkgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgaGkgPSBhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBoaSA9IG1pZDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzY2VuZGluZ0NvbXBhcmF0b3IoZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQsIHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhc2NlbmRpbmcoZihkKSwgeCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBhc2NlbmRpbmdCaXNlY3QgPSBiaXNlY3Rvcihhc2NlbmRpbmcpO1xuICAgIHZhciBiaXNlY3RSaWdodCA9IGFzY2VuZGluZ0Jpc2VjdC5yaWdodDtcbiAgICB2YXIgYmlzZWN0TGVmdCA9IGFzY2VuZGluZ0Jpc2VjdC5sZWZ0O1xuICAgIGZ1bmN0aW9uIHBhaXJzKGFycmF5LCBmKSB7XG4gICAgICAgIGlmIChmID09IG51bGwpXG4gICAgICAgICAgICBmID0gcGFpcjtcbiAgICAgICAgdmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoIC0gMSwgcCA9IGFycmF5WzBdLCBwYWlycyA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgICAgICAgd2hpbGUgKGkgPCBuKVxuICAgICAgICAgICAgcGFpcnNbaV0gPSBmKHAsIHAgPSBhcnJheVsrK2ldKTtcbiAgICAgICAgcmV0dXJuIHBhaXJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYWlyKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIFthLCBiXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3Jvc3ModmFsdWVzMCwgdmFsdWVzMSwgcmVkdWNlKSB7XG4gICAgICAgIHZhciBuMCA9IHZhbHVlczAubGVuZ3RoLCBuMSA9IHZhbHVlczEubGVuZ3RoLCB2YWx1ZXMgPSBuZXcgQXJyYXkobjAgKiBuMSksIGkwLCBpMSwgaSwgdmFsdWUwO1xuICAgICAgICBpZiAocmVkdWNlID09IG51bGwpXG4gICAgICAgICAgICByZWR1Y2UgPSBwYWlyO1xuICAgICAgICBmb3IgKGkwID0gaSA9IDA7IGkwIDwgbjA7ICsraTApIHtcbiAgICAgICAgICAgIGZvciAodmFsdWUwID0gdmFsdWVzMFtpMF0sIGkxID0gMDsgaTEgPCBuMTsgKytpMSwgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2ldID0gcmVkdWNlKHZhbHVlMCwgdmFsdWVzMVtpMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NlbmRpbmcoYSwgYikge1xuICAgICAgICByZXR1cm4gYiA8IGEgPyAtMSA6IGIgPiBhID8gMSA6IGIgPj0gYSA/IDAgOiBOYU47XG4gICAgfVxuICAgIGZ1bmN0aW9uIG51bWJlcih4KSB7XG4gICAgICAgIHJldHVybiB4ID09PSBudWxsID8gTmFOIDogK3g7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhcmlhbmNlKHZhbHVlcywgdmFsdWVvZikge1xuICAgICAgICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsIG0gPSAwLCBpID0gLTEsIG1lYW4gPSAwLCB2YWx1ZSwgZGVsdGEsIHN1bSA9IDA7XG4gICAgICAgIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZXNbaV0pKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IHZhbHVlIC0gbWVhbjtcbiAgICAgICAgICAgICAgICAgICAgbWVhbiArPSBkZWx0YSAvICsrbTtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGRlbHRhICogKHZhbHVlIC0gbWVhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSB2YWx1ZSAtIG1lYW47XG4gICAgICAgICAgICAgICAgICAgIG1lYW4gKz0gZGVsdGEgLyArK207XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBkZWx0YSAqICh2YWx1ZSAtIG1lYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobSA+IDEpXG4gICAgICAgICAgICByZXR1cm4gc3VtIC8gKG0gLSAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGV2aWF0aW9uKGFycmF5LCBmKSB7XG4gICAgICAgIHZhciB2ID0gdmFyaWFuY2UoYXJyYXksIGYpO1xuICAgICAgICByZXR1cm4gdiA/IE1hdGguc3FydCh2KSA6IHY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGV4dGVudCh2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgICAgICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLCBpID0gLTEsIHZhbHVlLCBtaW4sIG1heDtcbiAgICAgICAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW4gPiB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heCA8IHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA+IHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4IDwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbWluLCBtYXhdO1xuICAgIH1cbiAgICB2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGU7XG4gICAgdmFyIHNsaWNlID0gYXJyYXkuc2xpY2U7XG4gICAgdmFyIG1hcCA9IGFycmF5Lm1hcDtcbiAgICBmdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICAgICAgc3RhcnQgPSArc3RhcnQsIHN0b3AgPSArc3RvcCwgc3RlcCA9IChuID0gYXJndW1lbnRzLmxlbmd0aCkgPCAyID8gKHN0b3AgPSBzdGFydCwgc3RhcnQgPSAwLCAxKSA6IG4gPCAzID8gMSA6ICtzdGVwO1xuICAgICAgICB2YXIgaSA9IC0xLCBuID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCkpIHwgMCwgcmFuZ2UgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICByYW5nZVtpXSA9IHN0YXJ0ICsgaSAqIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICB2YXIgZTEwID0gTWF0aC5zcXJ0KDUwKSwgZTUgPSBNYXRoLnNxcnQoMTApLCBlMiA9IE1hdGguc3FydCgyKTtcbiAgICBmdW5jdGlvbiB0aWNrcyhzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgICAgICAgdmFyIHJldmVyc2UsIGkgPSAtMSwgbiwgdGlja3MsIHN0ZXA7XG4gICAgICAgIHN0b3AgPSArc3RvcCwgc3RhcnQgPSArc3RhcnQsIGNvdW50ID0gK2NvdW50O1xuICAgICAgICBpZiAoc3RhcnQgPT09IHN0b3AgJiYgY291bnQgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIFtzdGFydF07XG4gICAgICAgIGlmIChyZXZlcnNlID0gc3RvcCA8IHN0YXJ0KVxuICAgICAgICAgICAgbiA9IHN0YXJ0LCBzdGFydCA9IHN0b3AsIHN0b3AgPSBuO1xuICAgICAgICBpZiAoKHN0ZXAgPSB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkpID09PSAwIHx8ICFpc0Zpbml0ZShzdGVwKSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGguY2VpbChzdGFydCAvIHN0ZXApO1xuICAgICAgICAgICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAvIHN0ZXApO1xuICAgICAgICAgICAgdGlja3MgPSBuZXcgQXJyYXkobiA9IE1hdGguY2VpbChzdG9wIC0gc3RhcnQgKyAxKSk7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICB0aWNrc1tpXSA9IChzdGFydCArIGkpICogc3RlcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCAqIHN0ZXApO1xuICAgICAgICAgICAgc3RvcCA9IE1hdGguY2VpbChzdG9wICogc3RlcCk7XG4gICAgICAgICAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gTWF0aC5jZWlsKHN0YXJ0IC0gc3RvcCArIDEpKTtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHRpY2tzW2ldID0gKHN0YXJ0IC0gaSkgLyBzdGVwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXZlcnNlKVxuICAgICAgICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gICAgICAgIHZhciBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksIHBvd2VyID0gTWF0aC5mbG9vcihNYXRoLmxvZyhzdGVwKSAvIE1hdGguTE4xMCksIGVycm9yID0gc3RlcCAvIE1hdGgucG93KDEwLCBwb3dlcik7XG4gICAgICAgIHJldHVybiBwb3dlciA+PSAwXG4gICAgICAgICAgICA/IChlcnJvciA+PSBlMTAgPyAxMCA6IGVycm9yID49IGU1ID8gNSA6IGVycm9yID49IGUyID8gMiA6IDEpICogTWF0aC5wb3coMTAsIHBvd2VyKVxuICAgICAgICAgICAgOiAtTWF0aC5wb3coMTAsIC1wb3dlcikgLyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gICAgICAgIHZhciBzdGVwMCA9IE1hdGguYWJzKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksIHN0ZXAxID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IoTWF0aC5sb2coc3RlcDApIC8gTWF0aC5MTjEwKSksIGVycm9yID0gc3RlcDAgLyBzdGVwMTtcbiAgICAgICAgaWYgKGVycm9yID49IGUxMClcbiAgICAgICAgICAgIHN0ZXAxICo9IDEwO1xuICAgICAgICBlbHNlIGlmIChlcnJvciA+PSBlNSlcbiAgICAgICAgICAgIHN0ZXAxICo9IDU7XG4gICAgICAgIGVsc2UgaWYgKGVycm9yID49IGUyKVxuICAgICAgICAgICAgc3RlcDEgKj0gMjtcbiAgICAgICAgcmV0dXJuIHN0b3AgPCBzdGFydCA/IC1zdGVwMSA6IHN0ZXAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHVyZ2VzKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKE1hdGgubG9nKHZhbHVlcy5sZW5ndGgpIC8gTWF0aC5MTjIpICsgMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGlzdG9ncmFtKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpZGVudGl0eSwgZG9tYWluID0gZXh0ZW50LCB0aHJlc2hvbGQgPSBzdHVyZ2VzO1xuICAgICAgICBmdW5jdGlvbiBoaXN0b2dyYW0oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGksIG4gPSBkYXRhLmxlbmd0aCwgeCwgdmFsdWVzID0gbmV3IEFycmF5KG4pO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhbHVlc1tpXSA9IHZhbHVlKGRhdGFbaV0sIGksIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHh6ID0gZG9tYWluKHZhbHVlcyksIHgwID0geHpbMF0sIHgxID0geHpbMV0sIHR6ID0gdGhyZXNob2xkKHZhbHVlcywgeDAsIHgxKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgbnVtYmVyIG9mIHRocmVzaG9sZHMgaW50byB1bmlmb3JtIHRocmVzaG9sZHMuXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodHopKSB7XG4gICAgICAgICAgICAgICAgdHogPSB0aWNrU3RlcCh4MCwgeDEsIHR6KTtcbiAgICAgICAgICAgICAgICB0eiA9IHJhbmdlKE1hdGguY2VpbCh4MCAvIHR6KSAqIHR6LCB4MSwgdHopOyAvLyBleGNsdXNpdmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgdGhyZXNob2xkcyBvdXRzaWRlIHRoZSBkb21haW4uXG4gICAgICAgICAgICB2YXIgbSA9IHR6Lmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICh0elswXSA8PSB4MClcbiAgICAgICAgICAgICAgICB0ei5zaGlmdCgpLCAtLW07XG4gICAgICAgICAgICB3aGlsZSAodHpbbSAtIDFdID4geDEpXG4gICAgICAgICAgICAgICAgdHoucG9wKCksIC0tbTtcbiAgICAgICAgICAgIHZhciBiaW5zID0gbmV3IEFycmF5KG0gKyAxKSwgYmluO1xuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBiaW5zLlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBtOyArK2kpIHtcbiAgICAgICAgICAgICAgICBiaW4gPSBiaW5zW2ldID0gW107XG4gICAgICAgICAgICAgICAgYmluLngwID0gaSA+IDAgPyB0eltpIC0gMV0gOiB4MDtcbiAgICAgICAgICAgICAgICBiaW4ueDEgPSBpIDwgbSA/IHR6W2ldIDogeDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBc3NpZ24gZGF0YSB0byBiaW5zIGJ5IHZhbHVlLCBpZ25vcmluZyBhbnkgb3V0c2lkZSB0aGUgZG9tYWluLlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHggPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHgwIDw9IHggJiYgeCA8PSB4MSkge1xuICAgICAgICAgICAgICAgICAgICBiaW5zW2Jpc2VjdFJpZ2h0KHR6LCB4LCAwLCBtKV0ucHVzaChkYXRhW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmlucztcbiAgICAgICAgfVxuICAgICAgICBoaXN0b2dyYW0udmFsdWUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmFsdWUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBoaXN0b2dyYW0pIDogdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIGhpc3RvZ3JhbS5kb21haW4gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbX1swXSwgX1sxXV0pLCBoaXN0b2dyYW0pIDogZG9tYWluO1xuICAgICAgICB9O1xuICAgICAgICBoaXN0b2dyYW0udGhyZXNob2xkcyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aHJlc2hvbGQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IEFycmF5LmlzQXJyYXkoXykgPyBjb25zdGFudChzbGljZS5jYWxsKF8pKSA6IGNvbnN0YW50KF8pLCBoaXN0b2dyYW0pIDogdGhyZXNob2xkO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaGlzdG9ncmFtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBxdWFudGlsZSh2YWx1ZXMsIHAsIHZhbHVlb2YpIHtcbiAgICAgICAgaWYgKHZhbHVlb2YgPT0gbnVsbClcbiAgICAgICAgICAgIHZhbHVlb2YgPSBudW1iZXI7XG4gICAgICAgIGlmICghKG4gPSB2YWx1ZXMubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKChwID0gK3ApIDw9IDAgfHwgbiA8IDIpXG4gICAgICAgICAgICByZXR1cm4gK3ZhbHVlb2YodmFsdWVzWzBdLCAwLCB2YWx1ZXMpO1xuICAgICAgICBpZiAocCA+PSAxKVxuICAgICAgICAgICAgcmV0dXJuICt2YWx1ZW9mKHZhbHVlc1tuIC0gMV0sIG4gLSAxLCB2YWx1ZXMpO1xuICAgICAgICB2YXIgbiwgaSA9IChuIC0gMSkgKiBwLCBpMCA9IE1hdGguZmxvb3IoaSksIHZhbHVlMCA9ICt2YWx1ZW9mKHZhbHVlc1tpMF0sIGkwLCB2YWx1ZXMpLCB2YWx1ZTEgPSArdmFsdWVvZih2YWx1ZXNbaTAgKyAxXSwgaTAgKyAxLCB2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gdmFsdWUwICsgKHZhbHVlMSAtIHZhbHVlMCkgKiAoaSAtIGkwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnJlZWRtYW5EaWFjb25pcyh2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhbHVlcyA9IG1hcC5jYWxsKHZhbHVlcywgbnVtYmVyKS5zb3J0KGFzY2VuZGluZyk7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoMiAqIChxdWFudGlsZSh2YWx1ZXMsIDAuNzUpIC0gcXVhbnRpbGUodmFsdWVzLCAwLjI1KSkgKiBNYXRoLnBvdyh2YWx1ZXMubGVuZ3RoLCAtMSAvIDMpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjb3R0KHZhbHVlcywgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCgobWF4IC0gbWluKSAvICgzLjUgKiBkZXZpYXRpb24odmFsdWVzKSAqIE1hdGgucG93KHZhbHVlcy5sZW5ndGgsIC0xIC8gMykpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWF4KHZhbHVlcywgdmFsdWVvZikge1xuICAgICAgICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsIGkgPSAtMSwgdmFsdWUsIG1heDtcbiAgICAgICAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZWFuKHZhbHVlcywgdmFsdWVvZikge1xuICAgICAgICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsIG0gPSBuLCBpID0gLTEsIHZhbHVlLCBzdW0gPSAwO1xuICAgICAgICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpXG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIC0tbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKVxuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAtLW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0pXG4gICAgICAgICAgICByZXR1cm4gc3VtIC8gbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVkaWFuKHZhbHVlcywgdmFsdWVvZikge1xuICAgICAgICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsIGkgPSAtMSwgdmFsdWUsIG51bWJlcnMgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlc1tpXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVycy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1YW50aWxlKG51bWJlcnMuc29ydChhc2NlbmRpbmcpLCAwLjUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZShhcnJheXMpIHtcbiAgICAgICAgdmFyIG4gPSBhcnJheXMubGVuZ3RoLCBtLCBpID0gLTEsIGogPSAwLCBtZXJnZWQsIGFycmF5O1xuICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgIGogKz0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgICAgICAgbWVyZ2VkID0gbmV3IEFycmF5KGopO1xuICAgICAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgICAgICAgIGFycmF5ID0gYXJyYXlzW25dO1xuICAgICAgICAgICAgbSA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgtLW0gPj0gMCkge1xuICAgICAgICAgICAgICAgIG1lcmdlZFstLWpdID0gYXJyYXlbbV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWluKHZhbHVlcywgdmFsdWVvZikge1xuICAgICAgICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsIGkgPSAtMSwgdmFsdWUsIG1pbjtcbiAgICAgICAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiBtaW4gPiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgbWluID4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJtdXRlKGFycmF5LCBpbmRleGVzKSB7XG4gICAgICAgIHZhciBpID0gaW5kZXhlcy5sZW5ndGgsIHBlcm11dGVzID0gbmV3IEFycmF5KGkpO1xuICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgcGVybXV0ZXNbaV0gPSBhcnJheVtpbmRleGVzW2ldXTtcbiAgICAgICAgcmV0dXJuIHBlcm11dGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FuKHZhbHVlcywgY29tcGFyZSkge1xuICAgICAgICBpZiAoIShuID0gdmFsdWVzLmxlbmd0aCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBuLCBpID0gMCwgaiA9IDAsIHhpLCB4aiA9IHZhbHVlc1tqXTtcbiAgICAgICAgaWYgKGNvbXBhcmUgPT0gbnVsbClcbiAgICAgICAgICAgIGNvbXBhcmUgPSBhc2NlbmRpbmc7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBpZiAoY29tcGFyZSh4aSA9IHZhbHVlc1tpXSwgeGopIDwgMCB8fCBjb21wYXJlKHhqLCB4aikgIT09IDApIHtcbiAgICAgICAgICAgICAgICB4aiA9IHhpLCBqID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGFyZSh4aiwgeGopID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGo7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNodWZmbGUoYXJyYXksIGkwLCBpMSkge1xuICAgICAgICB2YXIgbSA9IChpMSA9PSBudWxsID8gYXJyYXkubGVuZ3RoIDogaTEpIC0gKGkwID0gaTAgPT0gbnVsbCA/IDAgOiAraTApLCB0LCBpO1xuICAgICAgICB3aGlsZSAobSkge1xuICAgICAgICAgICAgaSA9IE1hdGgucmFuZG9tKCkgKiBtLS0gfCAwO1xuICAgICAgICAgICAgdCA9IGFycmF5W20gKyBpMF07XG4gICAgICAgICAgICBhcnJheVttICsgaTBdID0gYXJyYXlbaSArIGkwXTtcbiAgICAgICAgICAgIGFycmF5W2kgKyBpMF0gPSB0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3VtKHZhbHVlcywgdmFsdWVvZikge1xuICAgICAgICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsIGkgPSAtMSwgdmFsdWUsIHN1bSA9IDA7XG4gICAgICAgIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID0gK3ZhbHVlc1tpXSlcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IHZhbHVlOyAvLyBOb3RlOiB6ZXJvIGFuZCBudWxsIGFyZSBlcXVpdmFsZW50LlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPSArdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpXG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc3Bvc2UobWF0cml4KSB7XG4gICAgICAgIGlmICghKG4gPSBtYXRyaXgubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IC0xLCBtID0gbWluKG1hdHJpeCwgbGVuZ3RoKSwgdHJhbnNwb3NlID0gbmV3IEFycmF5KG0pOyArK2kgPCBtOykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IC0xLCBuLCByb3cgPSB0cmFuc3Bvc2VbaV0gPSBuZXcgQXJyYXkobik7ICsraiA8IG47KSB7XG4gICAgICAgICAgICAgICAgcm93W2pdID0gbWF0cml4W2pdW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc3Bvc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxlbmd0aChkKSB7XG4gICAgICAgIHJldHVybiBkLmxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gemlwKCkge1xuICAgICAgICByZXR1cm4gdHJhbnNwb3NlKGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGV4cG9ydHMuYmlzZWN0ID0gYmlzZWN0UmlnaHQ7XG4gICAgZXhwb3J0cy5iaXNlY3RSaWdodCA9IGJpc2VjdFJpZ2h0O1xuICAgIGV4cG9ydHMuYmlzZWN0TGVmdCA9IGJpc2VjdExlZnQ7XG4gICAgZXhwb3J0cy5hc2NlbmRpbmcgPSBhc2NlbmRpbmc7XG4gICAgZXhwb3J0cy5iaXNlY3RvciA9IGJpc2VjdG9yO1xuICAgIGV4cG9ydHMuY3Jvc3MgPSBjcm9zcztcbiAgICBleHBvcnRzLmRlc2NlbmRpbmcgPSBkZXNjZW5kaW5nO1xuICAgIGV4cG9ydHMuZGV2aWF0aW9uID0gZGV2aWF0aW9uO1xuICAgIGV4cG9ydHMuZXh0ZW50ID0gZXh0ZW50O1xuICAgIGV4cG9ydHMuaGlzdG9ncmFtID0gaGlzdG9ncmFtO1xuICAgIGV4cG9ydHMudGhyZXNob2xkRnJlZWRtYW5EaWFjb25pcyA9IGZyZWVkbWFuRGlhY29uaXM7XG4gICAgZXhwb3J0cy50aHJlc2hvbGRTY290dCA9IHNjb3R0O1xuICAgIGV4cG9ydHMudGhyZXNob2xkU3R1cmdlcyA9IHN0dXJnZXM7XG4gICAgZXhwb3J0cy5tYXggPSBtYXg7XG4gICAgZXhwb3J0cy5tZWFuID0gbWVhbjtcbiAgICBleHBvcnRzLm1lZGlhbiA9IG1lZGlhbjtcbiAgICBleHBvcnRzLm1lcmdlID0gbWVyZ2U7XG4gICAgZXhwb3J0cy5taW4gPSBtaW47XG4gICAgZXhwb3J0cy5wYWlycyA9IHBhaXJzO1xuICAgIGV4cG9ydHMucGVybXV0ZSA9IHBlcm11dGU7XG4gICAgZXhwb3J0cy5xdWFudGlsZSA9IHF1YW50aWxlO1xuICAgIGV4cG9ydHMucmFuZ2UgPSByYW5nZTtcbiAgICBleHBvcnRzLnNjYW4gPSBzY2FuO1xuICAgIGV4cG9ydHMuc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgZXhwb3J0cy5zdW0gPSBzdW07XG4gICAgZXhwb3J0cy50aWNrcyA9IHRpY2tzO1xuICAgIGV4cG9ydHMudGlja0luY3JlbWVudCA9IHRpY2tJbmNyZW1lbnQ7XG4gICAgZXhwb3J0cy50aWNrU3RlcCA9IHRpY2tTdGVwO1xuICAgIGV4cG9ydHMudHJhbnNwb3NlID0gdHJhbnNwb3NlO1xuICAgIGV4cG9ydHMudmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICBleHBvcnRzLnppcCA9IHppcDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufSkpKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtY29sbGVjdGlvbkAxLjAuN0BkMy1jb2xsZWN0aW9uL2Rpc3QvZDMtY29sbGVjdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZDMtY29sbGVjdGlvbkAxLjAuN0BkMy1jb2xsZWN0aW9uL2Rpc3QvZDMtY29sbGVjdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBodHRwczovL2QzanMub3JnL2QzLWNvbGxlY3Rpb24vIHYxLjAuNyBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgIHRydWUgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIHByZWZpeCA9IFwiJFwiO1xuICAgIGZ1bmN0aW9uIE1hcCgpIHsgfVxuICAgIE1hcC5wcm90b3R5cGUgPSBtYXAucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogTWFwLFxuICAgICAgICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiAocHJlZml4ICsga2V5KSBpbiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3ByZWZpeCArIGtleV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbcHJlZml4ICsga2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJlZml4ICsga2V5O1xuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgZGVsZXRlIHRoaXNbcHJvcGVydHldO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcylcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeClcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbcHJvcGVydHldO1xuICAgICAgICB9LFxuICAgICAgICBrZXlzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcylcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeClcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHByb3BlcnR5LnNsaWNlKDEpKTtcbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHRoaXNbcHJvcGVydHldKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudHJpZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKVxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KVxuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLnB1c2goeyBrZXk6IHByb3BlcnR5LnNsaWNlKDEpLCB2YWx1ZTogdGhpc1twcm9wZXJ0eV0gfSk7XG4gICAgICAgICAgICByZXR1cm4gZW50cmllcztcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcylcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeClcbiAgICAgICAgICAgICAgICAgICAgKytzaXplO1xuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH0sXG4gICAgICAgIGVtcHR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKVxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZWFjaDogZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgIGYodGhpc1twcm9wZXJ0eV0sIHByb3BlcnR5LnNsaWNlKDEpLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gbWFwKG9iamVjdCwgZikge1xuICAgICAgICB2YXIgbWFwID0gbmV3IE1hcDtcbiAgICAgICAgLy8gQ29weSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgICAgIG9iamVjdC5lYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7IG1hcC5zZXQoa2V5LCB2YWx1ZSk7IH0pO1xuICAgICAgICAvLyBJbmRleCBhcnJheSBieSBudW1lcmljIGluZGV4IG9yIHNwZWNpZmllZCBrZXkgZnVuY3Rpb24uXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICAgICAgdmFyIGkgPSAtMSwgbiA9IG9iamVjdC5sZW5ndGgsIG87XG4gICAgICAgICAgICBpZiAoZiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgICAgICBtYXAuc2V0KGksIG9iamVjdFtpXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgICAgIG1hcC5zZXQoZihvID0gb2JqZWN0W2ldLCBpLCBvYmplY3QpLCBvKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0IG9iamVjdCB0byBtYXAuXG4gICAgICAgIGVsc2UgaWYgKG9iamVjdClcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpXG4gICAgICAgICAgICAgICAgbWFwLnNldChrZXksIG9iamVjdFtrZXldKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbmVzdCgpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXSwgc29ydEtleXMgPSBbXSwgc29ydFZhbHVlcywgcm9sbHVwLCBuZXN0O1xuICAgICAgICBmdW5jdGlvbiBhcHBseShhcnJheSwgZGVwdGgsIGNyZWF0ZVJlc3VsdCwgc2V0UmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVwdGggPj0ga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydFZhbHVlcyAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBhcnJheS5zb3J0KHNvcnRWYWx1ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByb2xsdXAgIT0gbnVsbCA/IHJvbGx1cChhcnJheSkgOiBhcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpID0gLTEsIG4gPSBhcnJheS5sZW5ndGgsIGtleSA9IGtleXNbZGVwdGgrK10sIGtleVZhbHVlLCB2YWx1ZSwgdmFsdWVzQnlLZXkgPSBtYXAoKSwgdmFsdWVzLCByZXN1bHQgPSBjcmVhdGVSZXN1bHQoKTtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcyA9IHZhbHVlc0J5S2V5LmdldChrZXlWYWx1ZSA9IGtleSh2YWx1ZSA9IGFycmF5W2ldKSArIFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc0J5S2V5LnNldChrZXlWYWx1ZSwgW3ZhbHVlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWVzQnlLZXkuZWFjaChmdW5jdGlvbiAodmFsdWVzLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBzZXRSZXN1bHQocmVzdWx0LCBrZXksIGFwcGx5KHZhbHVlcywgZGVwdGgsIGNyZWF0ZVJlc3VsdCwgc2V0UmVzdWx0KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZW50cmllcyhtYXAkJDEsIGRlcHRoKSB7XG4gICAgICAgICAgICBpZiAoKytkZXB0aCA+IGtleXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXAkJDE7XG4gICAgICAgICAgICB2YXIgYXJyYXksIHNvcnRLZXkgPSBzb3J0S2V5c1tkZXB0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHJvbGx1cCAhPSBudWxsICYmIGRlcHRoID49IGtleXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGFycmF5ID0gbWFwJCQxLmVudHJpZXMoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhcnJheSA9IFtdLCBtYXAkJDEuZWFjaChmdW5jdGlvbiAodiwgaykgeyBhcnJheS5wdXNoKHsga2V5OiBrLCB2YWx1ZXM6IGVudHJpZXModiwgZGVwdGgpIH0pOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBzb3J0S2V5ICE9IG51bGwgPyBhcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBzb3J0S2V5KGEua2V5LCBiLmtleSk7IH0pIDogYXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lc3QgPSB7XG4gICAgICAgICAgICBvYmplY3Q6IGZ1bmN0aW9uIChhcnJheSkgeyByZXR1cm4gYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU9iamVjdCwgc2V0T2JqZWN0KTsgfSxcbiAgICAgICAgICAgIG1hcDogZnVuY3Rpb24gKGFycmF5KSB7IHJldHVybiBhcHBseShhcnJheSwgMCwgY3JlYXRlTWFwLCBzZXRNYXApOyB9LFxuICAgICAgICAgICAgZW50cmllczogZnVuY3Rpb24gKGFycmF5KSB7IHJldHVybiBlbnRyaWVzKGFwcGx5KGFycmF5LCAwLCBjcmVhdGVNYXAsIHNldE1hcCksIDApOyB9LFxuICAgICAgICAgICAga2V5OiBmdW5jdGlvbiAoZCkgeyBrZXlzLnB1c2goZCk7IHJldHVybiBuZXN0OyB9LFxuICAgICAgICAgICAgc29ydEtleXM6IGZ1bmN0aW9uIChvcmRlcikgeyBzb3J0S2V5c1trZXlzLmxlbmd0aCAtIDFdID0gb3JkZXI7IHJldHVybiBuZXN0OyB9LFxuICAgICAgICAgICAgc29ydFZhbHVlczogZnVuY3Rpb24gKG9yZGVyKSB7IHNvcnRWYWx1ZXMgPSBvcmRlcjsgcmV0dXJuIG5lc3Q7IH0sXG4gICAgICAgICAgICByb2xsdXA6IGZ1bmN0aW9uIChmKSB7IHJvbGx1cCA9IGY7IHJldHVybiBuZXN0OyB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRPYmplY3Qob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZU1hcCgpIHtcbiAgICAgICAgcmV0dXJuIG1hcCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRNYXAobWFwJCQxLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIG1hcCQkMS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNldCgpIHsgfVxuICAgIHZhciBwcm90byA9IG1hcC5wcm90b3R5cGU7XG4gICAgU2V0LnByb3RvdHlwZSA9IHNldC5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBTZXQsXG4gICAgICAgIGhhczogcHJvdG8uaGFzLFxuICAgICAgICBhZGQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgKz0gXCJcIjtcbiAgICAgICAgICAgIHRoaXNbcHJlZml4ICsgdmFsdWVdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBwcm90by5yZW1vdmUsXG4gICAgICAgIGNsZWFyOiBwcm90by5jbGVhcixcbiAgICAgICAgdmFsdWVzOiBwcm90by5rZXlzLFxuICAgICAgICBzaXplOiBwcm90by5zaXplLFxuICAgICAgICBlbXB0eTogcHJvdG8uZW1wdHksXG4gICAgICAgIGVhY2g6IHByb3RvLmVhY2hcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHNldChvYmplY3QsIGYpIHtcbiAgICAgICAgdmFyIHNldCA9IG5ldyBTZXQ7XG4gICAgICAgIC8vIENvcHkgY29uc3RydWN0b3IuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTZXQpXG4gICAgICAgICAgICBvYmplY3QuZWFjaChmdW5jdGlvbiAodmFsdWUpIHsgc2V0LmFkZCh2YWx1ZSk7IH0pO1xuICAgICAgICAvLyBPdGhlcndpc2UsIGFzc3VtZSBpdOKAmXMgYW4gYXJyYXkuXG4gICAgICAgIGVsc2UgaWYgKG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGkgPSAtMSwgbiA9IG9iamVjdC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoZiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgICAgICBzZXQuYWRkKG9iamVjdFtpXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgICAgIHNldC5hZGQoZihvYmplY3RbaV0sIGksIG9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtleXMobWFwKSB7XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBtYXApXG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbHVlcyhtYXApIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWFwKVxuICAgICAgICAgICAgdmFsdWVzLnB1c2gobWFwW2tleV0pO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbnRyaWVzKG1hcCkge1xuICAgICAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWFwKVxuICAgICAgICAgICAgZW50cmllcy5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiBtYXBba2V5XSB9KTtcbiAgICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgfVxuICAgIGV4cG9ydHMubmVzdCA9IG5lc3Q7XG4gICAgZXhwb3J0cy5zZXQgPSBzZXQ7XG4gICAgZXhwb3J0cy5tYXAgPSBtYXA7XG4gICAgZXhwb3J0cy5rZXlzID0ga2V5cztcbiAgICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcbiAgICBleHBvcnRzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59KSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1jb21wb3NpdGUtcHJvamVjdGlvbnNAMS4zLjJAZDMtY29tcG9zaXRlLXByb2plY3Rpb25zL2QzLWNvbXBvc2l0ZS1wcm9qZWN0aW9ucy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2QzLWNvbXBvc2l0ZS1wcm9qZWN0aW9uc0AxLjMuMkBkMy1jb21wb3NpdGUtcHJvamVjdGlvbnMvZDMtY29tcG9zaXRlLXByb2plY3Rpb25zLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBodHRwOi8vZ2VvZXhhbXBsZXMuY29tL2QzLWNvbXBvc2l0ZS1wcm9qZWN0aW9ucy8gdjEuMy4yIENvcHlyaWdodCAyMDE5IFJvZ2VyIFZlY2lhbmEgaSBSb3ZpcmFcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgIHRydWUgPyBmYWN0b3J5KGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWdlbyAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1nZW9AMS4xMS45QGQzLWdlby9kaXN0L2QzLWdlby5qc1wiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtcGF0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1wYXRoQDEuMC45QGQzLXBhdGgvZGlzdC9kMy1wYXRoLmpzXCIpKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCBkM0dlbywgZDNQYXRoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBlcHNpbG9uID0gMWUtNjtcbiAgICBmdW5jdGlvbiBub29wKCkgeyB9XG4gICAgdmFyIHgwID0gSW5maW5pdHksIHkwID0geDAsIHgxID0gLXgwLCB5MSA9IHgxO1xuICAgIHZhciBib3VuZHNTdHJlYW0gPSB7XG4gICAgICAgIHBvaW50OiBib3VuZHNQb2ludCxcbiAgICAgICAgbGluZVN0YXJ0OiBub29wLFxuICAgICAgICBsaW5lRW5kOiBub29wLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IG5vb3AsXG4gICAgICAgIHBvbHlnb25FbmQ6IG5vb3AsXG4gICAgICAgIHJlc3VsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgICAgICAgICAgeDEgPSB5MSA9IC0oeTAgPSB4MCA9IEluZmluaXR5KTtcbiAgICAgICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGJvdW5kc1BvaW50KHgsIHkpIHtcbiAgICAgICAgaWYgKHggPCB4MClcbiAgICAgICAgICAgIHgwID0geDtcbiAgICAgICAgaWYgKHggPiB4MSlcbiAgICAgICAgICAgIHgxID0geDtcbiAgICAgICAgaWYgKHkgPCB5MClcbiAgICAgICAgICAgIHkwID0geTtcbiAgICAgICAgaWYgKHkgPiB5MSlcbiAgICAgICAgICAgIHkxID0geTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICAgIHZhciB3ID0gZXh0ZW50WzFdWzBdIC0gZXh0ZW50WzBdWzBdLCBoID0gZXh0ZW50WzFdWzFdIC0gZXh0ZW50WzBdWzFdLCBjbGlwID0gcHJvamVjdGlvbi5jbGlwRXh0ZW50ICYmIHByb2plY3Rpb24uY2xpcEV4dGVudCgpO1xuICAgICAgICBwcm9qZWN0aW9uXG4gICAgICAgICAgICAuc2NhbGUoMTUwKVxuICAgICAgICAgICAgLnRyYW5zbGF0ZShbMCwgMF0pO1xuICAgICAgICBpZiAoY2xpcCAhPSBudWxsKVxuICAgICAgICAgICAgcHJvamVjdGlvbi5jbGlwRXh0ZW50KG51bGwpO1xuICAgICAgICBkM0dlby5nZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uLnN0cmVhbShib3VuZHNTdHJlYW0pKTtcbiAgICAgICAgdmFyIGIgPSBib3VuZHNTdHJlYW0ucmVzdWx0KCksIGsgPSBNYXRoLm1pbih3IC8gKGJbMV1bMF0gLSBiWzBdWzBdKSwgaCAvIChiWzFdWzFdIC0gYlswXVsxXSkpLCB4ID0gK2V4dGVudFswXVswXSArICh3IC0gayAqIChiWzFdWzBdICsgYlswXVswXSkpIC8gMiwgeSA9ICtleHRlbnRbMF1bMV0gKyAoaCAtIGsgKiAoYlsxXVsxXSArIGJbMF1bMV0pKSAvIDI7XG4gICAgICAgIGlmIChjbGlwICE9IG51bGwpXG4gICAgICAgICAgICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoY2xpcCk7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uXG4gICAgICAgICAgICAuc2NhbGUoayAqIDE1MClcbiAgICAgICAgICAgIC50cmFuc2xhdGUoW3gsIHldKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBbWzAsIDBdLCBzaXplXSwgb2JqZWN0KTtcbiAgICB9XG4gICAgLy8gVGhlIHByb2plY3Rpb25zIG11c3QgaGF2ZSBtdXR1YWxseSBleGNsdXNpdmUgY2xpcCByZWdpb25zIG9uIHRoZSBzcGhlcmUsXG4gICAgLy8gYXMgdGhpcyB3aWxsIGF2b2lkIGVtaXR0aW5nIGludGVybGVhdmluZyBsaW5lcyBhbmQgcG9seWdvbnMuXG4gICAgZnVuY3Rpb24gbXVsdGlwbGV4KHN0cmVhbXMpIHtcbiAgICAgICAgdmFyIG4gPSBzdHJlYW1zLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvaW50KHgsIHkpOyB9LFxuICAgICAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0uc3BoZXJlKCk7IH0sXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lU3RhcnQoKTsgfSxcbiAgICAgICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lRW5kKCk7IH0sXG4gICAgICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uU3RhcnQoKTsgfSxcbiAgICAgICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uRW5kKCk7IH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQSBjb21wb3NpdGUgcHJvamVjdGlvbiBmb3IgdGhlIFVuaXRlZCBTdGF0ZXMsIGNvbmZpZ3VyZWQgYnkgZGVmYXVsdCBmb3JcbiAgICAvLyA5NjDDlzUwMC4gVGhlIHByb2plY3Rpb24gYWxzbyB3b3JrcyBxdWl0ZSB3ZWxsIGF0IDk2MMOXNjAwIGlmIHlvdSBjaGFuZ2UgdGhlXG4gICAgLy8gc2NhbGUgdG8gMTI4NSBhbmQgYWRqdXN0IHRoZSB0cmFuc2xhdGUgYWNjb3JkaW5nbHkuIFRoZSBzZXQgb2Ygc3RhbmRhcmRcbiAgICAvLyBwYXJhbGxlbHMgZm9yIGVhY2ggcmVnaW9uIGNvbWVzIGZyb20gVVNHUywgd2hpY2ggaXMgcHVibGlzaGVkIGhlcmU6XG4gICAgLy8gaHR0cDovL2Vnc2MudXNncy5nb3YvaXNiL3B1YnMvTWFwUHJvamVjdGlvbnMvcHJvamVjdGlvbnMuaHRtbCNhbGJlcnNcbiAgICBmdW5jdGlvbiBhbGJlcnNVc2EoKSB7XG4gICAgICAgIHZhciBjYWNoZSwgY2FjaGVTdHJlYW0sIGxvd2VyNDggPSBkM0dlby5nZW9BbGJlcnMoKSwgbG93ZXI0OFBvaW50LCBhbGFza2EgPSBkM0dlby5nZW9Db25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbMTU0LCAwXSkuY2VudGVyKFstMiwgNTguNV0pLnBhcmFsbGVscyhbNTUsIDY1XSksIGFsYXNrYVBvaW50LCAvLyBFUFNHOjMzMzhcbiAgICAgICAgaGF3YWlpID0gZDNHZW8uZ2VvQ29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWzE1NywgMF0pLmNlbnRlcihbLTMsIDE5LjldKS5wYXJhbGxlbHMoWzgsIDE4XSksIGhhd2FpaVBvaW50LCAvLyBFU1JJOjEwMjAwN1xuICAgICAgICBwb2ludCwgcG9pbnRTdHJlYW0gPSB7IHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyBwb2ludCA9IFt4LCB5XTsgfSB9O1xuICAgICAgICBmdW5jdGlvbiBhbGJlcnNVc2EoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludCA9IG51bGwsXG4gICAgICAgICAgICAgICAgKGxvd2VyNDhQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIHx8IChhbGFza2FQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpXG4gICAgICAgICAgICAgICAgICAgIHx8IChoYXdhaWlQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGFsYmVyc1VzYS5pbnZlcnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB0ID0gbG93ZXI0OC50cmFuc2xhdGUoKSwgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gaywgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICAgICAgICAgIHJldHVybiAoeSA+PSAwLjEyMCAmJiB5IDwgMC4yMzQgJiYgeCA+PSAtMC40MjUgJiYgeCA8IC0wLjIxNCA/IGFsYXNrYVxuICAgICAgICAgICAgICAgIDogeSA+PSAwLjE2NiAmJiB5IDwgMC4yMzQgJiYgeCA+PSAtMC4yMTQgJiYgeCA8IC0wLjExNSA/IGhhd2FpaVxuICAgICAgICAgICAgICAgICAgICA6IGxvd2VyNDgpLmludmVydChjb29yZGluYXRlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBtdWx0aXBsZXgoW2xvd2VyNDguc3RyZWFtKGNhY2hlU3RyZWFtID0gc3RyZWFtKSwgYWxhc2thLnN0cmVhbShzdHJlYW0pLCBoYXdhaWkuc3RyZWFtKHN0cmVhbSldKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLnByZWNpc2lvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvd2VyNDgucHJlY2lzaW9uKCk7XG4gICAgICAgICAgICBsb3dlcjQ4LnByZWNpc2lvbihfKSwgYWxhc2thLnByZWNpc2lvbihfKSwgaGF3YWlpLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2Euc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBsb3dlcjQ4LnNjYWxlKCk7XG4gICAgICAgICAgICBsb3dlcjQ4LnNjYWxlKF8pLCBhbGFza2Euc2NhbGUoXyAqIDAuMzUpLCBoYXdhaWkuc2NhbGUoXyk7XG4gICAgICAgICAgICByZXR1cm4gYWxiZXJzVXNhLnRyYW5zbGF0ZShsb3dlcjQ4LnRyYW5zbGF0ZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvd2VyNDgudHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSwgeCA9ICtfWzBdLCB5ID0gK19bMV07XG4gICAgICAgICAgICBsb3dlcjQ4UG9pbnQgPSBsb3dlcjQ4XG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShfKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuNDU1ICogaywgeSAtIDAuMjM4ICoga10sIFt4ICsgMC40NTUgKiBrLCB5ICsgMC4yMzggKiBrXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBhbGFza2FQb2ludCA9IGFsYXNrYVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjMwNyAqIGssIHkgKyAwLjIwMSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuNDI1ICogayArIGVwc2lsb24sIHkgKyAwLjEyMCAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjIxNCAqIGsgLSBlcHNpbG9uLCB5ICsgMC4yMzQgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgaGF3YWlpUG9pbnQgPSBoYXdhaWlcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4yMDUgKiBrLCB5ICsgMC4yMTIgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjIxNCAqIGsgKyBlcHNpbG9uLCB5ICsgMC4xNjYgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4xMTUgKiBrIC0gZXBzaWxvbiwgeSArIDAuMjM0ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2EuZml0RXh0ZW50ID0gZnVuY3Rpb24gKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0RXh0ZW50KGFsYmVyc1VzYSwgZXh0ZW50LCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2EuZml0U2l6ZSA9IGZ1bmN0aW9uIChzaXplLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRTaXplKGFsYmVyc1VzYSwgc2l6ZSwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhbGJlcnNVc2E7XG4gICAgICAgIH1cbiAgICAgICAgYWxiZXJzVXNhLmRyYXdDb21wb3NpdGlvbkJvcmRlcnMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgdmFyIGhhd2FpaTEgPSBsb3dlcjQ4KFstMTAyLjkxLCAyNi4zXSk7XG4gICAgICAgICAgICB2YXIgaGF3YWlpMiA9IGxvd2VyNDgoWy0xMDQuMCwgMjcuNV0pO1xuICAgICAgICAgICAgdmFyIGhhd2FpaTMgPSBsb3dlcjQ4KFstMTA4LjAsIDI5LjFdKTtcbiAgICAgICAgICAgIHZhciBoYXdhaWk0ID0gbG93ZXI0OChbLTExMC4wLCAyOS4xXSk7XG4gICAgICAgICAgICB2YXIgYWxhc2thMSA9IGxvd2VyNDgoWy0xMTAuMCwgMjYuN10pO1xuICAgICAgICAgICAgdmFyIGFsYXNrYTIgPSBsb3dlcjQ4KFstMTEyLjgsIDI3LjZdKTtcbiAgICAgICAgICAgIHZhciBhbGFza2EzID0gbG93ZXI0OChbLTExNC4zLCAzMC42XSk7XG4gICAgICAgICAgICB2YXIgYWxhc2thNCA9IGxvd2VyNDgoWy0xMTkuMywgMzAuMV0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oaGF3YWlpMVswXSwgaGF3YWlpMVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhoYXdhaWkyWzBdLCBoYXdhaWkyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGhhd2FpaTNbMF0sIGhhd2FpaTNbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oaGF3YWlpNFswXSwgaGF3YWlpNFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhhbGFza2ExWzBdLCBhbGFza2ExWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGFsYXNrYTJbMF0sIGFsYXNrYTJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYWxhc2thM1swXSwgYWxhc2thM1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhhbGFza2E0WzBdLCBhbGFza2E0WzFdKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLmdldENvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZDNQYXRoLnBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyhjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhbGJlcnNVc2Euc2NhbGUoMTA3MCk7XG4gICAgfVxuICAgIC8vIFRoZSBwcm9qZWN0aW9ucyBtdXN0IGhhdmUgbXV0dWFsbHkgZXhjbHVzaXZlIGNsaXAgcmVnaW9ucyBvbiB0aGUgc3BoZXJlLFxuICAgIC8vIGFzIHRoaXMgd2lsbCBhdm9pZCBlbWl0dGluZyBpbnRlcmxlYXZpbmcgbGluZXMgYW5kIHBvbHlnb25zLlxuICAgIGZ1bmN0aW9uIG11bHRpcGxleCQxKHN0cmVhbXMpIHtcbiAgICAgICAgdmFyIG4gPSBzdHJlYW1zLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvaW50KHgsIHkpOyB9LFxuICAgICAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0uc3BoZXJlKCk7IH0sXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lU3RhcnQoKTsgfSxcbiAgICAgICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lRW5kKCk7IH0sXG4gICAgICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uU3RhcnQoKTsgfSxcbiAgICAgICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uRW5kKCk7IH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQSBjb21wb3NpdGUgcHJvamVjdGlvbiBmb3IgdGhlIFVuaXRlZCBTdGF0ZXMsIGNvbmZpZ3VyZWQgYnkgZGVmYXVsdCBmb3JcbiAgICAvLyA5NjDDlzUwMC4gQWxzbyB3b3JrcyBxdWl0ZSB3ZWxsIGF0IDk2MMOXNjAwIHdpdGggc2NhbGUgMTI4NS4gVGhlIHNldCBvZlxuICAgIC8vIHN0YW5kYXJkIHBhcmFsbGVscyBmb3IgZWFjaCByZWdpb24gY29tZXMgZnJvbSBVU0dTLCB3aGljaCBpcyBwdWJsaXNoZWQgaGVyZTpcbiAgICAvLyBodHRwOi8vZWdzYy51c2dzLmdvdi9pc2IvcHVicy9NYXBQcm9qZWN0aW9ucy9wcm9qZWN0aW9ucy5odG1sI2FsYmVyc1xuICAgIGZ1bmN0aW9uIGFsYmVyc1VzYVRlcnJpdG9yaWVzKCkge1xuICAgICAgICB2YXIgY2FjaGUsIGNhY2hlU3RyZWFtLCBsb3dlcjQ4ID0gZDNHZW8uZ2VvQWxiZXJzKCksIGxvd2VyNDhQb2ludCwgYWxhc2thID0gZDNHZW8uZ2VvQ29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWzE1NCwgMF0pLmNlbnRlcihbLTIsIDU4LjVdKS5wYXJhbGxlbHMoWzU1LCA2NV0pLCBhbGFza2FQb2ludCwgLy8gRVBTRzozMzM4XG4gICAgICAgIGhhd2FpaSA9IGQzR2VvLmdlb0NvbmljRXF1YWxBcmVhKCkucm90YXRlKFsxNTcsIDBdKS5jZW50ZXIoWy0zLCAxOS45XSkucGFyYWxsZWxzKFs4LCAxOF0pLCBoYXdhaWlQb2ludCwgLy8gRVNSSToxMDIwMDdcbiAgICAgICAgcHVlcnRvUmljbyA9IGQzR2VvLmdlb0NvbmljRXF1YWxBcmVhKCkucm90YXRlKFs2NiwgMF0pLmNlbnRlcihbMCwgMThdKS5wYXJhbGxlbHMoWzgsIDE4XSksIHB1ZXJ0b1JpY29Qb2ludCwgLy9UYWtlbiBmcm9tIGh0dHBzOi8vYmwub2Nrcy5vcmcvbWJvc3RvY2svNTYyOTEyMFxuICAgICAgICBzYW1vYSA9IGQzR2VvLmdlb0VxdWlyZWN0YW5ndWxhcigpLnJvdGF0ZShbMTczLCAxNF0pLCBzYW1vYVBvaW50LCAvLyBFUFNHOjQxNjlcbiAgICAgICAgZ3VhbSA9IGQzR2VvLmdlb0VxdWlyZWN0YW5ndWxhcigpLnJvdGF0ZShbLTE0NSwgLTE2LjhdKSwgZ3VhbVBvaW50LCBwb2ludCwgcG9pbnRTdHJlYW0gPSB7IHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyBwb2ludCA9IFt4LCB5XTsgfSB9O1xuICAgICAgICAvKlxuICAgICAgICB2YXIgcHVlcnRvUmljb0Jib3ggPSBbWy02OC4zLCAxOV0sIFstNjMuOSwgMTddXTtcbiAgICAgICAgdmFyIHNhbW9hQmJveCA9IFtbLTE3MSwgLTE0XSwgWy0xNjgsIC0xNC44XV07XG4gICAgICAgIHZhciBndWFtQmJveCA9IFtbMTQ0LCAyMC44XSwgWzE0Ni41LCAxMi43XV07XG4gICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGFsYmVyc1VzYShjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIHggPSBjb29yZGluYXRlc1swXSwgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50ID0gbnVsbCxcbiAgICAgICAgICAgICAgICAobG93ZXI0OFBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGFsYXNrYVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGhhd2FpaVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHB1ZXJ0b1JpY29Qb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChzYW1vYVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGd1YW1Qb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGFsYmVyc1VzYS5pbnZlcnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB0ID0gbG93ZXI0OC50cmFuc2xhdGUoKSwgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gaywgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAvL0hvdyBhcmUgdGhlIHJldHVybiB2YWx1ZXMgY2FsY3VsYXRlZDpcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKlwiKTtcbiAgICAgICAgICAgIHZhciBjMCA9IHB1ZXJ0b1JpY28ocHVlcnRvUmljb0Jib3hbMF0pO1xuICAgICAgICAgICAgdmFyIHgwID0gKGMwWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgdmFyIHkwID0gKGMwWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDAgcHVlcnRvUmljb1wiLCB4MCArICcgLSAnICsgeTApO1xuICAgIFxuICAgICAgICAgICAgdmFyIGMxID0gcHVlcnRvUmljbyhwdWVydG9SaWNvQmJveFsxXSk7XG4gICAgICAgICAgICB2YXIgeDEgPSAoYzFbMF0gLSB0WzBdKSAvIGs7XG4gICAgICAgICAgICB2YXIgeTEgPSAoYzFbMV0gLSB0WzFdKSAvIGs7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJwMSBwdWVydG9SaWNvXCIsIHgxICsgJyAtICcgKyB5MSk7XG4gICAgXG4gICAgICAgICAgICBjMCA9IHNhbW9hKHNhbW9hQmJveFswXSk7XG4gICAgICAgICAgICB4MCA9IChjMFswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHkwID0gKGMwWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDAgc2Ftb2FcIiwgeDAgKyAnIC0gJyArIHkwKTtcbiAgICBcbiAgICAgICAgICAgIGMxID0gc2Ftb2Eoc2Ftb2FCYm94WzFdKTtcbiAgICAgICAgICAgIHgxID0gKGMxWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgeTEgPSAoYzFbMV0gLSB0WzFdKSAvIGs7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJwMSBzYW1vYVwiLCB4MSArICcgLSAnICsgeTEpO1xuICAgIFxuICAgICAgICAgICAgYzAgPSBndWFtKGd1YW1CYm94WzBdKTtcbiAgICAgICAgICAgIHgwID0gKGMwWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgeTAgPSAoYzBbMV0gLSB0WzFdKSAvIGs7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJwMCBndWFtXCIsIHgwICsgJyAtICcgKyB5MCk7XG4gICAgXG4gICAgICAgICAgICBjMSA9IGd1YW0oZ3VhbUJib3hbMV0pO1xuICAgICAgICAgICAgeDEgPSAoYzFbMF0gLSB0WzBdKSAvIGs7XG4gICAgICAgICAgICB5MSA9IChjMVsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAxIGd1YW1cIiwgeDEgKyAnIC0gJyArIHkxKTtcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gKHkgPj0gMC4xMjAgJiYgeSA8IDAuMjM0ICYmIHggPj0gLTAuNDI1ICYmIHggPCAtMC4yMTQgPyBhbGFza2FcbiAgICAgICAgICAgICAgICA6IHkgPj0gMC4xNjYgJiYgeSA8IDAuMjM0ICYmIHggPj0gLTAuMjE0ICYmIHggPCAtMC4xMTUgPyBoYXdhaWlcbiAgICAgICAgICAgICAgICAgICAgOiB5ID49IDAuMjA2NCAmJiB5IDwgMC4yNDEzICYmIHggPj0gMC4zMTIgJiYgeCA8IDAuMzg1ID8gcHVlcnRvUmljb1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB5ID49IDAuMDkgJiYgeSA8IDAuMTE5NyAmJiB4ID49IC0wLjQyNDMgJiYgeCA8IC0wLjMyMzIgPyBzYW1vYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAtMC4wNTE4ICYmIHkgPCAwLjA4OTUgJiYgeCA+PSAtMC40MjQzICYmIHggPCAtMC4zODI0ID8gZ3VhbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGxvd2VyNDgpLmludmVydChjb29yZGluYXRlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBtdWx0aXBsZXgkMShbbG93ZXI0OC5zdHJlYW0oY2FjaGVTdHJlYW0gPSBzdHJlYW0pLCBhbGFza2Euc3RyZWFtKHN0cmVhbSksIGhhd2FpaS5zdHJlYW0oc3RyZWFtKSwgcHVlcnRvUmljby5zdHJlYW0oc3RyZWFtKSwgc2Ftb2Euc3RyZWFtKHN0cmVhbSksIGd1YW0uc3RyZWFtKHN0cmVhbSldKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLnByZWNpc2lvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG93ZXI0OC5wcmVjaXNpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvd2VyNDgucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgYWxhc2thLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGhhd2FpaS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBwdWVydG9SaWNvLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHNhbW9hLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGd1YW0ucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5zY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG93ZXI0OC5zY2FsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG93ZXI0OC5zY2FsZShfKTtcbiAgICAgICAgICAgIGFsYXNrYS5zY2FsZShfICogMC4zNSk7XG4gICAgICAgICAgICBoYXdhaWkuc2NhbGUoXyk7XG4gICAgICAgICAgICBwdWVydG9SaWNvLnNjYWxlKF8pO1xuICAgICAgICAgICAgc2Ftb2Euc2NhbGUoXyAqIDIpO1xuICAgICAgICAgICAgZ3VhbS5zY2FsZShfKTtcbiAgICAgICAgICAgIHJldHVybiBhbGJlcnNVc2EudHJhbnNsYXRlKGxvd2VyNDgudHJhbnNsYXRlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2EudHJhbnNsYXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb3dlcjQ4LnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIHZhciBjMCA9IHB1ZXJ0b1JpY28udHJhbnNsYXRlKFt4ICsgMC4zNTAgKiBrLCB5ICsgMC4yMjQgKiBrXSkocHVlcnRvUmljb0Jib3hbMF0pO1xuICAgICAgICAgICAgdmFyIHgwID0gKHggLSBjMFswXSkgLyBrO1xuICAgICAgICAgICAgdmFyIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgIHZhciBjMSA9IHB1ZXJ0b1JpY28udHJhbnNsYXRlKFt4ICsgMC4zNTAgKiBrLCB5ICsgMC4yMjQgKiBrXSkocHVlcnRvUmljb0Jib3hbMV0pO1xuICAgICAgICAgICAgdmFyIHgxID0gKHggLSBjMVswXSkgLyBrO1xuICAgICAgICAgICAgdmFyIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygncHVlcnRvUmljbzogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJy5jbGlwRXh0ZW50KFtbeCAnK1xuICAgICAgICAgICAgICh4MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAnICogayArIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICAoeTA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uXSxbeCAnK1xuICAgICAgICAgICAgICh4MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAnICogayAtIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICAoeTE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uXV0pJyk7XG4gICAgICAgIFxuICAgICAgICAgICAgICBjMCA9IHNhbW9hLnRyYW5zbGF0ZShbeCAtIDAuNDkyICogaywgeSArIDAuMDkgKiBrXSkoc2Ftb2FCYm94WzBdKTtcbiAgICAgICAgICAgICAgeDAgPSAoeCAtIGMwWzBdKSAvIGs7XG4gICAgICAgICAgICAgIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgICAgYzEgPSBzYW1vYS50cmFuc2xhdGUoW3ggLSAwLjQ5MiAqIGssIHkgKyAwLjA5ICoga10pKHNhbW9hQmJveFsxXSk7XG4gICAgICAgICAgICAgIHgxID0gKHggLSBjMVswXSkgLyBrO1xuICAgICAgICAgICAgICB5MSA9ICh5IC0gYzFbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgICAgY29uc29sZS5pbmZvKCdzYW1vYTogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgICAgY29uc29sZS5pbmZvKCcuY2xpcEV4dGVudChbW3ggJytcbiAgICAgICAgICAgICAgKHgwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgICAnICogayArIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICAgKHkwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgICAnICogayArIGVwc2lsb25dLFt4ICcrXG4gICAgICAgICAgICAgICh4MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAgICh5MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uXV0pJyk7XG4gICAgICAgIFxuICAgICAgICAgICAgICBjMCA9IGd1YW0udHJhbnNsYXRlKFt4IC0gMC40MDggKiBrLCB5ICsgMC4wMTggKiBrXSkoZ3VhbUJib3hbMF0pO1xuICAgICAgICAgICAgICB4MCA9ICh4IC0gYzBbMF0pIC8gaztcbiAgICAgICAgICAgICAgeTAgPSAoeSAtIGMwWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICAgICBjMSA9IGd1YW0udHJhbnNsYXRlKFt4IC0gMC40MDggKiBrLCB5ICsgMC4wMTggKiBrXSkoZ3VhbUJib3hbMV0pO1xuICAgICAgICAgICAgICB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgICAgeTEgPSAoeSAtIGMxWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnZ3VhbTogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgICAgY29uc29sZS5pbmZvKCcuY2xpcEV4dGVudChbW3ggJytcbiAgICAgICAgICAgICAgKHgwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgICAnICogayArIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICAgKHkwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgICAnICogayArIGVwc2lsb25dLFt4ICcrXG4gICAgICAgICAgICAgICh4MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAgICh5MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uXV0pJyk7XG4gICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsb3dlcjQ4UG9pbnQgPSBsb3dlcjQ4XG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShfKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuNDU1ICogaywgeSAtIDAuMjM4ICoga10sIFt4ICsgMC40NTUgKiBrLCB5ICsgMC4yMzggKiBrXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBhbGFza2FQb2ludCA9IGFsYXNrYVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjMwNyAqIGssIHkgKyAwLjIwMSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuNDI1ICogayArIGVwc2lsb24sIHkgKyAwLjEyMCAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjIxNCAqIGsgLSBlcHNpbG9uLCB5ICsgMC4yMzMgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgaGF3YWlpUG9pbnQgPSBoYXdhaWlcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4yMDUgKiBrLCB5ICsgMC4yMTIgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjIxNCAqIGsgKyBlcHNpbG9uLCB5ICsgMC4xNjYgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4xMTUgKiBrIC0gZXBzaWxvbiwgeSArIDAuMjMzICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHB1ZXJ0b1JpY29Qb2ludCA9IHB1ZXJ0b1JpY29cbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4ICsgMC4zNTAgKiBrLCB5ICsgMC4yMjQgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggKyAwLjMxMiAqIGsgKyBlcHNpbG9uLCB5ICsgMC4yMDY0ICogayArIGVwc2lsb25dLCBbeCArIDAuMzg1ICogayAtIGVwc2lsb24sIHkgKyAwLjIzMyAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBzYW1vYVBvaW50ID0gc2Ftb2FcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC40OTIgKiBrLCB5ICsgMC4wOSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuNDI0MyAqIGsgKyBlcHNpbG9uLCB5ICsgMC4wOTAzICogayArIGVwc2lsb25dLCBbeCAtIDAuMzIzMyAqIGsgLSBlcHNpbG9uLCB5ICsgMC4xMTk3ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGd1YW1Qb2ludCA9IGd1YW1cbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC40MDggKiBrLCB5ICsgMC4wMTggKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjQyNDQgKiBrICsgZXBzaWxvbiwgeSAtIDAuMDUxOSAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjM4MjQgKiBrIC0gZXBzaWxvbiwgeSArIDAuMDg5NSAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLmZpdEV4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdEV4dGVudChhbGJlcnNVc2EsIGV4dGVudCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLmZpdFNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0U2l6ZShhbGJlcnNVc2EsIHNpemUsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYWxiZXJzVXNhO1xuICAgICAgICB9XG4gICAgICAgIGFsYmVyc1VzYS5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJDTElQIEVYVEVOVCBoYXdhaWk6IFwiLCBoYXdhaWkuY2xpcEV4dGVudCgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVMIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFtoYXdhaWkuY2xpcEV4dGVudCgpWzBdWzBdLCBoYXdhaWkuY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVVIgQkJPWDpcIiwgbG93ZXI0OC5pbnZlcnQoW2hhd2FpaS5jbGlwRXh0ZW50KClbMV1bMF0sIGhhd2FpaS5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMRCBCQk9YOlwiLCBsb3dlcjQ4LmludmVydChbaGF3YWlpLmNsaXBFeHRlbnQoKVsxXVswXSwgaGF3YWlpLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxMIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFtoYXdhaWkuY2xpcEV4dGVudCgpWzBdWzBdLCBoYXdhaWkuY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkNMSVAgRVhURU5UIGFsYXNrYTogXCIsIGFsYXNrYS5jbGlwRXh0ZW50KCkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVUwgQkJPWDpcIiwgbG93ZXI0OC5pbnZlcnQoW2FsYXNrYS5jbGlwRXh0ZW50KClbMF1bMF0sIGFsYXNrYS5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJVUiBCQk9YOlwiLCBsb3dlcjQ4LmludmVydChbYWxhc2thLmNsaXBFeHRlbnQoKVsxXVswXSwgYWxhc2thLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxEIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFthbGFza2EuY2xpcEV4dGVudCgpWzFdWzBdLCBhbGFza2EuY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEwgQkJPWDpcIiwgbG93ZXI0OC5pbnZlcnQoW2FsYXNrYS5jbGlwRXh0ZW50KClbMF1bMF0sIGFsYXNrYS5jbGlwRXh0ZW50KClbMV1bMV1dKSk7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQ0xJUCBFWFRFTlQgcHVlcnRvUmljbzogXCIsIHB1ZXJ0b1JpY28uY2xpcEV4dGVudCgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVMIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFtwdWVydG9SaWNvLmNsaXBFeHRlbnQoKVswXVswXSwgcHVlcnRvUmljby5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJVUiBCQk9YOlwiLCBsb3dlcjQ4LmludmVydChbcHVlcnRvUmljby5jbGlwRXh0ZW50KClbMV1bMF0sIHB1ZXJ0b1JpY28uY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEQgQkJPWDpcIiwgbG93ZXI0OC5pbnZlcnQoW3B1ZXJ0b1JpY28uY2xpcEV4dGVudCgpWzFdWzBdLCBwdWVydG9SaWNvLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxMIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFtwdWVydG9SaWNvLmNsaXBFeHRlbnQoKVswXVswXSwgcHVlcnRvUmljby5jbGlwRXh0ZW50KClbMV1bMV1dKSk7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQ0xJUCBFWFRFTlQgc2Ftb2E6IFwiLCBzYW1vYS5jbGlwRXh0ZW50KCkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVUwgQkJPWDpcIiwgbG93ZXI0OC5pbnZlcnQoW3NhbW9hLmNsaXBFeHRlbnQoKVswXVswXSwgc2Ftb2EuY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVVIgQkJPWDpcIiwgbG93ZXI0OC5pbnZlcnQoW3NhbW9hLmNsaXBFeHRlbnQoKVsxXVswXSwgc2Ftb2EuY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEQgQkJPWDpcIiwgbG93ZXI0OC5pbnZlcnQoW3NhbW9hLmNsaXBFeHRlbnQoKVsxXVswXSwgc2Ftb2EuY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEwgQkJPWDpcIiwgbG93ZXI0OC5pbnZlcnQoW3NhbW9hLmNsaXBFeHRlbnQoKVswXVswXSwgc2Ftb2EuY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJDTElQIEVYVEVOVCBndWFtOiBcIiwgZ3VhbS5jbGlwRXh0ZW50KCkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVUwgQkJPWDpcIiwgbG93ZXI0OC5pbnZlcnQoW2d1YW0uY2xpcEV4dGVudCgpWzBdWzBdLCBndWFtLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVSIEJCT1g6XCIsIGxvd2VyNDguaW52ZXJ0KFtndWFtLmNsaXBFeHRlbnQoKVsxXVswXSwgZ3VhbS5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMRCBCQk9YOlwiLCBsb3dlcjQ4LmludmVydChbZ3VhbS5jbGlwRXh0ZW50KClbMV1bMF0sIGd1YW0uY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEwgQkJPWDpcIiwgbG93ZXI0OC5pbnZlcnQoW2d1YW0uY2xpcEV4dGVudCgpWzBdWzBdLCBndWFtLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgdWxoYXdhaWkgPSBsb3dlcjQ4KFstMTEwLjQ2NDEsIDI4LjI4MDVdKTtcbiAgICAgICAgICAgIHZhciB1cmhhd2FpaSA9IGxvd2VyNDgoWy0xMDQuMDU5NywgMjguOTUyOF0pO1xuICAgICAgICAgICAgdmFyIGxkaGF3YWlpID0gbG93ZXI0OChbLTEwMy43MDQ5LCAyNS4xMDMxXSk7XG4gICAgICAgICAgICB2YXIgbGxoYXdhaWkgPSBsb3dlcjQ4KFstMTA5LjgzMzcsIDI0LjQ1MzFdKTtcbiAgICAgICAgICAgIHZhciB1bGFsYXNrYSA9IGxvd2VyNDgoWy0xMjQuNDc0NSwgMjguMTQwN10pO1xuICAgICAgICAgICAgdmFyIHVyYWxhc2thID0gbG93ZXI0OChbLTExMC45MzEsIDMwLjg4NDRdKTtcbiAgICAgICAgICAgIHZhciBsZGFsYXNrYSA9IGxvd2VyNDgoWy0xMDkuODMzNywgMjQuNDUzMV0pO1xuICAgICAgICAgICAgdmFyIGxsYWxhc2thID0gbG93ZXI0OChbLTEyMi40NjI4LCAyMS44NTYyXSk7XG4gICAgICAgICAgICB2YXIgdWxwdWVydG9SaWNvID0gbG93ZXI0OChbLTc2Ljg1NzksIDI1LjE1NDRdKTtcbiAgICAgICAgICAgIHZhciB1cnB1ZXJ0b1JpY28gPSBsb3dlcjQ4KFstNzIuNDI5LCAyNC4yMDk3XSk7XG4gICAgICAgICAgICB2YXIgbGRwdWVydG9SaWNvID0gbG93ZXI0OChbLTcyLjgyNjUsIDIyLjcwNTZdKTtcbiAgICAgICAgICAgIHZhciBsbHB1ZXJ0b1JpY28gPSBsb3dlcjQ4KFstNzcuMTg1MiwgMjMuNjM5Ml0pO1xuICAgICAgICAgICAgdmFyIHVsc2Ftb2EgPSBsb3dlcjQ4KFstMTI1LjAwOTMsIDI5Ljc3OTFdKTtcbiAgICAgICAgICAgIHZhciB1cnNhbW9hID0gbG93ZXI0OChbLTExOC41MTkzLCAzMS4zMjYyXSk7XG4gICAgICAgICAgICB2YXIgbGRzYW1vYSA9IGxvd2VyNDgoWy0xMTguMDY0LCAyOS42OTEyXSk7XG4gICAgICAgICAgICB2YXIgbGxzYW1vYSA9IGxvd2VyNDgoWy0xMjQuNDM2OSwgMjguMTY5XSk7XG4gICAgICAgICAgICB2YXIgdWxndWFtID0gbG93ZXI0OChbLTEyOC4xMzE0LCAzNy40NTgyXSk7XG4gICAgICAgICAgICB2YXIgdXJndWFtID0gbG93ZXI0OChbLTEyNS4yMTMyLCAzOC4yMTRdKTtcbiAgICAgICAgICAgIHZhciBsZGd1YW0gPSBsb3dlcjQ4KFstMTIyLjM2MTYsIDMwLjUxMTVdKTtcbiAgICAgICAgICAgIHZhciBsbGd1YW0gPSBsb3dlcjQ4KFstMTI1LjAzMTUsIDI5LjgyMTFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsaGF3YWlpWzBdLCB1bGhhd2FpaVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1cmhhd2FpaVswXSwgdXJoYXdhaWlbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRoYXdhaWlbMF0sIGxkaGF3YWlpWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkaGF3YWlpWzBdLCBsZGhhd2FpaVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbGhhd2FpaVswXSwgbGxoYXdhaWlbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsYWxhc2thWzBdLCB1bGFsYXNrYVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1cmFsYXNrYVswXSwgdXJhbGFza2FbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRhbGFza2FbMF0sIGxkYWxhc2thWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkYWxhc2thWzBdLCBsZGFsYXNrYVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbGFsYXNrYVswXSwgbGxhbGFza2FbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVscHVlcnRvUmljb1swXSwgdWxwdWVydG9SaWNvWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVycHVlcnRvUmljb1swXSwgdXJwdWVydG9SaWNvWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkcHVlcnRvUmljb1swXSwgbGRwdWVydG9SaWNvWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkcHVlcnRvUmljb1swXSwgbGRwdWVydG9SaWNvWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxscHVlcnRvUmljb1swXSwgbGxwdWVydG9SaWNvWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bHNhbW9hWzBdLCB1bHNhbW9hWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyc2Ftb2FbMF0sIHVyc2Ftb2FbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRzYW1vYVswXSwgbGRzYW1vYVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZHNhbW9hWzBdLCBsZHNhbW9hWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsc2Ftb2FbMF0sIGxsc2Ftb2FbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsZ3VhbVswXSwgdWxndWFtWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyZ3VhbVswXSwgdXJndWFtWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkZ3VhbVswXSwgbGRndWFtWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkZ3VhbVswXSwgbGRndWFtWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsZ3VhbVswXSwgbGxndWFtWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5nZXRDb21wb3NpdGlvbkJvcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGQzUGF0aC5wYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDb21wb3NpdGlvbkJvcmRlcnMoY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYWxiZXJzVXNhLnNjYWxlKDEwNzApO1xuICAgIH1cbiAgICAvLyBUaGUgcHJvamVjdGlvbnMgbXVzdCBoYXZlIG11dHVhbGx5IGV4Y2x1c2l2ZSBjbGlwIHJlZ2lvbnMgb24gdGhlIHNwaGVyZSxcbiAgICAvLyBhcyB0aGlzIHdpbGwgYXZvaWQgZW1pdHRpbmcgaW50ZXJsZWF2aW5nIGxpbmVzIGFuZCBwb2x5Z29ucy5cbiAgICBmdW5jdGlvbiBtdWx0aXBsZXgkMihzdHJlYW1zKSB7XG4gICAgICAgIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5zcGhlcmUoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgfSB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEEgY29tcG9zaXRlIHByb2plY3Rpb24gZm9yIFNwYWluLCBjb25maWd1cmVkIGJ5IGRlZmF1bHQgZm9yIDk2MMOXNTAwLlxuICAgIGZ1bmN0aW9uIGNvbmljQ29uZm9ybWFsU3BhaW4oKSB7XG4gICAgICAgIHZhciBjYWNoZSwgY2FjaGVTdHJlYW0sIGliZXJpYW5QZW5pbnN1bGUgPSBkM0dlby5nZW9Db25pY0NvbmZvcm1hbCgpLnJvdGF0ZShbNSwgLTM4LjZdKS5wYXJhbGxlbHMoWzAsIDYwXSksIGliZXJpYW5QZW5pbnN1bGVQb2ludCwgY2FuYXJ5SXNsYW5kcyA9IGQzR2VvLmdlb0NvbmljQ29uZm9ybWFsKCkucm90YXRlKFs1LCAtMzguNl0pLnBhcmFsbGVscyhbMCwgNjBdKSwgY2FuYXJ5SXNsYW5kc1BvaW50LCBwb2ludCwgcG9pbnRTdHJlYW0gPSB7IHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyBwb2ludCA9IFt4LCB5XTsgfSB9O1xuICAgICAgICAvKlxuICAgICAgICB2YXIgaWJlcmlhblBlbmluc3VsZUJib3ggPSBbWy0xMSwgNDZdLCBbNCwgMzVdXTtcbiAgICAgICAgdmFyIGNhbmFyeUlzbGFuZHNCYm94ID0gW1stMTkuMCwgMjguODVdLCBbLTEyLjcsIDI4LjFdXTtcbiAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY29uaWNDb25mb3JtYWxTcGFpbihjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIHggPSBjb29yZGluYXRlc1swXSwgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50ID0gbnVsbCxcbiAgICAgICAgICAgICAgICAoaWJlcmlhblBlbmluc3VsZVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGNhbmFyeUlzbGFuZHNQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbmljQ29uZm9ybWFsU3BhaW4uaW52ZXJ0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgayA9IGliZXJpYW5QZW5pbnN1bGUuc2NhbGUoKSwgdCA9IGliZXJpYW5QZW5pbnN1bGUudHJhbnNsYXRlKCksIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICAgICAgICByZXR1cm4gKHkgPj0gMC4wNTM0NiAmJiB5IDwgMC4wODk3ICYmIHggPj0gLTAuMTMzODggJiYgeCA8IC0wLjAzMjIgPyBjYW5hcnlJc2xhbmRzXG4gICAgICAgICAgICAgICAgOiBpYmVyaWFuUGVuaW5zdWxlKS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbFNwYWluLnN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IG11bHRpcGxleCQyKFtpYmVyaWFuUGVuaW5zdWxlLnN0cmVhbShjYWNoZVN0cmVhbSA9IHN0cmVhbSksIGNhbmFyeUlzbGFuZHMuc3RyZWFtKHN0cmVhbSldKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxTcGFpbi5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGliZXJpYW5QZW5pbnN1bGUucHJlY2lzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpYmVyaWFuUGVuaW5zdWxlLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGNhbmFyeUlzbGFuZHMucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsU3BhaW4uc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGliZXJpYW5QZW5pbnN1bGUuc2NhbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGliZXJpYW5QZW5pbnN1bGUuc2NhbGUoXyk7XG4gICAgICAgICAgICBjYW5hcnlJc2xhbmRzLnNjYWxlKF8pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmljQ29uZm9ybWFsU3BhaW4udHJhbnNsYXRlKGliZXJpYW5QZW5pbnN1bGUudHJhbnNsYXRlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbFNwYWluLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWJlcmlhblBlbmluc3VsZS50cmFuc2xhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrID0gaWJlcmlhblBlbmluc3VsZS5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICB2YXIgYzAgPSBpYmVyaWFuUGVuaW5zdWxlKGliZXJpYW5QZW5pbnN1bGVCYm94WzBdKTtcbiAgICAgICAgICAgdmFyIHgwID0gKHggLSBjMFswXSkgLyBrO1xuICAgICAgICAgICB2YXIgeTAgPSAoeSAtIGMwWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICB2YXIgYzEgPSBpYmVyaWFuUGVuaW5zdWxlKGliZXJpYW5QZW5pbnN1bGVCYm94WzFdKTtcbiAgICAgICAgICAgdmFyIHgxID0gKHggLSBjMVswXSkgLyBrO1xuICAgICAgICAgICB2YXIgeTEgPSAoeSAtIGMxWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICBjb25zb2xlLmluZm8oJ0liZXJpYW4gUGVuaW5zdWxhOiBwMDogJyArIHgwICsgJywgJyArIHkwICsgJyAsIHAxOiAnICsgeDEgKyAnIC0gJyArIHkxKTtcbiAgICAgICAgXG4gICAgICAgICAgIGMwID0gY2FuYXJ5SXNsYW5kcy50cmFuc2xhdGUoW3ggKyAwLjEgKiBrLCB5IC0gMC4wOTQgKiBrXSkoY2FuYXJ5SXNsYW5kc0Jib3hbMF0pO1xuICAgICAgICAgICB4MCA9ICh4IC0gYzBbMF0pIC8gaztcbiAgICAgICAgICAgeTAgPSAoeSAtIGMwWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICBjMSA9IGNhbmFyeUlzbGFuZHMudHJhbnNsYXRlKFt4ICsgMC4xICogaywgeSAtIDAuMDk0ICoga10pKGNhbmFyeUlzbGFuZHNCYm94WzFdKTtcbiAgICAgICAgICAgeDEgPSAoeCAtIGMxWzBdKSAvIGs7XG4gICAgICAgICAgIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgY29uc29sZS5pbmZvKCdDYW5yeSBJc2xhbmRzOiBwMDogJyArIHgwICsgJywgJyArIHkwICsgJyAsIHAxOiAnICsgeDEgKyAnIC0gJyArIHkxKTtcbiAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGliZXJpYW5QZW5pbnN1bGVQb2ludCA9IGliZXJpYW5QZW5pbnN1bGVcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKF8pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4wNjg1NyAqIGssIHkgLSAwLjEyODggKiBrXSwgW3ggKyAwLjEzMjQ5ICogaywgeSArIDAuMDYgKiBrXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBjYW5hcnlJc2xhbmRzUG9pbnQgPSBjYW5hcnlJc2xhbmRzXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMSAqIGssIHkgLSAwLjA5NCAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMTMzMSAqIGsgKyBlcHNpbG9uLCB5ICsgMC4wNTM0NTcgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4wMzU0ICogayAtIGVwc2lsb24sIHkgKyAwLjA4OTY5ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbFNwYWluLmZpdEV4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdEV4dGVudChjb25pY0NvbmZvcm1hbFNwYWluLCBleHRlbnQsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsU3BhaW4uZml0U2l6ZSA9IGZ1bmN0aW9uIChzaXplLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRTaXplKGNvbmljQ29uZm9ybWFsU3BhaW4sIHNpemUsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gY29uaWNDb25mb3JtYWxTcGFpbjtcbiAgICAgICAgfVxuICAgICAgICBjb25pY0NvbmZvcm1hbFNwYWluLmRyYXdDb21wb3NpdGlvbkJvcmRlcnMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkNMSVAgRVhURU5UOiBcIiwgY2FuYXJ5SXNsYW5kcy5jbGlwRXh0ZW50KCkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVUwgQkJPWDpcIiwgaWJlcmlhblBlbmluc3VsZS5pbnZlcnQoW2NhbmFyeUlzbGFuZHMuY2xpcEV4dGVudCgpWzBdWzBdLCBjYW5hcnlJc2xhbmRzLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVSIEJCT1g6XCIsIGliZXJpYW5QZW5pbnN1bGUuaW52ZXJ0KFtjYW5hcnlJc2xhbmRzLmNsaXBFeHRlbnQoKVsxXVswXSwgY2FuYXJ5SXNsYW5kcy5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMRCBCQk9YOlwiLCBpYmVyaWFuUGVuaW5zdWxlLmludmVydChbY2FuYXJ5SXNsYW5kcy5jbGlwRXh0ZW50KClbMV1bMF0sIGNhbmFyeUlzbGFuZHMuY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciB1bENhbmFyeUlzbGFuZHMgPSBpYmVyaWFuUGVuaW5zdWxlKFstMTQuMDM0Njc1MCwgMzQuOTY1MDA3XSk7XG4gICAgICAgICAgICB2YXIgdXJDYW5hcnlJc2xhbmRzID0gaWJlcmlhblBlbmluc3VsZShbLTcuNDIwODg5OSwgMzUuNTM2OTg4XSk7XG4gICAgICAgICAgICB2YXIgbGRDYW5hcnlJc2xhbmRzID0gaWJlcmlhblBlbmluc3VsZShbLTcuMzE0ODI3NSwgMzMuNTQzNTldKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsQ2FuYXJ5SXNsYW5kc1swXSwgdWxDYW5hcnlJc2xhbmRzWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyQ2FuYXJ5SXNsYW5kc1swXSwgdXJDYW5hcnlJc2xhbmRzWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkQ2FuYXJ5SXNsYW5kc1swXSwgbGRDYW5hcnlJc2xhbmRzWzFdKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxTcGFpbi5nZXRDb21wb3NpdGlvbkJvcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGQzUGF0aC5wYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDb21wb3NpdGlvbkJvcmRlcnMoY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29uaWNDb25mb3JtYWxTcGFpbi5zY2FsZSgyNzAwKTtcbiAgICB9XG4gICAgLy8gVGhlIHByb2plY3Rpb25zIG11c3QgaGF2ZSBtdXR1YWxseSBleGNsdXNpdmUgY2xpcCByZWdpb25zIG9uIHRoZSBzcGhlcmUsXG4gICAgLy8gYXMgdGhpcyB3aWxsIGF2b2lkIGVtaXR0aW5nIGludGVybGVhdmluZyBsaW5lcyBhbmQgcG9seWdvbnMuXG4gICAgZnVuY3Rpb24gbXVsdGlwbGV4JDMoc3RyZWFtcykge1xuICAgICAgICB2YXIgbiA9IHN0cmVhbXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHNwaGVyZTogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0uc3BoZXJlKCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZUVuZCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICAgIH0gfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBIGNvbXBvc2l0ZSBwcm9qZWN0aW9uIGZvciBQb3J0dWdhbCwgY29uZmlndXJlZCBieSBkZWZhdWx0IGZvciA5NjDDlzUwMC5cbiAgICBmdW5jdGlvbiBjb25pY0NvbmZvcm1hbFBvcnR1Z2FsKCkge1xuICAgICAgICB2YXIgY2FjaGUsIGNhY2hlU3RyZWFtLCBpYmVyaWFuUGVuaW5zdWxlID0gZDNHZW8uZ2VvQ29uaWNDb25mb3JtYWwoKS5yb3RhdGUoWzEwLCAtMzkuM10pLnBhcmFsbGVscyhbMCwgNjBdKSwgaWJlcmlhblBlbmluc3VsZVBvaW50LCBtYWRlaXJhID0gZDNHZW8uZ2VvQ29uaWNDb25mb3JtYWwoKS5yb3RhdGUoWzE3LCAtMzIuN10pLnBhcmFsbGVscyhbMCwgNjBdKSwgbWFkZWlyYVBvaW50LCBhem9yZXMgPSBkM0dlby5nZW9Db25pY0NvbmZvcm1hbCgpLnJvdGF0ZShbMjcuOCwgLTM4LjZdKS5wYXJhbGxlbHMoWzAsIDYwXSksIGF6b3Jlc1BvaW50LCBwb2ludCwgcG9pbnRTdHJlYW0gPSB7IHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyBwb2ludCA9IFt4LCB5XTsgfSB9O1xuICAgICAgICAvKlxuICAgICAgICB2YXIgaWJlcmlhblBlbmluc3VsZUJib3ggPSBbWy0xMSwgNDZdLCBbNCwgMzRdXTtcbiAgICAgICAgdmFyIG1hZGVpcmFCYm94ID0gW1stMTcuODUsIDMzLjZdLCBbLTE2LCAzMi4wMl1dO1xuICAgICAgICB2YXIgYXpvcmVzQmJveCA9IFtbLTMyLCA0MC41MjldLCBbLTIzLjk4LCAzNS43NV1dO1xuICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjb25pY0NvbmZvcm1hbFBvcnR1Z2FsKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGNvb3JkaW5hdGVzWzBdLCB5ID0gY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQgPSBudWxsLFxuICAgICAgICAgICAgICAgIChpYmVyaWFuUGVuaW5zdWxlUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAobWFkZWlyYVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGF6b3Jlc1BvaW50LnBvaW50KHgsIHkpLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uaWNDb25mb3JtYWxQb3J0dWdhbC5pbnZlcnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciBrID0gaWJlcmlhblBlbmluc3VsZS5zY2FsZSgpLCB0ID0gaWJlcmlhblBlbmluc3VsZS50cmFuc2xhdGUoKSwgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gaywgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAvL0hvdyBhcmUgdGhlIHJldHVybiB2YWx1ZXMgY2FsY3VsYXRlZDpcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKlwiKTtcbiAgICAgICAgICAgIHZhciBjMCA9IG1hZGVpcmEobWFkZWlyYUJib3hbMF0pO1xuICAgICAgICAgICAgdmFyIHgwID0gKGMwWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgdmFyIHkwID0gKGMwWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDAgbWFkZWlyYVwiLCB4MCArICcgLSAnICsgeTApO1xuICAgIFxuICAgICAgICAgICAgdmFyIGMxID0gbWFkZWlyYShtYWRlaXJhQmJveFsxXSk7XG4gICAgICAgICAgICB2YXIgeDEgPSAoYzFbMF0gLSB0WzBdKSAvIGs7XG4gICAgICAgICAgICB2YXIgeTEgPSAoYzFbMV0gLSB0WzFdKSAvIGs7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJwMSBtYWRlaXJhXCIsIHgxICsgJyAtICcgKyB5MSk7XG4gICAgXG4gICAgICAgICAgICBjMCA9IGF6b3Jlcyhhem9yZXNCYm94WzBdKTtcbiAgICAgICAgICAgIHgwID0gKGMwWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgeTAgPSAoYzBbMV0gLSB0WzFdKSAvIGs7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJwMCBhem9yZXNcIiwgeDAgKyAnIC0gJyArIHkwKTtcbiAgICBcbiAgICAgICAgICAgIGMxID0gYXpvcmVzKGF6b3Jlc0Jib3hbMV0pO1xuICAgICAgICAgICAgeDEgPSAoYzFbMF0gLSB0WzBdKSAvIGs7XG4gICAgICAgICAgICB5MSA9IChjMVsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAxIGF6b3Jlc1wiLCB4MSArICcgLSAnICsgeTEpO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiAoeSA+PSAwLjAwOTMgJiYgeSA8IDAuMDM2NzggJiYgeCA+PSAtMC4wMzg3NSAmJiB4IDwgLTAuMDExNiA/IG1hZGVpcmFcbiAgICAgICAgICAgICAgICA6IHkgPj0gLTAuMDQxMiAmJiB5IDwgMC4wMDkxICYmIHggPj0gLTAuMDc3ODIgJiYgeCA8IC0wLjAxMTY2ID8gYXpvcmVzXG4gICAgICAgICAgICAgICAgICAgIDogaWJlcmlhblBlbmluc3VsZSkuaW52ZXJ0KGNvb3JkaW5hdGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxQb3J0dWdhbC5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBtdWx0aXBsZXgkMyhbaWJlcmlhblBlbmluc3VsZS5zdHJlYW0oY2FjaGVTdHJlYW0gPSBzdHJlYW0pLCBtYWRlaXJhLnN0cmVhbShzdHJlYW0pLCBhem9yZXMuc3RyZWFtKHN0cmVhbSldKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxQb3J0dWdhbC5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGliZXJpYW5QZW5pbnN1bGUucHJlY2lzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpYmVyaWFuUGVuaW5zdWxlLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIG1hZGVpcmEucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgYXpvcmVzLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbFBvcnR1Z2FsLnNjYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpYmVyaWFuUGVuaW5zdWxlLnNjYWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpYmVyaWFuUGVuaW5zdWxlLnNjYWxlKF8pO1xuICAgICAgICAgICAgbWFkZWlyYS5zY2FsZShfKTtcbiAgICAgICAgICAgIGF6b3Jlcy5zY2FsZShfICogMC42KTtcbiAgICAgICAgICAgIHJldHVybiBjb25pY0NvbmZvcm1hbFBvcnR1Z2FsLnRyYW5zbGF0ZShpYmVyaWFuUGVuaW5zdWxlLnRyYW5zbGF0ZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxQb3J0dWdhbC50cmFuc2xhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGliZXJpYW5QZW5pbnN1bGUudHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgayA9IGliZXJpYW5QZW5pbnN1bGUuc2NhbGUoKSwgeCA9ICtfWzBdLCB5ID0gK19bMV07XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgdmFyIGMwID0gaWJlcmlhblBlbmluc3VsZShpYmVyaWFuUGVuaW5zdWxlQmJveFswXSk7XG4gICAgICAgICAgIHZhciB4MCA9ICh4IC0gYzBbMF0pIC8gaztcbiAgICAgICAgICAgdmFyIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgdmFyIGMxID0gaWJlcmlhblBlbmluc3VsZShpYmVyaWFuUGVuaW5zdWxlQmJveFsxXSk7XG4gICAgICAgICAgIHZhciB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgdmFyIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgY29uc29sZS5pbmZvKCdJYmVyaWFuIFBlbmluc3VsYTogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgIGNvbnNvbGUuaW5mbygnLmNsaXBFeHRlbnQoW1t4ICcrXG4gICAgICAgICAgICAoeDA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogaywgeSAnK1xuICAgICAgICAgICAgKHkwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGtdLFt4ICcrXG4gICAgICAgICAgICAoeDE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogaywgeSAnK1xuICAgICAgICAgICAgKHkxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGtdXSknKTtcbiAgICAgICAgXG4gICAgICAgICAgIGMwID0gbWFkZWlyYS50cmFuc2xhdGUoW3ggLSAwLjAyNjUgKiBrLCB5ICsgMC4wMjUgKiBrXSkobWFkZWlyYUJib3hbMF0pO1xuICAgICAgICAgICB4MCA9ICh4IC0gYzBbMF0pIC8gaztcbiAgICAgICAgICAgeTAgPSAoeSAtIGMwWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICBjMSA9IG1hZGVpcmEudHJhbnNsYXRlKFt4IC0gMC4wMjY1ICogaywgeSArIDAuMDI1ICoga10pKG1hZGVpcmFCYm94WzFdKTtcbiAgICAgICAgICAgeDEgPSAoeCAtIGMxWzBdKSAvIGs7XG4gICAgICAgICAgIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgY29uc29sZS5pbmZvKCdNYWRlaXJhOiBwMDogJyArIHgwICsgJywgJyArIHkwICsgJyAsIHAxOiAnICsgeDEgKyAnIC0gJyArIHkxKTtcbiAgICAgICAgICAgY29uc29sZS5pbmZvKCcuY2xpcEV4dGVudChbW3ggJytcbiAgICAgICAgICAgICh4MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrICsgZXBzaWxvbiwgeSAnK1xuICAgICAgICAgICAgKHkwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uXSxbeCAnK1xuICAgICAgICAgICAgKHgxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAoeTE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogayAtIGVwc2lsb25dXSknKTtcbiAgICAgICAgXG4gICAgICAgICAgICBjMCA9IGF6b3Jlcy50cmFuc2xhdGUoW3ggLSAwLjA0NSAqIGssIHkgKyAtMC4wMiAqIGtdKShhem9yZXNCYm94WzBdKTtcbiAgICAgICAgICAgIHgwID0gKHggLSBjMFswXSkgLyBrO1xuICAgICAgICAgICAgeTAgPSAoeSAtIGMwWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICAgYzEgPSBhem9yZXMudHJhbnNsYXRlKFt4IC0gMC4wNDUgKiBrLCB5ICsgLTAuMDIgKiBrXSkoYXpvcmVzQmJveFsxXSk7XG4gICAgICAgICAgICB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnQXpvcmVzOiBwMDogJyArIHgwICsgJywgJyArIHkwICsgJyAsIHAxOiAnICsgeDEgKyAnIC0gJyArIHkxKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnLmNsaXBFeHRlbnQoW1t4ICcrXG4gICAgICAgICAgICAgKHgwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgICcgKiBrICsgZXBzaWxvbiwgeSAnK1xuICAgICAgICAgICAgICh5MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAnICogayArIGVwc2lsb25dLFt4ICcrXG4gICAgICAgICAgICAgKHgxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbiwgeSAnK1xuICAgICAgICAgICAgICh5MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAnICogayAtIGVwc2lsb25dXSknKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWJlcmlhblBlbmluc3VsZVBvaW50ID0gaWJlcmlhblBlbmluc3VsZVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoXylcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjAxMTUgKiBrLCB5IC0gMC4xMTM4ICoga10sIFt4ICsgMC4yMTA1ICogaywgeSArIDAuMDY3MyAqIGtdXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIG1hZGVpcmFQb2ludCA9IG1hZGVpcmFcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4wMjY1ICogaywgeSArIDAuMDI1ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4wMzg4ICogayArIGVwc2lsb24sIHkgKyAwLjAwOTMgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4wMTE2ICogayAtIGVwc2lsb24sIHkgKyAwLjAzNjggKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgYXpvcmVzUG9pbnQgPSBhem9yZXNcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4wNDUgKiBrLCB5ICsgLTAuMDIgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjA3NzggKiBrICsgZXBzaWxvbiwgeSAtIDAuMDQxMyAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjAxMTcgKiBrIC0gZXBzaWxvbiwgeSArIDAuMDA5MSAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxQb3J0dWdhbC5maXRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQoY29uaWNDb25mb3JtYWxQb3J0dWdhbCwgZXh0ZW50LCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbFBvcnR1Z2FsLmZpdFNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0U2l6ZShjb25pY0NvbmZvcm1hbFBvcnR1Z2FsLCBzaXplLCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmljQ29uZm9ybWFsUG9ydHVnYWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uaWNDb25mb3JtYWxQb3J0dWdhbC5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJDTElQIEVYVEVOVCBNQURFSVJBOiBcIiwgbWFkZWlyYS5jbGlwRXh0ZW50KCkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVUwgQkJPWDpcIiwgaWJlcmlhblBlbmluc3VsZS5pbnZlcnQoW21hZGVpcmEuY2xpcEV4dGVudCgpWzBdWzBdLCBtYWRlaXJhLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVSIEJCT1g6XCIsIGliZXJpYW5QZW5pbnN1bGUuaW52ZXJ0KFttYWRlaXJhLmNsaXBFeHRlbnQoKVsxXVswXSwgbWFkZWlyYS5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMRCBCQk9YOlwiLCBpYmVyaWFuUGVuaW5zdWxlLmludmVydChbbWFkZWlyYS5jbGlwRXh0ZW50KClbMV1bMF0sIG1hZGVpcmEuY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEwgQkJPWDpcIiwgaWJlcmlhblBlbmluc3VsZS5pbnZlcnQoW21hZGVpcmEuY2xpcEV4dGVudCgpWzBdWzBdLCBtYWRlaXJhLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJDTElQIEVYVEVOVCBBWk9SRVM6IFwiLCBhem9yZXMuY2xpcEV4dGVudCgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVMIEJCT1g6XCIsIGliZXJpYW5QZW5pbnN1bGUuaW52ZXJ0KFthem9yZXMuY2xpcEV4dGVudCgpWzBdWzBdLCBhem9yZXMuY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVVIgQkJPWDpcIiwgaWJlcmlhblBlbmluc3VsZS5pbnZlcnQoW2F6b3Jlcy5jbGlwRXh0ZW50KClbMV1bMF0sIGF6b3Jlcy5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMRCBCQk9YOlwiLCBpYmVyaWFuUGVuaW5zdWxlLmludmVydChbYXpvcmVzLmNsaXBFeHRlbnQoKVsxXVswXSwgYXpvcmVzLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxMIEJCT1g6XCIsIGliZXJpYW5QZW5pbnN1bGUuaW52ZXJ0KFthem9yZXMuY2xpcEV4dGVudCgpWzBdWzBdLCBhem9yZXMuY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciB1bG1hZGVpcmEgPSBpYmVyaWFuUGVuaW5zdWxlKFstMTIuODM1MSwgMzguNzExM10pO1xuICAgICAgICAgICAgdmFyIHVybWFkZWlyYSA9IGliZXJpYW5QZW5pbnN1bGUoWy0xMC44NDgyLCAzOC43NjMzXSk7XG4gICAgICAgICAgICB2YXIgbGRtYWRlaXJhID0gaWJlcmlhblBlbmluc3VsZShbLTEwLjgxODEsIDM3LjIwNzJdKTtcbiAgICAgICAgICAgIHZhciBsbG1hZGVpcmEgPSBpYmVyaWFuUGVuaW5zdWxlKFstMTIuNzM0NSwgMzcuMTU3M10pO1xuICAgICAgICAgICAgdmFyIHVsYXpvcmVzID0gaWJlcmlhblBlbmluc3VsZShbLTE2LjA3NTMsIDQxLjQ0MzZdKTtcbiAgICAgICAgICAgIHZhciB1cmF6b3JlcyA9IGliZXJpYW5QZW5pbnN1bGUoWy0xMC45MTY4LCA0MS42ODYxXSk7XG4gICAgICAgICAgICB2YXIgbGRhem9yZXMgPSBpYmVyaWFuUGVuaW5zdWxlKFstMTAuODU1NywgMzguNzc0N10pO1xuICAgICAgICAgICAgdmFyIGxsYXpvcmVzID0gaWJlcmlhblBlbmluc3VsZShbLTE1LjY3MjgsIDM4LjU1MDVdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsbWFkZWlyYVswXSwgdWxtYWRlaXJhWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVybWFkZWlyYVswXSwgdXJtYWRlaXJhWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkbWFkZWlyYVswXSwgbGRtYWRlaXJhWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkbWFkZWlyYVswXSwgbGRtYWRlaXJhWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsbWFkZWlyYVswXSwgbGxtYWRlaXJhWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bGF6b3Jlc1swXSwgdWxhem9yZXNbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJhem9yZXNbMF0sIHVyYXpvcmVzWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkYXpvcmVzWzBdLCBsZGF6b3Jlc1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZGF6b3Jlc1swXSwgbGRhem9yZXNbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxhem9yZXNbMF0sIGxsYXpvcmVzWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsUG9ydHVnYWwuZ2V0Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBkM1BhdGgucGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzKGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbmljQ29uZm9ybWFsUG9ydHVnYWwuc2NhbGUoNDIwMCk7XG4gICAgfVxuICAgIC8vIFRoZSBwcm9qZWN0aW9ucyBtdXN0IGhhdmUgbXV0dWFsbHkgZXhjbHVzaXZlIGNsaXAgcmVnaW9ucyBvbiB0aGUgc3BoZXJlLFxuICAgIC8vIGFzIHRoaXMgd2lsbCBhdm9pZCBlbWl0dGluZyBpbnRlcmxlYXZpbmcgbGluZXMgYW5kIHBvbHlnb25zLlxuICAgIGZ1bmN0aW9uIG11bHRpcGxleCQ0KHN0cmVhbXMpIHtcbiAgICAgICAgdmFyIG4gPSBzdHJlYW1zLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnNwaGVyZSgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICB9IH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQSBjb21wb3NpdGUgcHJvamVjdGlvbiBmb3IgRWN1YWRvciwgY29uZmlndXJlZCBieSBkZWZhdWx0IGZvciA5NjDDlzUwMC5cbiAgICBmdW5jdGlvbiBtZXJjYXRvckVjdWFkb3IoKSB7XG4gICAgICAgIHZhciBjYWNoZSwgY2FjaGVTdHJlYW0sIG1haW5sYW5kID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5yb3RhdGUoWzgwLCAxLjVdKSwgbWFpbmxhbmRQb2ludCwgZ2FsYXBhZ29zID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5yb3RhdGUoWzkwLjczLCAxXSksIGdhbGFwYWdvc1BvaW50LCBwb2ludCwgcG9pbnRTdHJlYW0gPSB7IHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyBwb2ludCA9IFt4LCB5XTsgfSB9O1xuICAgICAgICAvKlxuICAgICAgICB2YXIgbWFpbmxhbmRCYm94ID0gW1stODEuNSwgMi43XSwgWy03MC4wLCAtNi4wXV07XG4gICAgICAgIHZhciBnYWxhcGFnb3NCYm94ID0gW1stOTIuMiwgMC41OF0sIFstODguOCwgLTEuOF1dO1xuICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBtZXJjYXRvckVjdWFkb3IoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludCA9IG51bGwsXG4gICAgICAgICAgICAgICAgKG1haW5sYW5kUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoZ2FsYXBhZ29zUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBtZXJjYXRvckVjdWFkb3IuaW52ZXJ0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgayA9IG1haW5sYW5kLnNjYWxlKCksIHQgPSBtYWlubGFuZC50cmFuc2xhdGUoKSwgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gaywgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAvL0hvdyBhcmUgdGhlIHJldHVybiB2YWx1ZXMgY2FsY3VsYXRlZDpcbiAgICAgICAgICAgIHZhciBjMCA9IGdhbGFwYWdvcyhnYWxhcGFnb3NCYm94WzBdKTtcbiAgICAgICAgICAgIHZhciB4MCA9IChjMFswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHZhciB5MCA9IChjMFsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAwIGdhbGFwYWdvc1wiLCB4MCArICcgLSAnICsgeTApO1xuICAgIFxuICAgIFxuICAgICAgICAgICAgdmFyIGMxID0gZ2FsYXBhZ29zKGdhbGFwYWdvc0Jib3hbMV0pO1xuICAgICAgICAgICAgdmFyIHgxID0gKGMxWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgdmFyIHkxID0gKGMxWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDEgZ2FsYXBhZ29zXCIsIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuICh5ID49IC0wLjA2NzYgJiYgeSA8IC0wLjAyNiAmJiB4ID49IC0wLjA4NTcgJiYgeCA8IC0wLjAyNjMgPyBnYWxhcGFnb3NcbiAgICAgICAgICAgICAgICA6IG1haW5sYW5kKS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBtZXJjYXRvckVjdWFkb3Iuc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gbXVsdGlwbGV4JDQoW21haW5sYW5kLnN0cmVhbShjYWNoZVN0cmVhbSA9IHN0cmVhbSksIGdhbGFwYWdvcy5zdHJlYW0oc3RyZWFtKV0pO1xuICAgICAgICB9O1xuICAgICAgICBtZXJjYXRvckVjdWFkb3IucHJlY2lzaW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWlubGFuZC5wcmVjaXNpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1haW5sYW5kLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGdhbGFwYWdvcy5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVyY2F0b3JFY3VhZG9yLnNjYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWlubGFuZC5zY2FsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFpbmxhbmQuc2NhbGUoXyk7XG4gICAgICAgICAgICBnYWxhcGFnb3Muc2NhbGUoXyk7XG4gICAgICAgICAgICByZXR1cm4gbWVyY2F0b3JFY3VhZG9yLnRyYW5zbGF0ZShtYWlubGFuZC50cmFuc2xhdGUoKSk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yRWN1YWRvci50cmFuc2xhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW5sYW5kLnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGsgPSBtYWlubGFuZC5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICB2YXIgYzAgPSBtYWlubGFuZChtYWlubGFuZEJib3hbMF0pO1xuICAgICAgICAgICB2YXIgeDAgPSAoeCAtIGMwWzBdKSAvIGs7XG4gICAgICAgICAgIHZhciB5MCA9ICh5IC0gYzBbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgIHZhciBjMSA9IG1haW5sYW5kKG1haW5sYW5kQmJveFsxXSk7XG4gICAgICAgICAgIHZhciB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgdmFyIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgY29uc29sZS5pbmZvKCdtYWlubGFuZDogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgIGNvbnNvbGUuaW5mbygnLmNsaXBFeHRlbnQoW1t4ICcrXG4gICAgICAgICAgICAoeDA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogaywgeSAnK1xuICAgICAgICAgICAgKHkwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGtdLFt4ICcrXG4gICAgICAgICAgICAoeDE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogaywgeSAnK1xuICAgICAgICAgICAgKHkxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGtdXSknKTtcbiAgICAgICAgXG4gICAgICAgICAgIGMwID0gZ2FsYXBhZ29zLnRyYW5zbGF0ZShbeCAtIDAuMDYgKiBrLCB5IC0gMC4wNCAqIGtdKShnYWxhcGFnb3NCYm94WzBdKTtcbiAgICAgICAgICAgeDAgPSAoeCAtIGMwWzBdKSAvIGs7XG4gICAgICAgICAgIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgYzEgPSBnYWxhcGFnb3MudHJhbnNsYXRlKFt4IC0gMC4wNiAqIGssIHkgLSAwLjA0ICoga10pKGdhbGFwYWdvc0Jib3hbMV0pO1xuICAgICAgICAgICB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgeTEgPSAoeSAtIGMxWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICBjb25zb2xlLmluZm8oJ2dhbGFwYWdvczogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgIGNvbnNvbGUuaW5mbygnLmNsaXBFeHRlbnQoW1t4ICcrXG4gICAgICAgICAgICAoeDA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogayArIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICh5MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrICsgZXBzaWxvbl0sW3ggJytcbiAgICAgICAgICAgICh4MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbiwgeSAnK1xuICAgICAgICAgICAgKHkxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uXV0pJyk7Ki9cbiAgICAgICAgICAgIG1haW5sYW5kUG9pbnQgPSBtYWlubGFuZFxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoXylcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjAyNjIgKiBrLCB5IC0gMC4wNzM0ICoga10sIFt4ICsgMC4xNzQxICogaywgeSArIDAuMDc5ICoga11dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgZ2FsYXBhZ29zUG9pbnQgPSBnYWxhcGFnb3NcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4wNiAqIGssIHkgLSAwLjA0ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4wODU3ICogayArIGVwc2lsb24sIHkgLSAwLjA2NzYgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4wMjYzICogayAtIGVwc2lsb24sIHkgLSAwLjAyNiAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVyY2F0b3JFY3VhZG9yLmZpdEV4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdEV4dGVudChtZXJjYXRvckVjdWFkb3IsIGV4dGVudCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVyY2F0b3JFY3VhZG9yLmZpdFNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0U2l6ZShtZXJjYXRvckVjdWFkb3IsIHNpemUsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gbWVyY2F0b3JFY3VhZG9yO1xuICAgICAgICB9XG4gICAgICAgIG1lcmNhdG9yRWN1YWRvci5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJDTElQIEVYVEVOVDogXCIsIGdhbGFwYWdvcy5jbGlwRXh0ZW50KCkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVUwgQkJPWDpcIiwgbWFpbmxhbmQuaW52ZXJ0KFtnYWxhcGFnb3MuY2xpcEV4dGVudCgpWzBdWzBdLCBnYWxhcGFnb3MuY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVVIgQkJPWDpcIiwgbWFpbmxhbmQuaW52ZXJ0KFtnYWxhcGFnb3MuY2xpcEV4dGVudCgpWzFdWzBdLCBnYWxhcGFnb3MuY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEQgQkJPWDpcIiwgbWFpbmxhbmQuaW52ZXJ0KFtnYWxhcGFnb3MuY2xpcEV4dGVudCgpWzFdWzBdLCBnYWxhcGFnb3MuY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEwgQkJPWDpcIiwgbWFpbmxhbmQuaW52ZXJ0KFtnYWxhcGFnb3MuY2xpcEV4dGVudCgpWzBdWzBdLCBnYWxhcGFnb3MuY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciB1bGdhbGFwYWdvcyA9IG1haW5sYW5kKFstODQuOTAzMiwgMi4zNzU3XSk7XG4gICAgICAgICAgICB2YXIgdXJnYWxhcGFnb3MgPSBtYWlubGFuZChbLTgxLjUwNDcsIDIuMzcwOF0pO1xuICAgICAgICAgICAgdmFyIGxkZ2FsYXBhZ29zID0gbWFpbmxhbmQoWy04MS41MDYzLCAtMC4wMV0pO1xuICAgICAgICAgICAgdmFyIGxsZ2FsYXBhZ29zID0gbWFpbmxhbmQoWy04NC45MDg2LCAtMC4wMDVdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsZ2FsYXBhZ29zWzBdLCB1bGdhbGFwYWdvc1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1cmdhbGFwYWdvc1swXSwgdXJnYWxhcGFnb3NbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRnYWxhcGFnb3NbMF0sIGxkZ2FsYXBhZ29zWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsZ2FsYXBhZ29zWzBdLCBsbGdhbGFwYWdvc1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9O1xuICAgICAgICBtZXJjYXRvckVjdWFkb3IuZ2V0Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBkM1BhdGgucGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzKGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1lcmNhdG9yRWN1YWRvci5zY2FsZSgzNTAwKTtcbiAgICB9XG4gICAgLy8gVGhlIHByb2plY3Rpb25zIG11c3QgaGF2ZSBtdXR1YWxseSBleGNsdXNpdmUgY2xpcCByZWdpb25zIG9uIHRoZSBzcGhlcmUsXG4gICAgLy8gYXMgdGhpcyB3aWxsIGF2b2lkIGVtaXR0aW5nIGludGVybGVhdmluZyBsaW5lcyBhbmQgcG9seWdvbnMuXG4gICAgZnVuY3Rpb24gbXVsdGlwbGV4JDUoc3RyZWFtcykge1xuICAgICAgICB2YXIgbiA9IHN0cmVhbXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHNwaGVyZTogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0uc3BoZXJlKCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZUVuZCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICAgIH0gfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBIGNvbXBvc2l0ZSBwcm9qZWN0aW9uIGZvciBDaGlsZSwgY29uZmlndXJlZCBieSBkZWZhdWx0IGZvciA5NjDDlzUwMC5cbiAgICBmdW5jdGlvbiB0cmFuc3ZlcnNlTWVyY2F0b3JDaGlsZSgpIHtcbiAgICAgICAgdmFyIGNhY2hlLCBjYWNoZVN0cmVhbSwgbWFpbmxhbmQgPSBkM0dlby5nZW9UcmFuc3ZlcnNlTWVyY2F0b3IoKS5yb3RhdGUoWzcyLCAzN10pLCBtYWlubGFuZFBvaW50LCBhbnRhcmN0aWMgPSBkM0dlby5nZW9TdGVyZW9ncmFwaGljKCkucm90YXRlKFs3MiwgMF0pLCBhbnRhcmN0aWNQb2ludCwganVhbkZlcm5hbmRleiA9IGQzR2VvLmdlb01lcmNhdG9yKCkucm90YXRlKFs4MCwgMzMuNV0pLCBqdWFuRmVybmFuZGV6UG9pbnQsIHBhc2N1YSA9IGQzR2VvLmdlb01lcmNhdG9yKCkucm90YXRlKFsxMTAsIDI1XSksIHBhc2N1YVBvaW50LCBwb2ludCwgcG9pbnRTdHJlYW0gPSB7IHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyBwb2ludCA9IFt4LCB5XTsgfSB9O1xuICAgICAgICAvKlxuICAgICAgICB2YXIgbWFpbmxhbmRCYm94ID0gW1stNzUuNSwgLTE1LjBdLCBbLTMyLCAtNDkuMF1dO1xuICAgICAgICB2YXIgYW50YXJjdGljQmJveCA9IFtbLTkxLjAsIC02MC4wXSwgWy00My4wLCAtOTAuMF1dO1xuICAgICAgICB2YXIganVhbkZlcm5hbmRlekJib3ggPSBbWy04MS4wLCAtMzMuMF0sIFstNzguNSwgLTM0LjBdXTtcbiAgICAgICAgdmFyIHBhc2N1YUJib3ggPSBbWy0xMTAsIC0yNi42XSwgWy0xMDguNywgLTI3LjVdXTtcbiAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gdHJhbnN2ZXJzZU1lcmNhdG9yQ2hpbGUoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludCA9IG51bGwsXG4gICAgICAgICAgICAgICAgKG1haW5sYW5kUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoYW50YXJjdGljUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoanVhbkZlcm5hbmRlelBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHBhc2N1YVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnN2ZXJzZU1lcmNhdG9yQ2hpbGUuaW52ZXJ0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgayA9IG1haW5sYW5kLnNjYWxlKCksIHQgPSBtYWlubGFuZC50cmFuc2xhdGUoKSwgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gaywgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAvL0hvdyBhcmUgdGhlIHJldHVybiB2YWx1ZXMgY2FsY3VsYXRlZDpcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIioqKioqKlwiKTtcbiAgICAgICAgICAgIHZhciBjMCA9IGFudGFyY3RpYyhhbnRhcmN0aWNCYm94WzBdKTtcbiAgICAgICAgICAgIHZhciB4MCA9IChjMFswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHZhciB5MCA9IChjMFsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAwIGFudGFyY3RpY1wiLCB4MCArICcgLSAnICsgeTApO1xuICAgIFxuICAgICAgICAgICAgdmFyIGMxID0gYW50YXJjdGljKGFudGFyY3RpY0Jib3hbMV0pO1xuICAgICAgICAgICAgdmFyIHgxID0gKGMxWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgdmFyIHkxID0gKGMxWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDEgYW50YXJjdGljXCIsIHgxICsgJyAtICcgKyB5MSk7XG4gICAgXG4gICAgICAgICAgICBjMCA9IGp1YW5GZXJuYW5kZXooanVhbkZlcm5hbmRlekJib3hbMF0pO1xuICAgICAgICAgICAgeDAgPSAoYzBbMF0gLSB0WzBdKSAvIGs7XG4gICAgICAgICAgICB5MCA9IChjMFsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAwIGp1YW5GZXJuYW5kZXpcIiwgeDAgKyAnIC0gJyArIHkwKTtcbiAgICBcbiAgICAgICAgICAgIGMxID0ganVhbkZlcm5hbmRleihqdWFuRmVybmFuZGV6QmJveFsxXSk7XG4gICAgICAgICAgICB4MSA9IChjMVswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHkxID0gKGMxWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDEganVhbkZlcm5hbmRlelwiLCB4MSArICcgLSAnICsgeTEpO1xuICAgIFxuICAgICAgICAgICAgYzAgPSBwYXNjdWEocGFzY3VhQmJveFswXSk7XG4gICAgICAgICAgICB4MCA9IChjMFswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHkwID0gKGMwWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDAgcGFzY3VhXCIsIHgwICsgJyAtICcgKyB5MCk7XG4gICAgXG4gICAgICAgICAgICBjMSA9IHBhc2N1YShwYXNjdWFCYm94WzFdKTtcbiAgICAgICAgICAgIHgxID0gKGMxWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgeTEgPSAoYzFbMV0gLSB0WzFdKSAvIGs7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJwMSBwYXNjdWFcIiwgeDEgKyAnIC0gJyArIHkxKTtcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gKHkgPj0gMC4yNTgyICYmIHkgPCAwLjMyICYmIHggPj0gLTAuMTAzNiAmJiB4IDwgLTAuMDg3ID8gYW50YXJjdGljXG4gICAgICAgICAgICAgICAgOiB5ID49IC0wLjAxMjk4ICYmIHkgPCAwLjAxMzMgJiYgeCA+PSAtMC4xMTM5NiAmJiB4IDwgLTAuMDU5NDQgPyBqdWFuRmVybmFuZGV6XG4gICAgICAgICAgICAgICAgICAgIDogeSA+PSAwLjAxNTM5ICYmIHkgPCAwLjAzOTExICYmIHggPj0gLTAuMDg5ICYmIHggPCAtMC4wNTg4ID8gcGFzY3VhXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG1haW5sYW5kKS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgICAgICB9O1xuICAgICAgICB0cmFuc3ZlcnNlTWVyY2F0b3JDaGlsZS5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBtdWx0aXBsZXgkNShbbWFpbmxhbmQuc3RyZWFtKGNhY2hlU3RyZWFtID0gc3RyZWFtKSwgYW50YXJjdGljLnN0cmVhbShzdHJlYW0pLCBqdWFuRmVybmFuZGV6LnN0cmVhbShzdHJlYW0pLCBwYXNjdWEuc3RyZWFtKHN0cmVhbSldKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnN2ZXJzZU1lcmNhdG9yQ2hpbGUucHJlY2lzaW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWlubGFuZC5wcmVjaXNpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1haW5sYW5kLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGFudGFyY3RpYy5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBqdWFuRmVybmFuZGV6LnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHBhc2N1YS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnN2ZXJzZU1lcmNhdG9yQ2hpbGUuc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW5sYW5kLnNjYWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWlubGFuZC5zY2FsZShfKTtcbiAgICAgICAgICAgIGFudGFyY3RpYy5zY2FsZShfICogMC4xNSk7XG4gICAgICAgICAgICBqdWFuRmVybmFuZGV6LnNjYWxlKF8gKiAxLjUpO1xuICAgICAgICAgICAgcGFzY3VhLnNjYWxlKF8gKiAxLjUpO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zdmVyc2VNZXJjYXRvckNoaWxlLnRyYW5zbGF0ZShtYWlubGFuZC50cmFuc2xhdGUoKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zdmVyc2VNZXJjYXRvckNoaWxlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbmxhbmQudHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgayA9IG1haW5sYW5kLnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIHZhciBjMCA9IG1haW5sYW5kKG1haW5sYW5kQmJveFswXSk7XG4gICAgICAgICAgIHZhciB4MCA9ICh4IC0gYzBbMF0pIC8gaztcbiAgICAgICAgICAgdmFyIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgdmFyIGMxID0gbWFpbmxhbmQobWFpbmxhbmRCYm94WzFdKTtcbiAgICAgICAgICAgdmFyIHgxID0gKHggLSBjMVswXSkgLyBrO1xuICAgICAgICAgICB2YXIgeTEgPSAoeSAtIGMxWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICBjb25zb2xlLmluZm8oJ01haW5sYW5kOiBwMDogJyArIHgwICsgJywgJyArIHkwICsgJyAsIHAxOiAnICsgeDEgKyAnIC0gJyArIHkxKTtcbiAgICAgICAgICAgY29uc29sZS5pbmZvKCcuY2xpcEV4dGVudChbW3ggJytcbiAgICAgICAgICAgICh4MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrLCB5ICcrXG4gICAgICAgICAgICAoeTA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICoga10sW3ggJytcbiAgICAgICAgICAgICh4MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrLCB5ICcrXG4gICAgICAgICAgICAoeTE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICoga11dKScpO1xuICAgICAgICBcbiAgICAgICAgICAgYzAgPSBhbnRhcmN0aWMudHJhbnNsYXRlKFt4IC0gMC4xICogaywgeSArIDAuMTcgKiBrXSkoYW50YXJjdGljQmJveFswXSk7XG4gICAgICAgICAgIHgwID0gKHggLSBjMFswXSkgLyBrO1xuICAgICAgICAgICB5MCA9ICh5IC0gYzBbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgIGMxID0gYW50YXJjdGljLnRyYW5zbGF0ZShbeCAtIDAuMSAqIGssIHkgKyAwLjE3ICoga10pKGFudGFyY3RpY0Jib3hbMV0pO1xuICAgICAgICAgICB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgeTEgPSAoeSAtIGMxWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICBjb25zb2xlLmluZm8oJ2FudGFyY3RpYzogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgIGNvbnNvbGUuaW5mbygnRG9lc24gdCB3b3JrIGR1ZSB0byAtOTAgbGF0aXR1ZGUhJyArICcuY2xpcEV4dGVudChbW3ggJytcbiAgICAgICAgICAgICh4MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrICsgZXBzaWxvbiwgeSAnK1xuICAgICAgICAgICAgKHkwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uXSxbeCAnK1xuICAgICAgICAgICAgKHgxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAoeTE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogayAtIGVwc2lsb25dXSknKTtcbiAgICAgICAgXG4gICAgICAgICAgICBjMCA9IGp1YW5GZXJuYW5kZXoudHJhbnNsYXRlKFt4IC0gMC4wOTIgKiBrLCB5IC0wICoga10pKGp1YW5GZXJuYW5kZXpCYm94WzBdKTtcbiAgICAgICAgICAgIHgwID0gKHggLSBjMFswXSkgLyBrO1xuICAgICAgICAgICAgeTAgPSAoeSAtIGMwWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICAgYzEgPSBqdWFuRmVybmFuZGV6LnRyYW5zbGF0ZShbeCAtIDAuMDkyICogaywgeSAtMCAqIGtdKShqdWFuRmVybmFuZGV6QmJveFsxXSk7XG4gICAgICAgICAgICB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnanVhbkZlcm5hbmRlejogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJy5jbGlwRXh0ZW50KFtbeCAnK1xuICAgICAgICAgICAgICh4MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAnICogayArIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICAoeTA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uXSxbeCAnK1xuICAgICAgICAgICAgICh4MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAnICogayAtIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICAoeTE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uXV0pJyk7XG4gICAgICAgIFxuICAgICAgICAgICAgIGMwID0gcGFzY3VhLnRyYW5zbGF0ZShbeCAtIDAuMDg5ICogaywgeSAtMC4wMjY1ICoga10pKHBhc2N1YUJib3hbMF0pO1xuICAgICAgICAgICAgIHgwID0gKHggLSBjMFswXSkgLyBrO1xuICAgICAgICAgICAgIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgICBjMSA9IHBhc2N1YS50cmFuc2xhdGUoW3ggLSAwLjA4OSAqIGssIHkgLTAuMDI2NSAqIGtdKShwYXNjdWFCYm94WzFdKTtcbiAgICAgICAgICAgICB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgICB5MSA9ICh5IC0gYzFbMV0pIC8gaztcbiAgICAgICAgXG4gICAgICAgICAgICAgY29uc29sZS5pbmZvKCdwYXNjdWE6IHAwOiAnICsgeDAgKyAnLCAnICsgeTAgKyAnICwgcDE6ICcgKyB4MSArICcgLSAnICsgeTEpO1xuICAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnLmNsaXBFeHRlbnQoW1t4ICcrXG4gICAgICAgICAgICAgICh4MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAgICh5MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uXSxbeCAnK1xuICAgICAgICAgICAgICAoeDE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeDEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbiwgeSAnK1xuICAgICAgICAgICAgICAoeTE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgICcgKiBrIC0gZXBzaWxvbl1dKScpO1xuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWFpbmxhbmRQb2ludCA9IG1haW5sYW5kXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShfKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMDU5ICogaywgeSAtIDAuMzgzNSAqIGtdLCBbeCArIDAuNDQ5OCAqIGssIHkgKyAwLjMzNzUgKiBrXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBhbnRhcmN0aWNQb2ludCA9IGFudGFyY3RpY1xuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjA4NyAqIGssIHkgKyAwLjE3ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4xMTY2ICogayArIGVwc2lsb24sIHkgKyAwLjI1ODIgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4wNiAqIGsgLSBlcHNpbG9uLCB5ICsgMC4zMiAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBqdWFuRmVybmFuZGV6UG9pbnQgPSBqdWFuRmVybmFuZGV6XG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMDkyICogaywgeSAtIDAgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjExNCAqIGsgKyBlcHNpbG9uLCB5IC0gMC4wMTMgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4wNTk0ICogayAtIGVwc2lsb24sIHkgKyAwLjAxMzMgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgcGFzY3VhUG9pbnQgPSBwYXNjdWFcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4wODkgKiBrLCB5IC0gMC4wMjY1ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4wODkgKiBrICsgZXBzaWxvbiwgeSArIDAuMDE1NCAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjA1ODggKiBrIC0gZXBzaWxvbiwgeSArIDAuMDM5MSAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnN2ZXJzZU1lcmNhdG9yQ2hpbGUuZml0RXh0ZW50ID0gZnVuY3Rpb24gKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0RXh0ZW50KHRyYW5zdmVyc2VNZXJjYXRvckNoaWxlLCBleHRlbnQsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zdmVyc2VNZXJjYXRvckNoaWxlLmZpdFNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0U2l6ZSh0cmFuc3ZlcnNlTWVyY2F0b3JDaGlsZSwgc2l6ZSwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc3ZlcnNlTWVyY2F0b3JDaGlsZTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc3ZlcnNlTWVyY2F0b3JDaGlsZS5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJDTElQIEVYVEVOVCBhbnRhcmN0aWM6IFwiLCBhbnRhcmN0aWMuY2xpcEV4dGVudCgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVMIEJCT1g6XCIsIG1haW5sYW5kLmludmVydChbYW50YXJjdGljLmNsaXBFeHRlbnQoKVswXVswXSwgYW50YXJjdGljLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlVSIEJCT1g6XCIsIG1haW5sYW5kLmludmVydChbYW50YXJjdGljLmNsaXBFeHRlbnQoKVsxXVswXSwgYW50YXJjdGljLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxEIEJCT1g6XCIsIG1haW5sYW5kLmludmVydChbYW50YXJjdGljLmNsaXBFeHRlbnQoKVsxXVswXSwgYW50YXJjdGljLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxMIEJCT1g6XCIsIG1haW5sYW5kLmludmVydChbYW50YXJjdGljLmNsaXBFeHRlbnQoKVswXVswXSwgYW50YXJjdGljLmNsaXBFeHRlbnQoKVsxXVsxXV0pKTtcbiAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJDTElQIEVYVEVOVCBqdWFuRmVybmFuZGV6OiBcIiwganVhbkZlcm5hbmRlei5jbGlwRXh0ZW50KCkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVUwgQkJPWDpcIiwgbWFpbmxhbmQuaW52ZXJ0KFtqdWFuRmVybmFuZGV6LmNsaXBFeHRlbnQoKVswXVswXSwganVhbkZlcm5hbmRlei5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJVUiBCQk9YOlwiLCBtYWlubGFuZC5pbnZlcnQoW2p1YW5GZXJuYW5kZXouY2xpcEV4dGVudCgpWzFdWzBdLCBqdWFuRmVybmFuZGV6LmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxEIEJCT1g6XCIsIG1haW5sYW5kLmludmVydChbanVhbkZlcm5hbmRlei5jbGlwRXh0ZW50KClbMV1bMF0sIGp1YW5GZXJuYW5kZXouY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiTEwgQkJPWDpcIiwgbWFpbmxhbmQuaW52ZXJ0KFtqdWFuRmVybmFuZGV6LmNsaXBFeHRlbnQoKVswXVswXSwganVhbkZlcm5hbmRlei5jbGlwRXh0ZW50KClbMV1bMV1dKSk7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiQ0xJUCBFWFRFTlQgcGFzY3VhOiBcIiwgcGFzY3VhLmNsaXBFeHRlbnQoKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJVTCBCQk9YOlwiLCBtYWlubGFuZC5pbnZlcnQoW3Bhc2N1YS5jbGlwRXh0ZW50KClbMF1bMF0sIHBhc2N1YS5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJVUiBCQk9YOlwiLCBtYWlubGFuZC5pbnZlcnQoW3Bhc2N1YS5jbGlwRXh0ZW50KClbMV1bMF0sIHBhc2N1YS5jbGlwRXh0ZW50KClbMF1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMRCBCQk9YOlwiLCBtYWlubGFuZC5pbnZlcnQoW3Bhc2N1YS5jbGlwRXh0ZW50KClbMV1bMF0sIHBhc2N1YS5jbGlwRXh0ZW50KClbMV1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMTCBCQk9YOlwiLCBtYWlubGFuZC5pbnZlcnQoW3Bhc2N1YS5jbGlwRXh0ZW50KClbMF1bMF0sIHBhc2N1YS5jbGlwRXh0ZW50KClbMV1bMV1dKSk7XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHVsYW50YXJjdGljID0gbWFpbmxhbmQoWy04Mi42OTk5LCAtNTEuMzA0M10pO1xuICAgICAgICAgICAgdmFyIHVyYW50YXJjdGljID0gbWFpbmxhbmQoWy03Ny41NDQyLCAtNTEuNjYzMV0pO1xuICAgICAgICAgICAgdmFyIGxkYW50YXJjdGljID0gbWFpbmxhbmQoWy03OC4wMjU0LCAtNTUuMTg2MF0pO1xuICAgICAgICAgICAgdmFyIGxsYW50YXJjdGljID0gbWFpbmxhbmQoWy04My42MTA2LCAtNTQuNzc4NV0pO1xuICAgICAgICAgICAgdmFyIHVsanVhbkZlcm5hbmRleiA9IG1haW5sYW5kKFstODAuMDYzOCwgLTM1Ljk4NDBdKTtcbiAgICAgICAgICAgIHZhciB1cmp1YW5GZXJuYW5kZXogPSBtYWlubGFuZChbLTc2LjIxNTMsIC0zNi4xODExXSk7XG4gICAgICAgICAgICB2YXIgbGRqdWFuRmVybmFuZGV6ID0gbWFpbmxhbmQoWy03Ni4yOTk0LCAtMzcuNjgzOV0pO1xuICAgICAgICAgICAgdmFyIGxsanVhbkZlcm5hbmRleiA9IG1haW5sYW5kKFstODAuMjIzMSwgLTM3LjQ3NTddKTtcbiAgICAgICAgICAgIHZhciB1bHBhc2N1YSA9IG1haW5sYW5kKFstNzguNDQyLCAtMzcuNzA2XSk7XG4gICAgICAgICAgICB2YXIgdXJwYXNjdWEgPSBtYWlubGFuZChbLTc2LjI2MywgLTM3LjgwNTRdKTtcbiAgICAgICAgICAgIHZhciBsZHBhc2N1YSA9IG1haW5sYW5kKFstNzYuMzQ0LCAtMzkuMTU5NV0pO1xuICAgICAgICAgICAgdmFyIGxscGFzY3VhID0gbWFpbmxhbmQoWy03OC41NjM4LCAtMzkuMDU1OV0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxhbnRhcmN0aWNbMF0sIHVsYW50YXJjdGljWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyYW50YXJjdGljWzBdLCB1cmFudGFyY3RpY1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZGFudGFyY3RpY1swXSwgbGRhbnRhcmN0aWNbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRhbnRhcmN0aWNbMF0sIGxkYW50YXJjdGljWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsYW50YXJjdGljWzBdLCBsbGFudGFyY3RpY1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxqdWFuRmVybmFuZGV6WzBdLCB1bGp1YW5GZXJuYW5kZXpbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJqdWFuRmVybmFuZGV6WzBdLCB1cmp1YW5GZXJuYW5kZXpbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRqdWFuRmVybmFuZGV6WzBdLCBsZGp1YW5GZXJuYW5kZXpbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRqdWFuRmVybmFuZGV6WzBdLCBsZGp1YW5GZXJuYW5kZXpbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxqdWFuRmVybmFuZGV6WzBdLCBsbGp1YW5GZXJuYW5kZXpbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVscGFzY3VhWzBdLCB1bHBhc2N1YVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1cnBhc2N1YVswXSwgdXJwYXNjdWFbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRwYXNjdWFbMF0sIGxkcGFzY3VhWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkcGFzY3VhWzBdLCBsZHBhc2N1YVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbHBhc2N1YVswXSwgbGxwYXNjdWFbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnN2ZXJzZU1lcmNhdG9yQ2hpbGUuZ2V0Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBkM1BhdGgucGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzKGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRyYW5zdmVyc2VNZXJjYXRvckNoaWxlLnNjYWxlKDcwMCk7XG4gICAgfVxuICAgIC8vIFRoZSBwcm9qZWN0aW9ucyBtdXN0IGhhdmUgbXV0dWFsbHkgZXhjbHVzaXZlIGNsaXAgcmVnaW9ucyBvbiB0aGUgc3BoZXJlLFxuICAgIC8vIGFzIHRoaXMgd2lsbCBhdm9pZCBlbWl0dGluZyBpbnRlcmxlYXZpbmcgbGluZXMgYW5kIHBvbHlnb25zLlxuICAgIGZ1bmN0aW9uIG11bHRpcGxleCQ2KHN0cmVhbXMpIHtcbiAgICAgICAgdmFyIG4gPSBzdHJlYW1zLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnNwaGVyZSgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICB9IH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQSBjb21wb3NpdGUgcHJvamVjdGlvbiBmb3IgUG9ydHVnYWwsIGNvbmZpZ3VyZWQgYnkgZGVmYXVsdCBmb3IgOTYww5c1MDAuXG4gICAgZnVuY3Rpb24gY29uaWNFcXVpZGlzdGFudEphcGFuKCkge1xuICAgICAgICB2YXIgY2FjaGUsIGNhY2hlU3RyZWFtLCBtYWlubGFuZCA9IGQzR2VvLmdlb0NvbmljRXF1aWRpc3RhbnQoKS5yb3RhdGUoWy0xMzYsIC0yMl0pLnBhcmFsbGVscyhbNDAsIDM0XSksIG1haW5sYW5kUG9pbnQsIC8vZ2lzLnN0YWNrZXhjaGFuZ2UuY29tL2EvNzMxMzVcbiAgICAgICAgaG9ra2FpZG8gPSBkM0dlby5nZW9Db25pY0VxdWlkaXN0YW50KCkucm90YXRlKFstMTQ2LCAtMjZdKS5wYXJhbGxlbHMoWzQwLCAzNF0pLCBob2trYWlkb1BvaW50LCBva2luYXdhID0gZDNHZW8uZ2VvQ29uaWNFcXVpZGlzdGFudCgpLnJvdGF0ZShbLTEyNiwgLTE5XSkucGFyYWxsZWxzKFs0MCwgMzRdKSwgb2tpbmF3YVBvaW50LCBwb2ludCwgcG9pbnRTdHJlYW0gPSB7IHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyBwb2ludCA9IFt4LCB5XTsgfSB9O1xuICAgICAgICAvKlxuICAgICAgICB2YXIgbWFpbmxhbmRCYm94ID0gW1sxMjYuMCwgNDEuNjA2XSwgWzE0Mi45NywgMjkuOTddXTtcbiAgICAgICAgdmFyIGhva2thaWRvQmJveCA9IFtbMTM4LjcsIDQ1LjYxXSwgWzE0Ni4yLCA0MS4yXV07XG4gICAgICAgIHZhciBva2luYXdhQmJveCA9IFtbMTIyLjYsIDI5LjBdLCBbMTMwLCAyMy43XV07XG4gICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGNvbmljRXF1aWRpc3RhbnRKYXBhbihjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIHggPSBjb29yZGluYXRlc1swXSwgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50ID0gbnVsbCxcbiAgICAgICAgICAgICAgICAobWFpbmxhbmRQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChob2trYWlkb1BvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG9raW5hd2FQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbmljRXF1aWRpc3RhbnRKYXBhbi5pbnZlcnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciBrID0gbWFpbmxhbmQuc2NhbGUoKSwgdCA9IG1haW5sYW5kLnRyYW5zbGF0ZSgpLCB4ID0gKGNvb3JkaW5hdGVzWzBdIC0gdFswXSkgLyBrLCB5ID0gKGNvb3JkaW5hdGVzWzFdIC0gdFsxXSkgLyBrO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIC8vSG93IGFyZSB0aGUgcmV0dXJuIHZhbHVlcyBjYWxjdWxhdGVkOlxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiKioqKioqXCIpO1xuICAgICAgICAgICAgdmFyIGMwID0gaG9ra2FpZG8oaG9ra2FpZG9CYm94WzBdKTtcbiAgICAgICAgICAgIHZhciB4MCA9IChjMFswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHZhciB5MCA9IChjMFsxXSAtIHRbMV0pIC8gaztcbiAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcInAwIGhva2thaWRvXCIsIHgwICsgJyAtICcgKyB5MCk7XG4gICAgXG4gICAgICAgICAgICB2YXIgYzEgPSBob2trYWlkbyhob2trYWlkb0Jib3hbMV0pO1xuICAgICAgICAgICAgdmFyIHgxID0gKGMxWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgdmFyIHkxID0gKGMxWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDEgaG9ra2FpZG9cIiwgeDEgKyAnIC0gJyArIHkxKTtcbiAgICBcbiAgICAgICAgICAgIGMwID0gb2tpbmF3YShva2luYXdhQmJveFswXSk7XG4gICAgICAgICAgICB4MCA9IChjMFswXSAtIHRbMF0pIC8gaztcbiAgICAgICAgICAgIHkwID0gKGMwWzFdIC0gdFsxXSkgLyBrO1xuICAgIFxuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwicDAgb2tpbmF3YVwiLCB4MCArICcgLSAnICsgeTApO1xuICAgIFxuICAgICAgICAgICAgYzEgPSBva2luYXdhKG9raW5hd2FCYm94WzFdKTtcbiAgICAgICAgICAgIHgxID0gKGMxWzBdIC0gdFswXSkgLyBrO1xuICAgICAgICAgICAgeTEgPSAoYzFbMV0gLSB0WzFdKSAvIGs7XG4gICAgXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJwMSBva2luYXdhXCIsIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuICh5ID49IC0wLjEwOTI1ICYmIHkgPCAtMC4wMjcwMSAmJiB4ID49IC0wLjEzNSAmJiB4IDwgLTAuMDM5NyA/IGhva2thaWRvXG4gICAgICAgICAgICAgICAgOiB5ID49IDAuMDQ3MTMgJiYgeSA8IDAuMTExMzggJiYgeCA+PSAtMC4wMzk4NiAmJiB4IDwgMC4wNTEgPyBva2luYXdhXG4gICAgICAgICAgICAgICAgICAgIDogbWFpbmxhbmQpLmludmVydChjb29yZGluYXRlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljRXF1aWRpc3RhbnRKYXBhbi5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBtdWx0aXBsZXgkNihbbWFpbmxhbmQuc3RyZWFtKGNhY2hlU3RyZWFtID0gc3RyZWFtKSwgaG9ra2FpZG8uc3RyZWFtKHN0cmVhbSksIG9raW5hd2Euc3RyZWFtKHN0cmVhbSldKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNFcXVpZGlzdGFudEphcGFuLnByZWNpc2lvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbmxhbmQucHJlY2lzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWlubGFuZC5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBob2trYWlkby5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBva2luYXdhLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0VxdWlkaXN0YW50SmFwYW4uc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW5sYW5kLnNjYWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWlubGFuZC5zY2FsZShfKTtcbiAgICAgICAgICAgIGhva2thaWRvLnNjYWxlKF8pO1xuICAgICAgICAgICAgb2tpbmF3YS5zY2FsZShfICogMC43KTtcbiAgICAgICAgICAgIHJldHVybiBjb25pY0VxdWlkaXN0YW50SmFwYW4udHJhbnNsYXRlKG1haW5sYW5kLnRyYW5zbGF0ZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNFcXVpZGlzdGFudEphcGFuLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbmxhbmQudHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgayA9IG1haW5sYW5kLnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIHZhciBjMCA9IG1haW5sYW5kKG1haW5sYW5kQmJveFswXSk7XG4gICAgICAgICAgIHZhciB4MCA9ICh4IC0gYzBbMF0pIC8gaztcbiAgICAgICAgICAgdmFyIHkwID0gKHkgLSBjMFsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgdmFyIGMxID0gbWFpbmxhbmQobWFpbmxhbmRCYm94WzFdKTtcbiAgICAgICAgICAgdmFyIHgxID0gKHggLSBjMVswXSkgLyBrO1xuICAgICAgICAgICB2YXIgeTEgPSAoeSAtIGMxWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICBjb25zb2xlLmluZm8oJ01haW46IHAwOiAnICsgeDAgKyAnLCAnICsgeTAgKyAnICwgcDE6ICcgKyB4MSArICcgLSAnICsgeTEpO1xuICAgICAgICAgICBjb25zb2xlLmluZm8oJy5jbGlwRXh0ZW50KFtbeCAnK1xuICAgICAgICAgICAgKHgwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGssIHkgJytcbiAgICAgICAgICAgICh5MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrXSxbeCAnK1xuICAgICAgICAgICAgKHgxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGssIHkgJytcbiAgICAgICAgICAgICh5MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh5MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrXV0pJyk7XG4gICAgICAgIFxuICAgICAgICAgICBjMCA9IGhva2thaWRvLnRyYW5zbGF0ZShbeCAtIDAuMDQyNSAqIGssIHkgLSAwLjAwNSAqIGtdKShob2trYWlkb0Jib3hbMF0pO1xuICAgICAgICAgICB4MCA9ICh4IC0gYzBbMF0pIC8gaztcbiAgICAgICAgICAgeTAgPSAoeSAtIGMwWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICBjMSA9IGhva2thaWRvLnRyYW5zbGF0ZShbeCAtIDAuMDQyNSAqIGssIHkgLSAwLjAwNSAqIGtdKShob2trYWlkb0Jib3hbMV0pO1xuICAgICAgICAgICB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgeTEgPSAoeSAtIGMxWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICBjb25zb2xlLmluZm8oJ2hva2thaWRvOiBwMDogJyArIHgwICsgJywgJyArIHkwICsgJyAsIHAxOiAnICsgeDEgKyAnIC0gJyArIHkxKTtcbiAgICAgICAgICAgY29uc29sZS5pbmZvKCcuY2xpcEV4dGVudChbW3ggJytcbiAgICAgICAgICAgICh4MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICcgKiBrICsgZXBzaWxvbiwgeSAnK1xuICAgICAgICAgICAgKHkwPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHkwLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uXSxbeCAnK1xuICAgICAgICAgICAgKHgxPDA/JysgJzonLSAnKSArIE1hdGguYWJzKHgxLnRvRml4ZWQoNCkpK1xuICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uLCB5ICcrXG4gICAgICAgICAgICAoeTE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAnICogayAtIGVwc2lsb25dXSknKTtcbiAgICAgICAgXG4gICAgICAgICAgICBjMCA9IG9raW5hd2EudHJhbnNsYXRlKFt4IC0gMCAqIGssIHkgKyAwICoga10pKG9raW5hd2FCYm94WzBdKTtcbiAgICAgICAgICAgIHgwID0gKHggLSBjMFswXSkgLyBrO1xuICAgICAgICAgICAgeTAgPSAoeSAtIGMwWzFdKSAvIGs7XG4gICAgICAgIFxuICAgICAgICAgICAgYzEgPSBva2luYXdhLnRyYW5zbGF0ZShbeCAtIDAgKiBrLCB5ICsgMCAqIGtdKShva2luYXdhQmJveFsxXSk7XG4gICAgICAgICAgICB4MSA9ICh4IC0gYzFbMF0pIC8gaztcbiAgICAgICAgICAgIHkxID0gKHkgLSBjMVsxXSkgLyBrO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnb2tpbmF3YTogcDA6ICcgKyB4MCArICcsICcgKyB5MCArICcgLCBwMTogJyArIHgxICsgJyAtICcgKyB5MSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJy5jbGlwRXh0ZW50KFtbeCAnK1xuICAgICAgICAgICAgICh4MDwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MC50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAnICogayArIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICAoeTA8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTAudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgJyAqIGsgKyBlcHNpbG9uXSxbeCAnK1xuICAgICAgICAgICAgICh4MTwwPycrICc6Jy0gJykgKyBNYXRoLmFicyh4MS50b0ZpeGVkKDQpKStcbiAgICAgICAgICAgICAnICogayAtIGVwc2lsb24sIHkgJytcbiAgICAgICAgICAgICAoeTE8MD8nKyAnOictICcpICsgTWF0aC5hYnMoeTEudG9GaXhlZCg0KSkrXG4gICAgICAgICAgICAgJyAqIGsgLSBlcHNpbG9uXV0pJyk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1haW5sYW5kUG9pbnQgPSBtYWlubGFuZFxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoXylcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjEzNTIgKiBrLCB5IC0gMC4xMDkxICoga10sIFt4ICsgMC4xMTcgKiBrLCB5ICsgMC4wOTggKiBrXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBob2trYWlkb1BvaW50ID0gaG9ra2FpZG9cbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4wNDI1ICogaywgeSAtIDAuMDA1ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4xMzUgKiBrICsgZXBzaWxvbiwgeSAtIDAuMTA5MyAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjAzOTcgKiBrIC0gZXBzaWxvbiwgeSAtIDAuMDI3ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIG9raW5hd2FQb2ludCA9IG9raW5hd2FcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKF8pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4wMzk5ICogayArIGVwc2lsb24sIHkgKyAwLjA0NzEgKiBrICsgZXBzaWxvbl0sIFt4ICsgMC4wNTEgKiBrIC0gZXBzaWxvbiwgeSArIDAuMTExNCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNFcXVpZGlzdGFudEphcGFuLmZpdEV4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdEV4dGVudChjb25pY0VxdWlkaXN0YW50SmFwYW4sIGV4dGVudCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNFcXVpZGlzdGFudEphcGFuLmZpdFNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0U2l6ZShjb25pY0VxdWlkaXN0YW50SmFwYW4sIHNpemUsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gY29uaWNFcXVpZGlzdGFudEphcGFuO1xuICAgICAgICB9XG4gICAgICAgIGNvbmljRXF1aWRpc3RhbnRKYXBhbi5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJDTElQIEVYVEVOVCBob2trYWlkbzogXCIsIGhva2thaWRvLmNsaXBFeHRlbnQoKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJVTCBCQk9YOlwiLCBtYWlubGFuZC5pbnZlcnQoW2hva2thaWRvLmNsaXBFeHRlbnQoKVswXVswXSwgaG9ra2FpZG8uY2xpcEV4dGVudCgpWzBdWzFdXSkpO1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVVIgQkJPWDpcIiwgbWFpbmxhbmQuaW52ZXJ0KFtob2trYWlkby5jbGlwRXh0ZW50KClbMV1bMF0sIGhva2thaWRvLmNsaXBFeHRlbnQoKVswXVsxXV0pKTtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkxEIEJCT1g6XCIsIG1haW5sYW5kLmludmVydChbaG9ra2FpZG8uY2xpcEV4dGVudCgpWzFdWzBdLCBob2trYWlkby5jbGlwRXh0ZW50KClbMV1bMV1dKSk7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJMTCBCQk9YOlwiLCBtYWlubGFuZC5pbnZlcnQoW2hva2thaWRvLmNsaXBFeHRlbnQoKVswXVswXSwgaG9ra2FpZG8uY2xpcEV4dGVudCgpWzFdWzFdXSkpO1xuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciB1bGhva2thaWRvID0gbWFpbmxhbmQoWzEyNi4wMTMyMDQ4MzY4OTE0MywgNDEuNjIxMDkwMzEwMjE1NTg1XSk7XG4gICAgICAgICAgICB2YXIgdXJob2trYWlkbyA9IG1haW5sYW5kKFsxMzMuMDQzMDQzODcwMjU5MDMsIDQyLjE1MDg3NTIzNzA3MTg2XSk7XG4gICAgICAgICAgICB2YXIgbGRob2trYWlkbyA9IG1haW5sYW5kKFsxMzMuMzAyMTc2NjA4MDY4OCwgMzcuNDM5NzU0NDQ3MjUwOThdKTtcbiAgICAgICAgICAgIHZhciBsbGhva2thaWRvID0gbWFpbmxhbmQoWzEyNi44Nzg4OTE2ODYyODIyNCwgMzYuOTU0ODg5NDUxNTk3NzldKTtcbiAgICAgICAgICAgIHZhciBsbG9raW5hd2EgPSBtYWlubGFuZChbMTMyLjksIDI5LjhdKTtcbiAgICAgICAgICAgIHZhciBsbW9raW5hd2EgPSBtYWlubGFuZChbMTM0LCAzM10pO1xuICAgICAgICAgICAgdmFyIGxyb2tpbmF3YSA9IG1haW5sYW5kKFsxMzkuMywgMzMuMl0pO1xuICAgICAgICAgICAgdmFyIGxscm9raW5hd2EgPSBtYWlubGFuZChbMTM5LjE2LCAzMC41XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bGhva2thaWRvWzBdLCB1bGhva2thaWRvWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyaG9ra2FpZG9bMF0sIHVyaG9ra2FpZG9bMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRob2trYWlkb1swXSwgbGRob2trYWlkb1sxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbGhva2thaWRvWzBdLCBsbGhva2thaWRvWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhsbG9raW5hd2FbMF0sIGxsb2tpbmF3YVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbW9raW5hd2FbMF0sIGxtb2tpbmF3YVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhscm9raW5hd2FbMF0sIGxyb2tpbmF3YVsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbHJva2luYXdhWzBdLCBsbHJva2luYXdhWzFdKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNFcXVpZGlzdGFudEphcGFuLmdldENvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZDNQYXRoLnBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyhjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb25pY0VxdWlkaXN0YW50SmFwYW4uc2NhbGUoMjIwMCk7XG4gICAgfVxuICAgIC8vIFRoZSBwcm9qZWN0aW9ucyBtdXN0IGhhdmUgbXV0dWFsbHkgZXhjbHVzaXZlIGNsaXAgcmVnaW9ucyBvbiB0aGUgc3BoZXJlLFxuICAgIC8vIGFzIHRoaXMgd2lsbCBhdm9pZCBlbWl0dGluZyBpbnRlcmxlYXZpbmcgbGluZXMgYW5kIHBvbHlnb25zLlxuICAgIGZ1bmN0aW9uIG11bHRpcGxleCQ3KHN0cmVhbXMpIHtcbiAgICAgICAgdmFyIG4gPSBzdHJlYW1zLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnNwaGVyZSgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICB9IH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQSBjb21wb3NpdGUgcHJvamVjdGlvbiBmb3IgRnJhbmNlLCBjb25maWd1cmVkIGJ5IGRlZmF1bHQgZm9yIDk2MMOXNTAwLlxuICAgIGZ1bmN0aW9uIGNvbmljQ29uZm9ybWFsRnJhbmNlKCkge1xuICAgICAgICB2YXIgY2FjaGUsIGNhY2hlU3RyZWFtLCBldXJvcGUgPSBkM0dlby5nZW9Db25pY0NvbmZvcm1hbCgpLnJvdGF0ZShbLTMsIC00Ni4yXSkucGFyYWxsZWxzKFswLCA2MF0pLCBldXJvcGVQb2ludCwgZ3V5YW5lID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5jZW50ZXIoWy01My4yLCAzLjldKSwgZ3V5YW5lUG9pbnQsIG1hcnRpbmlxdWUgPSBkM0dlby5nZW9NZXJjYXRvcigpLmNlbnRlcihbLTYxLjAzLCAxNC42N10pLCBtYXJ0aW5pcXVlUG9pbnQsIGd1YWRlbG91cGUgPSBkM0dlby5nZW9NZXJjYXRvcigpLmNlbnRlcihbLTYxLjQ2LCAxNi4xNF0pLCBndWFkZWxvdXBlUG9pbnQsIHNhaW50QmFydGhlbGVteSA9IGQzR2VvLmdlb01lcmNhdG9yKCkuY2VudGVyKFstNjIuODUsIDE3LjkyXSksIHNhaW50QmFydGhlbGVteVBvaW50LCBzdFBpZXJyZU1pcXVlbG9uID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5jZW50ZXIoWy01Ni4yMywgNDYuOTNdKSwgc3RQaWVycmVNaXF1ZWxvblBvaW50LCBtYXlvdHRlID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5jZW50ZXIoWzQ1LjE2LCAtMTIuOF0pLCBtYXlvdHRlUG9pbnQsIHJldW5pb24gPSBkM0dlby5nZW9NZXJjYXRvcigpLmNlbnRlcihbNTUuNTIsIC0yMS4xM10pLCByZXVuaW9uUG9pbnQsIG5vdXZlbGxlQ2FsZWRvbmllID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5jZW50ZXIoWzE2NS44LCAtMjEuMDddKSwgbm91dmVsbGVDYWxlZG9uaWVQb2ludCwgd2FsbGlzRnV0dW5hID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5jZW50ZXIoWy0xNzguMSwgLTE0LjNdKSwgd2FsbGlzRnV0dW5hUG9pbnQsIHBvbHluZXNpZSA9IGQzR2VvLmdlb01lcmNhdG9yKCkuY2VudGVyKFstMTUwLjU1LCAtMTcuMTFdKSwgcG9seW5lc2llUG9pbnQsIHBvbHluZXNpZTIgPSBkM0dlby5nZW9NZXJjYXRvcigpLmNlbnRlcihbLTE1MC41NSwgLTE3LjExXSksIHBvbHluZXNpZTJQb2ludCwgcG9pbnQsIHBvaW50U3RyZWFtID0geyBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgcG9pbnQgPSBbeCwgeV07IH0gfTtcbiAgICAgICAgLypcbiAgICAgICAgdmFyIGV1cm9wZUJib3ggPSBbWy02LjUsIDUxXSwgWzEwLCA0MV1dO1xuICAgICAgICB2YXIgZ3V5YW5lQmJveCA9IFtbLTU0LjUsIDYuMjldLCBbLTUwLjksIDEuNDhdXTtcbiAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY29uaWNDb25mb3JtYWxGcmFuY2UoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludCA9IG51bGwsXG4gICAgICAgICAgICAgICAgKGV1cm9wZVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGd1eWFuZVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG1hcnRpbmlxdWVQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChndWFkZWxvdXBlUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoc2FpbnRCYXJ0aGVsZW15UG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoc3RQaWVycmVNaXF1ZWxvblBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG1heW90dGVQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXVuaW9uUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAobm91dmVsbGVDYWxlZG9uaWVQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgICh3YWxsaXNGdXR1bmFQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChwb2x5bmVzaWVQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChwb2x5bmVzaWUyUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25pY0NvbmZvcm1hbEZyYW5jZS5pbnZlcnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciBrID0gZXVyb3BlLnNjYWxlKCksIHQgPSBldXJvcGUudHJhbnNsYXRlKCksIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICAgICAgICByZXR1cm4gKHkgPj0gMC4wMjkgJiYgeSA8IDAuMDg2NCAmJiB4ID49IC0wLjE0ICYmIHggPCAtMC4wOTk2ID8gZ3V5YW5lXG4gICAgICAgICAgICAgICAgOiB5ID49IDAgJiYgeSA8IDAuMDI5ICYmIHggPj0gLTAuMTQgJiYgeCA8IC0wLjA5OTYgPyBtYXJ0aW5pcXVlXG4gICAgICAgICAgICAgICAgICAgIDogeSA+PSAtMC4wMzIgJiYgeSA8IDAgJiYgeCA+PSAtMC4xNCAmJiB4IDwgLTAuMDk5NiA/IGd1YWRlbG91cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAtMC4wNTIgJiYgeSA8IC0wLjAzMiAmJiB4ID49IC0wLjE0ICYmIHggPCAtMC4wOTk2ID8gc2FpbnRCYXJ0aGVsZW15XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB5ID49IC0wLjA3NiAmJiB5IDwgMC4wNTIgJiYgeCA+PSAtMC4xNCAmJiB4IDwgLTAuMDk5NiA/IHN0UGllcnJlTWlxdWVsb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB5ID49IC0wLjA3NiAmJiB5IDwgLTAuMDUyICYmIHggPj0gMC4wOTY3ICYmIHggPCAwLjEzNzEgPyBtYXlvdHRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHkgPj0gLTAuMDUyICYmIHkgPCAtMC4wMiAmJiB4ID49IDAuMDk2NyAmJiB4IDwgMC4xMzcxID8gcmV1bmlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAtMC4wMiAmJiB5IDwgMC4wMTIgJiYgeCA+PSAwLjA5NjcgJiYgeCA8IDAuMTM3MSA/IG5vdXZlbGxlQ2FsZWRvbmllXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAwLjAxMiAmJiB5IDwgMC4wMzMgJiYgeCA+PSAwLjA5NjcgJiYgeCA8IDAuMTM3MSA/IHdhbGxpc0Z1dHVuYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB5ID49IDAuMDMzICYmIHkgPCAwLjA4NjQgJiYgeCA+PSAwLjA5NjcgJiYgeCA8IDAuMTM3MSA/IHBvbHluZXNpZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXVyb3BlKS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbEZyYW5jZS5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBtdWx0aXBsZXgkNyhbZXVyb3BlLnN0cmVhbShjYWNoZVN0cmVhbSA9IHN0cmVhbSksIGd1eWFuZS5zdHJlYW0oc3RyZWFtKSwgbWFydGluaXF1ZS5zdHJlYW0oc3RyZWFtKSwgZ3VhZGVsb3VwZS5zdHJlYW0oc3RyZWFtKSwgc2FpbnRCYXJ0aGVsZW15LnN0cmVhbShzdHJlYW0pLCBzdFBpZXJyZU1pcXVlbG9uLnN0cmVhbShzdHJlYW0pLCBtYXlvdHRlLnN0cmVhbShzdHJlYW0pLCByZXVuaW9uLnN0cmVhbShzdHJlYW0pLCBub3V2ZWxsZUNhbGVkb25pZS5zdHJlYW0oc3RyZWFtKSwgd2FsbGlzRnV0dW5hLnN0cmVhbShzdHJlYW0pLCBwb2x5bmVzaWUuc3RyZWFtKHN0cmVhbSksIHBvbHluZXNpZTIuc3RyZWFtKHN0cmVhbSldKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxGcmFuY2UucHJlY2lzaW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBldXJvcGUucHJlY2lzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldXJvcGUucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgZ3V5YW5lLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIG1hcnRpbmlxdWUucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgZ3VhZGVsb3VwZS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBzYWludEJhcnRoZWxlbXkucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgc3RQaWVycmVNaXF1ZWxvbi5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBtYXlvdHRlLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHJldW5pb24ucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgbm91dmVsbGVDYWxlZG9uaWUucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgd2FsbGlzRnV0dW5hLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHBvbHluZXNpZS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBwb2x5bmVzaWUyLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbEZyYW5jZS5zY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXVyb3BlLnNjYWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldXJvcGUuc2NhbGUoXyk7XG4gICAgICAgICAgICBndXlhbmUuc2NhbGUoXyAqIDAuNik7XG4gICAgICAgICAgICBtYXJ0aW5pcXVlLnNjYWxlKF8gKiAxLjYpO1xuICAgICAgICAgICAgZ3VhZGVsb3VwZS5zY2FsZShfICogMS40KTtcbiAgICAgICAgICAgIHNhaW50QmFydGhlbGVteS5zY2FsZShfICogNSk7XG4gICAgICAgICAgICBzdFBpZXJyZU1pcXVlbG9uLnNjYWxlKF8gKiAxLjMpO1xuICAgICAgICAgICAgbWF5b3R0ZS5zY2FsZShfICogMS42KTtcbiAgICAgICAgICAgIHJldW5pb24uc2NhbGUoXyAqIDEuMik7XG4gICAgICAgICAgICBub3V2ZWxsZUNhbGVkb25pZS5zY2FsZShfICogMC4zKTtcbiAgICAgICAgICAgIHdhbGxpc0Z1dHVuYS5zY2FsZShfICogMi43KTtcbiAgICAgICAgICAgIHBvbHluZXNpZS5zY2FsZShfICogMC41KTtcbiAgICAgICAgICAgIHBvbHluZXNpZTIuc2NhbGUoXyAqIDAuMDYpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmljQ29uZm9ybWFsRnJhbmNlLnRyYW5zbGF0ZShldXJvcGUudHJhbnNsYXRlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbEZyYW5jZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV1cm9wZS50cmFuc2xhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrID0gZXVyb3BlLnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xuICAgICAgICAgICAgZXVyb3BlUG9pbnQgPSBldXJvcGVcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKF8pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4wOTk2ICogaywgeSAtIDAuMDkwOCAqIGtdLCBbeCArIDAuMDk2NyAqIGssIHkgKyAwLjA4NjQgKiBrXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBndXlhbmVQb2ludCA9IGd1eWFuZVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjEyICogaywgeSArIDAuMDU3NSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMTQgKiBrICsgZXBzaWxvbiwgeSArIDAuMDI5ICogayArIGVwc2lsb25dLCBbeCAtIDAuMDk5NiAqIGsgLSBlcHNpbG9uLCB5ICsgMC4wODY0ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIG1hcnRpbmlxdWVQb2ludCA9IG1hcnRpbmlxdWVcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4xMiAqIGssIHkgKyAwLjAxMyAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMTQgKiBrICsgZXBzaWxvbiwgeSArIDAgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4wOTk2ICogayAtIGVwc2lsb24sIHkgKyAwLjAyOSAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBndWFkZWxvdXBlUG9pbnQgPSBndWFkZWxvdXBlXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMTIgKiBrLCB5IC0gMC4wMTQgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjE0ICogayArIGVwc2lsb24sIHkgLSAwLjAzMiAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjA5OTYgKiBrIC0gZXBzaWxvbiwgeSArIDAgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgc2FpbnRCYXJ0aGVsZW15UG9pbnQgPSBzYWludEJhcnRoZWxlbXlcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4xMiAqIGssIHkgLSAwLjA0NCAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMTQgKiBrICsgZXBzaWxvbiwgeSAtIDAuMDUyICogayArIGVwc2lsb25dLCBbeCAtIDAuMDk5NiAqIGsgLSBlcHNpbG9uLCB5IC0gMC4wMzIgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgc3RQaWVycmVNaXF1ZWxvblBvaW50ID0gc3RQaWVycmVNaXF1ZWxvblxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjEyICogaywgeSAtIDAuMDY1ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4xNCAqIGsgKyBlcHNpbG9uLCB5IC0gMC4wNzYgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4wOTk2ICogayAtIGVwc2lsb24sIHkgLSAwLjA1MiAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBtYXlvdHRlUG9pbnQgPSBtYXlvdHRlXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMTE3ICogaywgeSAtIDAuMDY0ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4ICsgMC4wOTY3ICogayArIGVwc2lsb24sIHkgLSAwLjA3NiAqIGsgKyBlcHNpbG9uXSwgW3ggKyAwLjEzNzEgKiBrIC0gZXBzaWxvbiwgeSAtIDAuMDUyICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHJldW5pb25Qb2ludCA9IHJldW5pb25cbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4ICsgMC4xMTYgKiBrLCB5IC0gMC4wMzU1ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4ICsgMC4wOTY3ICogayArIGVwc2lsb24sIHkgLSAwLjA1MiAqIGsgKyBlcHNpbG9uXSwgW3ggKyAwLjEzNzEgKiBrIC0gZXBzaWxvbiwgeSAtIDAuMDIgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgbm91dmVsbGVDYWxlZG9uaWVQb2ludCA9IG5vdXZlbGxlQ2FsZWRvbmllXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMTE2ICogaywgeSAtIDAuMDA0OCAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCArIDAuMDk2NyAqIGsgKyBlcHNpbG9uLCB5IC0gMC4wMiAqIGsgKyBlcHNpbG9uXSwgW3ggKyAwLjEzNzEgKiBrIC0gZXBzaWxvbiwgeSArIDAuMDEyICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHdhbGxpc0Z1dHVuYVBvaW50ID0gd2FsbGlzRnV0dW5hXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMTE2ICogaywgeSArIDAuMDIyICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4ICsgMC4wOTY3ICogayArIGVwc2lsb24sIHkgKyAwLjAxMiAqIGsgKyBlcHNpbG9uXSwgW3ggKyAwLjEzNzEgKiBrIC0gZXBzaWxvbiwgeSArIDAuMDMzICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHBvbHluZXNpZTJQb2ludCA9IHBvbHluZXNpZTJcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4ICsgMC4xMSAqIGssIHkgKyAwLjA0NSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCArIDAuMDk2NyAqIGsgKyBlcHNpbG9uLCB5ICsgMC4wMzMgKiBrICsgZXBzaWxvbl0sIFt4ICsgMC4xMzcxICogayAtIGVwc2lsb24sIHkgKyAwLjA2ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHBvbHluZXNpZVBvaW50ID0gcG9seW5lc2llXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMTE1ICogaywgeSArIDAuMDc1ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4ICsgMC4wOTY3ICogayArIGVwc2lsb24sIHkgKyAwLjA2ICogayArIGVwc2lsb25dLCBbeCArIDAuMTM3MSAqIGsgLSBlcHNpbG9uLCB5ICsgMC4wODY0ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbEZyYW5jZS5maXRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQoY29uaWNDb25mb3JtYWxGcmFuY2UsIGV4dGVudCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxGcmFuY2UuZml0U2l6ZSA9IGZ1bmN0aW9uIChzaXplLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRTaXplKGNvbmljQ29uZm9ybWFsRnJhbmNlLCBzaXplLCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmljQ29uZm9ybWFsRnJhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbmljQ29uZm9ybWFsRnJhbmNlLmRyYXdDb21wb3NpdGlvbkJvcmRlcnMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidmFyIHVsLCB1ciwgbGQsIGxsO1wiKTtcbiAgICAgICAgICAgIHZhciBwcm9qcyA9IFtndXlhbmUsIG1hcnRpbmlxdWUsIGd1YWRlbG91cGUsIHNhaW50QmFydGhlbGVteSwgc3RQaWVycmVNaXF1ZWxvbiwgbWF5b3R0ZSwgcmV1bmlvbiwgbm91dmVsbGVDYWxlZG9uaWUsIHdhbGxpc0Z1dHVuYSwgcG9seW5lc2llLCBwb2x5bmVzaWUyXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gcHJvanMpe1xuICAgICAgICAgICAgICB2YXIgdWwgPSBldXJvcGUuaW52ZXJ0KFtwcm9qc1tpXS5jbGlwRXh0ZW50KClbMF1bMF0sIHByb2pzW2ldLmNsaXBFeHRlbnQoKVswXVsxXV0pO1xuICAgICAgICAgICAgICB2YXIgdXIgPSBldXJvcGUuaW52ZXJ0KFtwcm9qc1tpXS5jbGlwRXh0ZW50KClbMV1bMF0sIHByb2pzW2ldLmNsaXBFeHRlbnQoKVswXVsxXV0pO1xuICAgICAgICAgICAgICB2YXIgbGQgPSBldXJvcGUuaW52ZXJ0KFtwcm9qc1tpXS5jbGlwRXh0ZW50KClbMV1bMF0sIHByb2pzW2ldLmNsaXBFeHRlbnQoKVsxXVsxXV0pO1xuICAgICAgICAgICAgICB2YXIgbGwgPSBldXJvcGUuaW52ZXJ0KFtwcm9qc1tpXS5jbGlwRXh0ZW50KClbMF1bMF0sIHByb2pzW2ldLmNsaXBFeHRlbnQoKVsxXVsxXV0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bCA9IGV1cm9wZShbXCIrdWwrXCJdKTtcIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidXIgPSBldXJvcGUoW1wiK3VyK1wiXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImxkID0gZXVyb3BlKFtcIitsZCtcIl0pO1wiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJsbCA9IGV1cm9wZShbXCIrbGwrXCJdKTtcIik7XG4gICAgICAgIFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQuY2xvc2VQYXRoKCk7XCIpO1xuICAgICAgICBcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgdmFyIHVsLCB1ciwgbGQsIGxsO1xuICAgICAgICAgICAgdWwgPSBldXJvcGUoWy03LjkzODg4NjcyNTExMTAzNiwgNDMuNzIxOTQ2MDkxODgzNV0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWy00LjgzMjA4MDg5NjQ1ODI5NSwgNDQuMTI5MzAyNjg1NDkzNzJdKTtcbiAgICAgICAgICAgIGxkID0gZXVyb3BlKFstNC4yMDUyOTk3NDM3OTMyNjMsIDQwLjk4MDk2MzQ2OTY3MzY1XSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbLTcuMDcxNzk2NDUzMTI2MTUyLCA0MC42MTAwMzczMTkxODE0NDRdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdWwgPSBldXJvcGUoWy04LjQyNzUxMzczNjE3NjkyLCA0NS4zMjg4OTQ1MjU1MzAzMV0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWy01LjE4NTk5MzA1Nzc3MTA3LCA0NS43NTY2NDQyMDYyOTc2XSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbLTQuODMyMDgwOTA1MTU0NDMxLCA0NC4xMjkzMDI3MjY3NTE0MjZdKTtcbiAgICAgICAgICAgIGxsID0gZXVyb3BlKFstNy45Mzg4ODY3MzcxMjYxOTIsIDQzLjcyMTk0NjEzMjYzODU0XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gZXVyb3BlKFstOS4wMTI2NTY4OTk2NTcwNDYsIDQ3LjEyNzczMzgyMTAzMDE3Nl0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWy01LjYxMDUyNDQ3NzI3OTMxNTUsIDQ3LjU3OTc3Nzg2MTQxMDYyNl0pO1xuICAgICAgICAgICAgbGQgPSBldXJvcGUoWy01LjE4NTk5MzA2NzE2ODU4NSwgNDUuNzU2NjQ0MjQ4MTcwMzQ2XSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbLTguNDI3NTEzNzQ5MTQxODExLCA0NS4zMjg4OTQ1NjY4NjMyNl0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbLTkuNDA1NzQ3NTU4OTg1NTUzLCA0OC4yNjUwNjM3NTU1NzQ1N10pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWy01Ljg5NjE3NTAxODQzOTU3NSwgNDguNzMzMzUyODUwODUxNjI0XSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbLTUuNjEwNTI0NDg3NTU2MDQzLCA0Ny41Nzk3Nzc5MDM5Mzc2MV0pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWy05LjAxMjY1NjkxMzgwODM1MSwgNDcuMTI3NzMzODYyOTcxMjU1XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gZXVyb3BlKFstOS45MDg0MzYwNjEzNDY5NzQsIDQ5LjY0MjQ0ODc4OTUwNTg1Nl0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWy02LjI2MjAyNjcxNjIzMzEyNCwgNTAuMTMxNDI2ODQxNzg3MTc0XSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbLTUuODk2MTc1MDI5MzMxMjMyLCA0OC43MzMzNTI4OTM3NzI1OF0pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWy05LjQwNTc0NzU3Mzk2MzkzLCA0OC4yNjUwNjM3OTc4Nzc2N10pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbMTEuOTk2OTA3NzA2NTA0NDYyLCA1MC4xNjAzOTAyODE2MzU3OV0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWzE1LjY0OTkwNzg3OTc3MzM0MywgNDkuNjgyNzkyNDY3NjUyNTNdKTtcbiAgICAgICAgICAgIGxkID0gZXVyb3BlKFsxNS4xNTY3MTI4NDA1MjY2MzIsIDQ4LjMwMzcxNTU3NjI1ODMxXSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbMTEuNjQxMjI2NjE3NTQ0MTEsIDQ4Ljc2MTA3ODI0MDU0NjgxNl0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbMTEuNjQxMjI2NjA2OTU1Nzg4LCA0OC43NjEwNzgxOTc1ODg5XSk7XG4gICAgICAgICAgICB1ciA9IGV1cm9wZShbMTUuMTU2NzEyODI1ODMyMTY0LCA0OC4zMDM3MTU1MzM5MDQ2NV0pO1xuICAgICAgICAgICAgbGQgPSBldXJvcGUoWzE0LjU0OTkzMjE2NjI0MTE3MiwgNDYuNDg2NjUzMjQ4NjE5OV0pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWzExLjIwNDQ0Mzc4Nzk1MjE4MywgNDYuOTE4OTkyMzM5MTQyNDhdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdWwgPSBldXJvcGUoWzExLjIwNDQ0Mzc3ODI5NzE2MSwgNDYuOTE4OTkyMjk2ODIzNjQ2XSk7XG4gICAgICAgICAgICB1ciA9IGV1cm9wZShbMTQuNTQ5OTMyMTUyODE1MDM5LCA0Ni40ODY2NTMyMDY4NTYzOTZdKTtcbiAgICAgICAgICAgIGxkID0gZXVyb3BlKFsxMy45OTQ0MDk3OTY3NjQwMDksIDQ0LjY5NTgzMzQ0NDMyMzI1Nl0pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWzEwLjgwNTMwNjU5OTI1Mzg0OCwgNDUuMTA1MTMzODcwNjg0OTI0XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gZXVyb3BlKFsxMC44MDUzMDY1OTA0MTIwODUsIDQ1LjEwNTEzMzgyOTAzMzA4XSk7XG4gICAgICAgICAgICB1ciA9IGV1cm9wZShbMTMuOTk0NDA5Nzg0NDQ3MzMsIDQ0LjY5NTgzMzQwMzE4MzYwNl0pO1xuICAgICAgICAgICAgbGQgPSBldXJvcGUoWzEzLjY1NDYzMzc5OTAyNDM5MiwgNDMuNTM1NTI0Njg1NTgxNTJdKTtcbiAgICAgICAgICAgIGxsID0gZXVyb3BlKFsxMC41NjE1MTY4MDM5ODA5NTYsIDQzLjkzMDY3MTQ1OTc5ODYyNF0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbMTAuNTYxNTE2Nzk1NjE3MzgzLCA0My45MzA2NzE0MTg1OTc1N10pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWzEzLjY1NDYzMzc4NzM2MTk1MiwgNDMuNTM1NTI0NjQ0ODY3MV0pO1xuICAgICAgICAgICAgbGQgPSBldXJvcGUoWzEyLjg2NzY5MTYwNDIzOTkwMSwgNDAuNjQwNzAxOTg1MDE5NDA1XSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbOS45OTc4MDk1MTU5ODc2ODgsIDQxLjAwMjg4MzQzMjU0NDcxXSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gZXVyb3BlKFsxMC44LCA0Mi40XSk7XG4gICAgICAgICAgICB1ciA9IGV1cm9wZShbMTIuOCwgNDIuMTNdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbEZyYW5jZS5nZXRDb21wb3NpdGlvbkJvcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGQzUGF0aC5wYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDb21wb3NpdGlvbkJvcmRlcnMoY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29uaWNDb25mb3JtYWxGcmFuY2Uuc2NhbGUoMjcwMCk7XG4gICAgfVxuICAgIC8vIFRoZSBwcm9qZWN0aW9ucyBtdXN0IGhhdmUgbXV0dWFsbHkgZXhjbHVzaXZlIGNsaXAgcmVnaW9ucyBvbiB0aGUgc3BoZXJlLFxuICAgIC8vIGFzIHRoaXMgd2lsbCBhdm9pZCBlbWl0dGluZyBpbnRlcmxlYXZpbmcgbGluZXMgYW5kIHBvbHlnb25zLlxuICAgIGZ1bmN0aW9uIG11bHRpcGxleCQ4KHN0cmVhbXMpIHtcbiAgICAgICAgdmFyIG4gPSBzdHJlYW1zLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnNwaGVyZSgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICB9IH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQSBjb21wb3NpdGUgcHJvamVjdGlvbiBmb3IgUG9ydHVnYWwsIGNvbmZpZ3VyZWQgYnkgZGVmYXVsdCBmb3IgOTYww5c1MDAuXG4gICAgZnVuY3Rpb24gY29uaWNDb25mb3JtYWxFdXJvcGUoKSB7XG4gICAgICAgIHZhciBjYWNoZSwgY2FjaGVTdHJlYW0sIGV1cm9wZSA9IGQzR2VvLmdlb0NvbmljQ29uZm9ybWFsKCkucm90YXRlKFstMTAsIC01M10pLnBhcmFsbGVscyhbMCwgNjBdKSwgZXVyb3BlUG9pbnQsIGd1YWRlbG91cGUgPSBkM0dlby5nZW9NZXJjYXRvcigpLmNlbnRlcihbLTYxLjQ2LCAxNi4xNF0pLCBndWFkZWxvdXBlUG9pbnQsIGd1eWFuZSA9IGQzR2VvLmdlb01lcmNhdG9yKCkuY2VudGVyKFstNTMuMiwgMy45XSksIGd1eWFuZVBvaW50LCBhem9yZXMgPSBkM0dlby5nZW9Db25pY0NvbmZvcm1hbCgpLnJvdGF0ZShbMjcuOCwgLTM4LjldKS5wYXJhbGxlbHMoWzAsIDYwXSksIGF6b3Jlc1BvaW50LCBhem9yZXMyID0gZDNHZW8uZ2VvQ29uaWNDb25mb3JtYWwoKS5yb3RhdGUoWzI1LjQzLCAtMzcuMzk4XSkucGFyYWxsZWxzKFswLCA2MF0pLCBhem9yZXMyUG9pbnQsIGF6b3JlczMgPSBkM0dlby5nZW9Db25pY0NvbmZvcm1hbCgpLnJvdGF0ZShbMzEuMTcsIC0zOS41MzldKS5wYXJhbGxlbHMoWzAsIDYwXSksIGF6b3JlczNQb2ludCwgbWFkZWlyYSA9IGQzR2VvLmdlb0NvbmljQ29uZm9ybWFsKCkucm90YXRlKFsxNywgLTMyLjddKS5wYXJhbGxlbHMoWzAsIDYwXSksIG1hZGVpcmFQb2ludCwgY2FuYXJ5SXNsYW5kcyA9IGQzR2VvLmdlb0NvbmljQ29uZm9ybWFsKCkucm90YXRlKFsxNiwgLTI4LjVdKS5wYXJhbGxlbHMoWzAsIDYwXSksIGNhbmFyeUlzbGFuZHNQb2ludCwgbWFydGluaXF1ZSA9IGQzR2VvLmdlb01lcmNhdG9yKCkuY2VudGVyKFstNjEuMDMsIDE0LjY3XSksIG1hcnRpbmlxdWVQb2ludCwgbWF5b3R0ZSA9IGQzR2VvLmdlb01lcmNhdG9yKCkuY2VudGVyKFs0NS4xNiwgLTEyLjhdKSwgbWF5b3R0ZVBvaW50LCByZXVuaW9uID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5jZW50ZXIoWzU1LjUyLCAtMjEuMTNdKSwgcmV1bmlvblBvaW50LCBtYWx0YSA9IGQzR2VvLmdlb0NvbmljQ29uZm9ybWFsKCkucm90YXRlKFstMTQuNCwgLTM1Ljk1XSkucGFyYWxsZWxzKFswLCA2MF0pLCBtYWx0YVBvaW50LCBwb2ludCwgcG9pbnRTdHJlYW0gPSB7IHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyBwb2ludCA9IFt4LCB5XTsgfSB9O1xuICAgICAgICAvKlxuICAgICAgICB2YXIgZXVyb3BlQmJveCA9IFtbLTYuNSwgNTFdLCBbMTAsIDQxXV07XG4gICAgICAgIHZhciBndXlhbmVCYm94ID0gW1stNTQuNSwgNi4yOV0sIFstNTAuOSwgMS40OF1dO1xuICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjb25pY0NvbmZvcm1hbEV1cm9wZShjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIHggPSBjb29yZGluYXRlc1swXSwgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50ID0gbnVsbCxcbiAgICAgICAgICAgICAgICAoZXVyb3BlUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoZ3V5YW5lUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAobWFydGluaXF1ZVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGd1YWRlbG91cGVQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChjYW5hcnlJc2xhbmRzUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAobWFkZWlyYVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG1heW90dGVQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXVuaW9uUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAobWFsdGFQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChhem9yZXNQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChhem9yZXMyUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoYXpvcmVzM1BvaW50LnBvaW50KHgsIHkpLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uaWNDb25mb3JtYWxFdXJvcGUuaW52ZXJ0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgayA9IGV1cm9wZS5zY2FsZSgpLCB0ID0gZXVyb3BlLnRyYW5zbGF0ZSgpLCB4ID0gKGNvb3JkaW5hdGVzWzBdIC0gKHRbMF0gKyAwLjA4ICogaykpIC8gaywgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICAgICAgICAgIHJldHVybiAoeSA+PSAtMC4zMSAmJiB5IDwgLTAuMjQgJiYgeCA+PSAwLjE0ICYmIHggPCAwLjI0ID8gZ3VhZGVsb3VwZVxuICAgICAgICAgICAgICAgIDogeSA+PSAtMC4yNCAmJiB5IDwgLTAuMTcgJiYgeCA+PSAwLjE0ICYmIHggPCAwLjI0ID8gZ3V5YW5lXG4gICAgICAgICAgICAgICAgICAgIDogeSA+PSAtMC4xNyAmJiB5IDwgLTAuMTIgJiYgeCA+PSAwLjIxICYmIHggPCAwLjI0ID8gYXpvcmVzMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiB5ID49IC0wLjE3ICYmIHkgPCAtMC4xNCAmJiB4ID49IDAuMTQgJiYgeCA8IDAuMTY1ID8gYXpvcmVzM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAtMC4xNyAmJiB5IDwgLTAuMSAmJiB4ID49IDAuMTQgJiYgeCA8IDAuMjQgPyBhem9yZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB5ID49IC0wLjEgJiYgeSA8IC0wLjAzICYmIHggPj0gMC4xNCAmJiB4IDwgMC4yNCA/IG1hZGVpcmFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAtMC4wMyAmJiB5IDwgMC4wNCAmJiB4ID49IDAuMTQgJiYgeCA8IDAuMjQgPyBjYW5hcnlJc2xhbmRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB5ID49IC0wLjMxICYmIHkgPCAtMC4yNCAmJiB4ID49IDAuMjQgJiYgeCA8IDAuMzQgPyBtYXJ0aW5pcXVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeSA+PSAtMC4yNCAmJiB5IDwgLTAuMTcgJiYgeCA+PSAwLjI0ICYmIHggPCAwLjM0ID8gbWF5b3R0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB5ID49IC0wLjE3ICYmIHkgPCAtMC4xICYmIHggPj0gMC4yNCAmJiB4IDwgMC4zNCA/IHJldW5pb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHkgPj0gLTAuMSAmJiB5IDwgLTAuMDMgJiYgeCA+PSAwLjI0ICYmIHggPCAwLjM0ID8gbWFsdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBldXJvcGUpLmludmVydChjb29yZGluYXRlcyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsRXVyb3BlLnN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IG11bHRpcGxleCQ4KFtldXJvcGUuc3RyZWFtKGNhY2hlU3RyZWFtID0gc3RyZWFtKSwgZ3V5YW5lLnN0cmVhbShzdHJlYW0pLCBtYXJ0aW5pcXVlLnN0cmVhbShzdHJlYW0pLCBndWFkZWxvdXBlLnN0cmVhbShzdHJlYW0pLCBjYW5hcnlJc2xhbmRzLnN0cmVhbShzdHJlYW0pLCBtYWRlaXJhLnN0cmVhbShzdHJlYW0pLCBtYXlvdHRlLnN0cmVhbShzdHJlYW0pLCByZXVuaW9uLnN0cmVhbShzdHJlYW0pLCBtYWx0YS5zdHJlYW0oc3RyZWFtKSwgYXpvcmVzLnN0cmVhbShzdHJlYW0pLCBhem9yZXMyLnN0cmVhbShzdHJlYW0pLCBhem9yZXMzLnN0cmVhbShzdHJlYW0pXSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsRXVyb3BlLnByZWNpc2lvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXVyb3BlLnByZWNpc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXVyb3BlLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGd1eWFuZS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBtYXJ0aW5pcXVlLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGd1YWRlbG91cGUucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgY2FuYXJ5SXNsYW5kcy5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBtYWRlaXJhLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIG1heW90dGUucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgcmV1bmlvbi5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBtYWx0YS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBhem9yZXMucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgYXpvcmVzMi5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBhem9yZXMzLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbEV1cm9wZS5zY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXVyb3BlLnNjYWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldXJvcGUuc2NhbGUoXyk7XG4gICAgICAgICAgICBndWFkZWxvdXBlLnNjYWxlKF8gKiAzKTtcbiAgICAgICAgICAgIGd1eWFuZS5zY2FsZShfICogMC44KTtcbiAgICAgICAgICAgIG1hcnRpbmlxdWUuc2NhbGUoXyAqIDMuNSk7XG4gICAgICAgICAgICByZXVuaW9uLnNjYWxlKF8gKiAyLjcpO1xuICAgICAgICAgICAgYXpvcmVzLnNjYWxlKF8gKiAyKTtcbiAgICAgICAgICAgIGF6b3JlczIuc2NhbGUoXyAqIDIpO1xuICAgICAgICAgICAgYXpvcmVzMy5zY2FsZShfICogMik7XG4gICAgICAgICAgICBtYWRlaXJhLnNjYWxlKF8gKiAzKTtcbiAgICAgICAgICAgIGNhbmFyeUlzbGFuZHMuc2NhbGUoXyk7XG4gICAgICAgICAgICBtYXlvdHRlLnNjYWxlKF8gKiA1LjUpO1xuICAgICAgICAgICAgbWFsdGEuc2NhbGUoXyAqIDYpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmljQ29uZm9ybWFsRXVyb3BlLnRyYW5zbGF0ZShldXJvcGUudHJhbnNsYXRlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbEV1cm9wZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV1cm9wZS50cmFuc2xhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrID0gZXVyb3BlLnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xuICAgICAgICAgICAgZXVyb3BlUG9pbnQgPSBldXJvcGVcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4wOCAqIGssIHldKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuNTEgKiBrLCB5IC0gMC4zMyAqIGtdLCBbeCArIDAuNSAqIGssIHkgKyAwLjMzICoga11dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgZ3VhZGVsb3VwZVBvaW50ID0gZ3VhZGVsb3VwZVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggKyAwLjE5ICogaywgeSAtIDAuMjc1ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4ICsgMC4xNCAqIGsgKyBlcHNpbG9uLCB5IC0gMC4zMSAqIGsgKyBlcHNpbG9uXSwgW3ggKyAwLjI0ICogayAtIGVwc2lsb24sIHkgLSAwLjI0ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGd1eWFuZVBvaW50ID0gZ3V5YW5lXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMTkgKiBrLCB5IC0gMC4yMDUgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggKyAwLjE0ICogayArIGVwc2lsb24sIHkgLSAwLjI0ICogayArIGVwc2lsb25dLCBbeCArIDAuMjQgKiBrIC0gZXBzaWxvbiwgeSAtIDAuMTcgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgYXpvcmVzUG9pbnQgPSBhem9yZXNcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4ICsgMC4xOSAqIGssIHkgLSAwLjEzNSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCArIDAuMTQgKiBrICsgZXBzaWxvbiwgeSAtIDAuMTcgKiBrICsgZXBzaWxvbl0sIFt4ICsgMC4yNCAqIGsgLSBlcHNpbG9uLCB5IC0gMC4xICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGF6b3JlczJQb2ludCA9IGF6b3JlczJcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4ICsgMC4yMjUgKiBrLCB5IC0gMC4xNDcgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggKyAwLjIxICogayArIGVwc2lsb24sIHkgLSAwLjE3ICogayArIGVwc2lsb25dLCBbeCArIDAuMjQgKiBrIC0gZXBzaWxvbiwgeSAtIDAuMTIgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgYXpvcmVzM1BvaW50ID0gYXpvcmVzM1xuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggKyAwLjE1MyAqIGssIHkgLSAwLjE1ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4ICsgMC4xNCAqIGsgKyBlcHNpbG9uLCB5IC0gMC4xNyAqIGsgKyBlcHNpbG9uXSwgW3ggKyAwLjE2NSAqIGsgLSBlcHNpbG9uLCB5IC0gMC4xNCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBtYWRlaXJhUG9pbnQgPSBtYWRlaXJhXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMTkgKiBrLCB5IC0gMC4wNjUgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggKyAwLjE0ICogayArIGVwc2lsb24sIHkgLSAwLjEgKiBrICsgZXBzaWxvbl0sIFt4ICsgMC4yNCAqIGsgLSBlcHNpbG9uLCB5IC0gMC4wMyAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBjYW5hcnlJc2xhbmRzUG9pbnQgPSBjYW5hcnlJc2xhbmRzXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMTkgKiBrLCB5ICsgMC4wMDUgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggKyAwLjE0ICogayArIGVwc2lsb24sIHkgLSAwLjAzICogayArIGVwc2lsb25dLCBbeCArIDAuMjQgKiBrIC0gZXBzaWxvbiwgeSArIDAuMDQgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgbWFydGluaXF1ZVBvaW50ID0gbWFydGluaXF1ZVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggKyAwLjI5ICogaywgeSAtIDAuMjc1ICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4ICsgMC4yNCAqIGsgKyBlcHNpbG9uLCB5IC0gMC4zMSAqIGsgKyBlcHNpbG9uXSwgW3ggKyAwLjM0ICogayAtIGVwc2lsb24sIHkgLSAwLjI0ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIG1heW90dGVQb2ludCA9IG1heW90dGVcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4ICsgMC4yOSAqIGssIHkgLSAwLjIwNSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCArIDAuMjQgKiBrICsgZXBzaWxvbiwgeSAtIDAuMjQgKiBrICsgZXBzaWxvbl0sIFt4ICsgMC4zNCAqIGsgLSBlcHNpbG9uLCB5IC0gMC4xNyAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICByZXVuaW9uUG9pbnQgPSByZXVuaW9uXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCArIDAuMjkgKiBrLCB5IC0gMC4xMzUgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggKyAwLjI0ICogayArIGVwc2lsb24sIHkgLSAwLjE3ICogayArIGVwc2lsb25dLCBbeCArIDAuMzQgKiBrIC0gZXBzaWxvbiwgeSAtIDAuMSAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBtYWx0YVBvaW50ID0gbWFsdGFcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4ICsgMC4yOSAqIGssIHkgLSAwLjA2NSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCArIDAuMjQgKiBrICsgZXBzaWxvbiwgeSAtIDAuMSAqIGsgKyBlcHNpbG9uXSwgW3ggKyAwLjM0ICogayAtIGVwc2lsb24sIHkgLSAwLjAzICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25pY0NvbmZvcm1hbEV1cm9wZS5maXRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQoY29uaWNDb25mb3JtYWxFdXJvcGUsIGV4dGVudCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uaWNDb25mb3JtYWxFdXJvcGUuZml0U2l6ZSA9IGZ1bmN0aW9uIChzaXplLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRTaXplKGNvbmljQ29uZm9ybWFsRXVyb3BlLCBzaXplLCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmljQ29uZm9ybWFsRXVyb3BlO1xuICAgICAgICB9XG4gICAgICAgIGNvbmljQ29uZm9ybWFsRXVyb3BlLmRyYXdDb21wb3NpdGlvbkJvcmRlcnMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidmFyIHVsLCB1ciwgbGQsIGxsO1wiKTtcbiAgICAgICAgICAgIHZhciBwcm9qcyA9IFtndXlhbmUsIG1hcnRpbmlxdWUsIGd1YWRlbG91cGUsIGNhbmFyeUlzbGFuZHMsIG1hZGVpcmEsIG1heW90dGUsIHJldW5pb24sIG1hbHRhLCBhem9yZXMsIGF6b3JlczIsIGF6b3JlczNdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBwcm9qcyl7XG4gICAgICAgICAgICAgIHZhciB1bCA9IGV1cm9wZS5pbnZlcnQoW3Byb2pzW2ldLmNsaXBFeHRlbnQoKVswXVswXSwgcHJvanNbaV0uY2xpcEV4dGVudCgpWzBdWzFdXSk7XG4gICAgICAgICAgICAgIHZhciB1ciA9IGV1cm9wZS5pbnZlcnQoW3Byb2pzW2ldLmNsaXBFeHRlbnQoKVsxXVswXSwgcHJvanNbaV0uY2xpcEV4dGVudCgpWzBdWzFdXSk7XG4gICAgICAgICAgICAgIHZhciBsZCA9IGV1cm9wZS5pbnZlcnQoW3Byb2pzW2ldLmNsaXBFeHRlbnQoKVsxXVswXSwgcHJvanNbaV0uY2xpcEV4dGVudCgpWzFdWzFdXSk7XG4gICAgICAgICAgICAgIHZhciBsbCA9IGV1cm9wZS5pbnZlcnQoW3Byb2pzW2ldLmNsaXBFeHRlbnQoKVswXVswXSwgcHJvanNbaV0uY2xpcEV4dGVudCgpWzFdWzFdXSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInVsID0gZXVyb3BlKFtcIit1bCtcIl0pO1wiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1ciA9IGV1cm9wZShbXCIrdXIrXCJdKTtcIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibGQgPSBldXJvcGUoW1wiK2xkK1wiXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImxsID0gZXVyb3BlKFtcIitsbCtcIl0pO1wiKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dC5jbG9zZVBhdGgoKTtcIik7XG4gICAgICAgIFxuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICB2YXIgdWwsIHVyLCBsZCwgbGw7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbNDIuNDU3NTU2MTA4Mjg2NDgsIDYzLjM0MzY1ODU0NzkxNDkzNF0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWzUyLjY1ODM3MjY2NjY3MDI5LCA1OS4zNTA0NTA4MDI5MDkyOV0pO1xuICAgICAgICAgICAgbGQgPSBldXJvcGUoWzQ3LjE5NzU0NTAyMjQ3Nzg1LCA1Ni4xMjY1MzQ5NjU0ODExN10pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWzM3LjY3MzAzNDI3MzM2MzA0NCwgNTkuNjE2MzgyNjg1MDYxMTFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdWwgPSBldXJvcGUoWzU5LjQxMTEwNzU0MDAzNDAzLCA2Mi4zNTA2OTcyNzM5OTMzNl0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWzY2Ljc1MDUwMjI4NjQwNzk0LCA1Ny4xMTc5NzMwMzYzNjAzOF0pO1xuICAgICAgICAgICAgbGQgPSBldXJvcGUoWzYwLjIzNjA2NTcyNTExMDQzNiwgNTQuNjMzMzE0MzM4MTg5OTJdKTtcbiAgICAgICAgICAgIGxsID0gZXVyb3BlKFs1Mi42NTgzNzMxMzE1MzMxMSwgNTkuMzUwNDUwODA0NTk5MzU1XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gZXVyb3BlKFs0OC44MTA5MTEzMDA4MDI0MywgNjYuOTMzNTM0MDI2MzQ2NDFdKTtcbiAgICAgICAgICAgIHVyID0gZXVyb3BlKFs1OS40MTExMDczMDY1NDY3OSwgNjIuMzUwNjk3NDA2NTMwODZdKTtcbiAgICAgICAgICAgIGxkID0gZXVyb3BlKFs1Mi42NTgzNzI4OTc0NDQxLCA1OS4zNTA0NTA5MjIyNDQ1XSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbNDIuNDU3NTU2MzE2NzU3NTEsIDYzLjM0MzY1ODY4ODA1ODIxXSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gZXVyb3BlKFszMS4wNTQxOTg0MTg0NDY0NzUsIDUyLjEwODA2NzM3NjYxODRdKTtcbiAgICAgICAgICAgIHVyID0gZXVyb3BlKFszOS4wOTg2OTI4NDg4NDExNywgNDkuNDAwNzAwMDQ3MTkwNTU0XSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbMzYuMDU4MDgxMTQ5OTE3NSwgNDYuMDI5NDQxNzQ5MDg0OThdKTtcbiAgICAgICAgICAgIGxsID0gZXVyb3BlKFsyOC42OTA1MDg1ODg4MzU3MjYsIDQ4LjQzMzEyNjk3OTM4NjQxNV0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbMzMuOTc3ODc3NzQ1OTEyMDI1LCA1NS44NDk5NDU1MDEzMzFdKTtcbiAgICAgICAgICAgIHVyID0gZXVyb3BlKFs0Mi43NTMyODQzMjE2NzcyNiwgNTIuNzg0NTUxMjI0NjIzNTNdKTtcbiAgICAgICAgICAgIGxkID0gZXVyb3BlKFszOS4wOTg2OTI5NzU0MDIyNCwgNDkuNDAwNzAwMTc2MTQ4NjI1XSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbMzEuMDU0MTk4NTE4MDcwMDgsIDUyLjEwODA2NzUxODEwOTIzXSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gZXVyb3BlKFs1Mi42NTgzNzI5MDA3NTkyOTYsIDU5LjM1MDQ1MDY4NTI2NDE1XSk7XG4gICAgICAgICAgICB1ciA9IGV1cm9wZShbNjAuMjM2MDY1NDk1ODMzMDQsIDU0LjYzMzMxNDIzODAwMjY0XSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbNTQuNjc1NjM3MDk1MzEyMiwgNTEuODkyMjk4Nzg5Mzk5NDU1XSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbNDcuMTk3NTQ1MjQ3ODgxODksIDU2LjEyNjUzNDg2MTIyMjc5NF0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbNDcuMTk3NTQ1MDYwODI0NTUsIDU2LjEyNjUzNDczNTU5MTQ1Nl0pO1xuICAgICAgICAgICAgdXIgPSBldXJvcGUoWzU0LjY3NTYzNjkwMDEyMzUxNCwgNTEuODkyMjk4NjgxMzM3MDk1XSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbNDkuOTQ0NDg2NDg5NTE0ODYsIDQ4Ljk4Nzc1NDg0OTgzMjg1XSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbNDIuNzUzMjg0Njg3MTYxMDgsIDUyLjc4NDU1MTI2MDYwODE4XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gZXVyb3BlKFs0Mi43NTMyODQ1MzQxNjc2OSwgNTIuNzg0NTUxMTMyMDkxMDFdKTtcbiAgICAgICAgICAgIHVyID0gZXVyb3BlKFs0OS45NDQ0ODYzMjMzOTc1OCwgNDguOTg3NzU0NzM3MDY0NTddKTtcbiAgICAgICAgICAgIGxkID0gZXVyb3BlKFs0NS45MTIzMzk5OTAzOTQzMTUsIDQ1Ljk5MzYxNzg0OTg3MDAzXSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbMzkuMDk4NjkzMTczNTY2MDcsIDQ5LjQwMDcwMDA5Mzc4NzExXSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gZXVyb3BlKFszNy42NzMwMzQxMTQyOTY2MzQsIDU5LjYxNjM4MjU0MTgzMTE5XSk7XG4gICAgICAgICAgICB1ciA9IGV1cm9wZShbNDcuMTk3NTQ0ODM1NDIwNTQ0LCA1Ni4xMjY1MzQ4Mzk4NDk4NDZdKTtcbiAgICAgICAgICAgIGxkID0gZXVyb3BlKFs0Mi43NTMyODQ0NzQ2NzA2NCwgNTIuNzg0NTUxMzUzMTQwNjhdKTtcbiAgICAgICAgICAgIGxsID0gZXVyb3BlKFszMy45Nzc4Nzc4NzAzNjM5MDUsIDU1Ljg0OTk0NTY0NDY3MTE0NV0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB1bCA9IGV1cm9wZShbNDQuNTY3NDg0ODY0NDYwMzIsIDU3LjI2NDg5MzY3ODQ1ODE4XSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbNDMuOTMzNTc5MTE5MzU4OCwgNTMuNzQ2NTQwOTQyNjAxNzI2XSk7XG4gICAgICAgICAgICBsbCA9IGV1cm9wZShbNDMsIDU2XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHVsID0gZXVyb3BlKFszNy42NzMwMzQxMTQyOTY2MzQsIDU5LjYxNjM4MjU0MTgzMTE5XSk7XG4gICAgICAgICAgICB1ciA9IGV1cm9wZShbNDAuMjU5MDI2OTE5NTM0NjYsIDU4LjgzMDAyMDQ0MjIyNjM5XSk7XG4gICAgICAgICAgICBsZCA9IGV1cm9wZShbMzguNDU4MjcwNDkyNzQyMDI0LCA1Ny4yNjIzMjE3ODAyODAwMl0pO1xuICAgICAgICAgICAgbGwgPSBldXJvcGUoWzM1Ljk3NzU0OTQ4MDMwMTU2LCA1OC4wMDI2NjYzNzk5MjM4Nl0pO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHVyWzBdLCB1clsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsZFswXSwgbGRbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmljQ29uZm9ybWFsRXVyb3BlLmdldENvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZDNQYXRoLnBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyhjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb25pY0NvbmZvcm1hbEV1cm9wZS5zY2FsZSg3NTApO1xuICAgIH1cbiAgICAvLyBUaGUgcHJvamVjdGlvbnMgbXVzdCBoYXZlIG11dHVhbGx5IGV4Y2x1c2l2ZSBjbGlwIHJlZ2lvbnMgb24gdGhlIHNwaGVyZSxcbiAgICAvLyBhcyB0aGlzIHdpbGwgYXZvaWQgZW1pdHRpbmcgaW50ZXJsZWF2aW5nIGxpbmVzIGFuZCBwb2x5Z29ucy5cbiAgICBmdW5jdGlvbiBtdWx0aXBsZXgkOShzdHJlYW1zKSB7XG4gICAgICAgIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5zcGhlcmUoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgfSB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEEgY29tcG9zaXRlIHByb2plY3Rpb24gZm9yIE1hbGF5c2lhLCBjb25maWd1cmVkIGJ5IGRlZmF1bHQgZm9yIDk2MMOXNTAwLlxuICAgIGZ1bmN0aW9uIG1lcmNhdG9yTWFsYXlzaWEoKSB7XG4gICAgICAgIHZhciBjYWNoZSwgY2FjaGVTdHJlYW0sIHBlbmluc3VsYXIgPSBkM0dlby5nZW9NZXJjYXRvcigpLmNlbnRlcihbMTA1LjI1LCA0LjAwXSksIHBlbmluc3VsYXJQb2ludCwgYm9ybmVvID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5jZW50ZXIoWzExOC42NSwgMi44Nl0pLCBib3JuZW9Qb2ludCwgcG9pbnQsIHBvaW50U3RyZWFtID0geyBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgcG9pbnQgPSBbeCwgeV07IH0gfTtcbiAgICAgICAgZnVuY3Rpb24gbWVyY2F0b3JNYWxheXNpYShjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIHggPSBjb29yZGluYXRlc1swXSwgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50ID0gbnVsbCxcbiAgICAgICAgICAgICAgICAocGVuaW5zdWxhclBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGJvcm5lb1BvaW50LnBvaW50KHgsIHkpLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyY2F0b3JNYWxheXNpYS5pbnZlcnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciBrID0gcGVuaW5zdWxhci5zY2FsZSgpLCB0ID0gcGVuaW5zdWxhci50cmFuc2xhdGUoKSwgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gaywgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICAgICAgICAgIHJldHVybiAoeSA+PSAtMC4wNTIxICYmIHkgPCAwLjAyMjkgJiYgeCA+PSAtMC4wMTExICYmIHggPCAwLjEwMDAgPyBib3JuZW9cbiAgICAgICAgICAgICAgICA6IHBlbmluc3VsYXIpLmludmVydChjb29yZGluYXRlcyk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yTWFsYXlzaWEuc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gbXVsdGlwbGV4JDkoW3Blbmluc3VsYXIuc3RyZWFtKGNhY2hlU3RyZWFtID0gc3RyZWFtKSwgYm9ybmVvLnN0cmVhbShzdHJlYW0pXSk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yTWFsYXlzaWEucHJlY2lzaW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwZW5pbnN1bGFyLnByZWNpc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVuaW5zdWxhci5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICBib3JuZW8ucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yTWFsYXlzaWEuc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlbmluc3VsYXIuc2NhbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlbmluc3VsYXIuc2NhbGUoXyk7XG4gICAgICAgICAgICBib3JuZW8uc2NhbGUoXyAqIDAuNjE1KTtcbiAgICAgICAgICAgIHJldHVybiBtZXJjYXRvck1hbGF5c2lhLnRyYW5zbGF0ZShwZW5pbnN1bGFyLnRyYW5zbGF0ZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVyY2F0b3JNYWxheXNpYS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlbmluc3VsYXIudHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgayA9IHBlbmluc3VsYXIuc2NhbGUoKSwgeCA9ICtfWzBdLCB5ID0gK19bMV07XG4gICAgICAgICAgICBwZW5pbnN1bGFyUG9pbnQgPSBwZW5pbnN1bGFyXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShfKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMTEwMCAqIGssIHkgLSAwLjA1MjEgKiBrXSwgW3ggLSAwLjAxMTEgKiBrLCB5ICsgMC4wNTIxICoga11dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgYm9ybmVvUG9pbnQgPSBib3JuZW9cbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4ICsgMC4wOTAwMCAqIGssIHkgLSAwLjAwICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4wMTExICogayArIGVwc2lsb24sIHkgLSAwLjA1MjEgKiBrICsgZXBzaWxvbl0sIFt4ICsgMC4xMDAwICogayAtIGVwc2lsb24sIHkgKyAwLjAyNCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVyY2F0b3JNYWxheXNpYS5maXRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQobWVyY2F0b3JNYWxheXNpYSwgZXh0ZW50LCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBtZXJjYXRvck1hbGF5c2lhLmZpdFNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0U2l6ZShtZXJjYXRvck1hbGF5c2lhLCBzaXplLCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG1lcmNhdG9yTWFsYXlzaWE7XG4gICAgICAgIH1cbiAgICAgICAgbWVyY2F0b3JNYWxheXNpYS5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBsbGJvciA9IHBlbmluc3VsYXIoWzEwNi4zMjE0LCAyLjAyMjhdKTtcbiAgICAgICAgICAgIHZhciBsbWJvciA9IHBlbmluc3VsYXIoWzEwNS4xODQzLCAyLjM3NjFdKTtcbiAgICAgICAgICAgIHZhciBscmJvciA9IHBlbmluc3VsYXIoWzEwNC4yMTUxLCAzLjM2MThdKTtcbiAgICAgICAgICAgIHZhciBsbHJib3IgPSBwZW5pbnN1bGFyKFsxMDQuMjE1MCwgNC41NjUxXSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhsbGJvclswXSwgbGxib3JbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obG1ib3JbMF0sIGxtYm9yWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxyYm9yWzBdLCBscmJvclsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbHJib3JbMF0sIGxscmJvclsxXSk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yTWFsYXlzaWEuZ2V0Q29tcG9zaXRpb25Cb3JkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBkM1BhdGgucGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Q29tcG9zaXRpb25Cb3JkZXJzKGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1lcmNhdG9yTWFsYXlzaWEuc2NhbGUoNDgwMCk7XG4gICAgfVxuICAgIC8vIFRoZSBwcm9qZWN0aW9ucyBtdXN0IGhhdmUgbXV0dWFsbHkgZXhjbHVzaXZlIGNsaXAgcmVnaW9ucyBvbiB0aGUgc3BoZXJlLFxuICAgIC8vIGFzIHRoaXMgd2lsbCBhdm9pZCBlbWl0dGluZyBpbnRlcmxlYXZpbmcgbGluZXMgYW5kIHBvbHlnb25zLlxuICAgIGZ1bmN0aW9uIG11bHRpcGxleCRhKHN0cmVhbXMpIHtcbiAgICAgICAgdmFyIG4gPSBzdHJlYW1zLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnNwaGVyZSgpO1xuICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICB9IH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQSBjb21wb3NpdGUgcHJvamVjdGlvbiBmb3IgRXF1YXRvcmlhbCBHdWluZWEsIGNvbmZpZ3VyZWQgYnkgZGVmYXVsdCBmb3IgOTYww5c1MDAuXG4gICAgZnVuY3Rpb24gbWVyY2F0b3JFcXVhdG9yaWFsR3VpbmVhKCkge1xuICAgICAgICB2YXIgY2FjaGUsIGNhY2hlU3RyZWFtLCBjb250aW5lbnQgPSBkM0dlby5nZW9NZXJjYXRvcigpLnJvdGF0ZShbLTkuNSwgLTEuNV0pLCBjb250aW5lbnRQb2ludCwgYmlva28gPSBkM0dlby5nZW9NZXJjYXRvcigpLnJvdGF0ZShbLTguNiwgLTMuNV0pLCBiaW9rb1BvaW50LCBhbm5vYm9uID0gZDNHZW8uZ2VvTWVyY2F0b3IoKS5yb3RhdGUoWy01LjYsIDEuNDVdKSwgYW5ub2JvblBvaW50LCBwb2ludCwgcG9pbnRTdHJlYW0gPSB7IHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyBwb2ludCA9IFt4LCB5XTsgfSB9O1xuICAgICAgICBmdW5jdGlvbiBtZXJjYXRvckVxdWF0b3JpYWxHdWluZWEoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciB4ID0gY29vcmRpbmF0ZXNbMF0sIHkgPSBjb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludCA9IG51bGwsXG4gICAgICAgICAgICAgICAgKGNvbnRpbmVudFBvaW50LnBvaW50KHgsIHkpLCBwb2ludCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKGJpb2tvUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAoYW5ub2JvblBvaW50LnBvaW50KHgsIHkpLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyY2F0b3JFcXVhdG9yaWFsR3VpbmVhLmludmVydCA9IGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIGsgPSBjb250aW5lbnQuc2NhbGUoKSwgdCA9IGNvbnRpbmVudC50cmFuc2xhdGUoKSwgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gaywgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICAgICAgICAgIHJldHVybiAoeSA+PSAtMC4wMiAmJiB5IDwgMCAmJiB4ID49IC0wLjAzOCAmJiB4IDwgLTAuMDA1ID8gYmlva29cbiAgICAgICAgICAgICAgICA6IHkgPj0gMCAmJiB5IDwgMC4wMiAmJiB4ID49IC0wLjAzOCAmJiB4IDwgLTAuMDA1ID8gYW5ub2JvblxuICAgICAgICAgICAgICAgICAgICA6IGNvbnRpbmVudCkuaW52ZXJ0KGNvb3JkaW5hdGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVyY2F0b3JFcXVhdG9yaWFsR3VpbmVhLnN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IG11bHRpcGxleCRhKFtjb250aW5lbnQuc3RyZWFtKGNhY2hlU3RyZWFtID0gc3RyZWFtKSwgYmlva28uc3RyZWFtKHN0cmVhbSksIGFubm9ib24uc3RyZWFtKHN0cmVhbSldKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVyY2F0b3JFcXVhdG9yaWFsR3VpbmVhLnByZWNpc2lvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGluZW50LnByZWNpc2lvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGluZW50LnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGJpb2tvLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIGFubm9ib24ucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yRXF1YXRvcmlhbEd1aW5lYS5zY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGluZW50LnNjYWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW5lbnQuc2NhbGUoXyk7XG4gICAgICAgICAgICBiaW9rby5zY2FsZShfICogMS41KTtcbiAgICAgICAgICAgIGFubm9ib24uc2NhbGUoXyAqIDQpO1xuICAgICAgICAgICAgcmV0dXJuIG1lcmNhdG9yRXF1YXRvcmlhbEd1aW5lYS50cmFuc2xhdGUoY29udGluZW50LnRyYW5zbGF0ZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVyY2F0b3JFcXVhdG9yaWFsR3VpbmVhLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGluZW50LnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGsgPSBjb250aW5lbnQuc2NhbGUoKSwgeCA9ICtfWzBdLCB5ID0gK19bMV07XG4gICAgICAgICAgICBjb250aW5lbnRQb2ludCA9IGNvbnRpbmVudFxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoXylcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjAwNSAqIGssIHkgLSAwLjAyICoga10sIFt4ICsgMC4wMzggKiBrLCB5ICsgMC4wMiAqIGtdXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGJpb2tvUG9pbnQgPSBiaW9rb1xuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjAyNSAqIGssIHkgLSAwLjAxICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4wMzggKiBrICsgZXBzaWxvbiwgeSAtIDAuMDIgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4wMDUgKiBrIC0gZXBzaWxvbiwgeSArIDAgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgYW5ub2JvblBvaW50ID0gYW5ub2JvblxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjAyNSAqIGssIHkgKyAwLjAxICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4wMzggKiBrICsgZXBzaWxvbiwgeSAtIDAgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4wMDUgKiBrIC0gZXBzaWxvbiwgeSArIDAuMDIgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yRXF1YXRvcmlhbEd1aW5lYS5maXRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQobWVyY2F0b3JFcXVhdG9yaWFsR3VpbmVhLCBleHRlbnQsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIG1lcmNhdG9yRXF1YXRvcmlhbEd1aW5lYS5maXRTaXplID0gZnVuY3Rpb24gKHNpemUsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdFNpemUobWVyY2F0b3JFcXVhdG9yaWFsR3VpbmVhLCBzaXplLCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG1lcmNhdG9yRXF1YXRvcmlhbEd1aW5lYTtcbiAgICAgICAgfVxuICAgICAgICBtZXJjYXRvckVxdWF0b3JpYWxHdWluZWEuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ2YXIgdWwsIHVyLCBsZCwgbGw7XCIpO1xuICAgICAgICAgICAgdmFyIHByb2pzID0gW2NvbnRpbmVudCwgYmlva28sIGFubm9ib25dO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBwcm9qcyl7XG4gICAgICAgICAgICAgIHZhciB1bCA9IGNvbnRpbmVudC5pbnZlcnQoW3Byb2pzW2ldLmNsaXBFeHRlbnQoKVswXVswXSwgcHJvanNbaV0uY2xpcEV4dGVudCgpWzBdWzFdXSk7XG4gICAgICAgICAgICAgIHZhciB1ciA9IGNvbnRpbmVudC5pbnZlcnQoW3Byb2pzW2ldLmNsaXBFeHRlbnQoKVsxXVswXSwgcHJvanNbaV0uY2xpcEV4dGVudCgpWzBdWzFdXSk7XG4gICAgICAgICAgICAgIHZhciBsZCA9IGNvbnRpbmVudC5pbnZlcnQoW3Byb2pzW2ldLmNsaXBFeHRlbnQoKVsxXVswXSwgcHJvanNbaV0uY2xpcEV4dGVudCgpWzFdWzFdXSk7XG4gICAgICAgICAgICAgIHZhciBsbCA9IGNvbnRpbmVudC5pbnZlcnQoW3Byb2pzW2ldLmNsaXBFeHRlbnQoKVswXVswXSwgcHJvanNbaV0uY2xpcEV4dGVudCgpWzFdWzFdXSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInVsID0gY29udGluZW50KFtcIit1bCtcIl0pO1wiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1ciA9IGNvbnRpbmVudChbXCIrdXIrXCJdKTtcIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibGQgPSBjb250aW5lbnQoW1wiK2xkK1wiXSk7XCIpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImxsID0gY29udGluZW50KFtcIitsbCtcIl0pO1wiKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dC5tb3ZlVG8odWxbMF0sIHVsWzFdKTtcIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dC5saW5lVG8obGxbMF0sIGxsWzFdKTtcIik7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dC5jbG9zZVBhdGgoKTtcIik7XG4gICAgICAgIFxuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICB2YXIgdWwsIHVyLCBsZCwgbGw7XG4gICAgICAgICAgICB1bCA9IGNvbnRpbmVudChbOS4yMTMyNzI3Mjc1MTY4MiwgMi42NDU4MjA0Mzk0NTQxMjNdKTtcbiAgICAgICAgICAgIHVyID0gY29udGluZW50KFsxMS42NzkxMjYyOTMyMzk4NzIsIDIuNjQ0NzU1NTE5MjY4Njg5XSk7XG4gICAgICAgICAgICBsZCA9IGNvbnRpbmVudChbMTEuNjc2ODQ1Mzg5MDI5MjI3LCAwLjM1MzA3ODI0NjM3NjA2NDMzXSk7XG4gICAgICAgICAgICBsbCA9IGNvbnRpbmVudChbOS4yMTM1NzI5MTc3NzQwMTQsIDAuMzU0MTQyMDUyMDQ0MTc3NTRdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdWwgPSBjb250aW5lbnQoWzcuMzIwODczNzExNTQzNjY5LCAyLjY0NDc1NTUxNDQ5OTc1XSk7XG4gICAgICAgICAgICB1ciA9IGNvbnRpbmVudChbOS4yMTMyNzI3MjI3Mzg2NTgsIDIuNjQ1ODIwNDM0Njc5ODAzXSk7XG4gICAgICAgICAgICBsZCA9IGNvbnRpbmVudChbOS4yMTM0MjI4OTY0ODAzNDksIDEuNDk5OTgxMjUwNTI4MzA1NF0pO1xuICAgICAgICAgICAgbGwgPSBjb250aW5lbnQoWzcuMzIyMDE0NzYwNTIwNzg3LCAxLjQ5ODkxNjg4Nzg5ODU1NjZdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdWwgPSBjb250aW5lbnQoWzcuMzIyMDE0NzYwNTMwMjkwNSwgMS40OTg5MTY4NzgzNDkyNzY2XSk7XG4gICAgICAgICAgICB1ciA9IGNvbnRpbmVudChbOS4yMTM0MjI4OTY0ODE1OTgsIDEuNDk5OTgxMjQwOTc5MDIxXSk7XG4gICAgICAgICAgICBsZCA9IGNvbnRpbmVudChbOS4yMTM1NzI5MTI5OTk2MDQsIDAuMzU0MTQyMDU2ODE3MjQ3XSk7XG4gICAgICAgICAgICBsbCA9IGNvbnRpbmVudChbNy4zMjMxNTQ2MTU3Mzk4MDksIDAuMzUzMDc4MjUxMTU0NTA0XSk7XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbWVyY2F0b3JFcXVhdG9yaWFsR3VpbmVhLmdldENvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gZDNQYXRoLnBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyhjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtZXJjYXRvckVxdWF0b3JpYWxHdWluZWEuc2NhbGUoMTIwMDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtdWx0aXBsZXgkYihzdHJlYW1zKSB7XG4gICAgICAgIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNwaGVyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0uc3BoZXJlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFsYmVyc1VrKCkge1xuICAgICAgICB2YXIgY2FjaGUsIGNhY2hlU3RyZWFtLCBtYWluID0gZDNHZW8uZ2VvQWxiZXJzKClcbiAgICAgICAgICAgIC5yb3RhdGUoWzQuNCwgMC44XSlcbiAgICAgICAgICAgIC5jZW50ZXIoWzAsIDU1LjRdKVxuICAgICAgICAgICAgLnBhcmFsbGVscyhbNTAsIDYwXSksIG1haW5Qb2ludCwgc2hldGxhbmQgPSBkM0dlby5nZW9BbGJlcnMoKVxuICAgICAgICAgICAgLnJvdGF0ZShbNC40LCAwLjhdKVxuICAgICAgICAgICAgLmNlbnRlcihbMCwgNTUuNF0pXG4gICAgICAgICAgICAucGFyYWxsZWxzKFs1MCwgNjBdKSwgc2hldGxhbmRQb2ludCwgcG9pbnQsIHBvaW50U3RyZWFtID0ge1xuICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBbeCwgeV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGFsYmVyc1VrKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGNvb3JkaW5hdGVzWzBdLCB5ID0gY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICByZXR1cm4gKChwb2ludCA9IG51bGwpLFxuICAgICAgICAgICAgICAgIChtYWluUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KSB8fCAoc2hldGxhbmRQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBhbGJlcnNVay5pbnZlcnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIHZhciBrID0gbWFpbi5zY2FsZSgpLCB0ID0gbWFpbi50cmFuc2xhdGUoKSwgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gaywgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICAgICAgICAgIHJldHVybiAoeSA+PSAtMC4wODkgJiYgeSA8IDAuMDYgJiYgeCA+PSAwLjAyOSAmJiB4IDwgMC4wNDZcbiAgICAgICAgICAgICAgICA/IHNoZXRsYW5kXG4gICAgICAgICAgICAgICAgOiBtYWluKS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVay5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbVxuICAgICAgICAgICAgICAgID8gY2FjaGVcbiAgICAgICAgICAgICAgICA6IChjYWNoZSA9IG11bHRpcGxleCRiKFtcbiAgICAgICAgICAgICAgICAgICAgbWFpbi5zdHJlYW0oKGNhY2hlU3RyZWFtID0gc3RyZWFtKSksXG4gICAgICAgICAgICAgICAgICAgIHNoZXRsYW5kLnN0cmVhbShzdHJlYW0pXG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVay5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYWluLnByZWNpc2lvbigpO1xuICAgICAgICAgICAgbWFpbi5wcmVjaXNpb24oXyksIHNoZXRsYW5kLnByZWNpc2lvbihfKTtcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVay5zY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1haW4uc2NhbGUoKTtcbiAgICAgICAgICAgIG1haW4uc2NhbGUoXyksIHNoZXRsYW5kLnNjYWxlKF8pO1xuICAgICAgICAgICAgcmV0dXJuIGFsYmVyc1VrLnRyYW5zbGF0ZShtYWluLnRyYW5zbGF0ZSgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVWsudHJhbnNsYXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFpbi50cmFuc2xhdGUoKTtcbiAgICAgICAgICAgIHZhciBrID0gbWFpbi5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcbiAgICAgICAgICAgIG1haW5Qb2ludCA9IG1haW5cbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKF8pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1xuICAgICAgICAgICAgICAgIFt4IC0gMC4wNjUgKiBrLCB5IC0gMC4wODkgKiBrXSxcbiAgICAgICAgICAgICAgICBbeCArIDAuMDc1ICogaywgeSArIDAuMDg5ICoga11cbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBzaGV0bGFuZFBvaW50ID0gc2hldGxhbmRcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4ICsgMC4wMSAqIGssIHkgKyAwLjAyNSAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtcbiAgICAgICAgICAgICAgICBbeCArIDAuMDI5ICogayArIGVwc2lsb24sIHkgLSAwLjA4OSAqIGsgKyBlcHNpbG9uXSxcbiAgICAgICAgICAgICAgICBbeCArIDAuMDQ2ICogayAtIGVwc2lsb24sIHkgLSAwLjA2ICogayAtIGVwc2lsb25dXG4gICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VrLmZpdEV4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdEV4dGVudChhbGJlcnNVaywgZXh0ZW50LCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVay5maXRTaXplID0gZnVuY3Rpb24gKHNpemUsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdFNpemUoYWxiZXJzVWssIHNpemUsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gYWxiZXJzVWs7XG4gICAgICAgIH1cbiAgICAgICAgYWxiZXJzVWsuZHJhd0NvbXBvc2l0aW9uQm9yZGVycyA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICAvKnZhciB1bCA9IG1haW4uaW52ZXJ0KFtcbiAgICAgICAgICAgICAgc2hldGxhbmQuY2xpcEV4dGVudCgpWzBdWzBdLFxuICAgICAgICAgICAgICBzaGV0bGFuZC5jbGlwRXh0ZW50KClbMF1bMV1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdmFyIHVyID0gbWFpbi5pbnZlcnQoW1xuICAgICAgICAgICAgICBzaGV0bGFuZC5jbGlwRXh0ZW50KClbMV1bMF0sXG4gICAgICAgICAgICAgIHNoZXRsYW5kLmNsaXBFeHRlbnQoKVswXVsxXVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB2YXIgbGQgPSBtYWluLmludmVydChbXG4gICAgICAgICAgICAgIHNoZXRsYW5kLmNsaXBFeHRlbnQoKVsxXVswXSxcbiAgICAgICAgICAgICAgc2hldGxhbmQuY2xpcEV4dGVudCgpWzFdWzFdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHZhciBsbCA9IG1haW4uaW52ZXJ0KFtcbiAgICAgICAgICAgICAgc2hldGxhbmQuY2xpcEV4dGVudCgpWzBdWzBdLFxuICAgICAgICAgICAgICBzaGV0bGFuZC5jbGlwRXh0ZW50KClbMV1bMV1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidWwgPSBtYWluKFtcIiArIHVsICsgXCJdKTtcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInVyID0gbWFpbihbXCIgKyB1ciArIFwiXSk7XCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJsZCA9IG1haW4oW1wiICsgbGQgKyBcIl0pO1wiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibGwgPSBtYWluKFtcIiArIGxsICsgXCJdKTtcIik7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb250ZXh0Lm1vdmVUbyh1bFswXSwgdWxbMV0pO1wiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dC5saW5lVG8odXJbMF0sIHVyWzFdKTtcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbnRleHQubGluZVRvKGxkWzBdLCBsZFsxXSk7XCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb250ZXh0LmxpbmVUbyhsbFswXSwgbGxbMV0pO1wiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY29udGV4dC5jbG9zZVBhdGgoKTtcIik7Ki9cbiAgICAgICAgICAgIHZhciB1bCwgdXIsIGxkLCBsbDtcbiAgICAgICAgICAgIHVsID0gbWFpbihbLTEuMTEzMjA1ODcwMjQyMzY1LCA1OS42NDkyMDA1MDc3MzM1N10pO1xuICAgICAgICAgICAgdXIgPSBtYWluKFswLjgwNzg5OTA5MjM5OTYwNiwgNTkuNTkwODU4MzY0NzIyNjldKTtcbiAgICAgICAgICAgIGxkID0gbWFpbihbMC41Nzc4NjExOTYxNDIwMzg2LCA1Ny45MzQ2NzgyMjgzMjU3N10pO1xuICAgICAgICAgICAgbGwgPSBtYWluKFstMS4yNTg2Nzc4MjA3ODQ0OCwgNTcuOTkwMjk0NTAwODUxNDJdKTtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHVsWzBdLCB1bFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh1clswXSwgdXJbMV0pO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8obGRbMF0sIGxkWzFdKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKGxsWzBdLCBsbFsxXSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVay5nZXRDb21wb3NpdGlvbkJvcmRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IGQzUGF0aC5wYXRoKCk7XG4gICAgICAgICAgICB0aGlzLmRyYXdDb21wb3NpdGlvbkJvcmRlcnMoY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC50b1N0cmluZygpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYWxiZXJzVWsuc2NhbGUoMjgwMCk7XG4gICAgfVxuICAgIGV4cG9ydHMuZ2VvQWxiZXJzVWsgPSBhbGJlcnNVaztcbiAgICBleHBvcnRzLmdlb0FsYmVyc1VzYSA9IGFsYmVyc1VzYTtcbiAgICBleHBvcnRzLmdlb0FsYmVyc1VzYVRlcnJpdG9yaWVzID0gYWxiZXJzVXNhVGVycml0b3JpZXM7XG4gICAgZXhwb3J0cy5nZW9Db25pY0NvbmZvcm1hbEV1cm9wZSA9IGNvbmljQ29uZm9ybWFsRXVyb3BlO1xuICAgIGV4cG9ydHMuZ2VvQ29uaWNDb25mb3JtYWxGcmFuY2UgPSBjb25pY0NvbmZvcm1hbEZyYW5jZTtcbiAgICBleHBvcnRzLmdlb0NvbmljQ29uZm9ybWFsUG9ydHVnYWwgPSBjb25pY0NvbmZvcm1hbFBvcnR1Z2FsO1xuICAgIGV4cG9ydHMuZ2VvQ29uaWNDb25mb3JtYWxTcGFpbiA9IGNvbmljQ29uZm9ybWFsU3BhaW47XG4gICAgZXhwb3J0cy5nZW9Db25pY0VxdWlkaXN0YW50SmFwYW4gPSBjb25pY0VxdWlkaXN0YW50SmFwYW47XG4gICAgZXhwb3J0cy5nZW9NZXJjYXRvckVjdWFkb3IgPSBtZXJjYXRvckVjdWFkb3I7XG4gICAgZXhwb3J0cy5nZW9NZXJjYXRvckVxdWF0b3JpYWxHdWluZWEgPSBtZXJjYXRvckVxdWF0b3JpYWxHdWluZWE7XG4gICAgZXhwb3J0cy5nZW9NZXJjYXRvck1hbGF5c2lhID0gbWVyY2F0b3JNYWxheXNpYTtcbiAgICBleHBvcnRzLmdlb1RyYW5zdmVyc2VNZXJjYXRvckNoaWxlID0gdHJhbnN2ZXJzZU1lcmNhdG9yQ2hpbGU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pKSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWRzdkAxLjIuMEBkMy1kc3YvZGlzdC9kMy1kc3YuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2QzLWRzdkAxLjIuMEBkMy1kc3YvZGlzdC9kMy1kc3YuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1kc3YvIHYxLjIuMCBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgIHRydWUgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cykge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICB2YXIgRU9MID0ge30sIEVPRiA9IHt9LCBRVU9URSA9IDM0LCBORVdMSU5FID0gMTAsIFJFVFVSTiA9IDEzO1xuICAgIGZ1bmN0aW9uIG9iamVjdENvbnZlcnRlcihjb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJkXCIsIFwicmV0dXJuIHtcIiArIGNvbHVtbnMubWFwKGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobmFtZSkgKyBcIjogZFtcIiArIGkgKyBcIl0gfHwgXFxcIlxcXCJcIjtcbiAgICAgICAgfSkuam9pbihcIixcIikgKyBcIn1cIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN1c3RvbUNvbnZlcnRlcihjb2x1bW5zLCBmKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocm93LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZihvYmplY3Qocm93KSwgaSwgY29sdW1ucyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIENvbXB1dGUgdW5pcXVlIGNvbHVtbnMgaW4gb3JkZXIgb2YgZGlzY292ZXJ5LlxuICAgIGZ1bmN0aW9uIGluZmVyQ29sdW1ucyhyb3dzKSB7XG4gICAgICAgIHZhciBjb2x1bW5TZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBjb2x1bW5zID0gW107XG4gICAgICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBjb2x1bW4gaW4gcm93KSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoY29sdW1uIGluIGNvbHVtblNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1ucy5wdXNoKGNvbHVtblNldFtjb2x1bW5dID0gY29sdW1uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29sdW1ucztcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFkKHZhbHVlLCB3aWR0aCkge1xuICAgICAgICB2YXIgcyA9IHZhbHVlICsgXCJcIiwgbGVuZ3RoID0gcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oMCkgKyBzIDogcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9ybWF0WWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiB5ZWFyIDwgMCA/IFwiLVwiICsgcGFkKC15ZWFyLCA2KVxuICAgICAgICAgICAgOiB5ZWFyID4gOTk5OSA/IFwiK1wiICsgcGFkKHllYXIsIDYpXG4gICAgICAgICAgICAgICAgOiBwYWQoeWVhciwgNCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICAgICAgICB2YXIgaG91cnMgPSBkYXRlLmdldFVUQ0hvdXJzKCksIG1pbnV0ZXMgPSBkYXRlLmdldFVUQ01pbnV0ZXMoKSwgc2Vjb25kcyA9IGRhdGUuZ2V0VVRDU2Vjb25kcygpLCBtaWxsaXNlY29uZHMgPSBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICByZXR1cm4gaXNOYU4oZGF0ZSkgPyBcIkludmFsaWQgRGF0ZVwiXG4gICAgICAgICAgICA6IGZvcm1hdFllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSArIFwiLVwiICsgcGFkKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEsIDIpICsgXCItXCIgKyBwYWQoZGF0ZS5nZXRVVENEYXRlKCksIDIpXG4gICAgICAgICAgICAgICAgKyAobWlsbGlzZWNvbmRzID8gXCJUXCIgKyBwYWQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWQobWludXRlcywgMikgKyBcIjpcIiArIHBhZChzZWNvbmRzLCAyKSArIFwiLlwiICsgcGFkKG1pbGxpc2Vjb25kcywgMykgKyBcIlpcIlxuICAgICAgICAgICAgICAgICAgICA6IHNlY29uZHMgPyBcIlRcIiArIHBhZChob3VycywgMikgKyBcIjpcIiArIHBhZChtaW51dGVzLCAyKSArIFwiOlwiICsgcGFkKHNlY29uZHMsIDIpICsgXCJaXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbWludXRlcyB8fCBob3VycyA/IFwiVFwiICsgcGFkKGhvdXJzLCAyKSArIFwiOlwiICsgcGFkKG1pbnV0ZXMsIDIpICsgXCJaXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkc3YoZGVsaW1pdGVyKSB7XG4gICAgICAgIHZhciByZUZvcm1hdCA9IG5ldyBSZWdFeHAoXCJbXFxcIlwiICsgZGVsaW1pdGVyICsgXCJcXG5cXHJdXCIpLCBERUxJTUlURVIgPSBkZWxpbWl0ZXIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgZnVuY3Rpb24gcGFyc2UodGV4dCwgZikge1xuICAgICAgICAgICAgdmFyIGNvbnZlcnQsIGNvbHVtbnMsIHJvd3MgPSBwYXJzZVJvd3ModGV4dCwgZnVuY3Rpb24gKHJvdywgaSkge1xuICAgICAgICAgICAgICAgIGlmIChjb252ZXJ0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydChyb3csIGkgLSAxKTtcbiAgICAgICAgICAgICAgICBjb2x1bW5zID0gcm93LCBjb252ZXJ0ID0gZiA/IGN1c3RvbUNvbnZlcnRlcihyb3csIGYpIDogb2JqZWN0Q29udmVydGVyKHJvdyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJvd3MuY29sdW1ucyA9IGNvbHVtbnMgfHwgW107XG4gICAgICAgICAgICByZXR1cm4gcm93cztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwYXJzZVJvd3ModGV4dCwgZikge1xuICAgICAgICAgICAgdmFyIHJvd3MgPSBbXSwgLy8gb3V0cHV0IHJvd3NcbiAgICAgICAgICAgIE4gPSB0ZXh0Lmxlbmd0aCwgSSA9IDAsIC8vIGN1cnJlbnQgY2hhcmFjdGVyIGluZGV4XG4gICAgICAgICAgICBuID0gMCwgLy8gY3VycmVudCBsaW5lIG51bWJlclxuICAgICAgICAgICAgdCwgLy8gY3VycmVudCB0b2tlblxuICAgICAgICAgICAgZW9mID0gTiA8PSAwLCAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPRj9cbiAgICAgICAgICAgIGVvbCA9IGZhbHNlOyAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPTD9cbiAgICAgICAgICAgIC8vIFN0cmlwIHRoZSB0cmFpbGluZyBuZXdsaW5lLlxuICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChOIC0gMSkgPT09IE5FV0xJTkUpXG4gICAgICAgICAgICAgICAgLS1OO1xuICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChOIC0gMSkgPT09IFJFVFVSTilcbiAgICAgICAgICAgICAgICAtLU47XG4gICAgICAgICAgICBmdW5jdGlvbiB0b2tlbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW9mKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRU9GO1xuICAgICAgICAgICAgICAgIGlmIChlb2wpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlb2wgPSBmYWxzZSwgRU9MO1xuICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlIHF1b3Rlcy5cbiAgICAgICAgICAgICAgICB2YXIgaSwgaiA9IEksIGM7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChqKSA9PT0gUVVPVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKEkrKyA8IE4gJiYgdGV4dC5jaGFyQ29kZUF0KEkpICE9PSBRVU9URSB8fCB0ZXh0LmNoYXJDb2RlQXQoKytJKSA9PT0gUVVPVEUpXG4gICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoaSA9IEkpID49IE4pXG4gICAgICAgICAgICAgICAgICAgICAgICBlb2YgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoYyA9IHRleHQuY2hhckNvZGVBdChJKyspKSA9PT0gTkVXTElORSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW9sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IE5FV0xJTkUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytJO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGogKyAxLCBpIC0gMSkucmVwbGFjZSgvXCJcIi9nLCBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZpbmQgbmV4dCBkZWxpbWl0ZXIgb3IgbmV3bGluZS5cbiAgICAgICAgICAgICAgICB3aGlsZSAoSSA8IE4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjID0gdGV4dC5jaGFyQ29kZUF0KGkgPSBJKyspKSA9PT0gTkVXTElORSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW9sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IE5FV0xJTkUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytJO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgIT09IERFTElNSVRFUilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIGxhc3QgdG9rZW4gYmVmb3JlIEVPRi5cbiAgICAgICAgICAgICAgICByZXR1cm4gZW9mID0gdHJ1ZSwgdGV4dC5zbGljZShqLCBOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICgodCA9IHRva2VuKCkpICE9PSBFT0YpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUgKHQgIT09IEVPTCAmJiB0ICE9PSBFT0YpXG4gICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKHQpLCB0ID0gdG9rZW4oKTtcbiAgICAgICAgICAgICAgICBpZiAoZiAmJiAocm93ID0gZihyb3csIG4rKykpID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gcm93cy5tYXAoZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShyb3dbY29sdW1uXSk7XG4gICAgICAgICAgICAgICAgfSkuam9pbihkZWxpbWl0ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9ybWF0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgICAgIGlmIChjb2x1bW5zID09IG51bGwpXG4gICAgICAgICAgICAgICAgY29sdW1ucyA9IGluZmVyQ29sdW1ucyhyb3dzKTtcbiAgICAgICAgICAgIHJldHVybiBbY29sdW1ucy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKV0uY29uY2F0KHByZWZvcm1hdEJvZHkocm93cywgY29sdW1ucykpLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgICAgICBpZiAoY29sdW1ucyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbHVtbnMgPSBpbmZlckNvbHVtbnMocm93cyk7XG4gICAgICAgICAgICByZXR1cm4gcHJlZm9ybWF0Qm9keShyb3dzLCBjb2x1bW5zKS5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvcm1hdFJvd3Mocm93cykge1xuICAgICAgICAgICAgcmV0dXJuIHJvd3MubWFwKGZvcm1hdFJvdykuam9pbihcIlxcblwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb3JtYXRSb3cocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gcm93Lm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCJcbiAgICAgICAgICAgICAgICA6IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IGZvcm1hdERhdGUodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogcmVGb3JtYXQudGVzdCh2YWx1ZSArPSBcIlwiKSA/IFwiXFxcIlwiICsgdmFsdWUucmVwbGFjZSgvXCIvZywgXCJcXFwiXFxcIlwiKSArIFwiXFxcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJzZTogcGFyc2UsXG4gICAgICAgICAgICBwYXJzZVJvd3M6IHBhcnNlUm93cyxcbiAgICAgICAgICAgIGZvcm1hdDogZm9ybWF0LFxuICAgICAgICAgICAgZm9ybWF0Qm9keTogZm9ybWF0Qm9keSxcbiAgICAgICAgICAgIGZvcm1hdFJvd3M6IGZvcm1hdFJvd3MsXG4gICAgICAgICAgICBmb3JtYXRSb3c6IGZvcm1hdFJvdyxcbiAgICAgICAgICAgIGZvcm1hdFZhbHVlOiBmb3JtYXRWYWx1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgY3N2ID0gZHN2KFwiLFwiKTtcbiAgICB2YXIgY3N2UGFyc2UgPSBjc3YucGFyc2U7XG4gICAgdmFyIGNzdlBhcnNlUm93cyA9IGNzdi5wYXJzZVJvd3M7XG4gICAgdmFyIGNzdkZvcm1hdCA9IGNzdi5mb3JtYXQ7XG4gICAgdmFyIGNzdkZvcm1hdEJvZHkgPSBjc3YuZm9ybWF0Qm9keTtcbiAgICB2YXIgY3N2Rm9ybWF0Um93cyA9IGNzdi5mb3JtYXRSb3dzO1xuICAgIHZhciBjc3ZGb3JtYXRSb3cgPSBjc3YuZm9ybWF0Um93O1xuICAgIHZhciBjc3ZGb3JtYXRWYWx1ZSA9IGNzdi5mb3JtYXRWYWx1ZTtcbiAgICB2YXIgdHN2ID0gZHN2KFwiXFx0XCIpO1xuICAgIHZhciB0c3ZQYXJzZSA9IHRzdi5wYXJzZTtcbiAgICB2YXIgdHN2UGFyc2VSb3dzID0gdHN2LnBhcnNlUm93cztcbiAgICB2YXIgdHN2Rm9ybWF0ID0gdHN2LmZvcm1hdDtcbiAgICB2YXIgdHN2Rm9ybWF0Qm9keSA9IHRzdi5mb3JtYXRCb2R5O1xuICAgIHZhciB0c3ZGb3JtYXRSb3dzID0gdHN2LmZvcm1hdFJvd3M7XG4gICAgdmFyIHRzdkZvcm1hdFJvdyA9IHRzdi5mb3JtYXRSb3c7XG4gICAgdmFyIHRzdkZvcm1hdFZhbHVlID0gdHN2LmZvcm1hdFZhbHVlO1xuICAgIGZ1bmN0aW9uIGF1dG9UeXBlKG9iamVjdCkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XS50cmltKCksIG51bWJlciwgbTtcbiAgICAgICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IFwidHJ1ZVwiKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBcIk5hTlwiKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gTmFOO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWlzTmFOKG51bWJlciA9ICt2YWx1ZSkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudW1iZXI7XG4gICAgICAgICAgICBlbHNlIGlmIChtID0gdmFsdWUubWF0Y2goL14oWy0rXVxcZHsyfSk/XFxkezR9KC1cXGR7Mn0oLVxcZHsyfSk/KT8oVFxcZHsyfTpcXGR7Mn0oOlxcZHsyfShcXC5cXGR7M30pPyk/KFp8Wy0rXVxcZHsyfTpcXGR7Mn0pPyk/JC8pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpeHR6ICYmICEhbVs0XSAmJiAhbVs3XSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8tL2csIFwiL1wiKS5yZXBsYWNlKC9ULywgXCIgXCIpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtZHN2L2lzc3Vlcy80NVxuICAgIHZhciBmaXh0eiA9IG5ldyBEYXRlKFwiMjAxOS0wMS0wMVQwMDowMFwiKS5nZXRIb3VycygpIHx8IG5ldyBEYXRlKFwiMjAxOS0wNy0wMVQwMDowMFwiKS5nZXRIb3VycygpO1xuICAgIGV4cG9ydHMuYXV0b1R5cGUgPSBhdXRvVHlwZTtcbiAgICBleHBvcnRzLmNzdkZvcm1hdCA9IGNzdkZvcm1hdDtcbiAgICBleHBvcnRzLmNzdkZvcm1hdEJvZHkgPSBjc3ZGb3JtYXRCb2R5O1xuICAgIGV4cG9ydHMuY3N2Rm9ybWF0Um93ID0gY3N2Rm9ybWF0Um93O1xuICAgIGV4cG9ydHMuY3N2Rm9ybWF0Um93cyA9IGNzdkZvcm1hdFJvd3M7XG4gICAgZXhwb3J0cy5jc3ZGb3JtYXRWYWx1ZSA9IGNzdkZvcm1hdFZhbHVlO1xuICAgIGV4cG9ydHMuY3N2UGFyc2UgPSBjc3ZQYXJzZTtcbiAgICBleHBvcnRzLmNzdlBhcnNlUm93cyA9IGNzdlBhcnNlUm93cztcbiAgICBleHBvcnRzLmRzdkZvcm1hdCA9IGRzdjtcbiAgICBleHBvcnRzLnRzdkZvcm1hdCA9IHRzdkZvcm1hdDtcbiAgICBleHBvcnRzLnRzdkZvcm1hdEJvZHkgPSB0c3ZGb3JtYXRCb2R5O1xuICAgIGV4cG9ydHMudHN2Rm9ybWF0Um93ID0gdHN2Rm9ybWF0Um93O1xuICAgIGV4cG9ydHMudHN2Rm9ybWF0Um93cyA9IHRzdkZvcm1hdFJvd3M7XG4gICAgZXhwb3J0cy50c3ZGb3JtYXRWYWx1ZSA9IHRzdkZvcm1hdFZhbHVlO1xuICAgIGV4cG9ydHMudHN2UGFyc2UgPSB0c3ZQYXJzZTtcbiAgICBleHBvcnRzLnRzdlBhcnNlUm93cyA9IHRzdlBhcnNlUm93cztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1nZW8tcHJvamVjdGlvbkAyLjEuMkBkMy1nZW8tcHJvamVjdGlvbi9idWlsZC9kMy1nZW8tcHJvamVjdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2QzLWdlby1wcm9qZWN0aW9uQDIuMS4yQGQzLWdlby1wcm9qZWN0aW9uL2J1aWxkL2QzLWdlby1wcm9qZWN0aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBodHRwczovL2QzanMub3JnL2QzLWdlby1wcm9qZWN0aW9uLyBWZXJzaW9uIDIuMS4yLiBDb3B5cmlnaHQgMjAxNyBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgICB0cnVlID8gZmFjdG9yeShleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1nZW8gKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtZ2VvQDEuMTEuOUBkMy1nZW8vZGlzdC9kMy1nZW8uanNcIiksIF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWFycmF5QDEuMi40QGQzLWFycmF5L2Rpc3QvZDMtYXJyYXkuanNcIikpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIGQzR2VvLCBkM0FycmF5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgYXRhbiA9IE1hdGguYXRhbjtcbiAgICB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgZXhwID0gTWF0aC5leHA7XG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgbG9nID0gTWF0aC5sb2c7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4O1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbjtcbiAgICB2YXIgcG93ID0gTWF0aC5wb3c7XG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7IH07XG4gICAgdmFyIHNpbiA9IE1hdGguc2luO1xuICAgIHZhciB0YW4gPSBNYXRoLnRhbjtcbiAgICB2YXIgZXBzaWxvbiA9IDFlLTY7XG4gICAgdmFyIGVwc2lsb24yID0gMWUtMTI7XG4gICAgdmFyIHBpID0gTWF0aC5QSTtcbiAgICB2YXIgaGFsZlBpID0gcGkgLyAyO1xuICAgIHZhciBxdWFydGVyUGkgPSBwaSAvIDQ7XG4gICAgdmFyIHNxcnQxXzIgPSBNYXRoLlNRUlQxXzI7XG4gICAgdmFyIHNxcnQyID0gc3FydCgyKTtcbiAgICB2YXIgc3FydFBpID0gc3FydChwaSk7XG4gICAgdmFyIHRhdSA9IHBpICogMjtcbiAgICB2YXIgZGVncmVlcyA9IDE4MCAvIHBpO1xuICAgIHZhciByYWRpYW5zID0gcGkgLyAxODA7XG4gICAgZnVuY3Rpb24gc2luY2koeCkge1xuICAgICAgICByZXR1cm4geCA/IHggLyBNYXRoLnNpbih4KSA6IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzaW4oeCkge1xuICAgICAgICByZXR1cm4geCA+IDEgPyBoYWxmUGkgOiB4IDwgLTEgPyAtaGFsZlBpIDogTWF0aC5hc2luKHgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhY29zKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcXJ0KHgpIHtcbiAgICAgICAgcmV0dXJuIHggPiAwID8gTWF0aC5zcXJ0KHgpIDogMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGFuaCh4KSB7XG4gICAgICAgIHggPSBleHAoMiAqIHgpO1xuICAgICAgICByZXR1cm4gKHggLSAxKSAvICh4ICsgMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpbmgoeCkge1xuICAgICAgICByZXR1cm4gKGV4cCh4KSAtIGV4cCgteCkpIC8gMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29zaCh4KSB7XG4gICAgICAgIHJldHVybiAoZXhwKHgpICsgZXhwKC14KSkgLyAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcnNpbmgoeCkge1xuICAgICAgICByZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4ICsgMSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmNvc2goeCkge1xuICAgICAgICByZXR1cm4gbG9nKHggKyBzcXJ0KHggKiB4IC0gMSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhaXJ5UmF3KGJldGEpIHtcbiAgICAgICAgdmFyIHRhbkJldGFfMiA9IHRhbihiZXRhIC8gMiksIGIgPSAyICogbG9nKGNvcyhiZXRhIC8gMikpIC8gKHRhbkJldGFfMiAqIHRhbkJldGFfMik7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGNvc3ggPSBjb3MoeCksIGNvc3kgPSBjb3MoeSksIHNpbnkgPSBzaW4oeSksIGNvc3ogPSBjb3N5ICogY29zeCwgayA9IC0oKDEgLSBjb3N6ID8gbG9nKCgxICsgY29zeikgLyAyKSAvICgxIC0gY29zeikgOiAtMC41KSArIGIgLyAoMSArIGNvc3opKTtcbiAgICAgICAgICAgIHJldHVybiBbayAqIGNvc3kgKiBzaW4oeCksIGsgKiBzaW55XTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgciA9IHNxcnQoeCAqIHggKyB5ICogeSksIHogPSAtYmV0YSAvIDIsIGkgPSA1MCwgZGVsdGE7XG4gICAgICAgICAgICBpZiAoIXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgel8yID0geiAvIDIsIGNvc3pfMiA9IGNvcyh6XzIpLCBzaW56XzIgPSBzaW4oel8yKSwgdGFuel8yID0gdGFuKHpfMiksIGxuc2Vjel8yID0gbG9nKDEgLyBjb3N6XzIpO1xuICAgICAgICAgICAgICAgIHogLT0gZGVsdGEgPSAoMiAvIHRhbnpfMiAqIGxuc2Vjel8yIC0gYiAqIHRhbnpfMiAtIHIpIC8gKC1sbnNlY3pfMiAvIChzaW56XzIgKiBzaW56XzIpICsgMSAtIGIgLyAoMiAqIGNvc3pfMiAqIGNvc3pfMikpO1xuICAgICAgICAgICAgfSB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24gJiYgLS1pID4gMCk7XG4gICAgICAgICAgICB2YXIgc2lueiA9IHNpbih6KTtcbiAgICAgICAgICAgIHJldHVybiBbYXRhbjIoeCAqIHNpbnosIHIgKiBjb3MoeikpLCBhc2luKHkgKiBzaW56IC8gcildO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgdmFyIGFpcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiZXRhID0gaGFsZlBpLCBtID0gZDNHZW8uZ2VvUHJvamVjdGlvbk11dGF0b3IoYWlyeVJhdyksIHAgPSBtKGJldGEpO1xuICAgICAgICBwLnJhZGl1cyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IG0oYmV0YSA9IF8gKiByYWRpYW5zKSA6IGJldGEgKiBkZWdyZWVzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcFxuICAgICAgICAgICAgLnNjYWxlKDE3OS45NzYpXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDE0Nyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBhaXRvZmZSYXcoeCwgeSkge1xuICAgICAgICB2YXIgY29zeSA9IGNvcyh5KSwgc2luY2lhID0gc2luY2koYWNvcyhjb3N5ICogY29zKHggLz0gMikpKTtcbiAgICAgICAgcmV0dXJuIFsyICogY29zeSAqIHNpbih4KSAqIHNpbmNpYSwgc2luKHkpICogc2luY2lhXTtcbiAgICB9XG4gICAgLy8gQWJvcnQgaWYgW3gsIHldIGlzIG5vdCB3aXRoaW4gYW4gZWxsaXBzZSBjZW50ZXJlZCBhdCBbMCwgMF0gd2l0aFxuICAgIC8vIHNlbWktbWFqb3IgYXhpcyBwaSBhbmQgc2VtaS1taW5vciBheGlzIHBpLzIuXG4gICAgYWl0b2ZmUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICh4ICogeCArIDQgKiB5ICogeSA+IHBpICogcGkgKyBlcHNpbG9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgeDEgPSB4LCB5MSA9IHksIGkgPSAyNTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIHNpbnggPSBzaW4oeDEpLCBzaW54XzIgPSBzaW4oeDEgLyAyKSwgY29zeF8yID0gY29zKHgxIC8gMiksIHNpbnkgPSBzaW4oeTEpLCBjb3N5ID0gY29zKHkxKSwgc2luXzJ5ID0gc2luKDIgKiB5MSksIHNpbjJ5ID0gc2lueSAqIHNpbnksIGNvczJ5ID0gY29zeSAqIGNvc3ksIHNpbjJ4XzIgPSBzaW54XzIgKiBzaW54XzIsIGMgPSAxIC0gY29zMnkgKiBjb3N4XzIgKiBjb3N4XzIsIGUgPSBjID8gYWNvcyhjb3N5ICogY29zeF8yKSAqIHNxcnQoZiA9IDEgLyBjKSA6IGYgPSAwLCBmLCBmeCA9IDIgKiBlICogY29zeSAqIHNpbnhfMiAtIHgsIGZ5ID0gZSAqIHNpbnkgLSB5LCBkeGR4ID0gZiAqIChjb3MyeSAqIHNpbjJ4XzIgKyBlICogY29zeSAqIGNvc3hfMiAqIHNpbjJ5KSwgZHhkeSA9IGYgKiAoMC41ICogc2lueCAqIHNpbl8yeSAtIGUgKiAyICogc2lueSAqIHNpbnhfMiksIGR5ZHggPSBmICogMC4yNSAqIChzaW5fMnkgKiBzaW54XzIgLSBlICogc2lueSAqIGNvczJ5ICogc2lueCksIGR5ZHkgPSBmICogKHNpbjJ5ICogY29zeF8yICsgZSAqIHNpbjJ4XzIgKiBjb3N5KSwgeiA9IGR4ZHkgKiBkeWR4IC0gZHlkeSAqIGR4ZHg7XG4gICAgICAgICAgICBpZiAoIXopXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB2YXIgZHggPSAoZnkgKiBkeGR5IC0gZnggKiBkeWR5KSAvIHosIGR5ID0gKGZ4ICogZHlkeCAtIGZ5ICogZHhkeCkgLyB6O1xuICAgICAgICAgICAgeDEgLT0gZHgsIHkxIC09IGR5O1xuICAgICAgICB9IHdoaWxlICgoYWJzKGR4KSA+IGVwc2lsb24gfHwgYWJzKGR5KSA+IGVwc2lsb24pICYmIC0taSA+IDApO1xuICAgICAgICByZXR1cm4gW3gxLCB5MV07XG4gICAgfTtcbiAgICB2YXIgYWl0b2ZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihhaXRvZmZSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTUyLjYzKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGFybWFkaWxsb1JhdyhwaGkwKSB7XG4gICAgICAgIHZhciBzaW5QaGkwID0gc2luKHBoaTApLCBjb3NQaGkwID0gY29zKHBoaTApLCBzUGhpMCA9IHBoaTAgPj0gMCA/IDEgOiAtMSwgdGFuUGhpMCA9IHRhbihzUGhpMCAqIHBoaTApLCBrID0gKDEgKyBzaW5QaGkwIC0gY29zUGhpMCkgLyAyO1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgY29zUGhpID0gY29zKHBoaSksIGNvc0xhbWJkYSA9IGNvcyhsYW1iZGEgLz0gMik7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICgxICsgY29zUGhpKSAqIHNpbihsYW1iZGEpLFxuICAgICAgICAgICAgICAgIChzUGhpMCAqIHBoaSA+IC1hdGFuMihjb3NMYW1iZGEsIHRhblBoaTApIC0gMWUtMyA/IDAgOiAtc1BoaTAgKiAxMCkgKyBrICsgc2luKHBoaSkgKiBjb3NQaGkwIC0gKDEgKyBjb3NQaGkpICogc2luUGhpMCAqIGNvc0xhbWJkYSAvLyBUT0RPIEQzIGNvcmUgc2hvdWxkIGFsbG93IG51bGwgb3IgW05hTiwgTmFOXSB0byBiZSByZXR1cm5lZC5cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGxhbWJkYSA9IDAsIHBoaSA9IDAsIGkgPSA1MDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgY29zTGFtYmRhID0gY29zKGxhbWJkYSksIHNpbkxhbWJkYSA9IHNpbihsYW1iZGEpLCBjb3NQaGkgPSBjb3MocGhpKSwgc2luUGhpID0gc2luKHBoaSksIEEgPSAxICsgY29zUGhpLCBmeCA9IEEgKiBzaW5MYW1iZGEgLSB4LCBmeSA9IGsgKyBzaW5QaGkgKiBjb3NQaGkwIC0gQSAqIHNpblBoaTAgKiBjb3NMYW1iZGEgLSB5LCBkeGRMYW1iZGEgPSBBICogY29zTGFtYmRhIC8gMiwgZHhkUGhpID0gLXNpbkxhbWJkYSAqIHNpblBoaSwgZHlkTGFtYmRhID0gc2luUGhpMCAqIEEgKiBzaW5MYW1iZGEgLyAyLCBkeWRQaGkgPSBjb3NQaGkwICogY29zUGhpICsgc2luUGhpMCAqIGNvc0xhbWJkYSAqIHNpblBoaSwgZGVub21pbmF0b3IgPSBkeGRQaGkgKiBkeWRMYW1iZGEgLSBkeWRQaGkgKiBkeGRMYW1iZGEsIGRMYW1iZGEgPSAoZnkgKiBkeGRQaGkgLSBmeCAqIGR5ZFBoaSkgLyBkZW5vbWluYXRvciAvIDIsIGRQaGkgPSAoZnggKiBkeWRMYW1iZGEgLSBmeSAqIGR4ZExhbWJkYSkgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgICAgICBsYW1iZGEgLT0gZExhbWJkYSwgcGhpIC09IGRQaGk7XG4gICAgICAgICAgICB9IHdoaWxlICgoYWJzKGRMYW1iZGEpID4gZXBzaWxvbiB8fCBhYnMoZFBoaSkgPiBlcHNpbG9uKSAmJiAtLWkgPiAwKTtcbiAgICAgICAgICAgIHJldHVybiBzUGhpMCAqIHBoaSA+IC1hdGFuMihjb3MobGFtYmRhKSwgdGFuUGhpMCkgLSAxZS0zID8gW2xhbWJkYSAqIDIsIHBoaV0gOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgdmFyIGFybWFkaWxsbyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBoaTAgPSAyMCAqIHJhZGlhbnMsIHNQaGkwID0gcGhpMCA+PSAwID8gMSA6IC0xLCB0YW5QaGkwID0gdGFuKHNQaGkwICogcGhpMCksIG0gPSBkM0dlby5nZW9Qcm9qZWN0aW9uTXV0YXRvcihhcm1hZGlsbG9SYXcpLCBwID0gbShwaGkwKSwgc3RyZWFtXyA9IHAuc3RyZWFtO1xuICAgICAgICBwLnBhcmFsbGVsID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gcGhpMCAqIGRlZ3JlZXM7XG4gICAgICAgICAgICB0YW5QaGkwID0gdGFuKChzUGhpMCA9IChwaGkwID0gXyAqIHJhZGlhbnMpID49IDAgPyAxIDogLTEpICogcGhpMCk7XG4gICAgICAgICAgICByZXR1cm4gbShwaGkwKTtcbiAgICAgICAgfTtcbiAgICAgICAgcC5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgcm90YXRlID0gcC5yb3RhdGUoKSwgcm90YXRlU3RyZWFtID0gc3RyZWFtXyhzdHJlYW0pLCBzcGhlcmVTdHJlYW0gPSAocC5yb3RhdGUoWzAsIDBdKSwgc3RyZWFtXyhzdHJlYW0pKTtcbiAgICAgICAgICAgIHAucm90YXRlKHJvdGF0ZSk7XG4gICAgICAgICAgICByb3RhdGVTdHJlYW0uc3BoZXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNwaGVyZVN0cmVhbS5wb2x5Z29uU3RhcnQoKSwgc3BoZXJlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGxhbWJkYSA9IHNQaGkwICogLTE4MDsgc1BoaTAgKiBsYW1iZGEgPCAxODA7IGxhbWJkYSArPSBzUGhpMCAqIDkwKVxuICAgICAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ucG9pbnQobGFtYmRhLCBzUGhpMCAqIDkwKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc1BoaTAgKiAobGFtYmRhIC09IHBoaTApID49IC0xODApIHsgLy8gVE9ETyBwcmVjaXNpb24/XG4gICAgICAgICAgICAgICAgICAgIHNwaGVyZVN0cmVhbS5wb2ludChsYW1iZGEsIHNQaGkwICogLWF0YW4yKGNvcyhsYW1iZGEgKiByYWRpYW5zIC8gMiksIHRhblBoaTApICogZGVncmVlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwaGVyZVN0cmVhbS5saW5lRW5kKCksIHNwaGVyZVN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJvdGF0ZVN0cmVhbTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBcbiAgICAgICAgICAgIC5zY2FsZSgyMTguNjk1KVxuICAgICAgICAgICAgLmNlbnRlcihbMCwgMjguMDk3NF0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gYXVndXN0UmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciB0YW5QaGkgPSB0YW4ocGhpIC8gMiksIGsgPSBzcXJ0KDEgLSB0YW5QaGkgKiB0YW5QaGkpLCBjID0gMSArIGsgKiBjb3MobGFtYmRhIC89IDIpLCB4ID0gc2luKGxhbWJkYSkgKiBrIC8gYywgeSA9IHRhblBoaSAvIGMsIHgyID0geCAqIHgsIHkyID0geSAqIHk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICA0IC8gMyAqIHggKiAoMyArIHgyIC0gMyAqIHkyKSxcbiAgICAgICAgICAgIDQgLyAzICogeSAqICgzICsgMyAqIHgyIC0geTIpXG4gICAgICAgIF07XG4gICAgfVxuICAgIGF1Z3VzdFJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB4ICo9IDMgLyA4LCB5ICo9IDMgLyA4O1xuICAgICAgICBpZiAoIXggJiYgYWJzKHkpID4gMSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgeDIgPSB4ICogeCwgeTIgPSB5ICogeSwgcyA9IDEgKyB4MiArIHkyLCBzaW4zRXRhID0gc3FydCgocyAtIHNxcnQocyAqIHMgLSA0ICogeSAqIHkpKSAvIDIpLCBldGEgPSBhc2luKHNpbjNFdGEpIC8gMywgeGkgPSBzaW4zRXRhID8gYXJjb3NoKGFicyh5IC8gc2luM0V0YSkpIC8gMyA6IGFyc2luaChhYnMoeCkpIC8gMywgY29zRXRhID0gY29zKGV0YSksIGNvc2hYaSA9IGNvc2goeGkpLCBkID0gY29zaFhpICogY29zaFhpIC0gY29zRXRhICogY29zRXRhO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2lnbih4KSAqIDIgKiBhdGFuMihzaW5oKHhpKSAqIGNvc0V0YSwgMC4yNSAtIGQpLFxuICAgICAgICAgICAgc2lnbih5KSAqIDIgKiBhdGFuMihjb3NoWGkgKiBzaW4oZXRhKSwgMC4yNSArIGQpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgYXVndXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihhdWd1c3RSYXcpXG4gICAgICAgICAgICAuc2NhbGUoNjYuMTYwMyk7XG4gICAgfTtcbiAgICB2YXIgc3FydDggPSBzcXJ0KDgpO1xuICAgIHZhciBwaGkwID0gbG9nKDEgKyBzcXJ0Mik7XG4gICAgZnVuY3Rpb24gYmFrZXJSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIHBoaTAgPSBhYnMocGhpKTtcbiAgICAgICAgcmV0dXJuIHBoaTAgPCBxdWFydGVyUGlcbiAgICAgICAgICAgID8gW2xhbWJkYSwgbG9nKHRhbihxdWFydGVyUGkgKyBwaGkgLyAyKSldXG4gICAgICAgICAgICA6IFtsYW1iZGEgKiBjb3MocGhpMCkgKiAoMiAqIHNxcnQyIC0gMSAvIHNpbihwaGkwKSksIHNpZ24ocGhpKSAqICgyICogc3FydDIgKiAocGhpMCAtIHF1YXJ0ZXJQaSkgLSBsb2codGFuKHBoaTAgLyAyKSkpXTtcbiAgICB9XG4gICAgYmFrZXJSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKCh5MCA9IGFicyh5KSkgPCBwaGkwKVxuICAgICAgICAgICAgcmV0dXJuIFt4LCAyICogYXRhbihleHAoeSkpIC0gaGFsZlBpXTtcbiAgICAgICAgdmFyIHBoaSA9IHF1YXJ0ZXJQaSwgaSA9IDI1LCBkZWx0YSwgeTA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBjb3NQaGlfMiA9IGNvcyhwaGkgLyAyKSwgdGFuUGhpXzIgPSB0YW4ocGhpIC8gMik7XG4gICAgICAgICAgICBwaGkgLT0gZGVsdGEgPSAoc3FydDggKiAocGhpIC0gcXVhcnRlclBpKSAtIGxvZyh0YW5QaGlfMikgLSB5MCkgLyAoc3FydDggLSBjb3NQaGlfMiAqIGNvc1BoaV8yIC8gKDIgKiB0YW5QaGlfMikpO1xuICAgICAgICB9IHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbjIgJiYgLS1pID4gMCk7XG4gICAgICAgIHJldHVybiBbeCAvIChjb3MocGhpKSAqIChzcXJ0OCAtIDEgLyBzaW4ocGhpKSkpLCBzaWduKHkpICogcGhpXTtcbiAgICB9O1xuICAgIHZhciBiYWtlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oYmFrZXJSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTEyLjMxNCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBiZXJnaGF1c1Jhdyhsb2Jlcykge1xuICAgICAgICB2YXIgayA9IDIgKiBwaSAvIGxvYmVzO1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgcCA9IGQzR2VvLmdlb0F6aW11dGhhbEVxdWlkaXN0YW50UmF3KGxhbWJkYSwgcGhpKTtcbiAgICAgICAgICAgIGlmIChhYnMobGFtYmRhKSA+IGhhbGZQaSkgeyAvLyBiYWNrIGhlbWlzcGhlcmVcbiAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBhdGFuMihwWzFdLCBwWzBdKSwgciA9IHNxcnQocFswXSAqIHBbMF0gKyBwWzFdICogcFsxXSksIHRoZXRhMCA9IGsgKiByb3VuZCgodGhldGEgLSBoYWxmUGkpIC8gaykgKyBoYWxmUGksIGFscGhhID0gYXRhbjIoc2luKHRoZXRhIC09IHRoZXRhMCksIDIgLSBjb3ModGhldGEpKTsgLy8gYW5nbGUgcmVsYXRpdmUgdG8gbG9iZSBlbmRcbiAgICAgICAgICAgICAgICB0aGV0YSA9IHRoZXRhMCArIGFzaW4ocGkgLyByICogc2luKGFscGhhKSkgLSBhbHBoYTtcbiAgICAgICAgICAgICAgICBwWzBdID0gciAqIGNvcyh0aGV0YSk7XG4gICAgICAgICAgICAgICAgcFsxXSA9IHIgKiBzaW4odGhldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHIgPSBzcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgaWYgKHIgPiBoYWxmUGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSBhdGFuMih5LCB4KSwgdGhldGEwID0gayAqIHJvdW5kKCh0aGV0YSAtIGhhbGZQaSkgLyBrKSArIGhhbGZQaSwgcyA9IHRoZXRhID4gdGhldGEwID8gLTEgOiAxLCBBID0gciAqIGNvcyh0aGV0YTAgLSB0aGV0YSksIGNvdEFscGhhID0gMSAvIHRhbihzICogYWNvcygoQSAtIHBpKSAvIHNxcnQocGkgKiAocGkgLSAyICogQSkgKyByICogcikpKTtcbiAgICAgICAgICAgICAgICB0aGV0YSA9IHRoZXRhMCArIDIgKiBhdGFuKChjb3RBbHBoYSArIHMgKiBzcXJ0KGNvdEFscGhhICogY290QWxwaGEgLSAzKSkgLyAzKTtcbiAgICAgICAgICAgICAgICB4ID0gciAqIGNvcyh0aGV0YSksIHkgPSByICogc2luKHRoZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkM0dlby5nZW9BemltdXRoYWxFcXVpZGlzdGFudFJhdy5pbnZlcnQoeCwgeSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICB2YXIgYmVyZ2hhdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2JlcyA9IDUsIG0gPSBkM0dlby5nZW9Qcm9qZWN0aW9uTXV0YXRvcihiZXJnaGF1c1JhdyksIHAgPSBtKGxvYmVzKSwgcHJvamVjdGlvblN0cmVhbSA9IHAuc3RyZWFtLCBlcHNpbG9uJCQxID0gMWUtMiwgY3IgPSAtY29zKGVwc2lsb24kJDEgKiByYWRpYW5zKSwgc3IgPSBzaW4oZXBzaWxvbiQkMSAqIHJhZGlhbnMpO1xuICAgICAgICBwLmxvYmVzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gbShsb2JlcyA9ICtfKSA6IGxvYmVzO1xuICAgICAgICB9O1xuICAgICAgICBwLnN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciByb3RhdGUgPSBwLnJvdGF0ZSgpLCByb3RhdGVTdHJlYW0gPSBwcm9qZWN0aW9uU3RyZWFtKHN0cmVhbSksIHNwaGVyZVN0cmVhbSA9IChwLnJvdGF0ZShbMCwgMF0pLCBwcm9qZWN0aW9uU3RyZWFtKHN0cmVhbSkpO1xuICAgICAgICAgICAgcC5yb3RhdGUocm90YXRlKTtcbiAgICAgICAgICAgIHJvdGF0ZVN0cmVhbS5zcGhlcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3BoZXJlU3RyZWFtLnBvbHlnb25TdGFydCgpLCBzcGhlcmVTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGRlbHRhID0gMzYwIC8gbG9iZXMsIGRlbHRhMCA9IDIgKiBwaSAvIGxvYmVzLCBwaGkgPSA5MCAtIDE4MCAvIGxvYmVzLCBwaGkwID0gaGFsZlBpOyBpIDwgbG9iZXM7ICsraSwgcGhpIC09IGRlbHRhLCBwaGkwIC09IGRlbHRhMCkge1xuICAgICAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ucG9pbnQoYXRhbjIoc3IgKiBjb3MocGhpMCksIGNyKSAqIGRlZ3JlZXMsIGFzaW4oc3IgKiBzaW4ocGhpMCkpICogZGVncmVlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaGkgPCAtOTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaGVyZVN0cmVhbS5wb2ludCgtOTAsIC0xODAgLSBwaGkgLSBlcHNpbG9uJCQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaGVyZVN0cmVhbS5wb2ludCgtOTAsIC0xODAgLSBwaGkgKyBlcHNpbG9uJCQxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwaGVyZVN0cmVhbS5wb2ludCg5MCwgcGhpICsgZXBzaWxvbiQkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ucG9pbnQoOTAsIHBoaSAtIGVwc2lsb24kJDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNwaGVyZVN0cmVhbS5saW5lRW5kKCksIHNwaGVyZVN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJvdGF0ZVN0cmVhbTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBcbiAgICAgICAgICAgIC5zY2FsZSg4Ny44MDc2KVxuICAgICAgICAgICAgLmNlbnRlcihbMCwgMTcuMTg3NV0pXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDE4MCAtIDFlLTMpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbW9sbHdlaWRlQnJvbWxleVRoZXRhKGNwLCBwaGkpIHtcbiAgICAgICAgdmFyIGNwc2luUGhpID0gY3AgKiBzaW4ocGhpKSwgaSA9IDMwLCBkZWx0YTtcbiAgICAgICAgZG9cbiAgICAgICAgICAgIHBoaSAtPSBkZWx0YSA9IChwaGkgKyBzaW4ocGhpKSAtIGNwc2luUGhpKSAvICgxICsgY29zKHBoaSkpO1xuICAgICAgICB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24gJiYgLS1pID4gMCk7XG4gICAgICAgIHJldHVybiBwaGkgLyAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb2xsd2VpZGVCcm9tbGV5UmF3KGN4LCBjeSwgY3ApIHtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgcmV0dXJuIFtjeCAqIGxhbWJkYSAqIGNvcyhwaGkgPSBtb2xsd2VpZGVCcm9tbGV5VGhldGEoY3AsIHBoaSkpLCBjeSAqIHNpbihwaGkpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geSA9IGFzaW4oeSAvIGN5KSwgW3ggLyAoY3ggKiBjb3MoeSkpLCBhc2luKCgyICogeSArIHNpbigyICogeSkpIC8gY3ApXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIHZhciBtb2xsd2VpZGVSYXcgPSBtb2xsd2VpZGVCcm9tbGV5UmF3KHNxcnQyIC8gaGFsZlBpLCBzcXJ0MiwgcGkpO1xuICAgIHZhciBtb2xsd2VpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKG1vbGx3ZWlkZVJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNjkuNTI5KTtcbiAgICB9O1xuICAgIHZhciBrID0gMi4wMDI3NjtcbiAgICB2YXIgdyA9IDEuMTEwNzI7XG4gICAgZnVuY3Rpb24gYm9nZ3NSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIHRoZXRhID0gbW9sbHdlaWRlQnJvbWxleVRoZXRhKHBpLCBwaGkpO1xuICAgICAgICByZXR1cm4gW2sgKiBsYW1iZGEgLyAoMSAvIGNvcyhwaGkpICsgdyAvIGNvcyh0aGV0YSkpLCAocGhpICsgc3FydDIgKiBzaW4odGhldGEpKSAvIGtdO1xuICAgIH1cbiAgICBib2dnc1Jhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIga3kgPSBrICogeSwgdGhldGEgPSB5IDwgMCA/IC1xdWFydGVyUGkgOiBxdWFydGVyUGksIGkgPSAyNSwgZGVsdGEsIHBoaTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcGhpID0ga3kgLSBzcXJ0MiAqIHNpbih0aGV0YSk7XG4gICAgICAgICAgICB0aGV0YSAtPSBkZWx0YSA9IChzaW4oMiAqIHRoZXRhKSArIDIgKiB0aGV0YSAtIHBpICogc2luKHBoaSkpIC8gKDIgKiBjb3MoMiAqIHRoZXRhKSArIDIgKyBwaSAqIGNvcyhwaGkpICogc3FydDIgKiBjb3ModGhldGEpKTtcbiAgICAgICAgfSB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24gJiYgLS1pID4gMCk7XG4gICAgICAgIHBoaSA9IGt5IC0gc3FydDIgKiBzaW4odGhldGEpO1xuICAgICAgICByZXR1cm4gW3ggKiAoMSAvIGNvcyhwaGkpICsgdyAvIGNvcyh0aGV0YSkpIC8gaywgcGhpXTtcbiAgICB9O1xuICAgIHZhciBib2dncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oYm9nZ3NSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTYwLjg1Nyk7XG4gICAgfTtcbiAgICB2YXIgcGFyYWxsZWwxID0gZnVuY3Rpb24gKHByb2plY3RBdCkge1xuICAgICAgICB2YXIgcGhpMCA9IDAsIG0gPSBkM0dlby5nZW9Qcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpLCBwID0gbShwaGkwKTtcbiAgICAgICAgcC5wYXJhbGxlbCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IG0ocGhpMCA9IF8gKiByYWRpYW5zKSA6IHBoaTAgKiBkZWdyZWVzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHNpbnVzb2lkYWxSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgcmV0dXJuIFtsYW1iZGEgKiBjb3MocGhpKSwgcGhpXTtcbiAgICB9XG4gICAgc2ludXNvaWRhbFJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gW3ggLyBjb3MoeSksIHldO1xuICAgIH07XG4gICAgdmFyIHNpbnVzb2lkYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKHNpbnVzb2lkYWxSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTUyLjYzKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGJvbm5lUmF3KHBoaTApIHtcbiAgICAgICAgaWYgKCFwaGkwKVxuICAgICAgICAgICAgcmV0dXJuIHNpbnVzb2lkYWxSYXc7XG4gICAgICAgIHZhciBjb3RQaGkwID0gMSAvIHRhbihwaGkwKTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIHJobyA9IGNvdFBoaTAgKyBwaGkwIC0gcGhpLCBlID0gcmhvID8gbGFtYmRhICogY29zKHBoaSkgLyByaG8gOiByaG87XG4gICAgICAgICAgICByZXR1cm4gW3JobyAqIHNpbihlKSwgY290UGhpMCAtIHJobyAqIGNvcyhlKV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHJobyA9IHNxcnQoeCAqIHggKyAoeSA9IGNvdFBoaTAgLSB5KSAqIHkpLCBwaGkgPSBjb3RQaGkwICsgcGhpMCAtIHJobztcbiAgICAgICAgICAgIHJldHVybiBbcmhvIC8gY29zKHBoaSkgKiBhdGFuMih4LCB5KSwgcGhpXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIHZhciBib25uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFsbGVsMShib25uZVJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxMjMuMDgyKVxuICAgICAgICAgICAgLmNlbnRlcihbMCwgMjYuMTQ0MV0pXG4gICAgICAgICAgICAucGFyYWxsZWwoNDUpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gYm90dG9tbGV5UmF3KHNpblBzaSkge1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgcmhvID0gaGFsZlBpIC0gcGhpLCBldGEgPSByaG8gPyBsYW1iZGEgKiBzaW5Qc2kgKiBzaW4ocmhvKSAvIHJobyA6IHJobztcbiAgICAgICAgICAgIHJldHVybiBbcmhvICogc2luKGV0YSkgLyBzaW5Qc2ksIGhhbGZQaSAtIHJobyAqIGNvcyhldGEpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgeDEgPSB4ICogc2luUHNpLCB5MSA9IGhhbGZQaSAtIHksIHJobyA9IHNxcnQoeDEgKiB4MSArIHkxICogeTEpLCBldGEgPSBhdGFuMih4MSwgeTEpO1xuICAgICAgICAgICAgcmV0dXJuIFsocmhvID8gcmhvIC8gc2luKHJobykgOiAxKSAqIGV0YSAvIHNpblBzaSwgaGFsZlBpIC0gcmhvXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIHZhciBib3R0b21sZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaW5Qc2kgPSAwLjUsIG0gPSBkM0dlby5nZW9Qcm9qZWN0aW9uTXV0YXRvcihib3R0b21sZXlSYXcpLCBwID0gbShzaW5Qc2kpO1xuICAgICAgICBwLmZyYWN0aW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gbShzaW5Qc2kgPSArXykgOiBzaW5Qc2k7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwXG4gICAgICAgICAgICAuc2NhbGUoMTU4LjgzNyk7XG4gICAgfTtcbiAgICB2YXIgYnJvbWxleVJhdyA9IG1vbGx3ZWlkZUJyb21sZXlSYXcoMSwgNCAvIHBpLCBwaSk7XG4gICAgdmFyIGJyb21sZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGJyb21sZXlSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTUyLjYzKTtcbiAgICB9O1xuICAgIC8vIEF6aW11dGhhbCBkaXN0YW5jZS5cbiAgICBmdW5jdGlvbiBkaXN0YW5jZShkUGhpLCBjMSwgczEsIGMyLCBzMiwgZExhbWJkYSkge1xuICAgICAgICB2YXIgY29zZExhbWJkYSA9IGNvcyhkTGFtYmRhKSwgcjtcbiAgICAgICAgaWYgKGFicyhkUGhpKSA+IDEgfHwgYWJzKGRMYW1iZGEpID4gMSkge1xuICAgICAgICAgICAgciA9IGFjb3MoczEgKiBzMiArIGMxICogYzIgKiBjb3NkTGFtYmRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzaW5kUGhpID0gc2luKGRQaGkgLyAyKSwgc2luZExhbWJkYSA9IHNpbihkTGFtYmRhIC8gMik7XG4gICAgICAgICAgICByID0gMiAqIGFzaW4oc3FydChzaW5kUGhpICogc2luZFBoaSArIGMxICogYzIgKiBzaW5kTGFtYmRhICogc2luZExhbWJkYSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhYnMocikgPiBlcHNpbG9uID8gW3IsIGF0YW4yKGMyICogc2luKGRMYW1iZGEpLCBjMSAqIHMyIC0gczEgKiBjMiAqIGNvc2RMYW1iZGEpXSA6IFswLCAwXTtcbiAgICB9XG4gICAgLy8gQW5nbGUgb3Bwb3NpdGUgYSwgYW5kIGNvbnRhaW5lZCBiZXR3ZWVuIHNpZGVzIG9mIGxlbmd0aHMgYiBhbmQgYy5cbiAgICBmdW5jdGlvbiBhbmdsZShiLCBjLCBhKSB7XG4gICAgICAgIHJldHVybiBhY29zKChiICogYiArIGMgKiBjIC0gYSAqIGEpIC8gKDIgKiBiICogYykpO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgbG9uZ2l0dWRlLlxuICAgIGZ1bmN0aW9uIGxvbmdpdHVkZShsYW1iZGEpIHtcbiAgICAgICAgcmV0dXJuIGxhbWJkYSAtIDIgKiBwaSAqIGZsb29yKChsYW1iZGEgKyBwaSkgLyAoMiAqIHBpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoYW1iZXJsaW5SYXcocDAsIHAxLCBwMikge1xuICAgICAgICB2YXIgcG9pbnRzID0gW1xuICAgICAgICAgICAgW3AwWzBdLCBwMFsxXSwgc2luKHAwWzFdKSwgY29zKHAwWzFdKV0sXG4gICAgICAgICAgICBbcDFbMF0sIHAxWzFdLCBzaW4ocDFbMV0pLCBjb3MocDFbMV0pXSxcbiAgICAgICAgICAgIFtwMlswXSwgcDJbMV0sIHNpbihwMlsxXSksIGNvcyhwMlsxXSldXG4gICAgICAgIF07XG4gICAgICAgIGZvciAodmFyIGEgPSBwb2ludHNbMl0sIGIsIGkgPSAwOyBpIDwgMzsgKytpLCBhID0gYikge1xuICAgICAgICAgICAgYiA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGEudiA9IGRpc3RhbmNlKGJbMV0gLSBhWzFdLCBhWzNdLCBhWzJdLCBiWzNdLCBiWzJdLCBiWzBdIC0gYVswXSk7XG4gICAgICAgICAgICBhLnBvaW50ID0gWzAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZXRhMCA9IGFuZ2xlKHBvaW50c1swXS52WzBdLCBwb2ludHNbMl0udlswXSwgcG9pbnRzWzFdLnZbMF0pLCBiZXRhMSA9IGFuZ2xlKHBvaW50c1swXS52WzBdLCBwb2ludHNbMV0udlswXSwgcG9pbnRzWzJdLnZbMF0pLCBiZXRhMiA9IHBpIC0gYmV0YTA7XG4gICAgICAgIHBvaW50c1syXS5wb2ludFsxXSA9IDA7XG4gICAgICAgIHBvaW50c1swXS5wb2ludFswXSA9IC0ocG9pbnRzWzFdLnBvaW50WzBdID0gcG9pbnRzWzBdLnZbMF0gLyAyKTtcbiAgICAgICAgdmFyIG1lYW4gPSBbXG4gICAgICAgICAgICBwb2ludHNbMl0ucG9pbnRbMF0gPSBwb2ludHNbMF0ucG9pbnRbMF0gKyBwb2ludHNbMl0udlswXSAqIGNvcyhiZXRhMCksXG4gICAgICAgICAgICAyICogKHBvaW50c1swXS5wb2ludFsxXSA9IHBvaW50c1sxXS5wb2ludFsxXSA9IHBvaW50c1syXS52WzBdICogc2luKGJldGEwKSlcbiAgICAgICAgXTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIHNpblBoaSA9IHNpbihwaGkpLCBjb3NQaGkgPSBjb3MocGhpKSwgdiA9IG5ldyBBcnJheSgzKSwgaTtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgZGlzdGFuY2UgYW5kIGF6aW11dGggZnJvbSBjb250cm9sIHBvaW50cy5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICB2W2ldID0gZGlzdGFuY2UocGhpIC0gcFsxXSwgcFszXSwgcFsyXSwgY29zUGhpLCBzaW5QaGksIGxhbWJkYSAtIHBbMF0pO1xuICAgICAgICAgICAgICAgIGlmICghdltpXVswXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAucG9pbnQ7XG4gICAgICAgICAgICAgICAgdltpXVsxXSA9IGxvbmdpdHVkZSh2W2ldWzFdIC0gcC52WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFyaXRobWV0aWMgbWVhbiBvZiBpbnRlcmNlcHRpb24gcG9pbnRzLlxuICAgICAgICAgICAgdmFyIHBvaW50ID0gbWVhbi5zbGljZSgpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBqID0gaSA9PSAyID8gMCA6IGkgKyAxO1xuICAgICAgICAgICAgICAgIHZhciBhID0gYW5nbGUocG9pbnRzW2ldLnZbMF0sIHZbaV1bMF0sIHZbal1bMF0pO1xuICAgICAgICAgICAgICAgIGlmICh2W2ldWzFdIDwgMClcbiAgICAgICAgICAgICAgICAgICAgYSA9IC1hO1xuICAgICAgICAgICAgICAgIGlmICghaSkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludFswXSArPSB2W2ldWzBdICogY29zKGEpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludFsxXSAtPSB2W2ldWzBdICogc2luKGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IGJldGExIC0gYTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRbMF0gLT0gdltpXVswXSAqIGNvcyhhKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRbMV0gLT0gdltpXVswXSAqIHNpbihhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBiZXRhMiAtIGE7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50WzBdICs9IHZbaV1bMF0gKiBjb3MoYSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50WzFdICs9IHZbaV1bMF0gKiBzaW4oYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRbMF0gLz0gMywgcG9pbnRbMV0gLz0gMztcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRSYWRpYW5zKHApIHtcbiAgICAgICAgcmV0dXJuIHBbMF0gKj0gcmFkaWFucywgcFsxXSAqPSByYWRpYW5zLCBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGFtYmVybGluQWZyaWNhKCkge1xuICAgICAgICByZXR1cm4gY2hhbWJlcmxpbihbMCwgMjJdLCBbNDUsIDIyXSwgWzIyLjUsIC0yMl0pXG4gICAgICAgICAgICAuc2NhbGUoMzgwKVxuICAgICAgICAgICAgLmNlbnRlcihbMjIuNSwgMl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGFtYmVybGluKHAwLCBwMSwgcDIpIHtcbiAgICAgICAgdmFyIGMgPSBkM0dlby5nZW9DZW50cm9pZCh7IHR5cGU6IFwiTXVsdGlQb2ludFwiLCBjb29yZGluYXRlczogW3AwLCBwMSwgcDJdIH0pLCBSID0gWy1jWzBdLCAtY1sxXV0sIHIgPSBkM0dlby5nZW9Sb3RhdGlvbihSKSwgcCA9IGQzR2VvLmdlb1Byb2plY3Rpb24oY2hhbWJlcmxpblJhdyhwb2ludFJhZGlhbnMocihwMCkpLCBwb2ludFJhZGlhbnMocihwMSkpLCBwb2ludFJhZGlhbnMocihwMikpKSkucm90YXRlKFIpLCBjZW50ZXIgPSBwLmNlbnRlcjtcbiAgICAgICAgZGVsZXRlIHAucm90YXRlO1xuICAgICAgICBwLmNlbnRlciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGNlbnRlcihyKF8pKSA6IHIuaW52ZXJ0KGNlbnRlcigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoOTApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2xsaWdub25SYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIGFscGhhID0gc3FydCgxIC0gc2luKHBoaSkpO1xuICAgICAgICByZXR1cm4gWygyIC8gc3FydFBpKSAqIGxhbWJkYSAqIGFscGhhLCBzcXJ0UGkgKiAoMSAtIGFscGhhKV07XG4gICAgfVxuICAgIGNvbGxpZ25vblJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgbGFtYmRhID0gKGxhbWJkYSA9IHkgLyBzcXJ0UGkgLSAxKSAqIGxhbWJkYTtcbiAgICAgICAgcmV0dXJuIFtsYW1iZGEgPiAwID8geCAqIHNxcnQocGkgLyBsYW1iZGEpIC8gMiA6IDAsIGFzaW4oMSAtIGxhbWJkYSldO1xuICAgIH07XG4gICAgdmFyIGNvbGxpZ25vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oY29sbGlnbm9uUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDk1LjY0NjQpXG4gICAgICAgICAgICAuY2VudGVyKFswLCAzMF0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gY3JhaWdSYXcocGhpMCkge1xuICAgICAgICB2YXIgdGFuUGhpMCA9IHRhbihwaGkwKTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgcmV0dXJuIFtsYW1iZGEsIChsYW1iZGEgPyBsYW1iZGEgLyBzaW4obGFtYmRhKSA6IDEpICogKHNpbihwaGkpICogY29zKGxhbWJkYSkgLSB0YW5QaGkwICogY29zKHBoaSkpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IHRhblBoaTAgPyBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgaWYgKHgpXG4gICAgICAgICAgICAgICAgeSAqPSBzaW4oeCkgLyB4O1xuICAgICAgICAgICAgdmFyIGNvc0xhbWJkYSA9IGNvcyh4KTtcbiAgICAgICAgICAgIHJldHVybiBbeCwgMiAqIGF0YW4yKHNxcnQoY29zTGFtYmRhICogY29zTGFtYmRhICsgdGFuUGhpMCAqIHRhblBoaTAgLSB5ICogeSkgLSBjb3NMYW1iZGEsIHRhblBoaTAgLSB5KV07XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIFt4LCBhc2luKHggPyB5ICogdGFuKHgpIC8geCA6IHkpXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIHZhciBjcmFpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFsbGVsMShjcmFpZ1JhdylcbiAgICAgICAgICAgIC5zY2FsZSgyNDkuODI4KVxuICAgICAgICAgICAgLmNsaXBBbmdsZSg5MCk7XG4gICAgfTtcbiAgICB2YXIgc3FydDMgPSBzcXJ0KDMpO1xuICAgIGZ1bmN0aW9uIGNyYXN0ZXJSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgcmV0dXJuIFtzcXJ0MyAqIGxhbWJkYSAqICgyICogY29zKDIgKiBwaGkgLyAzKSAtIDEpIC8gc3FydFBpLCBzcXJ0MyAqIHNxcnRQaSAqIHNpbihwaGkgLyAzKV07XG4gICAgfVxuICAgIGNyYXN0ZXJSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHBoaSA9IDMgKiBhc2luKHkgLyAoc3FydDMgKiBzcXJ0UGkpKTtcbiAgICAgICAgcmV0dXJuIFtzcXJ0UGkgKiB4IC8gKHNxcnQzICogKDIgKiBjb3MoMiAqIHBoaSAvIDMpIC0gMSkpLCBwaGldO1xuICAgIH07XG4gICAgdmFyIGNyYXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGNyYXN0ZXJSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTU2LjE5KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGN5bGluZHJpY2FsRXF1YWxBcmVhUmF3KHBoaTApIHtcbiAgICAgICAgdmFyIGNvc1BoaTAgPSBjb3MocGhpMCk7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGFtYmRhICogY29zUGhpMCwgc2luKHBoaSkgLyBjb3NQaGkwXTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gW3ggLyBjb3NQaGkwLCBhc2luKHkgKiBjb3NQaGkwKV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICB2YXIgY3lsaW5kcmljYWxFcXVhbEFyZWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbGxlbDEoY3lsaW5kcmljYWxFcXVhbEFyZWFSYXcpXG4gICAgICAgICAgICAucGFyYWxsZWwoMzguNTgpIC8vIGFjb3Moc3FydCh3aWR0aCAvIGhlaWdodCAvIHBpKSkgKiByYWRpYW5zXG4gICAgICAgICAgICAuc2NhbGUoMTk1LjA0NCk7IC8vIHdpZHRoIC8gKHNxcnQod2lkdGggLyBoZWlnaHQgLyBwaSkgKiAyICogcGkpXG4gICAgfTtcbiAgICBmdW5jdGlvbiBjeWxpbmRyaWNhbFN0ZXJlb2dyYXBoaWNSYXcocGhpMCkge1xuICAgICAgICB2YXIgY29zUGhpMCA9IGNvcyhwaGkwKTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgcmV0dXJuIFtsYW1iZGEgKiBjb3NQaGkwLCAoMSArIGNvc1BoaTApICogdGFuKHBoaSAvIDIpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gW3ggLyBjb3NQaGkwLCBhdGFuKHkgLyAoMSArIGNvc1BoaTApKSAqIDJdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgdmFyIGN5bGluZHJpY2FsU3RlcmVvZ3JhcGhpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFsbGVsMShjeWxpbmRyaWNhbFN0ZXJlb2dyYXBoaWNSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTI0Ljc1KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGVja2VydDFSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIGFscGhhID0gc3FydCg4IC8gKDMgKiBwaSkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYWxwaGEgKiBsYW1iZGEgKiAoMSAtIGFicyhwaGkpIC8gcGkpLFxuICAgICAgICAgICAgYWxwaGEgKiBwaGlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZWNrZXJ0MVJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgYWxwaGEgPSBzcXJ0KDggLyAoMyAqIHBpKSksIHBoaSA9IHkgLyBhbHBoYTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHggLyAoYWxwaGEgKiAoMSAtIGFicyhwaGkpIC8gcGkpKSxcbiAgICAgICAgICAgIHBoaVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIGVja2VydDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGVja2VydDFSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTY1LjY2NCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBlY2tlcnQyUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBhbHBoYSA9IHNxcnQoNCAtIDMgKiBzaW4oYWJzKHBoaSkpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIDIgLyBzcXJ0KDYgKiBwaSkgKiBsYW1iZGEgKiBhbHBoYSxcbiAgICAgICAgICAgIHNpZ24ocGhpKSAqIHNxcnQoMiAqIHBpIC8gMykgKiAoMiAtIGFscGhhKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBlY2tlcnQyUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBhbHBoYSA9IDIgLSBhYnMoeSkgLyBzcXJ0KDIgKiBwaSAvIDMpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeCAqIHNxcnQoNiAqIHBpKSAvICgyICogYWxwaGEpLFxuICAgICAgICAgICAgc2lnbih5KSAqIGFzaW4oKDQgLSBhbHBoYSAqIGFscGhhKSAvIDMpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgZWNrZXJ0MiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oZWNrZXJ0MlJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNjUuNjY0KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGVja2VydDNSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIGsgPSBzcXJ0KHBpICogKDQgKyBwaSkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMiAvIGsgKiBsYW1iZGEgKiAoMSArIHNxcnQoMSAtIDQgKiBwaGkgKiBwaGkgLyAocGkgKiBwaSkpKSxcbiAgICAgICAgICAgIDQgLyBrICogcGhpXG4gICAgICAgIF07XG4gICAgfVxuICAgIGVja2VydDNSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGsgPSBzcXJ0KHBpICogKDQgKyBwaSkpIC8gMjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHggKiBrIC8gKDEgKyBzcXJ0KDEgLSB5ICogeSAqICg0ICsgcGkpIC8gKDQgKiBwaSkpKSxcbiAgICAgICAgICAgIHkgKiBrIC8gMlxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIGVja2VydDMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGVja2VydDNSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTgwLjczOSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBlY2tlcnQ0UmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBrID0gKDIgKyBoYWxmUGkpICogc2luKHBoaSk7XG4gICAgICAgIHBoaSAvPSAyO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgZGVsdGEgPSBJbmZpbml0eTsgaSA8IDEwICYmIGFicyhkZWx0YSkgPiBlcHNpbG9uOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgICAgICAgICAgIHBoaSAtPSBkZWx0YSA9IChwaGkgKyBzaW4ocGhpKSAqIChjb3NQaGkgKyAyKSAtIGspIC8gKDIgKiBjb3NQaGkgKiAoMSArIGNvc1BoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAyIC8gc3FydChwaSAqICg0ICsgcGkpKSAqIGxhbWJkYSAqICgxICsgY29zKHBoaSkpLFxuICAgICAgICAgICAgMiAqIHNxcnQocGkgLyAoNCArIHBpKSkgKiBzaW4ocGhpKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBlY2tlcnQ0UmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBBID0geSAqIHNxcnQoKDQgKyBwaSkgLyBwaSkgLyAyLCBrID0gYXNpbihBKSwgYyA9IGNvcyhrKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHggLyAoMiAvIHNxcnQocGkgKiAoNCArIHBpKSkgKiAoMSArIGMpKSxcbiAgICAgICAgICAgIGFzaW4oKGsgKyBBICogKGMgKyAyKSkgLyAoMiArIGhhbGZQaSkpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgZWNrZXJ0NCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oZWNrZXJ0NFJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxODAuNzM5KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGVja2VydDVSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxhbWJkYSAqICgxICsgY29zKHBoaSkpIC8gc3FydCgyICsgcGkpLFxuICAgICAgICAgICAgMiAqIHBoaSAvIHNxcnQoMiArIHBpKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBlY2tlcnQ1UmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBrID0gc3FydCgyICsgcGkpLCBwaGkgPSB5ICogayAvIDI7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBrICogeCAvICgxICsgY29zKHBoaSkpLFxuICAgICAgICAgICAgcGhpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgZWNrZXJ0NSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oZWNrZXJ0NVJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNzMuMDQ0KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGVja2VydDZSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIGsgPSAoMSArIGhhbGZQaSkgKiBzaW4ocGhpKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGRlbHRhID0gSW5maW5pdHk7IGkgPCAxMCAmJiBhYnMoZGVsdGEpID4gZXBzaWxvbjsgaSsrKSB7XG4gICAgICAgICAgICBwaGkgLT0gZGVsdGEgPSAocGhpICsgc2luKHBoaSkgLSBrKSAvICgxICsgY29zKHBoaSkpO1xuICAgICAgICB9XG4gICAgICAgIGsgPSBzcXJ0KDIgKyBwaSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsYW1iZGEgKiAoMSArIGNvcyhwaGkpKSAvIGssXG4gICAgICAgICAgICAyICogcGhpIC8ga1xuICAgICAgICBdO1xuICAgIH1cbiAgICBlY2tlcnQ2UmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBqID0gMSArIGhhbGZQaSwgayA9IHNxcnQoaiAvIDIpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeCAqIDIgKiBrIC8gKDEgKyBjb3MoeSAqPSBrKSksXG4gICAgICAgICAgICBhc2luKCh5ICsgc2luKHkpKSAvIGopXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgZWNrZXJ0NiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oZWNrZXJ0NlJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNzMuMDQ0KTtcbiAgICB9O1xuICAgIHZhciBlaXNlbmxvaHJLID0gMyArIDIgKiBzcXJ0MjtcbiAgICBmdW5jdGlvbiBlaXNlbmxvaHJSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIHMwID0gc2luKGxhbWJkYSAvPSAyKSwgYzAgPSBjb3MobGFtYmRhKSwgayA9IHNxcnQoY29zKHBoaSkpLCBjMSA9IGNvcyhwaGkgLz0gMiksIHQgPSBzaW4ocGhpKSAvIChjMSArIHNxcnQyICogYzAgKiBrKSwgYyA9IHNxcnQoMiAvICgxICsgdCAqIHQpKSwgdiA9IHNxcnQoKHNxcnQyICogYzEgKyAoYzAgKyBzMCkgKiBrKSAvIChzcXJ0MiAqIGMxICsgKGMwIC0gczApICogaykpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZWlzZW5sb2hySyAqIChjICogKHYgLSAxIC8gdikgLSAyICogbG9nKHYpKSxcbiAgICAgICAgICAgIGVpc2VubG9ocksgKiAoYyAqIHQgKiAodiArIDEgLyB2KSAtIDIgKiBhdGFuKHQpKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBlaXNlbmxvaHJSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKCEocCA9IGF1Z3VzdFJhdy5pbnZlcnQoeCAvIDEuMiwgeSAqIDEuMDY1KSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGxhbWJkYSA9IHBbMF0sIHBoaSA9IHBbMV0sIGkgPSAyMCwgcDtcbiAgICAgICAgeCAvPSBlaXNlbmxvaHJLLCB5IC89IGVpc2VubG9ocks7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBfMCA9IGxhbWJkYSAvIDIsIF8xID0gcGhpIC8gMiwgczAgPSBzaW4oXzApLCBjMCA9IGNvcyhfMCksIHMxID0gc2luKF8xKSwgYzEgPSBjb3MoXzEpLCBjb3MxID0gY29zKHBoaSksIGsgPSBzcXJ0KGNvczEpLCB0ID0gczEgLyAoYzEgKyBzcXJ0MiAqIGMwICogayksIHQyID0gdCAqIHQsIGMgPSBzcXJ0KDIgLyAoMSArIHQyKSksIHYwID0gKHNxcnQyICogYzEgKyAoYzAgKyBzMCkgKiBrKSwgdjEgPSAoc3FydDIgKiBjMSArIChjMCAtIHMwKSAqIGspLCB2MiA9IHYwIC8gdjEsIHYgPSBzcXJ0KHYyKSwgdm0xdiA9IHYgLSAxIC8gdiwgdnAxdiA9IHYgKyAxIC8gdiwgZnggPSBjICogdm0xdiAtIDIgKiBsb2codikgLSB4LCBmeSA9IGMgKiB0ICogdnAxdiAtIDIgKiBhdGFuKHQpIC0geSwgZGVsdGF0RGVsdGFMYW1iZGEgPSBzMSAmJiBzcXJ0MV8yICogayAqIHMwICogdDIgLyBzMSwgZGVsdGF0RGVsdGFQaGkgPSAoc3FydDIgKiBjMCAqIGMxICsgaykgLyAoMiAqIChjMSArIHNxcnQyICogYzAgKiBrKSAqIChjMSArIHNxcnQyICogYzAgKiBrKSAqIGspLCBkZWx0YWNEZWx0YXQgPSAtMC41ICogdCAqIGMgKiBjICogYywgZGVsdGFjRGVsdGFMYW1iZGEgPSBkZWx0YWNEZWx0YXQgKiBkZWx0YXREZWx0YUxhbWJkYSwgZGVsdGFjRGVsdGFQaGkgPSBkZWx0YWNEZWx0YXQgKiBkZWx0YXREZWx0YVBoaSwgQSA9IChBID0gMiAqIGMxICsgc3FydDIgKiBrICogKGMwIC0gczApKSAqIEEgKiB2LCBkZWx0YXZEZWx0YUxhbWJkYSA9IChzcXJ0MiAqIGMwICogYzEgKiBrICsgY29zMSkgLyBBLCBkZWx0YXZEZWx0YVBoaSA9IC0oc3FydDIgKiBzMCAqIHMxKSAvIChrICogQSksIGRlbHRheERlbHRhTGFtYmRhID0gdm0xdiAqIGRlbHRhY0RlbHRhTGFtYmRhIC0gMiAqIGRlbHRhdkRlbHRhTGFtYmRhIC8gdiArIGMgKiAoZGVsdGF2RGVsdGFMYW1iZGEgKyBkZWx0YXZEZWx0YUxhbWJkYSAvIHYyKSwgZGVsdGF4RGVsdGFQaGkgPSB2bTF2ICogZGVsdGFjRGVsdGFQaGkgLSAyICogZGVsdGF2RGVsdGFQaGkgLyB2ICsgYyAqIChkZWx0YXZEZWx0YVBoaSArIGRlbHRhdkRlbHRhUGhpIC8gdjIpLCBkZWx0YXlEZWx0YUxhbWJkYSA9IHQgKiB2cDF2ICogZGVsdGFjRGVsdGFMYW1iZGEgLSAyICogZGVsdGF0RGVsdGFMYW1iZGEgLyAoMSArIHQyKSArIGMgKiB2cDF2ICogZGVsdGF0RGVsdGFMYW1iZGEgKyBjICogdCAqIChkZWx0YXZEZWx0YUxhbWJkYSAtIGRlbHRhdkRlbHRhTGFtYmRhIC8gdjIpLCBkZWx0YXlEZWx0YVBoaSA9IHQgKiB2cDF2ICogZGVsdGFjRGVsdGFQaGkgLSAyICogZGVsdGF0RGVsdGFQaGkgLyAoMSArIHQyKSArIGMgKiB2cDF2ICogZGVsdGF0RGVsdGFQaGkgKyBjICogdCAqIChkZWx0YXZEZWx0YVBoaSAtIGRlbHRhdkRlbHRhUGhpIC8gdjIpLCBkZW5vbWluYXRvciA9IGRlbHRheERlbHRhUGhpICogZGVsdGF5RGVsdGFMYW1iZGEgLSBkZWx0YXlEZWx0YVBoaSAqIGRlbHRheERlbHRhTGFtYmRhO1xuICAgICAgICAgICAgaWYgKCFkZW5vbWluYXRvcilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZhciBkZWx0YUxhbWJkYSA9IChmeSAqIGRlbHRheERlbHRhUGhpIC0gZnggKiBkZWx0YXlEZWx0YVBoaSkgLyBkZW5vbWluYXRvciwgZGVsdGFQaGkgPSAoZnggKiBkZWx0YXlEZWx0YUxhbWJkYSAtIGZ5ICogZGVsdGF4RGVsdGFMYW1iZGEpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICBsYW1iZGEgLT0gZGVsdGFMYW1iZGE7XG4gICAgICAgICAgICBwaGkgPSBtYXgoLWhhbGZQaSwgbWluKGhhbGZQaSwgcGhpIC0gZGVsdGFQaGkpKTtcbiAgICAgICAgfSB3aGlsZSAoKGFicyhkZWx0YUxhbWJkYSkgPiBlcHNpbG9uIHx8IGFicyhkZWx0YVBoaSkgPiBlcHNpbG9uKSAmJiAtLWkgPiAwKTtcbiAgICAgICAgcmV0dXJuIGFicyhhYnMocGhpKSAtIGhhbGZQaSkgPCBlcHNpbG9uID8gWzAsIHBoaV0gOiBpICYmIFtsYW1iZGEsIHBoaV07XG4gICAgfTtcbiAgICB2YXIgZWlzZW5sb2hyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihlaXNlbmxvaHJSYXcpXG4gICAgICAgICAgICAuc2NhbGUoNjIuNTI3MSk7XG4gICAgfTtcbiAgICB2YXIgZmFoZXlLID0gY29zKDM1ICogcmFkaWFucyk7XG4gICAgZnVuY3Rpb24gZmFoZXlSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIHQgPSB0YW4ocGhpIC8gMik7XG4gICAgICAgIHJldHVybiBbbGFtYmRhICogZmFoZXlLICogc3FydCgxIC0gdCAqIHQpLCAoMSArIGZhaGV5SykgKiB0XTtcbiAgICB9XG4gICAgZmFoZXlSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHQgPSB5IC8gKDEgKyBmYWhleUspO1xuICAgICAgICByZXR1cm4gW3ggJiYgeCAvIChmYWhleUsgKiBzcXJ0KDEgLSB0ICogdCkpLCAyICogYXRhbih0KV07XG4gICAgfTtcbiAgICB2YXIgZmFoZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGZhaGV5UmF3KVxuICAgICAgICAgICAgLnNjYWxlKDEzNy4xNTIpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZm91Y2F1dFJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgayA9IHBoaSAvIDIsIGNvc2sgPSBjb3Moayk7XG4gICAgICAgIHJldHVybiBbMiAqIGxhbWJkYSAvIHNxcnRQaSAqIGNvcyhwaGkpICogY29zayAqIGNvc2ssIHNxcnRQaSAqIHRhbihrKV07XG4gICAgfVxuICAgIGZvdWNhdXRSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGsgPSBhdGFuKHkgLyBzcXJ0UGkpLCBjb3NrID0gY29zKGspLCBwaGkgPSAyICogaztcbiAgICAgICAgcmV0dXJuIFt4ICogc3FydFBpIC8gMiAvIChjb3MocGhpKSAqIGNvc2sgKiBjb3NrKSwgcGhpXTtcbiAgICB9O1xuICAgIHZhciBmb3VjYXV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihmb3VjYXV0UmF3KVxuICAgICAgICAgICAgLnNjYWxlKDEzNS4yNjQpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ2lsYmVydEZvcndhcmQocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIFtwb2ludFswXSAvIDIsIGFzaW4odGFuKHBvaW50WzFdIC8gMiAqIHJhZGlhbnMpKSAqIGRlZ3JlZXNdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnaWxiZXJ0SW52ZXJ0KHBvaW50KSB7XG4gICAgICAgIHJldHVybiBbcG9pbnRbMF0gKiAyLCAyICogYXRhbihzaW4ocG9pbnRbMV0gKiByYWRpYW5zKSkgKiBkZWdyZWVzXTtcbiAgICB9XG4gICAgdmFyIGdpbGJlcnQgPSBmdW5jdGlvbiAocHJvamVjdGlvblR5cGUpIHtcbiAgICAgICAgaWYgKHByb2plY3Rpb25UeXBlID09IG51bGwpXG4gICAgICAgICAgICBwcm9qZWN0aW9uVHlwZSA9IGQzR2VvLmdlb09ydGhvZ3JhcGhpYztcbiAgICAgICAgdmFyIHByb2plY3Rpb24gPSBwcm9qZWN0aW9uVHlwZSgpLCBlcXVpcmVjdGFuZ3VsYXIgPSBkM0dlby5nZW9FcXVpcmVjdGFuZ3VsYXIoKS5zY2FsZShkZWdyZWVzKS5wcmVjaXNpb24oMCkuY2xpcEFuZ2xlKG51bGwpLnRyYW5zbGF0ZShbMCwgMF0pOyAvLyBhbnRpbWVyaWRpYW4gY3V0dGluZ1xuICAgICAgICBmdW5jdGlvbiBnaWxiZXJ0KHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdGlvbihnaWxiZXJ0Rm9yd2FyZChwb2ludCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9qZWN0aW9uLmludmVydClcbiAgICAgICAgICAgIGdpbGJlcnQuaW52ZXJ0ID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdpbGJlcnRJbnZlcnQocHJvamVjdGlvbi5pbnZlcnQocG9pbnQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGdpbGJlcnQuc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIHMxID0gcHJvamVjdGlvbi5zdHJlYW0oc3RyZWFtKSwgczAgPSBlcXVpcmVjdGFuZ3VsYXIuc3RyZWFtKHtcbiAgICAgICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKGxhbWJkYSwgcGhpKSB7IHMxLnBvaW50KGxhbWJkYSAvIDIsIGFzaW4odGFuKC1waGkgLyAyICogcmFkaWFucykpICogZGVncmVlcyk7IH0sXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHMxLmxpbmVTdGFydCgpOyB9LFxuICAgICAgICAgICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgczEubGluZUVuZCgpOyB9LFxuICAgICAgICAgICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyBzMS5wb2x5Z29uU3RhcnQoKTsgfSxcbiAgICAgICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHMxLnBvbHlnb25FbmQoKTsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzMC5zcGhlcmUgPSBzMS5zcGhlcmU7XG4gICAgICAgICAgICByZXR1cm4gczA7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHByb3BlcnR5KG5hbWUpIHtcbiAgICAgICAgICAgIGdpbGJlcnRbbmFtZV0gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByb2plY3Rpb25bbmFtZV0oXyksIGdpbGJlcnQpIDogcHJvamVjdGlvbltuYW1lXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBnaWxiZXJ0LnJvdGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlcXVpcmVjdGFuZ3VsYXIucm90YXRlKF8pLCBnaWxiZXJ0KSA6IGVxdWlyZWN0YW5ndWxhci5yb3RhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgZ2lsYmVydC5jZW50ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJvamVjdGlvbi5jZW50ZXIoZ2lsYmVydEZvcndhcmQoXykpLCBnaWxiZXJ0KSA6IGdpbGJlcnRJbnZlcnQocHJvamVjdGlvbi5jZW50ZXIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIHByb3BlcnR5KFwiY2xpcEFuZ2xlXCIpO1xuICAgICAgICBwcm9wZXJ0eShcImNsaXBFeHRlbnRcIik7XG4gICAgICAgIHByb3BlcnR5KFwic2NhbGVcIik7XG4gICAgICAgIHByb3BlcnR5KFwidHJhbnNsYXRlXCIpO1xuICAgICAgICBwcm9wZXJ0eShcInByZWNpc2lvblwiKTtcbiAgICAgICAgcmV0dXJuIGdpbGJlcnRcbiAgICAgICAgICAgIC5zY2FsZSgyNDkuNSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBnaW5nZXJ5UmF3KHJobywgbikge1xuICAgICAgICB2YXIgayA9IDIgKiBwaSAvIG4sIHJobzIgPSByaG8gKiByaG87XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciBwID0gZDNHZW8uZ2VvQXppbXV0aGFsRXF1aWRpc3RhbnRSYXcobGFtYmRhLCBwaGkpLCB4ID0gcFswXSwgeSA9IHBbMV0sIHIyID0geCAqIHggKyB5ICogeTtcbiAgICAgICAgICAgIGlmIChyMiA+IHJobzIpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHNxcnQocjIpLCB0aGV0YSA9IGF0YW4yKHksIHgpLCB0aGV0YTAgPSBrICogcm91bmQodGhldGEgLyBrKSwgYWxwaGEgPSB0aGV0YSAtIHRoZXRhMCwgcmhvQ29zQWxwaGEgPSByaG8gKiBjb3MoYWxwaGEpLCBrXyA9IChyaG8gKiBzaW4oYWxwaGEpIC0gYWxwaGEgKiBzaW4ocmhvQ29zQWxwaGEpKSAvIChoYWxmUGkgLSByaG9Db3NBbHBoYSksIHNfID0gZ2luZ2VyeUxlbmd0aChhbHBoYSwga18pLCBlID0gKHBpIC0gcmhvKSAvIGdpbmdlcnlJbnRlZ3JhdGUoc18sIHJob0Nvc0FscGhhLCBwaSk7XG4gICAgICAgICAgICAgICAgeCA9IHI7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSA1MCwgZGVsdGE7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICB4IC09IGRlbHRhID0gKHJobyArIGdpbmdlcnlJbnRlZ3JhdGUoc18sIHJob0Nvc0FscGhhLCB4KSAqIGUgLSByKSAvIChzXyh4KSAqIGUpO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uICYmIC0taSA+IDApO1xuICAgICAgICAgICAgICAgIHkgPSBhbHBoYSAqIHNpbih4KTtcbiAgICAgICAgICAgICAgICBpZiAoeCA8IGhhbGZQaSlcbiAgICAgICAgICAgICAgICAgICAgeSAtPSBrXyAqICh4IC0gaGFsZlBpKTtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHNpbih0aGV0YTApLCBjID0gY29zKHRoZXRhMCk7XG4gICAgICAgICAgICAgICAgcFswXSA9IHggKiBjIC0geSAqIHM7XG4gICAgICAgICAgICAgICAgcFsxXSA9IHggKiBzICsgeSAqIGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgcjIgPSB4ICogeCArIHkgKiB5O1xuICAgICAgICAgICAgaWYgKHIyID4gcmhvMikge1xuICAgICAgICAgICAgICAgIHZhciByID0gc3FydChyMiksIHRoZXRhID0gYXRhbjIoeSwgeCksIHRoZXRhMCA9IGsgKiByb3VuZCh0aGV0YSAvIGspLCBkVGhldGEgPSB0aGV0YSAtIHRoZXRhMDtcbiAgICAgICAgICAgICAgICB4ID0gciAqIGNvcyhkVGhldGEpO1xuICAgICAgICAgICAgICAgIHkgPSByICogc2luKGRUaGV0YSk7XG4gICAgICAgICAgICAgICAgdmFyIHhfaGFsZlBpID0geCAtIGhhbGZQaSwgc2lueCA9IHNpbih4KSwgYWxwaGEgPSB5IC8gc2lueCwgZGVsdGEgPSB4IDwgaGFsZlBpID8gSW5maW5pdHkgOiAwLCBpID0gMTA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJob3NpbkFscGhhID0gcmhvICogc2luKGFscGhhKSwgcmhvQ29zQWxwaGEgPSByaG8gKiBjb3MoYWxwaGEpLCBzaW5SaG9Db3NBbHBoYSA9IHNpbihyaG9Db3NBbHBoYSksIGhhbGZQaV9SaG9Db3NBbHBoYSA9IGhhbGZQaSAtIHJob0Nvc0FscGhhLCBrXyA9IChyaG9zaW5BbHBoYSAtIGFscGhhICogc2luUmhvQ29zQWxwaGEpIC8gaGFsZlBpX1Job0Nvc0FscGhhLCBzXyA9IGdpbmdlcnlMZW5ndGgoYWxwaGEsIGtfKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFicyhkZWx0YSkgPCBlcHNpbG9uMiB8fCAhLS1pKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhIC09IGRlbHRhID0gKGFscGhhICogc2lueCAtIGtfICogeF9oYWxmUGkgLSB5KSAvIChzaW54IC0geF9oYWxmUGkgKiAyICogKGhhbGZQaV9SaG9Db3NBbHBoYSAqIChyaG9Db3NBbHBoYSArIGFscGhhICogcmhvc2luQWxwaGEgKiBjb3MocmhvQ29zQWxwaGEpIC0gc2luUmhvQ29zQWxwaGEpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJob3NpbkFscGhhICogKHJob3NpbkFscGhhIC0gYWxwaGEgKiBzaW5SaG9Db3NBbHBoYSkpIC8gKGhhbGZQaV9SaG9Db3NBbHBoYSAqIGhhbGZQaV9SaG9Db3NBbHBoYSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByID0gcmhvICsgZ2luZ2VyeUludGVncmF0ZShzXywgcmhvQ29zQWxwaGEsIHgpICogKHBpIC0gcmhvKSAvIGdpbmdlcnlJbnRlZ3JhdGUoc18sIHJob0Nvc0FscGhhLCBwaSk7XG4gICAgICAgICAgICAgICAgdGhldGEgPSB0aGV0YTAgKyBhbHBoYTtcbiAgICAgICAgICAgICAgICB4ID0gciAqIGNvcyh0aGV0YSk7XG4gICAgICAgICAgICAgICAgeSA9IHIgKiBzaW4odGhldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGQzR2VvLmdlb0F6aW11dGhhbEVxdWlkaXN0YW50UmF3LmludmVydCh4LCB5KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdpbmdlcnlMZW5ndGgoYWxwaGEsIGspIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICB2YXIgeV8gPSBhbHBoYSAqIGNvcyh4KTtcbiAgICAgICAgICAgIGlmICh4IDwgaGFsZlBpKVxuICAgICAgICAgICAgICAgIHlfIC09IGs7XG4gICAgICAgICAgICByZXR1cm4gc3FydCgxICsgeV8gKiB5Xyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE51bWVyaWNhbCBpbnRlZ3JhdGlvbjogdHJhcGV6b2lkYWwgcnVsZS5cbiAgICBmdW5jdGlvbiBnaW5nZXJ5SW50ZWdyYXRlKGYsIGEsIGIpIHtcbiAgICAgICAgdmFyIG4gPSA1MCwgaCA9IChiIC0gYSkgLyBuLCBzID0gZihhKSArIGYoYik7XG4gICAgICAgIGZvciAodmFyIGkgPSAxLCB4ID0gYTsgaSA8IG47ICsraSlcbiAgICAgICAgICAgIHMgKz0gMiAqIGYoeCArPSBoKTtcbiAgICAgICAgcmV0dXJuIHMgKiAwLjUgKiBoO1xuICAgIH1cbiAgICB2YXIgZ2luZ2VyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG4gPSA2LCByaG8gPSAzMCAqIHJhZGlhbnMsIGNSaG8gPSBjb3MocmhvKSwgc1JobyA9IHNpbihyaG8pLCBtID0gZDNHZW8uZ2VvUHJvamVjdGlvbk11dGF0b3IoZ2luZ2VyeVJhdyksIHAgPSBtKHJobywgbiksIHN0cmVhbV8gPSBwLnN0cmVhbSwgZXBzaWxvbiQkMSA9IDFlLTIsIGNyID0gLWNvcyhlcHNpbG9uJCQxICogcmFkaWFucyksIHNyID0gc2luKGVwc2lsb24kJDEgKiByYWRpYW5zKTtcbiAgICAgICAgcC5yYWRpdXMgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiByaG8gKiBkZWdyZWVzO1xuICAgICAgICAgICAgY1JobyA9IGNvcyhyaG8gPSBfICogcmFkaWFucyk7XG4gICAgICAgICAgICBzUmhvID0gc2luKHJobyk7XG4gICAgICAgICAgICByZXR1cm4gbShyaG8sIG4pO1xuICAgICAgICB9O1xuICAgICAgICBwLmxvYmVzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgIHJldHVybiBtKHJobywgbiA9ICtfKTtcbiAgICAgICAgfTtcbiAgICAgICAgcC5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgcm90YXRlID0gcC5yb3RhdGUoKSwgcm90YXRlU3RyZWFtID0gc3RyZWFtXyhzdHJlYW0pLCBzcGhlcmVTdHJlYW0gPSAocC5yb3RhdGUoWzAsIDBdKSwgc3RyZWFtXyhzdHJlYW0pKTtcbiAgICAgICAgICAgIHAucm90YXRlKHJvdGF0ZSk7XG4gICAgICAgICAgICByb3RhdGVTdHJlYW0uc3BoZXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNwaGVyZVN0cmVhbS5wb2x5Z29uU3RhcnQoKSwgc3BoZXJlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBkZWx0YSA9IDIgKiBwaSAvIG4sIHBoaSA9IDA7IGkgPCBuOyArK2ksIHBoaSAtPSBkZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ucG9pbnQoYXRhbjIoc3IgKiBjb3MocGhpKSwgY3IpICogZGVncmVlcywgYXNpbihzciAqIHNpbihwaGkpKSAqIGRlZ3JlZXMpO1xuICAgICAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ucG9pbnQoYXRhbjIoc1JobyAqIGNvcyhwaGkgLSBkZWx0YSAvIDIpLCBjUmhvKSAqIGRlZ3JlZXMsIGFzaW4oc1JobyAqIHNpbihwaGkgLSBkZWx0YSAvIDIpKSAqIGRlZ3JlZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ubGluZUVuZCgpLCBzcGhlcmVTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByb3RhdGVTdHJlYW07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwXG4gICAgICAgICAgICAucm90YXRlKFs5MCwgLTQwXSlcbiAgICAgICAgICAgIC5zY2FsZSg5MS43MDk1KVxuICAgICAgICAgICAgLmNsaXBBbmdsZSgxODAgLSAxZS0zKTtcbiAgICB9O1xuICAgIHZhciBnaW56YnVyZ1BvbHljb25pY1JhdyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgOClcbiAgICAgICAgICAgIGggPSAwO1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICBpZiAoIXBoaSlcbiAgICAgICAgICAgICAgICByZXR1cm4gW2EgKiBsYW1iZGEgLyBwaSwgMF07XG4gICAgICAgICAgICB2YXIgcGhpMiA9IHBoaSAqIHBoaSwgeEIgPSBhICsgcGhpMiAqIChiICsgcGhpMiAqIChjICsgcGhpMiAqIGQpKSwgeUIgPSBwaGkgKiAoZSAtIDEgKyBwaGkyICogKGYgLSBoICsgcGhpMiAqIGcpKSwgbSA9ICh4QiAqIHhCICsgeUIgKiB5QikgLyAoMiAqIHlCKSwgYWxwaGEgPSBsYW1iZGEgKiBhc2luKHhCIC8gbSkgLyBwaTtcbiAgICAgICAgICAgIHJldHVybiBbbSAqIHNpbihhbHBoYSksIHBoaSAqICgxICsgcGhpMiAqIGgpICsgbSAqICgxIC0gY29zKGFscGhhKSldO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBsYW1iZGEgPSBwaSAqIHggLyBhLCBwaGkgPSB5LCBkZWx0YUxhbWJkYSwgZGVsdGFQaGksIGkgPSA1MDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgcGhpMiA9IHBoaSAqIHBoaSwgeEIgPSBhICsgcGhpMiAqIChiICsgcGhpMiAqIChjICsgcGhpMiAqIGQpKSwgeUIgPSBwaGkgKiAoZSAtIDEgKyBwaGkyICogKGYgLSBoICsgcGhpMiAqIGcpKSwgcCA9IHhCICogeEIgKyB5QiAqIHlCLCBxID0gMiAqIHlCLCBtID0gcCAvIHEsIG0yID0gbSAqIG0sIGRBbHBoYWRMYW1iZGEgPSBhc2luKHhCIC8gbSkgLyBwaSwgYWxwaGEgPSBsYW1iZGEgKiBkQWxwaGFkTGFtYmRhLCB4QjIgPSB4QiAqIHhCLCBkeEJkUGhpID0gKDIgKiBiICsgcGhpMiAqICg0ICogYyArIHBoaTIgKiA2ICogZCkpICogcGhpLCBkeUJkUGhpID0gZSArIHBoaTIgKiAoMyAqIGYgKyBwaGkyICogNSAqIGcpLCBkcGRQaGkgPSAyICogKHhCICogZHhCZFBoaSArIHlCICogKGR5QmRQaGkgLSAxKSksIGRxZFBoaSA9IDIgKiAoZHlCZFBoaSAtIDEpLCBkbWRQaGkgPSAoZHBkUGhpICogcSAtIHAgKiBkcWRQaGkpIC8gKHEgKiBxKSwgY29zQWxwaGEgPSBjb3MoYWxwaGEpLCBzaW5BbHBoYSA9IHNpbihhbHBoYSksIG1jb3NBbHBoYSA9IG0gKiBjb3NBbHBoYSwgbXNpbkFscGhhID0gbSAqIHNpbkFscGhhLCBkQWxwaGFkUGhpID0gKChsYW1iZGEgLyBwaSkgKiAoMSAvIHNxcnQoMSAtIHhCMiAvIG0yKSkgKiAoZHhCZFBoaSAqIG0gLSB4QiAqIGRtZFBoaSkpIC8gbTIsIGZ4ID0gbXNpbkFscGhhIC0geCwgZnkgPSBwaGkgKiAoMSArIHBoaTIgKiBoKSArIG0gLSBtY29zQWxwaGEgLSB5LCBkZWx0YXhEZWx0YVBoaSA9IGRtZFBoaSAqIHNpbkFscGhhICsgbWNvc0FscGhhICogZEFscGhhZFBoaSwgZGVsdGF4RGVsdGFMYW1iZGEgPSBtY29zQWxwaGEgKiBkQWxwaGFkTGFtYmRhLCBkZWx0YXlEZWx0YVBoaSA9IDEgKyBkbWRQaGkgLSAoZG1kUGhpICogY29zQWxwaGEgLSBtc2luQWxwaGEgKiBkQWxwaGFkUGhpKSwgZGVsdGF5RGVsdGFMYW1iZGEgPSBtc2luQWxwaGEgKiBkQWxwaGFkTGFtYmRhLCBkZW5vbWluYXRvciA9IGRlbHRheERlbHRhUGhpICogZGVsdGF5RGVsdGFMYW1iZGEgLSBkZWx0YXlEZWx0YVBoaSAqIGRlbHRheERlbHRhTGFtYmRhO1xuICAgICAgICAgICAgICAgIGlmICghZGVub21pbmF0b3IpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxhbWJkYSAtPSBkZWx0YUxhbWJkYSA9IChmeSAqIGRlbHRheERlbHRhUGhpIC0gZnggKiBkZWx0YXlEZWx0YVBoaSkgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgICAgICBwaGkgLT0gZGVsdGFQaGkgPSAoZnggKiBkZWx0YXlEZWx0YUxhbWJkYSAtIGZ5ICogZGVsdGF4RGVsdGFMYW1iZGEpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICB9IHdoaWxlICgoYWJzKGRlbHRhTGFtYmRhKSA+IGVwc2lsb24gfHwgYWJzKGRlbHRhUGhpKSA+IGVwc2lsb24pICYmIC0taSA+IDApO1xuICAgICAgICAgICAgcmV0dXJuIFtsYW1iZGEsIHBoaV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH07XG4gICAgdmFyIGdpbnpidXJnNFJhdyA9IGdpbnpidXJnUG9seWNvbmljUmF3KDIuODI4NCwgLTEuNjk4OCwgMC43NTQzMiwgLTAuMTgwNzEsIDEuNzYwMDMsIC0wLjM4OTE0LCAwLjA0MjU1NSk7XG4gICAgdmFyIGdpbnpidXJnNCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oZ2luemJ1cmc0UmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE0OS45OTUpO1xuICAgIH07XG4gICAgdmFyIGdpbnpidXJnNVJhdyA9IGdpbnpidXJnUG9seWNvbmljUmF3KDIuNTgzODE5LCAtMC44MzU4MjcsIDAuMTcwMzU0LCAtMC4wMzgwOTQsIDEuNTQzMzEzLCAtMC40MTE0MzUsIDAuMDgyNzQyKTtcbiAgICB2YXIgZ2luemJ1cmc1ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihnaW56YnVyZzVSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTUzLjkzKTtcbiAgICB9O1xuICAgIHZhciBnaW56YnVyZzZSYXcgPSBnaW56YnVyZ1BvbHljb25pY1Jhdyg1IC8gNiAqIHBpLCAtMC42MjYzNiwgLTAuMDM0NCwgMCwgMS4zNDkzLCAtMC4wNTUyNCwgMCwgMC4wNDUpO1xuICAgIHZhciBnaW56YnVyZzYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGdpbnpidXJnNlJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxMzAuOTQ1KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdpbnpidXJnOFJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgbGFtYmRhMiA9IGxhbWJkYSAqIGxhbWJkYSwgcGhpMiA9IHBoaSAqIHBoaTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxhbWJkYSAqICgxIC0gMC4xNjIzODggKiBwaGkyKSAqICgwLjg3IC0gMC4wMDA5NTI0MjYgKiBsYW1iZGEyICogbGFtYmRhMiksXG4gICAgICAgICAgICBwaGkgKiAoMSArIHBoaTIgLyAxMilcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZ2luemJ1cmc4UmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBsYW1iZGEgPSB4LCBwaGkgPSB5LCBpID0gNTAsIGRlbHRhO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgcGhpMiA9IHBoaSAqIHBoaTtcbiAgICAgICAgICAgIHBoaSAtPSBkZWx0YSA9IChwaGkgKiAoMSArIHBoaTIgLyAxMikgLSB5KSAvICgxICsgcGhpMiAvIDQpO1xuICAgICAgICB9IHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbiAmJiAtLWkgPiAwKTtcbiAgICAgICAgaSA9IDUwO1xuICAgICAgICB4IC89IDEgLSAwLjE2MjM4OCAqIHBoaTI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBsYW1iZGE0ID0gKGxhbWJkYTQgPSBsYW1iZGEgKiBsYW1iZGEpICogbGFtYmRhNDtcbiAgICAgICAgICAgIGxhbWJkYSAtPSBkZWx0YSA9IChsYW1iZGEgKiAoMC44NyAtIDAuMDAwOTUyNDI2ICogbGFtYmRhNCkgLSB4KSAvICgwLjg3IC0gMC4wMDQ3NjIxMyAqIGxhbWJkYTQpO1xuICAgICAgICB9IHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbiAmJiAtLWkgPiAwKTtcbiAgICAgICAgcmV0dXJuIFtsYW1iZGEsIHBoaV07XG4gICAgfTtcbiAgICB2YXIgZ2luemJ1cmc4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihnaW56YnVyZzhSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTMxLjc0Nyk7XG4gICAgfTtcbiAgICB2YXIgZ2luemJ1cmc5UmF3ID0gZ2luemJ1cmdQb2x5Y29uaWNSYXcoMi42NTE2LCAtMC43NjUzNCwgMC4xOTEyMywgLTAuMDQ3MDk0LCAxLjM2Mjg5LCAtMC4xMzk2NSwgMC4wMzE3NjIpO1xuICAgIHZhciBnaW56YnVyZzkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGdpbnpidXJnOVJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxMzEuMDg3KTtcbiAgICB9O1xuICAgIHZhciBzcXVhcmVSYXcgPSBmdW5jdGlvbiAocHJvamVjdCkge1xuICAgICAgICB2YXIgZHggPSBwcm9qZWN0KGhhbGZQaSwgMClbMF0gLSBwcm9qZWN0KC1oYWxmUGksIDApWzBdO1xuICAgICAgICBmdW5jdGlvbiBwcm9qZWN0U3F1YXJlKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgcyA9IGxhbWJkYSA+IDAgPyAtMC41IDogMC41LCBwb2ludCA9IHByb2plY3QobGFtYmRhICsgcyAqIHBpLCBwaGkpO1xuICAgICAgICAgICAgcG9pbnRbMF0gLT0gcyAqIGR4O1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9qZWN0LmludmVydClcbiAgICAgICAgICAgIHByb2plY3RTcXVhcmUuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHggPiAwID8gLTAuNSA6IDAuNSwgbG9jYXRpb24gPSBwcm9qZWN0LmludmVydCh4ICsgcyAqIGR4LCB5KSwgbGFtYmRhID0gbG9jYXRpb25bMF0gLSBzICogcGk7XG4gICAgICAgICAgICAgICAgaWYgKGxhbWJkYSA8IC1waSlcbiAgICAgICAgICAgICAgICAgICAgbGFtYmRhICs9IDIgKiBwaTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsYW1iZGEgPiBwaSlcbiAgICAgICAgICAgICAgICAgICAgbGFtYmRhIC09IDIgKiBwaTtcbiAgICAgICAgICAgICAgICBsb2NhdGlvblswXSA9IGxhbWJkYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJvamVjdFNxdWFyZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdyaW5nb3J0ZW5SYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIHNMYW1iZGEgPSBzaWduKGxhbWJkYSksIHNQaGkgPSBzaWduKHBoaSksIGNvc1BoaSA9IGNvcyhwaGkpLCB4ID0gY29zKGxhbWJkYSkgKiBjb3NQaGksIHkgPSBzaW4obGFtYmRhKSAqIGNvc1BoaSwgeiA9IHNpbihzUGhpICogcGhpKTtcbiAgICAgICAgbGFtYmRhID0gYWJzKGF0YW4yKHksIHopKTtcbiAgICAgICAgcGhpID0gYXNpbih4KTtcbiAgICAgICAgaWYgKGFicyhsYW1iZGEgLSBoYWxmUGkpID4gZXBzaWxvbilcbiAgICAgICAgICAgIGxhbWJkYSAlPSBoYWxmUGk7XG4gICAgICAgIHZhciBwb2ludCA9IGdyaW5nb3J0ZW5IZXhhZGVjYW50KGxhbWJkYSA+IHBpIC8gNCA/IGhhbGZQaSAtIGxhbWJkYSA6IGxhbWJkYSwgcGhpKTtcbiAgICAgICAgaWYgKGxhbWJkYSA+IHBpIC8gNClcbiAgICAgICAgICAgIHogPSBwb2ludFswXSwgcG9pbnRbMF0gPSAtcG9pbnRbMV0sIHBvaW50WzFdID0gLXo7XG4gICAgICAgIHJldHVybiAocG9pbnRbMF0gKj0gc0xhbWJkYSwgcG9pbnRbMV0gKj0gLXNQaGksIHBvaW50KTtcbiAgICB9XG4gICAgZ3JpbmdvcnRlblJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoYWJzKHgpID4gMSlcbiAgICAgICAgICAgIHggPSBzaWduKHgpICogMiAtIHg7XG4gICAgICAgIGlmIChhYnMoeSkgPiAxKVxuICAgICAgICAgICAgeSA9IHNpZ24oeSkgKiAyIC0geTtcbiAgICAgICAgdmFyIHN4ID0gc2lnbih4KSwgc3kgPSBzaWduKHkpLCB4MCA9IC1zeCAqIHgsIHkwID0gLXN5ICogeSwgdCA9IHkwIC8geDAgPCAxLCBwID0gZ3JpbmdvcnRlbkhleGFkZWNhbnRJbnZlcnQodCA/IHkwIDogeDAsIHQgPyB4MCA6IHkwKSwgbGFtYmRhID0gcFswXSwgcGhpID0gcFsxXSwgY29zUGhpID0gY29zKHBoaSk7XG4gICAgICAgIGlmICh0KVxuICAgICAgICAgICAgbGFtYmRhID0gLWhhbGZQaSAtIGxhbWJkYTtcbiAgICAgICAgcmV0dXJuIFtzeCAqIChhdGFuMihzaW4obGFtYmRhKSAqIGNvc1BoaSwgLXNpbihwaGkpKSArIHBpKSwgc3kgKiBhc2luKGNvcyhsYW1iZGEpICogY29zUGhpKV07XG4gICAgfTtcbiAgICBmdW5jdGlvbiBncmluZ29ydGVuSGV4YWRlY2FudChsYW1iZGEsIHBoaSkge1xuICAgICAgICBpZiAocGhpID09PSBoYWxmUGkpXG4gICAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICB2YXIgc2luUGhpID0gc2luKHBoaSksIHIgPSBzaW5QaGkgKiBzaW5QaGksIHIyID0gciAqIHIsIGogPSAxICsgcjIsIGsgPSAxICsgMyAqIHIyLCBxID0gMSAtIHIyLCB6ID0gYXNpbigxIC8gc3FydChqKSksIHYgPSBxICsgciAqIGogKiB6LCBwMiA9ICgxIC0gc2luUGhpKSAvIHYsIHAgPSBzcXJ0KHAyKSwgYTIgPSBwMiAqIGosIGEgPSBzcXJ0KGEyKSwgaCA9IHAgKiBxLCB4LCBpO1xuICAgICAgICBpZiAobGFtYmRhID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFswLCAtKGggKyByICogYSldO1xuICAgICAgICB2YXIgY29zUGhpID0gY29zKHBoaSksIHNlY1BoaSA9IDEgLyBjb3NQaGksIGRyZFBoaSA9IDIgKiBzaW5QaGkgKiBjb3NQaGksIGR2ZFBoaSA9ICgtMyAqIHIgKyB6ICogaykgKiBkcmRQaGksIGRwMmRQaGkgPSAoLXYgKiBjb3NQaGkgLSAoMSAtIHNpblBoaSkgKiBkdmRQaGkpIC8gKHYgKiB2KSwgZHBkUGhpID0gKDAuNSAqIGRwMmRQaGkpIC8gcCwgZGhkUGhpID0gcSAqIGRwZFBoaSAtIDIgKiByICogcCAqIGRyZFBoaSwgZHJhMmRQaGkgPSByICogaiAqIGRwMmRQaGkgKyBwMiAqIGsgKiBkcmRQaGksIG11ID0gLXNlY1BoaSAqIGRyZFBoaSwgbnUgPSAtc2VjUGhpICogZHJhMmRQaGksIHpldGEgPSAtMiAqIHNlY1BoaSAqIGRoZFBoaSwgbGFtYmRhMSA9IDQgKiBsYW1iZGEgLyBwaSwgZGVsdGE7XG4gICAgICAgIC8vIFNsb3dlciBidXQgYWNjdXJhdGUgYmlzZWN0aW9uIG1ldGhvZC5cbiAgICAgICAgaWYgKGxhbWJkYSA+IDAuMjIyICogcGkgfHwgcGhpIDwgcGkgLyA0ICYmIGxhbWJkYSA+IDAuMTc1ICogcGkpIHtcbiAgICAgICAgICAgIHggPSAoaCArIHIgKiBzcXJ0KGEyICogKDEgKyByMikgLSBoICogaCkpIC8gKDEgKyByMik7XG4gICAgICAgICAgICBpZiAobGFtYmRhID4gcGkgLyA0KVxuICAgICAgICAgICAgICAgIHJldHVybiBbeCwgeF07XG4gICAgICAgICAgICB2YXIgeDEgPSB4LCB4MCA9IDAuNSAqIHg7XG4gICAgICAgICAgICB4ID0gMC41ICogKHgwICsgeDEpLCBpID0gNTA7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgdmFyIGcgPSBzcXJ0KGEyIC0geCAqIHgpLCBmID0gKHggKiAoemV0YSArIG11ICogZykgKyBudSAqIGFzaW4oeCAvIGEpKSAtIGxhbWJkYTE7XG4gICAgICAgICAgICAgICAgaWYgKCFmKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoZiA8IDApXG4gICAgICAgICAgICAgICAgICAgIHgwID0geDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHgxID0geDtcbiAgICAgICAgICAgICAgICB4ID0gMC41ICogKHgwICsgeDEpO1xuICAgICAgICAgICAgfSB3aGlsZSAoYWJzKHgxIC0geDApID4gZXBzaWxvbiAmJiAtLWkgPiAwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZXd0b24tUmFwaHNvbi5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4ID0gZXBzaWxvbiwgaSA9IDI1O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciB4MiA9IHggKiB4LCBnMiA9IHNxcnQoYTIgLSB4MiksIHpldGFNdWcgPSB6ZXRhICsgbXUgKiBnMiwgZjIgPSB4ICogemV0YU11ZyArIG51ICogYXNpbih4IC8gYSkgLSBsYW1iZGExLCBkZiA9IHpldGFNdWcgKyAobnUgLSBtdSAqIHgyKSAvIGcyO1xuICAgICAgICAgICAgICAgIHggLT0gZGVsdGEgPSBnMiA/IGYyIC8gZGYgOiAwO1xuICAgICAgICAgICAgfSB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24gJiYgLS1pID4gMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt4LCAtaCAtIHIgKiBzcXJ0KGEyIC0geCAqIHgpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ3JpbmdvcnRlbkhleGFkZWNhbnRJbnZlcnQoeCwgeSkge1xuICAgICAgICB2YXIgeDAgPSAwLCB4MSA9IDEsIHIgPSAwLjUsIGkgPSA1MDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHZhciByMiA9IHIgKiByLCBzaW5QaGkgPSBzcXJ0KHIpLCB6ID0gYXNpbigxIC8gc3FydCgxICsgcjIpKSwgdiA9ICgxIC0gcjIpICsgciAqICgxICsgcjIpICogeiwgcDIgPSAoMSAtIHNpblBoaSkgLyB2LCBwID0gc3FydChwMiksIGEyID0gcDIgKiAoMSArIHIyKSwgaCA9IHAgKiAoMSAtIHIyKSwgZzIgPSBhMiAtIHggKiB4LCBnID0gc3FydChnMiksIHkwID0geSArIGggKyByICogZztcbiAgICAgICAgICAgIGlmIChhYnMoeDEgLSB4MCkgPCBlcHNpbG9uMiB8fCAtLWkgPT09IDAgfHwgeTAgPT09IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoeTAgPiAwKVxuICAgICAgICAgICAgICAgIHgwID0gcjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB4MSA9IHI7XG4gICAgICAgICAgICByID0gMC41ICogKHgwICsgeDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgcGhpID0gYXNpbihzaW5QaGkpLCBjb3NQaGkgPSBjb3MocGhpKSwgc2VjUGhpID0gMSAvIGNvc1BoaSwgZHJkUGhpID0gMiAqIHNpblBoaSAqIGNvc1BoaSwgZHZkUGhpID0gKC0zICogciArIHogKiAoMSArIDMgKiByMikpICogZHJkUGhpLCBkcDJkUGhpID0gKC12ICogY29zUGhpIC0gKDEgLSBzaW5QaGkpICogZHZkUGhpKSAvICh2ICogdiksIGRwZFBoaSA9IDAuNSAqIGRwMmRQaGkgLyBwLCBkaGRQaGkgPSAoMSAtIHIyKSAqIGRwZFBoaSAtIDIgKiByICogcCAqIGRyZFBoaSwgemV0YSA9IC0yICogc2VjUGhpICogZGhkUGhpLCBtdSA9IC1zZWNQaGkgKiBkcmRQaGksIG51ID0gLXNlY1BoaSAqIChyICogKDEgKyByMikgKiBkcDJkUGhpICsgcDIgKiAoMSArIDMgKiByMikgKiBkcmRQaGkpO1xuICAgICAgICByZXR1cm4gW3BpIC8gNCAqICh4ICogKHpldGEgKyBtdSAqIGcpICsgbnUgKiBhc2luKHggLyBzcXJ0KGEyKSkpLCBwaGldO1xuICAgIH1cbiAgICB2YXIgZ3JpbmdvcnRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oc3F1YXJlUmF3KGdyaW5nb3J0ZW5SYXcpKVxuICAgICAgICAgICAgLnNjYWxlKDIzOS43NSk7XG4gICAgfTtcbiAgICAvLyBSZXR1cm5zIFtzbiwgY24sIGRuXSh1ICsgaXZ8bSkuXG4gICAgZnVuY3Rpb24gZWxsaXB0aWNKaSh1LCB2LCBtKSB7XG4gICAgICAgIHZhciBhLCBiLCBjO1xuICAgICAgICBpZiAoIXUpIHtcbiAgICAgICAgICAgIGIgPSBlbGxpcHRpY0oodiwgMSAtIG0pO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBbMCwgYlswXSAvIGJbMV1dLFxuICAgICAgICAgICAgICAgIFsxIC8gYlsxXSwgMF0sXG4gICAgICAgICAgICAgICAgW2JbMl0gLyBiWzFdLCAwXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBhID0gZWxsaXB0aWNKKHUsIG0pO1xuICAgICAgICBpZiAoIXYpXG4gICAgICAgICAgICByZXR1cm4gW1thWzBdLCAwXSwgW2FbMV0sIDBdLCBbYVsyXSwgMF1dO1xuICAgICAgICBiID0gZWxsaXB0aWNKKHYsIDEgLSBtKTtcbiAgICAgICAgYyA9IGJbMV0gKiBiWzFdICsgbSAqIGFbMF0gKiBhWzBdICogYlswXSAqIGJbMF07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBbYVswXSAqIGJbMl0gLyBjLCBhWzFdICogYVsyXSAqIGJbMF0gKiBiWzFdIC8gY10sXG4gICAgICAgICAgICBbYVsxXSAqIGJbMV0gLyBjLCAtYVswXSAqIGFbMl0gKiBiWzBdICogYlsyXSAvIGNdLFxuICAgICAgICAgICAgW2FbMl0gKiBiWzFdICogYlsyXSAvIGMsIC1tICogYVswXSAqIGFbMV0gKiBiWzBdIC8gY11cbiAgICAgICAgXTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBbc24sIGNuLCBkbiwgcGhdKHV8bSkuXG4gICAgZnVuY3Rpb24gZWxsaXB0aWNKKHUsIG0pIHtcbiAgICAgICAgdmFyIGFpLCBiLCBwaGksIHQsIHR3b247XG4gICAgICAgIGlmIChtIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgdCA9IHNpbih1KTtcbiAgICAgICAgICAgIGIgPSBjb3ModSk7XG4gICAgICAgICAgICBhaSA9IG0gKiAodSAtIHQgKiBiKSAvIDQ7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHQgLSBhaSAqIGIsXG4gICAgICAgICAgICAgICAgYiArIGFpICogdCxcbiAgICAgICAgICAgICAgICAxIC0gbSAqIHQgKiB0IC8gMixcbiAgICAgICAgICAgICAgICB1IC0gYWlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0gPj0gMSAtIGVwc2lsb24pIHtcbiAgICAgICAgICAgIGFpID0gKDEgLSBtKSAvIDQ7XG4gICAgICAgICAgICBiID0gY29zaCh1KTtcbiAgICAgICAgICAgIHQgPSB0YW5oKHUpO1xuICAgICAgICAgICAgcGhpID0gMSAvIGI7XG4gICAgICAgICAgICB0d29uID0gYiAqIHNpbmgodSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHQgKyBhaSAqICh0d29uIC0gdSkgLyAoYiAqIGIpLFxuICAgICAgICAgICAgICAgIHBoaSAtIGFpICogdCAqIHBoaSAqICh0d29uIC0gdSksXG4gICAgICAgICAgICAgICAgcGhpICsgYWkgKiB0ICogcGhpICogKHR3b24gKyB1KSxcbiAgICAgICAgICAgICAgICAyICogYXRhbihleHAodSkpIC0gaGFsZlBpICsgYWkgKiAodHdvbiAtIHUpIC8gYlxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IFsxLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSwgYyA9IFtzcXJ0KG0pLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSwgaSA9IDA7XG4gICAgICAgIGIgPSBzcXJ0KDEgLSBtKTtcbiAgICAgICAgdHdvbiA9IDE7XG4gICAgICAgIHdoaWxlIChhYnMoY1tpXSAvIGFbaV0pID4gZXBzaWxvbiAmJiBpIDwgOCkge1xuICAgICAgICAgICAgYWkgPSBhW2krK107XG4gICAgICAgICAgICBjW2ldID0gKGFpIC0gYikgLyAyO1xuICAgICAgICAgICAgYVtpXSA9IChhaSArIGIpIC8gMjtcbiAgICAgICAgICAgIGIgPSBzcXJ0KGFpICogYik7XG4gICAgICAgICAgICB0d29uICo9IDI7XG4gICAgICAgIH1cbiAgICAgICAgcGhpID0gdHdvbiAqIGFbaV0gKiB1O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB0ID0gY1tpXSAqIHNpbihiID0gcGhpKSAvIGFbaV07XG4gICAgICAgICAgICBwaGkgPSAoYXNpbih0KSArIHBoaSkgLyAyO1xuICAgICAgICB9IHdoaWxlICgtLWkpO1xuICAgICAgICByZXR1cm4gW3NpbihwaGkpLCB0ID0gY29zKHBoaSksIHQgLyBjb3MocGhpIC0gYiksIHBoaV07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBGKHBoaStpUHNpfG0pLlxuICAgIC8vIFNlZSBBYnJhbW93aXR6IGFuZCBTdGVndW4sIDE3LjQuMTEuXG4gICAgZnVuY3Rpb24gZWxsaXB0aWNGaShwaGksIHBzaSwgbSkge1xuICAgICAgICB2YXIgciA9IGFicyhwaGkpLCBpID0gYWJzKHBzaSksIHNpbmhQc2kgPSBzaW5oKGkpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgdmFyIGNzY1BoaSA9IDEgLyBzaW4ociksIGNvdFBoaTIgPSAxIC8gKHRhbihyKSAqIHRhbihyKSksIGIgPSAtKGNvdFBoaTIgKyBtICogKHNpbmhQc2kgKiBzaW5oUHNpICogY3NjUGhpICogY3NjUGhpKSAtIDEgKyBtKSwgYyA9IChtIC0gMSkgKiBjb3RQaGkyLCBjb3RMYW1iZGEyID0gKC1iICsgc3FydChiICogYiAtIDQgKiBjKSkgLyAyO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBlbGxpcHRpY0YoYXRhbigxIC8gc3FydChjb3RMYW1iZGEyKSksIG0pICogc2lnbihwaGkpLFxuICAgICAgICAgICAgICAgIGVsbGlwdGljRihhdGFuKHNxcnQoKGNvdExhbWJkYTIgLyBjb3RQaGkyIC0gMSkgLyBtKSksIDEgLSBtKSAqIHNpZ24ocHNpKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGVsbGlwdGljRihhdGFuKHNpbmhQc2kpLCAxIC0gbSkgKiBzaWduKHBzaSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIEYocGhpfG0pIHdoZXJlIG0gPSBrwrIgPSBzaW7Css6xLlxuICAgIC8vIFNlZSBBYnJhbW93aXR6IGFuZCBTdGVndW4sIDE3LjYuNy5cbiAgICBmdW5jdGlvbiBlbGxpcHRpY0YocGhpLCBtKSB7XG4gICAgICAgIGlmICghbSlcbiAgICAgICAgICAgIHJldHVybiBwaGk7XG4gICAgICAgIGlmIChtID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIGxvZyh0YW4ocGhpIC8gMiArIHF1YXJ0ZXJQaSkpO1xuICAgICAgICB2YXIgYSA9IDEsIGIgPSBzcXJ0KDEgLSBtKSwgYyA9IHNxcnQobSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBhYnMoYykgPiBlcHNpbG9uOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwaGkgJSBwaSkge1xuICAgICAgICAgICAgICAgIHZhciBkUGhpID0gYXRhbihiICogdGFuKHBoaSkgLyBhKTtcbiAgICAgICAgICAgICAgICBpZiAoZFBoaSA8IDApXG4gICAgICAgICAgICAgICAgICAgIGRQaGkgKz0gcGk7XG4gICAgICAgICAgICAgICAgcGhpICs9IGRQaGkgKyB+fihwaGkgLyBwaSkgKiBwaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwaGkgKz0gcGhpO1xuICAgICAgICAgICAgYyA9IChhICsgYikgLyAyO1xuICAgICAgICAgICAgYiA9IHNxcnQoYSAqIGIpO1xuICAgICAgICAgICAgYyA9ICgoYSA9IGMpIC0gYikgLyAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaGkgLyAocG93KDIsIGkpICogYSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGd1eW91UmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBrXyA9IChzcXJ0MiAtIDEpIC8gKHNxcnQyICsgMSksIGsgPSBzcXJ0KDEgLSBrXyAqIGtfKSwgSyA9IGVsbGlwdGljRihoYWxmUGksIGsgKiBrKSwgZiA9IC0xLCBwc2kgPSBsb2codGFuKHBpIC8gNCArIGFicyhwaGkpIC8gMikpLCByID0gZXhwKGYgKiBwc2kpIC8gc3FydChrXyksIGF0ID0gZ3V5b3VDb21wbGV4QXRhbihyICogY29zKGYgKiBsYW1iZGEpLCByICogc2luKGYgKiBsYW1iZGEpKSwgdCA9IGVsbGlwdGljRmkoYXRbMF0sIGF0WzFdLCBrICogayk7XG4gICAgICAgIHJldHVybiBbLXRbMV0sIChwaGkgPj0gMCA/IDEgOiAtMSkgKiAoMC41ICogSyAtIHRbMF0pXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ3V5b3VDb21wbGV4QXRhbih4LCB5KSB7XG4gICAgICAgIHZhciB4MiA9IHggKiB4LCB5XzEgPSB5ICsgMSwgdCA9IDEgLSB4MiAtIHkgKiB5O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMC41ICogKCh4ID49IDAgPyBoYWxmUGkgOiAtaGFsZlBpKSAtIGF0YW4yKHQsIDIgKiB4KSksXG4gICAgICAgICAgICAtMC4yNSAqIGxvZyh0ICogdCArIDQgKiB4MikgKyAwLjUgKiBsb2coeV8xICogeV8xICsgeDIpXG4gICAgICAgIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGd1eW91Q29tcGxleERpdmlkZShhLCBiKSB7XG4gICAgICAgIHZhciBkZW5vbWluYXRvciA9IGJbMF0gKiBiWzBdICsgYlsxXSAqIGJbMV07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAoYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSkgLyBkZW5vbWluYXRvcixcbiAgICAgICAgICAgIChhWzFdICogYlswXSAtIGFbMF0gKiBiWzFdKSAvIGRlbm9taW5hdG9yXG4gICAgICAgIF07XG4gICAgfVxuICAgIGd1eW91UmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBrXyA9IChzcXJ0MiAtIDEpIC8gKHNxcnQyICsgMSksIGsgPSBzcXJ0KDEgLSBrXyAqIGtfKSwgSyA9IGVsbGlwdGljRihoYWxmUGksIGsgKiBrKSwgZiA9IC0xLCBqID0gZWxsaXB0aWNKaSgwLjUgKiBLIC0geSwgLXgsIGsgKiBrKSwgdG4gPSBndXlvdUNvbXBsZXhEaXZpZGUoalswXSwgalsxXSksIGxhbWJkYSA9IGF0YW4yKHRuWzFdLCB0blswXSkgLyBmO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbGFtYmRhLFxuICAgICAgICAgICAgMiAqIGF0YW4oZXhwKDAuNSAvIGYgKiBsb2coa18gKiB0blswXSAqIHRuWzBdICsga18gKiB0blsxXSAqIHRuWzFdKSkpIC0gaGFsZlBpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgZ3V5b3UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKHNxdWFyZVJhdyhndXlvdVJhdykpXG4gICAgICAgICAgICAuc2NhbGUoMTUxLjQ5Nik7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBoYW1tZXJSYXcoQSwgQikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpXG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgaWYgKEIgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gZDNHZW8uZ2VvQXppbXV0aGFsRXF1YWxBcmVhUmF3O1xuICAgICAgICBpZiAoQiA9PT0gSW5maW5pdHkpXG4gICAgICAgICAgICByZXR1cm4gaGFtbWVyUXVhcnRpY0F1dGhhbGljUmF3O1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBkM0dlby5nZW9BemltdXRoYWxFcXVhbEFyZWFSYXcobGFtYmRhIC8gQiwgcGhpKTtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzWzBdICo9IEE7XG4gICAgICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gZDNHZW8uZ2VvQXppbXV0aGFsRXF1YWxBcmVhUmF3LmludmVydCh4IC8gQSwgeSk7XG4gICAgICAgICAgICBjb29yZGluYXRlc1swXSAqPSBCO1xuICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFtbWVyUXVhcnRpY0F1dGhhbGljUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsYW1iZGEgKiBjb3MocGhpKSAvIGNvcyhwaGkgLz0gMiksXG4gICAgICAgICAgICAyICogc2luKHBoaSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgaGFtbWVyUXVhcnRpY0F1dGhhbGljUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBwaGkgPSAyICogYXNpbih5IC8gMik7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB4ICogY29zKHBoaSAvIDIpIC8gY29zKHBoaSksXG4gICAgICAgICAgICBwaGlcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHZhciBoYW1tZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBCID0gMiwgbSA9IGQzR2VvLmdlb1Byb2plY3Rpb25NdXRhdG9yKGhhbW1lclJhdyksIHAgPSBtKEIpO1xuICAgICAgICBwLmNvZWZmaWNpZW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gQjtcbiAgICAgICAgICAgIHJldHVybiBtKEIgPSArXyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwXG4gICAgICAgICAgICAuc2NhbGUoMTY5LjUyOSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBoYW1tZXJSZXRyb2F6aW11dGhhbFJhdyhwaGkwKSB7XG4gICAgICAgIHZhciBzaW5QaGkwID0gc2luKHBoaTApLCBjb3NQaGkwID0gY29zKHBoaTApLCByb3RhdGUgPSBoYW1tZXJSZXRyb2F6aW11dGhhbFJvdGF0aW9uKHBoaTApO1xuICAgICAgICByb3RhdGUuaW52ZXJ0ID0gaGFtbWVyUmV0cm9hemltdXRoYWxSb3RhdGlvbigtcGhpMCk7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciBwID0gcm90YXRlKGxhbWJkYSwgcGhpKTtcbiAgICAgICAgICAgIGxhbWJkYSA9IHBbMF0sIHBoaSA9IHBbMV07XG4gICAgICAgICAgICB2YXIgc2luUGhpID0gc2luKHBoaSksIGNvc1BoaSA9IGNvcyhwaGkpLCBjb3NMYW1iZGEgPSBjb3MobGFtYmRhKSwgeiA9IGFjb3Moc2luUGhpMCAqIHNpblBoaSArIGNvc1BoaTAgKiBjb3NQaGkgKiBjb3NMYW1iZGEpLCBzaW56ID0gc2luKHopLCBLID0gYWJzKHNpbnopID4gZXBzaWxvbiA/IHogLyBzaW56IDogMTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgSyAqIGNvc1BoaTAgKiBzaW4obGFtYmRhKSxcbiAgICAgICAgICAgICAgICAoYWJzKGxhbWJkYSkgPiBoYWxmUGkgPyBLIDogLUspIC8vIHJvdGF0ZSBmb3IgYmFjayBoZW1pc3BoZXJlXG4gICAgICAgICAgICAgICAgICAgICogKHNpblBoaTAgKiBjb3NQaGkgLSBjb3NQaGkwICogc2luUGhpICogY29zTGFtYmRhKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgcmhvID0gc3FydCh4ICogeCArIHkgKiB5KSwgc2lueiA9IC1zaW4ocmhvKSwgY29zeiA9IGNvcyhyaG8pLCBhID0gcmhvICogY29zeiwgYiA9IC15ICogc2lueiwgYyA9IHJobyAqIHNpblBoaTAsIGQgPSBzcXJ0KGEgKiBhICsgYiAqIGIgLSBjICogYyksIHBoaSA9IGF0YW4yKGEgKiBjICsgYiAqIGQsIGIgKiBjIC0gYSAqIGQpLCBsYW1iZGEgPSAocmhvID4gaGFsZlBpID8gLTEgOiAxKSAqIGF0YW4yKHggKiBzaW56LCByaG8gKiBjb3MocGhpKSAqIGNvc3ogKyB5ICogc2luKHBoaSkgKiBzaW56KTtcbiAgICAgICAgICAgIHJldHVybiByb3RhdGUuaW52ZXJ0KGxhbWJkYSwgcGhpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIC8vIExhdGl0dWRpbmFsIHJvdGF0aW9uIGJ5IHBoaTAuXG4gICAgLy8gVGVtcG9yYXJ5IGhhY2sgdW50aWwgRDMgc3VwcG9ydHMgYXJiaXRyYXJ5IHNtYWxsLWNpcmNsZSBjbGlwcGluZyBvcmlnaW5zLlxuICAgIGZ1bmN0aW9uIGhhbW1lclJldHJvYXppbXV0aGFsUm90YXRpb24ocGhpMCkge1xuICAgICAgICB2YXIgc2luUGhpMCA9IHNpbihwaGkwKSwgY29zUGhpMCA9IGNvcyhwaGkwKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLCB4ID0gY29zKGxhbWJkYSkgKiBjb3NQaGksIHkgPSBzaW4obGFtYmRhKSAqIGNvc1BoaSwgeiA9IHNpbihwaGkpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBhdGFuMih5LCB4ICogY29zUGhpMCAtIHogKiBzaW5QaGkwKSxcbiAgICAgICAgICAgICAgICBhc2luKHogKiBjb3NQaGkwICsgeCAqIHNpblBoaTApXG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgaGFtbWVyUmV0cm9hemltdXRoYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwaGkwID0gMCwgbSA9IGQzR2VvLmdlb1Byb2plY3Rpb25NdXRhdG9yKGhhbW1lclJldHJvYXppbXV0aGFsUmF3KSwgcCA9IG0ocGhpMCksIHJvdGF0ZV8gPSBwLnJvdGF0ZSwgc3RyZWFtXyA9IHAuc3RyZWFtLCBjaXJjbGUgPSBkM0dlby5nZW9DaXJjbGUoKTtcbiAgICAgICAgcC5wYXJhbGxlbCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBoaTAgKiBkZWdyZWVzO1xuICAgICAgICAgICAgdmFyIHIgPSBwLnJvdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG0ocGhpMCA9IF8gKiByYWRpYW5zKS5yb3RhdGUocik7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRlbXBvcmFyeSBoYWNrOyBzZWUgaGFtbWVyUmV0cm9hemltdXRoYWxSb3RhdGlvbi5cbiAgICAgICAgcC5yb3RhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiAoXyA9IHJvdGF0ZV8uY2FsbChwKSwgX1sxXSArPSBwaGkwICogZGVncmVlcywgXyk7XG4gICAgICAgICAgICByb3RhdGVfLmNhbGwocCwgW19bMF0sIF9bMV0gLSBwaGkwICogZGVncmVlc10pO1xuICAgICAgICAgICAgY2lyY2xlLmNlbnRlcihbLV9bMF0sIC1fWzFdXSk7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfTtcbiAgICAgICAgcC5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICBzdHJlYW0gPSBzdHJlYW1fKHN0cmVhbSk7XG4gICAgICAgICAgICBzdHJlYW0uc3BoZXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgZXBzaWxvbiQkMSA9IDFlLTIsIHJpbmcgPSBjaXJjbGUucmFkaXVzKDkwIC0gZXBzaWxvbiQkMSkoKS5jb29yZGluYXRlc1swXSwgbiA9IHJpbmcubGVuZ3RoIC0gMSwgaSA9IC0xLCBwO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KChwID0gcmluZ1tpXSlbMF0sIHBbMV0pO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgcmluZyA9IGNpcmNsZS5yYWRpdXMoOTAgKyBlcHNpbG9uJCQxKSgpLmNvb3JkaW5hdGVzWzBdO1xuICAgICAgICAgICAgICAgIG4gPSByaW5nLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlICgtLWkgPj0gMClcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KChwID0gcmluZ1tpXSlbMF0sIHBbMV0pO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcFxuICAgICAgICAgICAgLnNjYWxlKDc5LjQxODcpXG4gICAgICAgICAgICAucGFyYWxsZWwoNDUpXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDE4MCAtIDFlLTMpO1xuICAgIH07XG4gICAgdmFyIGhlYWxwaXhQYXJhbGxlbCA9IDQxICsgNDggLyAzNiArIDM3IC8gMzYwMDtcbiAgICB2YXIgaGVhbHBpeExhbWJlcnQgPSBjeWxpbmRyaWNhbEVxdWFsQXJlYVJhdygwKTtcbiAgICBmdW5jdGlvbiBoZWFscGl4UmF3KEgpIHtcbiAgICAgICAgdmFyIHBoaTAgPSBoZWFscGl4UGFyYWxsZWwgKiByYWRpYW5zLCBkeCA9IGNvbGxpZ25vblJhdyhwaSwgcGhpMClbMF0gLSBjb2xsaWdub25SYXcoLXBpLCBwaGkwKVswXSwgeTAgPSBoZWFscGl4TGFtYmVydCgwLCBwaGkwKVsxXSwgeTEgPSBjb2xsaWdub25SYXcoMCwgcGhpMClbMV0sIGR5MSA9IHNxcnRQaSAtIHkxLCBrID0gdGF1IC8gSCwgdyA9IDQgLyB0YXUsIGggPSB5MCArIChkeTEgKiBkeTEgKiA0KSAvIHRhdTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIHBvaW50LCBwaGkyID0gYWJzKHBoaSk7XG4gICAgICAgICAgICBpZiAocGhpMiA+IHBoaTApIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IG1pbihIIC0gMSwgbWF4KDAsIGZsb29yKChsYW1iZGEgKyBwaSkgLyBrKSkpO1xuICAgICAgICAgICAgICAgIGxhbWJkYSArPSBwaSAqIChIIC0gMSkgLyBIIC0gaSAqIGs7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBjb2xsaWdub25SYXcobGFtYmRhLCBwaGkyKTtcbiAgICAgICAgICAgICAgICBwb2ludFswXSA9IHBvaW50WzBdICogdGF1IC8gZHggLSB0YXUgKiAoSCAtIDEpIC8gKDIgKiBIKSArIGkgKiB0YXUgLyBIO1xuICAgICAgICAgICAgICAgIHBvaW50WzFdID0geTAgKyAocG9pbnRbMV0gLSB5MSkgKiA0ICogZHkxIC8gdGF1O1xuICAgICAgICAgICAgICAgIGlmIChwaGkgPCAwKVxuICAgICAgICAgICAgICAgICAgICBwb2ludFsxXSA9IC1wb2ludFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvaW50ID0gaGVhbHBpeExhbWJlcnQobGFtYmRhLCBwaGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRbMF0gKj0gdywgcG9pbnRbMV0gLz0gaDtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB4IC89IHcsIHkgKj0gaDtcbiAgICAgICAgICAgIHZhciB5MiA9IGFicyh5KTtcbiAgICAgICAgICAgIGlmICh5MiA+IHkwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSBtaW4oSCAtIDEsIG1heCgwLCBmbG9vcigoeCArIHBpKSAvIGspKSk7XG4gICAgICAgICAgICAgICAgeCA9ICh4ICsgcGkgKiAoSCAtIDEpIC8gSCAtIGkgKiBrKSAqIGR4IC8gdGF1O1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGNvbGxpZ25vblJhdy5pbnZlcnQoeCwgMC4yNSAqICh5MiAtIHkwKSAqIHRhdSAvIGR5MSArIHkxKTtcbiAgICAgICAgICAgICAgICBwb2ludFswXSAtPSBwaSAqIChIIC0gMSkgLyBIIC0gaSAqIGs7XG4gICAgICAgICAgICAgICAgaWYgKHkgPCAwKVxuICAgICAgICAgICAgICAgICAgICBwb2ludFsxXSA9IC1wb2ludFsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGVhbHBpeExhbWJlcnQuaW52ZXJ0KHgsIHkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BoZXJlKHN0ZXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICBkM0FycmF5LnJhbmdlKC0xODAsIDE4MCArIHN0ZXAgLyAyLCBzdGVwKS5tYXAoZnVuY3Rpb24gKHgsIGkpIHsgcmV0dXJuIFt4LCBpICYgMSA/IDkwIC0gMWUtNiA6IGhlYWxwaXhQYXJhbGxlbF07IH0pXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoZDNBcnJheS5yYW5nZSgxODAsIC0xODAgLSBzdGVwIC8gMiwgLXN0ZXApLm1hcChmdW5jdGlvbiAoeCwgaSkgeyByZXR1cm4gW3gsIGkgJiAxID8gLTkwICsgMWUtNiA6IC1oZWFscGl4UGFyYWxsZWxdOyB9KSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGhlYWxwaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBIID0gNCwgbSA9IGQzR2VvLmdlb1Byb2plY3Rpb25NdXRhdG9yKGhlYWxwaXhSYXcpLCBwID0gbShIKSwgc3RyZWFtXyA9IHAuc3RyZWFtO1xuICAgICAgICBwLmxvYmVzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gbShIID0gK18pIDogSDtcbiAgICAgICAgfTtcbiAgICAgICAgcC5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgcm90YXRlID0gcC5yb3RhdGUoKSwgcm90YXRlU3RyZWFtID0gc3RyZWFtXyhzdHJlYW0pLCBzcGhlcmVTdHJlYW0gPSAocC5yb3RhdGUoWzAsIDBdKSwgc3RyZWFtXyhzdHJlYW0pKTtcbiAgICAgICAgICAgIHAucm90YXRlKHJvdGF0ZSk7XG4gICAgICAgICAgICByb3RhdGVTdHJlYW0uc3BoZXJlID0gZnVuY3Rpb24gKCkgeyBkM0dlby5nZW9TdHJlYW0oc3BoZXJlKDE4MCAvIEgpLCBzcGhlcmVTdHJlYW0pOyB9O1xuICAgICAgICAgICAgcmV0dXJuIHJvdGF0ZVN0cmVhbTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBcbiAgICAgICAgICAgIC5zY2FsZSgyMzkuNzUpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaGlsbFJhdyhLKSB7XG4gICAgICAgIHZhciBMID0gMSArIEssIHNpbkJ0ID0gc2luKDEgLyBMKSwgQnQgPSBhc2luKHNpbkJ0KSwgQSA9IDIgKiBzcXJ0KHBpIC8gKEIgPSBwaSArIDQgKiBCdCAqIEwpKSwgQiwgcmhvMCA9IDAuNSAqIEEgKiAoTCArIHNxcnQoSyAqICgyICsgSykpKSwgSzIgPSBLICogSywgTDIgPSBMICogTDtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIHQgPSAxIC0gc2luKHBoaSksIHJobywgb21lZ2E7XG4gICAgICAgICAgICBpZiAodCAmJiB0IDwgMikge1xuICAgICAgICAgICAgICAgIHZhciB0aGV0YSA9IGhhbGZQaSAtIHBoaSwgaSA9IDI1LCBkZWx0YTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaW5UaGV0YSA9IHNpbih0aGV0YSksIGNvc1RoZXRhID0gY29zKHRoZXRhKSwgQnRfQnQxID0gQnQgKyBhdGFuMihzaW5UaGV0YSwgTCAtIGNvc1RoZXRhKSwgQyA9IDEgKyBMMiAtIDIgKiBMICogY29zVGhldGE7XG4gICAgICAgICAgICAgICAgICAgIHRoZXRhIC09IGRlbHRhID0gKHRoZXRhIC0gSzIgKiBCdCAtIEwgKiBzaW5UaGV0YSArIEMgKiBCdF9CdDEgLSAwLjUgKiB0ICogQikgLyAoMiAqIEwgKiBzaW5UaGV0YSAqIEJ0X0J0MSk7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24yICYmIC0taSA+IDApO1xuICAgICAgICAgICAgICAgIHJobyA9IEEgKiBzcXJ0KEMpO1xuICAgICAgICAgICAgICAgIG9tZWdhID0gbGFtYmRhICogQnRfQnQxIC8gcGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByaG8gPSBBICogKEsgKyB0KTtcbiAgICAgICAgICAgICAgICBvbWVnYSA9IGxhbWJkYSAqIEJ0IC8gcGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHJobyAqIHNpbihvbWVnYSksXG4gICAgICAgICAgICAgICAgcmhvMCAtIHJobyAqIGNvcyhvbWVnYSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHJobzIgPSB4ICogeCArICh5IC09IHJobzApICogeSwgY29zVGhldGEgPSAoMSArIEwyIC0gcmhvMiAvIChBICogQSkpIC8gKDIgKiBMKSwgdGhldGEgPSBhY29zKGNvc1RoZXRhKSwgc2luVGhldGEgPSBzaW4odGhldGEpLCBCdF9CdDEgPSBCdCArIGF0YW4yKHNpblRoZXRhLCBMIC0gY29zVGhldGEpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBhc2luKHggLyBzcXJ0KHJobzIpKSAqIHBpIC8gQnRfQnQxLFxuICAgICAgICAgICAgICAgIGFzaW4oMSAtIDIgKiAodGhldGEgLSBLMiAqIEJ0IC0gTCAqIHNpblRoZXRhICsgKDEgKyBMMiAtIDIgKiBMICogY29zVGhldGEpICogQnRfQnQxKSAvIEIpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgdmFyIGhpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBLID0gMSwgbSA9IGQzR2VvLmdlb1Byb2plY3Rpb25NdXRhdG9yKGhpbGxSYXcpLCBwID0gbShLKTtcbiAgICAgICAgcC5yYXRpbyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IG0oSyA9ICtfKSA6IEs7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwXG4gICAgICAgICAgICAuc2NhbGUoMTY3Ljc3NClcbiAgICAgICAgICAgIC5jZW50ZXIoWzAsIDE4LjY3XSk7XG4gICAgfTtcbiAgICB2YXIgc2ludU1vbGx3ZWlkZVBoaSA9IDAuNzEwOTg4OTU5NjIwNzU2NztcbiAgICB2YXIgc2ludU1vbGx3ZWlkZVkgPSAwLjA1MjgwMzUyNzQ1NDI7XG4gICAgZnVuY3Rpb24gc2ludU1vbGx3ZWlkZVJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICByZXR1cm4gcGhpID4gLXNpbnVNb2xsd2VpZGVQaGlcbiAgICAgICAgICAgID8gKGxhbWJkYSA9IG1vbGx3ZWlkZVJhdyhsYW1iZGEsIHBoaSksIGxhbWJkYVsxXSArPSBzaW51TW9sbHdlaWRlWSwgbGFtYmRhKVxuICAgICAgICAgICAgOiBzaW51c29pZGFsUmF3KGxhbWJkYSwgcGhpKTtcbiAgICB9XG4gICAgc2ludU1vbGx3ZWlkZVJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4geSA+IC1zaW51TW9sbHdlaWRlUGhpXG4gICAgICAgICAgICA/IG1vbGx3ZWlkZVJhdy5pbnZlcnQoeCwgeSAtIHNpbnVNb2xsd2VpZGVZKVxuICAgICAgICAgICAgOiBzaW51c29pZGFsUmF3LmludmVydCh4LCB5KTtcbiAgICB9O1xuICAgIHZhciBzaW51TW9sbHdlaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihzaW51TW9sbHdlaWRlUmF3KVxuICAgICAgICAgICAgLnJvdGF0ZShbLTIwLCAtNTVdKVxuICAgICAgICAgICAgLnNjYWxlKDE2NC4yNjMpXG4gICAgICAgICAgICAuY2VudGVyKFswLCAtNS40MDM2XSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBob21vbG9zaW5lUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBhYnMocGhpKSA+IHNpbnVNb2xsd2VpZGVQaGlcbiAgICAgICAgICAgID8gKGxhbWJkYSA9IG1vbGx3ZWlkZVJhdyhsYW1iZGEsIHBoaSksIGxhbWJkYVsxXSAtPSBwaGkgPiAwID8gc2ludU1vbGx3ZWlkZVkgOiAtc2ludU1vbGx3ZWlkZVksIGxhbWJkYSlcbiAgICAgICAgICAgIDogc2ludXNvaWRhbFJhdyhsYW1iZGEsIHBoaSk7XG4gICAgfVxuICAgIGhvbW9sb3NpbmVSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIGFicyh5KSA+IHNpbnVNb2xsd2VpZGVQaGlcbiAgICAgICAgICAgID8gbW9sbHdlaWRlUmF3LmludmVydCh4LCB5ICsgKHkgPiAwID8gc2ludU1vbGx3ZWlkZVkgOiAtc2ludU1vbGx3ZWlkZVkpKVxuICAgICAgICAgICAgOiBzaW51c29pZGFsUmF3LmludmVydCh4LCB5KTtcbiAgICB9O1xuICAgIHZhciBob21vbG9zaW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihob21vbG9zaW5lUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE1Mi42Myk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwb2ludEVxdWFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFicyhhWzBdIC0gYlswXSkgPCBlcHNpbG9uICYmIGFicyhhWzFdIC0gYlsxXSkgPCBlcHNpbG9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZUxpbmUoY29vcmRpbmF0ZXMsIG0pIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aCwgcDAgPSBjb29yZGluYXRlc1swXSwgcDEsIGR4LCBkeSwgcmVzYW1wbGVkID0gW107XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBwMSA9IGNvb3JkaW5hdGVzW2ldO1xuICAgICAgICAgICAgZHggPSAocDFbMF0gLSBwMFswXSkgLyBtO1xuICAgICAgICAgICAgZHkgPSAocDFbMV0gLSBwMFsxXSkgLyBtO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtOyArK2opXG4gICAgICAgICAgICAgICAgcmVzYW1wbGVkLnB1c2goW3AwWzBdICsgaiAqIGR4LCBwMFsxXSArIGogKiBkeV0pO1xuICAgICAgICAgICAgcDAgPSBwMTtcbiAgICAgICAgfVxuICAgICAgICByZXNhbXBsZWQucHVzaChwMSk7XG4gICAgICAgIHJldHVybiByZXNhbXBsZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlU3BoZXJlKGxvYmVzKSB7XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IFtdLCBsb2JlLCBsYW1iZGEwLCBwaGkwLCBwaGkxLCBsYW1iZGEyLCBwaGkyLCBpLCBuID0gbG9iZXNbMF0ubGVuZ3RoO1xuICAgICAgICAvLyBOb3J0aGVybiBIZW1pc3BoZXJlXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGxvYmUgPSBsb2Jlc1swXVtpXTtcbiAgICAgICAgICAgIGxhbWJkYTAgPSBsb2JlWzBdWzBdLCBwaGkwID0gbG9iZVswXVsxXSwgcGhpMSA9IGxvYmVbMV1bMV07XG4gICAgICAgICAgICBsYW1iZGEyID0gbG9iZVsyXVswXSwgcGhpMiA9IGxvYmVbMl1bMV07XG4gICAgICAgICAgICBjb29yZGluYXRlcy5wdXNoKGludGVycG9sYXRlTGluZShbXG4gICAgICAgICAgICAgICAgW2xhbWJkYTAgKyBlcHNpbG9uLCBwaGkwICsgZXBzaWxvbl0sXG4gICAgICAgICAgICAgICAgW2xhbWJkYTAgKyBlcHNpbG9uLCBwaGkxIC0gZXBzaWxvbl0sXG4gICAgICAgICAgICAgICAgW2xhbWJkYTIgLSBlcHNpbG9uLCBwaGkxIC0gZXBzaWxvbl0sXG4gICAgICAgICAgICAgICAgW2xhbWJkYTIgLSBlcHNpbG9uLCBwaGkyICsgZXBzaWxvbl1cbiAgICAgICAgICAgIF0sIDMwKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU291dGhlcm4gSGVtaXNwaGVyZVxuICAgICAgICBmb3IgKGkgPSBsb2Jlc1sxXS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgbG9iZSA9IGxvYmVzWzFdW2ldO1xuICAgICAgICAgICAgbGFtYmRhMCA9IGxvYmVbMF1bMF0sIHBoaTAgPSBsb2JlWzBdWzFdLCBwaGkxID0gbG9iZVsxXVsxXTtcbiAgICAgICAgICAgIGxhbWJkYTIgPSBsb2JlWzJdWzBdLCBwaGkyID0gbG9iZVsyXVsxXTtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnB1c2goaW50ZXJwb2xhdGVMaW5lKFtcbiAgICAgICAgICAgICAgICBbbGFtYmRhMiAtIGVwc2lsb24sIHBoaTIgLSBlcHNpbG9uXSxcbiAgICAgICAgICAgICAgICBbbGFtYmRhMiAtIGVwc2lsb24sIHBoaTEgKyBlcHNpbG9uXSxcbiAgICAgICAgICAgICAgICBbbGFtYmRhMCArIGVwc2lsb24sIHBoaTEgKyBlcHNpbG9uXSxcbiAgICAgICAgICAgICAgICBbbGFtYmRhMCArIGVwc2lsb24sIHBoaTAgLSBlcHNpbG9uXVxuICAgICAgICAgICAgXSwgMzApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICAgICAgICBjb29yZGluYXRlczogW2QzQXJyYXkubWVyZ2UoY29vcmRpbmF0ZXMpXVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgaW50ZXJydXB0ID0gZnVuY3Rpb24gKHByb2plY3QsIGxvYmVzKSB7XG4gICAgICAgIHZhciBzcGhlcmUgPSBpbnRlcnBvbGF0ZVNwaGVyZShsb2Jlcyk7XG4gICAgICAgIGxvYmVzID0gbG9iZXMubWFwKGZ1bmN0aW9uIChsb2JlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9iZS5tYXAoZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBbbFswXVswXSAqIHJhZGlhbnMsIGxbMF1bMV0gKiByYWRpYW5zXSxcbiAgICAgICAgICAgICAgICAgICAgW2xbMV1bMF0gKiByYWRpYW5zLCBsWzFdWzFdICogcmFkaWFuc10sXG4gICAgICAgICAgICAgICAgICAgIFtsWzJdWzBdICogcmFkaWFucywgbFsyXVsxXSAqIHJhZGlhbnNdXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGJvdW5kcyA9IGxvYmVzLm1hcChmdW5jdGlvbiAobG9iZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvYmUubWFwKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHgwID0gcHJvamVjdChsWzBdWzBdLCBsWzBdWzFdKVswXSwgeDEgPSBwcm9qZWN0KGxbMl1bMF0sIGxbMl1bMV0pWzBdLCB5MCA9IHByb2plY3QobFsxXVswXSwgbFswXVsxXSlbMV0sIHkxID0gcHJvamVjdChsWzFdWzBdLCBsWzFdWzFdKVsxXSwgdDtcbiAgICAgICAgICAgICAgICBpZiAoeTAgPiB5MSlcbiAgICAgICAgICAgICAgICAgICAgdCA9IHkwLCB5MCA9IHkxLCB5MSA9IHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgc2lnbiQkMSA9IHBoaSA8IDAgPyAtMSA6ICsxLCBsb2JlID0gbG9iZXNbKyhwaGkgPCAwKV07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxvYmUubGVuZ3RoIC0gMTsgaSA8IG4gJiYgbGFtYmRhID4gbG9iZVtpXVsyXVswXTsgKytpKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHZhciBwID0gcHJvamVjdChsYW1iZGEgLSBsb2JlW2ldWzFdWzBdLCBwaGkpO1xuICAgICAgICAgICAgcFswXSArPSBwcm9qZWN0KGxvYmVbaV1bMV1bMF0sIHNpZ24kJDEgKiBwaGkgPiBzaWduJCQxICogbG9iZVtpXVswXVsxXSA/IGxvYmVbaV1bMF1bMV0gOiBwaGkpWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXNzdW1lcyBtdXR1YWxseSBleGNsdXNpdmUgYm91bmRpbmcgYm94ZXMgZm9yIGxvYmVzLlxuICAgICAgICBpZiAocHJvamVjdC5pbnZlcnQpXG4gICAgICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kID0gYm91bmRzWysoeSA8IDApXSwgbG9iZSA9IGxvYmVzWysoeSA8IDApXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGJvdW5kLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGJvdW5kW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYlswXVswXSA8PSB4ICYmIHggPCBiWzFdWzBdICYmIGJbMF1bMV0gPD0geSAmJiB5IDwgYlsxXVsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSBwcm9qZWN0LmludmVydCh4IC0gcHJvamVjdChsb2JlW2ldWzFdWzBdLCAwKVswXSwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwWzBdICs9IGxvYmVbaV1bMV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRFcXVhbChmb3J3YXJkKHBbMF0sIHBbMV0pLCBbeCwgeV0pID8gcCA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB2YXIgcCA9IGQzR2VvLmdlb1Byb2plY3Rpb24oZm9yd2FyZCksIHN0cmVhbV8gPSBwLnN0cmVhbTtcbiAgICAgICAgcC5zdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgcm90YXRlID0gcC5yb3RhdGUoKSwgcm90YXRlU3RyZWFtID0gc3RyZWFtXyhzdHJlYW0pLCBzcGhlcmVTdHJlYW0gPSAocC5yb3RhdGUoWzAsIDBdKSwgc3RyZWFtXyhzdHJlYW0pKTtcbiAgICAgICAgICAgIHAucm90YXRlKHJvdGF0ZSk7XG4gICAgICAgICAgICByb3RhdGVTdHJlYW0uc3BoZXJlID0gZnVuY3Rpb24gKCkgeyBkM0dlby5nZW9TdHJlYW0oc3BoZXJlLCBzcGhlcmVTdHJlYW0pOyB9O1xuICAgICAgICAgICAgcmV0dXJuIHJvdGF0ZVN0cmVhbTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfTtcbiAgICB2YXIgbG9iZXMgPSBbW1xuICAgICAgICAgICAgW1stMTgwLCAwXSwgWy0xMDAsIDkwXSwgWy00MCwgMF1dLFxuICAgICAgICAgICAgW1stNDAsIDBdLCBbMzAsIDkwXSwgWzE4MCwgMF1dXG4gICAgICAgIF0sIFtcbiAgICAgICAgICAgIFtbLTE4MCwgMF0sIFstMTYwLCAtOTBdLCBbLTEwMCwgMF1dLFxuICAgICAgICAgICAgW1stMTAwLCAwXSwgWy02MCwgLTkwXSwgWy0yMCwgMF1dLFxuICAgICAgICAgICAgW1stMjAsIDBdLCBbMjAsIC05MF0sIFs4MCwgMF1dLFxuICAgICAgICAgICAgW1s4MCwgMF0sIFsxNDAsIC05MF0sIFsxODAsIDBdXVxuICAgICAgICBdXTtcbiAgICB2YXIgYm9nZ3MkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGludGVycnVwdChib2dnc1JhdywgbG9iZXMpXG4gICAgICAgICAgICAuc2NhbGUoMTYwLjg1Nyk7XG4gICAgfTtcbiAgICB2YXIgbG9iZXMkMSA9IFtbXG4gICAgICAgICAgICBbWy0xODAsIDBdLCBbLTEwMCwgOTBdLCBbLTQwLCAwXV0sXG4gICAgICAgICAgICBbWy00MCwgMF0sIFszMCwgOTBdLCBbMTgwLCAwXV1cbiAgICAgICAgXSwgW1xuICAgICAgICAgICAgW1stMTgwLCAwXSwgWy0xNjAsIC05MF0sIFstMTAwLCAwXV0sXG4gICAgICAgICAgICBbWy0xMDAsIDBdLCBbLTYwLCAtOTBdLCBbLTIwLCAwXV0sXG4gICAgICAgICAgICBbWy0yMCwgMF0sIFsyMCwgLTkwXSwgWzgwLCAwXV0sXG4gICAgICAgICAgICBbWzgwLCAwXSwgWzE0MCwgLTkwXSwgWzE4MCwgMF1dXG4gICAgICAgIF1dO1xuICAgIHZhciBob21vbG9zaW5lJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnJ1cHQoaG9tb2xvc2luZVJhdywgbG9iZXMkMSlcbiAgICAgICAgICAgIC5zY2FsZSgxNTIuNjMpO1xuICAgIH07XG4gICAgdmFyIGxvYmVzJDIgPSBbW1xuICAgICAgICAgICAgW1stMTgwLCAwXSwgWy0xMDAsIDkwXSwgWy00MCwgMF1dLFxuICAgICAgICAgICAgW1stNDAsIDBdLCBbMzAsIDkwXSwgWzE4MCwgMF1dXG4gICAgICAgIF0sIFtcbiAgICAgICAgICAgIFtbLTE4MCwgMF0sIFstMTYwLCAtOTBdLCBbLTEwMCwgMF1dLFxuICAgICAgICAgICAgW1stMTAwLCAwXSwgWy02MCwgLTkwXSwgWy0yMCwgMF1dLFxuICAgICAgICAgICAgW1stMjAsIDBdLCBbMjAsIC05MF0sIFs4MCwgMF1dLFxuICAgICAgICAgICAgW1s4MCwgMF0sIFsxNDAsIC05MF0sIFsxODAsIDBdXVxuICAgICAgICBdXTtcbiAgICB2YXIgbW9sbHdlaWRlJDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnJ1cHQobW9sbHdlaWRlUmF3LCBsb2JlcyQyKVxuICAgICAgICAgICAgLnNjYWxlKDE2OS41MjkpO1xuICAgIH07XG4gICAgdmFyIGxvYmVzJDMgPSBbW1xuICAgICAgICAgICAgW1stMTgwLCAwXSwgWy05MCwgOTBdLCBbMCwgMF1dLFxuICAgICAgICAgICAgW1swLCAwXSwgWzkwLCA5MF0sIFsxODAsIDBdXVxuICAgICAgICBdLCBbXG4gICAgICAgICAgICBbWy0xODAsIDBdLCBbLTkwLCAtOTBdLCBbMCwgMF1dLFxuICAgICAgICAgICAgW1swLCAwXSwgWzkwLCAtOTBdLCBbMTgwLCAwXV1cbiAgICAgICAgXV07XG4gICAgdmFyIG1vbGx3ZWlkZUhlbWlzcGhlcmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaW50ZXJydXB0KG1vbGx3ZWlkZVJhdywgbG9iZXMkMylcbiAgICAgICAgICAgIC5zY2FsZSgxNjkuNTI5KVxuICAgICAgICAgICAgLnJvdGF0ZShbMjAsIDBdKTtcbiAgICB9O1xuICAgIHZhciBsb2JlcyQ0ID0gW1tcbiAgICAgICAgICAgIFtbLTE4MCwgMzVdLCBbLTMwLCA5MF0sIFswLCAzNV1dLFxuICAgICAgICAgICAgW1swLCAzNV0sIFszMCwgOTBdLCBbMTgwLCAzNV1dXG4gICAgICAgIF0sIFtcbiAgICAgICAgICAgIFtbLTE4MCwgLTEwXSwgWy0xMDIsIC05MF0sIFstNjUsIC0xMF1dLFxuICAgICAgICAgICAgW1stNjUsIC0xMF0sIFs1LCAtOTBdLCBbNzcsIC0xMF1dLFxuICAgICAgICAgICAgW1s3NywgLTEwXSwgWzEwMywgLTkwXSwgWzE4MCwgLTEwXV1cbiAgICAgICAgXV07XG4gICAgdmFyIHNpbnVNb2xsd2VpZGUkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGludGVycnVwdChzaW51TW9sbHdlaWRlUmF3LCBsb2JlcyQ0KVxuICAgICAgICAgICAgLnJvdGF0ZShbLTIwLCAtNTVdKVxuICAgICAgICAgICAgLnNjYWxlKDE2NC4yNjMpXG4gICAgICAgICAgICAuY2VudGVyKFswLCAtNS40MDM2XSk7XG4gICAgfTtcbiAgICB2YXIgbG9iZXMkNSA9IFtbXG4gICAgICAgICAgICBbWy0xODAsIDBdLCBbLTExMCwgOTBdLCBbLTQwLCAwXV0sXG4gICAgICAgICAgICBbWy00MCwgMF0sIFswLCA5MF0sIFs0MCwgMF1dLFxuICAgICAgICAgICAgW1s0MCwgMF0sIFsxMTAsIDkwXSwgWzE4MCwgMF1dXG4gICAgICAgIF0sIFtcbiAgICAgICAgICAgIFtbLTE4MCwgMF0sIFstMTEwLCAtOTBdLCBbLTQwLCAwXV0sXG4gICAgICAgICAgICBbWy00MCwgMF0sIFswLCAtOTBdLCBbNDAsIDBdXSxcbiAgICAgICAgICAgIFtbNDAsIDBdLCBbMTEwLCAtOTBdLCBbMTgwLCAwXV1cbiAgICAgICAgXV07XG4gICAgdmFyIHNpbnVzb2lkYWwkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGludGVycnVwdChzaW51c29pZGFsUmF3LCBsb2JlcyQ1KVxuICAgICAgICAgICAgLnNjYWxlKDE1Mi42MylcbiAgICAgICAgICAgIC5yb3RhdGUoWy0yMCwgMF0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24ga2F2cmF5c2tpeTdSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgcmV0dXJuIFszIC8gdGF1ICogbGFtYmRhICogc3FydChwaSAqIHBpIC8gMyAtIHBoaSAqIHBoaSksIHBoaV07XG4gICAgfVxuICAgIGthdnJheXNraXk3UmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiBbdGF1IC8gMyAqIHggLyBzcXJ0KHBpICogcGkgLyAzIC0geSAqIHkpLCB5XTtcbiAgICB9O1xuICAgIHZhciBrYXZyYXlza2l5NyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24oa2F2cmF5c2tpeTdSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTU4LjgzNyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsYWdyYW5nZVJhdyhuKSB7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIGlmIChhYnMoYWJzKHBoaSkgLSBoYWxmUGkpIDwgZXBzaWxvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gWzAsIHBoaSA8IDAgPyAtMiA6IDJdO1xuICAgICAgICAgICAgdmFyIHNpblBoaSA9IHNpbihwaGkpLCB2ID0gcG93KCgxICsgc2luUGhpKSAvICgxIC0gc2luUGhpKSwgbiAvIDIpLCBjID0gMC41ICogKHYgKyAxIC8gdikgKyBjb3MobGFtYmRhICo9IG4pO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAyICogc2luKGxhbWJkYSkgLyBjLFxuICAgICAgICAgICAgICAgICh2IC0gMSAvIHYpIC8gY1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgeTAgPSBhYnMoeSk7XG4gICAgICAgICAgICBpZiAoYWJzKHkwIC0gMikgPCBlcHNpbG9uKVxuICAgICAgICAgICAgICAgIHJldHVybiB4ID8gbnVsbCA6IFswLCBzaWduKHkpICogaGFsZlBpXTtcbiAgICAgICAgICAgIGlmICh5MCA+IDIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB4IC89IDIsIHkgLz0gMjtcbiAgICAgICAgICAgIHZhciB4MiA9IHggKiB4LCB5MiA9IHkgKiB5LCB0ID0gMiAqIHkgLyAoMSArIHgyICsgeTIpOyAvLyB0YW5oKG5QaGkpXG4gICAgICAgICAgICB0ID0gcG93KCgxICsgdCkgLyAoMSAtIHQpLCAxIC8gbik7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGF0YW4yKDIgKiB4LCAxIC0geDIgLSB5MikgLyBuLFxuICAgICAgICAgICAgICAgIGFzaW4oKHQgLSAxKSAvICh0ICsgMSkpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgdmFyIGxhZ3JhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbiA9IDAuNSwgbSA9IGQzR2VvLmdlb1Byb2plY3Rpb25NdXRhdG9yKGxhZ3JhbmdlUmF3KSwgcCA9IG0obik7XG4gICAgICAgIHAuc3BhY2luZyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IG0obiA9ICtfKSA6IG47XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwXG4gICAgICAgICAgICAuc2NhbGUoMTI0Ljc1KTtcbiAgICB9O1xuICAgIHZhciBwaV9zcXJ0MiA9IHBpIC8gc3FydDI7XG4gICAgZnVuY3Rpb24gbGFycml2ZWVSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxhbWJkYSAqICgxICsgc3FydChjb3MocGhpKSkpIC8gMixcbiAgICAgICAgICAgIHBoaSAvIChjb3MocGhpIC8gMikgKiBjb3MobGFtYmRhIC8gNikpXG4gICAgICAgIF07XG4gICAgfVxuICAgIGxhcnJpdmVlUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB4MCA9IGFicyh4KSwgeTAgPSBhYnMoeSksIGxhbWJkYSA9IGVwc2lsb24sIHBoaSA9IGhhbGZQaTtcbiAgICAgICAgaWYgKHkwIDwgcGlfc3FydDIpXG4gICAgICAgICAgICBwaGkgKj0geTAgLyBwaV9zcXJ0MjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbGFtYmRhICs9IDYgKiBhY29zKHBpX3NxcnQyIC8geTApO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzaW5QaGkgPSBzaW4ocGhpKSwgc3FydGNvc1BoaSA9IHNxcnQoY29zKHBoaSkpLCBzaW5QaGlfMiA9IHNpbihwaGkgLyAyKSwgY29zUGhpXzIgPSBjb3MocGhpIC8gMiksIHNpbkxhbWJkYV82ID0gc2luKGxhbWJkYSAvIDYpLCBjb3NMYW1iZGFfNiA9IGNvcyhsYW1iZGEgLyA2KSwgZjAgPSAwLjUgKiBsYW1iZGEgKiAoMSArIHNxcnRjb3NQaGkpIC0geDAsIGYxID0gcGhpIC8gKGNvc1BoaV8yICogY29zTGFtYmRhXzYpIC0geTAsIGRmMGRQaGkgPSBzcXJ0Y29zUGhpID8gLTAuMjUgKiBsYW1iZGEgKiBzaW5QaGkgLyBzcXJ0Y29zUGhpIDogMCwgZGYwZExhbWJkYSA9IDAuNSAqICgxICsgc3FydGNvc1BoaSksIGRmMWRQaGkgPSAoMSArIDAuNSAqIHBoaSAqIHNpblBoaV8yIC8gY29zUGhpXzIpIC8gKGNvc1BoaV8yICogY29zTGFtYmRhXzYpLCBkZjFkTGFtYmRhID0gKHBoaSAvIGNvc1BoaV8yKSAqIChzaW5MYW1iZGFfNiAvIDYpIC8gKGNvc0xhbWJkYV82ICogY29zTGFtYmRhXzYpLCBkZW5vbSA9IGRmMGRQaGkgKiBkZjFkTGFtYmRhIC0gZGYxZFBoaSAqIGRmMGRMYW1iZGEsIGRQaGkgPSAoZjAgKiBkZjFkTGFtYmRhIC0gZjEgKiBkZjBkTGFtYmRhKSAvIGRlbm9tLCBkTGFtYmRhID0gKGYxICogZGYwZFBoaSAtIGYwICogZGYxZFBoaSkgLyBkZW5vbTtcbiAgICAgICAgICAgIHBoaSAtPSBkUGhpO1xuICAgICAgICAgICAgbGFtYmRhIC09IGRMYW1iZGE7XG4gICAgICAgICAgICBpZiAoYWJzKGRQaGkpIDwgZXBzaWxvbiAmJiBhYnMoZExhbWJkYSkgPCBlcHNpbG9uKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeCA8IDAgPyAtbGFtYmRhIDogbGFtYmRhLCB5IDwgMCA/IC1waGkgOiBwaGldO1xuICAgIH07XG4gICAgdmFyIGxhcnJpdmVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihsYXJyaXZlZVJhdylcbiAgICAgICAgICAgIC5zY2FsZSg5Ny4yNjcyKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxhc2tvd3NraVJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgbGFtYmRhMiA9IGxhbWJkYSAqIGxhbWJkYSwgcGhpMiA9IHBoaSAqIHBoaTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxhbWJkYSAqICgwLjk3NTUzNCArIHBoaTIgKiAoLTAuMTE5MTYxICsgbGFtYmRhMiAqIC0wLjAxNDMwNTkgKyBwaGkyICogLTAuMDU0NzAwOSkpLFxuICAgICAgICAgICAgcGhpICogKDEuMDAzODQgKyBsYW1iZGEyICogKDAuMDgwMjg5NCArIHBoaTIgKiAtMC4wMjg1NSArIGxhbWJkYTIgKiAwLjAwMDE5OTAyNSkgKyBwaGkyICogKDAuMDk5ODkwOSArIHBoaTIgKiAtMC4wNDkxMDMyKSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbGFza293c2tpUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBsYW1iZGEgPSBzaWduKHgpICogcGksIHBoaSA9IHkgLyAyLCBpID0gNTA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBsYW1iZGEyID0gbGFtYmRhICogbGFtYmRhLCBwaGkyID0gcGhpICogcGhpLCBsYW1iZGFQaGkgPSBsYW1iZGEgKiBwaGksIGZ4ID0gbGFtYmRhICogKDAuOTc1NTM0ICsgcGhpMiAqICgtMC4xMTkxNjEgKyBsYW1iZGEyICogLTAuMDE0MzA1OSArIHBoaTIgKiAtMC4wNTQ3MDA5KSkgLSB4LCBmeSA9IHBoaSAqICgxLjAwMzg0ICsgbGFtYmRhMiAqICgwLjA4MDI4OTQgKyBwaGkyICogLTAuMDI4NTUgKyBsYW1iZGEyICogMC4wMDAxOTkwMjUpICsgcGhpMiAqICgwLjA5OTg5MDkgKyBwaGkyICogLTAuMDQ5MTAzMikpIC0geSwgZGVsdGF4RGVsdGFMYW1iZGEgPSAwLjk3NTUzNCAtIHBoaTIgKiAoMC4xMTkxNjEgKyAzICogbGFtYmRhMiAqIDAuMDE0MzA1OSArIHBoaTIgKiAwLjA1NDcwMDkpLCBkZWx0YXhEZWx0YVBoaSA9IC1sYW1iZGFQaGkgKiAoMiAqIDAuMTE5MTYxICsgNCAqIDAuMDU0NzAwOSAqIHBoaTIgKyAyICogMC4wMTQzMDU5ICogbGFtYmRhMiksIGRlbHRheURlbHRhTGFtYmRhID0gbGFtYmRhUGhpICogKDIgKiAwLjA4MDI4OTQgKyA0ICogMC4wMDAxOTkwMjUgKiBsYW1iZGEyICsgMiAqIC0wLjAyODU1ICogcGhpMiksIGRlbHRheURlbHRhUGhpID0gMS4wMDM4NCArIGxhbWJkYTIgKiAoMC4wODAyODk0ICsgMC4wMDAxOTkwMjUgKiBsYW1iZGEyKSArIHBoaTIgKiAoMyAqICgwLjA5OTg5MDkgLSAwLjAyODU1ICogbGFtYmRhMikgLSA1ICogMC4wNDkxMDMyICogcGhpMiksIGRlbm9taW5hdG9yID0gZGVsdGF4RGVsdGFQaGkgKiBkZWx0YXlEZWx0YUxhbWJkYSAtIGRlbHRheURlbHRhUGhpICogZGVsdGF4RGVsdGFMYW1iZGEsIGRlbHRhTGFtYmRhID0gKGZ5ICogZGVsdGF4RGVsdGFQaGkgLSBmeCAqIGRlbHRheURlbHRhUGhpKSAvIGRlbm9taW5hdG9yLCBkZWx0YVBoaSA9IChmeCAqIGRlbHRheURlbHRhTGFtYmRhIC0gZnkgKiBkZWx0YXhEZWx0YUxhbWJkYSkgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgIGxhbWJkYSAtPSBkZWx0YUxhbWJkYSwgcGhpIC09IGRlbHRhUGhpO1xuICAgICAgICB9IHdoaWxlICgoYWJzKGRlbHRhTGFtYmRhKSA+IGVwc2lsb24gfHwgYWJzKGRlbHRhUGhpKSA+IGVwc2lsb24pICYmIC0taSA+IDApO1xuICAgICAgICByZXR1cm4gaSAmJiBbbGFtYmRhLCBwaGldO1xuICAgIH07XG4gICAgdmFyIGxhc2tvd3NraSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24obGFza293c2tpUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDEzOS45OCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBsaXR0cm93UmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBzaW4obGFtYmRhKSAvIGNvcyhwaGkpLFxuICAgICAgICAgICAgdGFuKHBoaSkgKiBjb3MobGFtYmRhKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBsaXR0cm93UmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB4MiA9IHggKiB4LCB5MiA9IHkgKiB5LCB5Ml8xID0geTIgKyAxLCBjb3NQaGkgPSB4XG4gICAgICAgICAgICA/IHNxcnQxXzIgKiBzcXJ0KCh5Ml8xIC0gc3FydCh4MiAqIHgyICsgMiAqIHgyICogKHkyIC0gMSkgKyB5Ml8xICogeTJfMSkpIC8geDIgKyAxKVxuICAgICAgICAgICAgOiAxIC8gc3FydCh5Ml8xKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGFzaW4oeCAqIGNvc1BoaSksXG4gICAgICAgICAgICBzaWduKHkpICogYWNvcyhjb3NQaGkpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgbGl0dHJvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24obGl0dHJvd1JhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNDQuMDQ5KVxuICAgICAgICAgICAgLmNsaXBBbmdsZSg5MCAtIDFlLTMpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbG94aW11dGhhbFJhdyhwaGkwKSB7XG4gICAgICAgIHZhciBjb3NQaGkwID0gY29zKHBoaTApLCB0YW5QaGkwID0gdGFuKHF1YXJ0ZXJQaSArIHBoaTAgLyAyKTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIHkgPSBwaGkgLSBwaGkwLCB4ID0gYWJzKHkpIDwgZXBzaWxvbiA/IGxhbWJkYSAqIGNvc1BoaTBcbiAgICAgICAgICAgICAgICA6IGFicyh4ID0gcXVhcnRlclBpICsgcGhpIC8gMikgPCBlcHNpbG9uIHx8IGFicyhhYnMoeCkgLSBoYWxmUGkpIDwgZXBzaWxvblxuICAgICAgICAgICAgICAgICAgICA/IDAgOiBsYW1iZGEgKiB5IC8gbG9nKHRhbih4KSAvIHRhblBoaTApO1xuICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgbGFtYmRhLCBwaGkgPSB5ICsgcGhpMDtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYWJzKHkpIDwgZXBzaWxvbiA/IHggLyBjb3NQaGkwXG4gICAgICAgICAgICAgICAgICAgIDogKGFicyhsYW1iZGEgPSBxdWFydGVyUGkgKyBwaGkgLyAyKSA8IGVwc2lsb24gfHwgYWJzKGFicyhsYW1iZGEpIC0gaGFsZlBpKSA8IGVwc2lsb24pID8gMFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB4ICogbG9nKHRhbihsYW1iZGEpIC8gdGFuUGhpMCkgLyB5LFxuICAgICAgICAgICAgICAgIHBoaVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIHZhciBsb3hpbXV0aGFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcGFyYWxsZWwxKGxveGltdXRoYWxSYXcpXG4gICAgICAgICAgICAucGFyYWxsZWwoNDApXG4gICAgICAgICAgICAuc2NhbGUoMTU4LjgzNyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBtaWxsZXJSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgcmV0dXJuIFtsYW1iZGEsIDEuMjUgKiBsb2codGFuKHF1YXJ0ZXJQaSArIDAuNCAqIHBoaSkpXTtcbiAgICB9XG4gICAgbWlsbGVyUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiBbeCwgMi41ICogYXRhbihleHAoMC44ICogeSkpIC0gMC42MjUgKiBwaV07XG4gICAgfTtcbiAgICB2YXIgbWlsbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihtaWxsZXJSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTA4LjMxOCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBtb2RpZmllZFN0ZXJlb2dyYXBoaWNSYXcoQykge1xuICAgICAgICB2YXIgbSA9IEMubGVuZ3RoIC0gMTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLCBrID0gMiAvICgxICsgY29zUGhpICogY29zKGxhbWJkYSkpLCB6ciA9IGsgKiBjb3NQaGkgKiBzaW4obGFtYmRhKSwgemkgPSBrICogc2luKHBoaSksIGkgPSBtLCB3ID0gQ1tpXSwgYXIgPSB3WzBdLCBhaSA9IHdbMV0sIHQ7XG4gICAgICAgICAgICB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgICAgICAgICB3ID0gQ1tpXTtcbiAgICAgICAgICAgICAgICBhciA9IHdbMF0gKyB6ciAqICh0ID0gYXIpIC0gemkgKiBhaTtcbiAgICAgICAgICAgICAgICBhaSA9IHdbMV0gKyB6ciAqIGFpICsgemkgKiB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXIgPSB6ciAqICh0ID0gYXIpIC0gemkgKiBhaTtcbiAgICAgICAgICAgIGFpID0genIgKiBhaSArIHppICogdDtcbiAgICAgICAgICAgIHJldHVybiBbYXIsIGFpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgaSA9IDIwLCB6ciA9IHgsIHppID0geTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IG0sIHcgPSBDW2pdLCBhciA9IHdbMF0sIGFpID0gd1sxXSwgYnIgPSAwLCBiaSA9IDAsIHQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKC0taiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHcgPSBDW2pdO1xuICAgICAgICAgICAgICAgICAgICBiciA9IGFyICsgenIgKiAodCA9IGJyKSAtIHppICogYmk7XG4gICAgICAgICAgICAgICAgICAgIGJpID0gYWkgKyB6ciAqIGJpICsgemkgKiB0O1xuICAgICAgICAgICAgICAgICAgICBhciA9IHdbMF0gKyB6ciAqICh0ID0gYXIpIC0gemkgKiBhaTtcbiAgICAgICAgICAgICAgICAgICAgYWkgPSB3WzFdICsgenIgKiBhaSArIHppICogdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnIgPSBhciArIHpyICogKHQgPSBicikgLSB6aSAqIGJpO1xuICAgICAgICAgICAgICAgIGJpID0gYWkgKyB6ciAqIGJpICsgemkgKiB0O1xuICAgICAgICAgICAgICAgIGFyID0genIgKiAodCA9IGFyKSAtIHppICogYWkgLSB4O1xuICAgICAgICAgICAgICAgIGFpID0genIgKiBhaSArIHppICogdCAtIHk7XG4gICAgICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gYnIgKiBiciArIGJpICogYmksIGRlbHRhciwgZGVsdGFpO1xuICAgICAgICAgICAgICAgIHpyIC09IGRlbHRhciA9IChhciAqIGJyICsgYWkgKiBiaSkgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgICAgICB6aSAtPSBkZWx0YWkgPSAoYWkgKiBiciAtIGFyICogYmkpIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICB9IHdoaWxlIChhYnMoZGVsdGFyKSArIGFicyhkZWx0YWkpID4gZXBzaWxvbiAqIGVwc2lsb24gJiYgLS1pID4gMCk7XG4gICAgICAgICAgICBpZiAoaSkge1xuICAgICAgICAgICAgICAgIHZhciByaG8gPSBzcXJ0KHpyICogenIgKyB6aSAqIHppKSwgYyA9IDIgKiBhdGFuKHJobyAqIDAuNSksIHNpbmMgPSBzaW4oYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthdGFuMih6ciAqIHNpbmMsIHJobyAqIGNvcyhjKSksIHJobyA/IGFzaW4oemkgKiBzaW5jIC8gcmhvKSA6IDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9yd2FyZDtcbiAgICB9XG4gICAgdmFyIGFsYXNrYSA9IFtbMC45OTcyNTIzLCAwXSwgWzAuMDA1MjUxMywgLTAuMDA0MTE3NV0sIFswLjAwNzQ2MDYsIDAuMDA0ODEyNV0sIFstMC4wMTUzNzgzLCAtMC4xOTY4MjUzXSwgWzAuMDYzNjg3MSwgLTAuMTQwODAyN10sIFswLjM2NjA5NzYsIC0wLjI5MzczODJdXTtcbiAgICB2YXIgZ3M0OCA9IFtbMC45ODg3OSwgMF0sIFswLCAwXSwgWy0wLjA1MDkwOSwgMF0sIFswLCAwXSwgWzAuMDc1NTI4LCAwXV07XG4gICAgdmFyIGdzNTAgPSBbWzAuOTg0Mjk5MCwgMF0sIFswLjAyMTE2NDIsIDAuMDAzNzYwOF0sIFstMC4xMDM2MDE4LCAtMC4wNTc1MTAyXSwgWy0wLjAzMjkwOTUsIC0wLjAzMjAxMTldLCBbMC4wNDk5NDcxLCAwLjEyMjMzMzVdLCBbMC4wMjYwNDYwLCAwLjA4OTk4MDVdLCBbMC4wMDA3Mzg4LCAtMC4xNDM1NzkyXSwgWzAuMDA3NTg0OCwgLTAuMTMzNDEwOF0sIFstMC4wMjE2NDczLCAwLjA3NzY2NDVdLCBbLTAuMDIyNTE2MSwgMC4wODUzNjczXV07XG4gICAgdmFyIG1pbGxlciQxID0gW1swLjkyNDUsIDBdLCBbMCwgMF0sIFswLjAxOTQzLCAwXV07XG4gICAgdmFyIGxlZSA9IFtbMC43MjEzMTYsIDBdLCBbMCwgMF0sIFstMC4wMDg4MTYyNSwgLTAuMDA2MTczMjVdXTtcbiAgICBmdW5jdGlvbiBtb2RpZmllZFN0ZXJlb2dyYXBoaWNBbGFza2EoKSB7XG4gICAgICAgIHJldHVybiBtb2RpZmllZFN0ZXJlb2dyYXBoaWMoYWxhc2thLCBbMTUyLCAtNjRdKVxuICAgICAgICAgICAgLnNjYWxlKDE1MDApXG4gICAgICAgICAgICAuY2VudGVyKFstMTYwLjkwOCwgNjIuNDg2NF0pXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDI1KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kaWZpZWRTdGVyZW9ncmFwaGljR3M0OCgpIHtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVkU3RlcmVvZ3JhcGhpYyhnczQ4LCBbOTUsIC0zOF0pXG4gICAgICAgICAgICAuc2NhbGUoMTAwMClcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoNTUpXG4gICAgICAgICAgICAuY2VudGVyKFstOTYuNTU2MywgMzguODY3NV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb2RpZmllZFN0ZXJlb2dyYXBoaWNHczUwKCkge1xuICAgICAgICByZXR1cm4gbW9kaWZpZWRTdGVyZW9ncmFwaGljKGdzNTAsIFsxMjAsIC00NV0pXG4gICAgICAgICAgICAuc2NhbGUoMzU5LjUxMylcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoNTUpXG4gICAgICAgICAgICAuY2VudGVyKFstMTE3LjQ3NCwgNTMuMDYyOF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb2RpZmllZFN0ZXJlb2dyYXBoaWNNaWxsZXIoKSB7XG4gICAgICAgIHJldHVybiBtb2RpZmllZFN0ZXJlb2dyYXBoaWMobWlsbGVyJDEsIFstMjAsIC0xOF0pXG4gICAgICAgICAgICAuc2NhbGUoMjA5LjA5MSlcbiAgICAgICAgICAgIC5jZW50ZXIoWzIwLCAxNi43MjE0XSlcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoODIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb2RpZmllZFN0ZXJlb2dyYXBoaWNMZWUoKSB7XG4gICAgICAgIHJldHVybiBtb2RpZmllZFN0ZXJlb2dyYXBoaWMobGVlLCBbMTY1LCAxMF0pXG4gICAgICAgICAgICAuc2NhbGUoMjUwKVxuICAgICAgICAgICAgLmNsaXBBbmdsZSgxMzApXG4gICAgICAgICAgICAuY2VudGVyKFstMTY1LCAtMTBdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kaWZpZWRTdGVyZW9ncmFwaGljKGNvZWZmaWNpZW50cywgcm90YXRlKSB7XG4gICAgICAgIHZhciBwID0gZDNHZW8uZ2VvUHJvamVjdGlvbihtb2RpZmllZFN0ZXJlb2dyYXBoaWNSYXcoY29lZmZpY2llbnRzKSkucm90YXRlKHJvdGF0ZSkuY2xpcEFuZ2xlKDkwKSwgciA9IGQzR2VvLmdlb1JvdGF0aW9uKHJvdGF0ZSksIGNlbnRlciA9IHAuY2VudGVyO1xuICAgICAgICBkZWxldGUgcC5yb3RhdGU7XG4gICAgICAgIHAuY2VudGVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gY2VudGVyKHIoXykpIDogci5pbnZlcnQoY2VudGVyKCkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgdmFyIHNxcnQ2ID0gc3FydCg2KTtcbiAgICB2YXIgc3FydDcgPSBzcXJ0KDcpO1xuICAgIGZ1bmN0aW9uIG10RmxhdFBvbGFyUGFyYWJvbGljUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciB0aGV0YSA9IGFzaW4oNyAqIHNpbihwaGkpIC8gKDMgKiBzcXJ0NikpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc3FydDYgKiBsYW1iZGEgKiAoMiAqIGNvcygyICogdGhldGEgLyAzKSAtIDEpIC8gc3FydDcsXG4gICAgICAgICAgICA5ICogc2luKHRoZXRhIC8gMykgLyBzcXJ0N1xuICAgICAgICBdO1xuICAgIH1cbiAgICBtdEZsYXRQb2xhclBhcmFib2xpY1Jhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgdGhldGEgPSAzICogYXNpbih5ICogc3FydDcgLyA5KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHggKiBzcXJ0NyAvIChzcXJ0NiAqICgyICogY29zKDIgKiB0aGV0YSAvIDMpIC0gMSkpLFxuICAgICAgICAgICAgYXNpbihzaW4odGhldGEpICogMyAqIHNxcnQ2IC8gNylcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHZhciBtdEZsYXRQb2xhclBhcmFib2xpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24obXRGbGF0UG9sYXJQYXJhYm9saWNSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTY0Ljg1OSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBtdEZsYXRQb2xhclF1YXJ0aWNSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIGsgPSAoMSArIHNxcnQxXzIpICogc2luKHBoaSksIHRoZXRhID0gcGhpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgZGVsdGE7IGkgPCAyNTsgaSsrKSB7XG4gICAgICAgICAgICB0aGV0YSAtPSBkZWx0YSA9IChzaW4odGhldGEgLyAyKSArIHNpbih0aGV0YSkgLSBrKSAvICgwLjUgKiBjb3ModGhldGEgLyAyKSArIGNvcyh0aGV0YSkpO1xuICAgICAgICAgICAgaWYgKGFicyhkZWx0YSkgPCBlcHNpbG9uKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsYW1iZGEgKiAoMSArIDIgKiBjb3ModGhldGEpIC8gY29zKHRoZXRhIC8gMikpIC8gKDMgKiBzcXJ0MiksXG4gICAgICAgICAgICAyICogc3FydCgzKSAqIHNpbih0aGV0YSAvIDIpIC8gc3FydCgyICsgc3FydDIpXG4gICAgICAgIF07XG4gICAgfVxuICAgIG10RmxhdFBvbGFyUXVhcnRpY1Jhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgc2luVGhldGFfMiA9IHkgKiBzcXJ0KDIgKyBzcXJ0MikgLyAoMiAqIHNxcnQoMykpLCB0aGV0YSA9IDIgKiBhc2luKHNpblRoZXRhXzIpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMyAqIHNxcnQyICogeCAvICgxICsgMiAqIGNvcyh0aGV0YSkgLyBjb3ModGhldGEgLyAyKSksXG4gICAgICAgICAgICBhc2luKChzaW5UaGV0YV8yICsgc2luKHRoZXRhKSkgLyAoMSArIHNxcnQxXzIpKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIG10RmxhdFBvbGFyUXVhcnRpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24obXRGbGF0UG9sYXJRdWFydGljUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE4OC4yMDkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbXRGbGF0UG9sYXJTaW51c29pZGFsUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBBID0gc3FydCg2IC8gKDQgKyBwaSkpLCBrID0gKDEgKyBwaSAvIDQpICogc2luKHBoaSksIHRoZXRhID0gcGhpIC8gMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGRlbHRhOyBpIDwgMjU7IGkrKykge1xuICAgICAgICAgICAgdGhldGEgLT0gZGVsdGEgPSAodGhldGEgLyAyICsgc2luKHRoZXRhKSAtIGspIC8gKDAuNSArIGNvcyh0aGV0YSkpO1xuICAgICAgICAgICAgaWYgKGFicyhkZWx0YSkgPCBlcHNpbG9uKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBBICogKDAuNSArIGNvcyh0aGV0YSkpICogbGFtYmRhIC8gMS41LFxuICAgICAgICAgICAgQSAqIHRoZXRhXG4gICAgICAgIF07XG4gICAgfVxuICAgIG10RmxhdFBvbGFyU2ludXNvaWRhbFJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgQSA9IHNxcnQoNiAvICg0ICsgcGkpKSwgdGhldGEgPSB5IC8gQTtcbiAgICAgICAgaWYgKGFicyhhYnModGhldGEpIC0gaGFsZlBpKSA8IGVwc2lsb24pXG4gICAgICAgICAgICB0aGV0YSA9IHRoZXRhIDwgMCA/IC1oYWxmUGkgOiBoYWxmUGk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAxLjUgKiB4IC8gKEEgKiAoMC41ICsgY29zKHRoZXRhKSkpLFxuICAgICAgICAgICAgYXNpbigodGhldGEgLyAyICsgc2luKHRoZXRhKSkgLyAoMSArIHBpIC8gNCkpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgbXRGbGF0UG9sYXJTaW51c29pZGFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihtdEZsYXRQb2xhclNpbnVzb2lkYWxSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTY2LjUxOCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuYXR1cmFsRWFydGhSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIHBoaTIgPSBwaGkgKiBwaGksIHBoaTQgPSBwaGkyICogcGhpMjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxhbWJkYSAqICgwLjg3MDcgLSAwLjEzMTk3OSAqIHBoaTIgKyBwaGk0ICogKC0wLjAxMzc5MSArIHBoaTQgKiAoMC4wMDM5NzEgKiBwaGkyIC0gMC4wMDE1MjkgKiBwaGk0KSkpLFxuICAgICAgICAgICAgcGhpICogKDEuMDA3MjI2ICsgcGhpMiAqICgwLjAxNTA4NSArIHBoaTQgKiAoLTAuMDQ0NDc1ICsgMC4wMjg4NzQgKiBwaGkyIC0gMC4wMDU5MTYgKiBwaGk0KSkpXG4gICAgICAgIF07XG4gICAgfVxuICAgIG5hdHVyYWxFYXJ0aFJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgcGhpID0geSwgaSA9IDI1LCBkZWx0YTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIHBoaTIgPSBwaGkgKiBwaGksIHBoaTQgPSBwaGkyICogcGhpMjtcbiAgICAgICAgICAgIHBoaSAtPSBkZWx0YSA9IChwaGkgKiAoMS4wMDcyMjYgKyBwaGkyICogKDAuMDE1MDg1ICsgcGhpNCAqICgtMC4wNDQ0NzUgKyAwLjAyODg3NCAqIHBoaTIgLSAwLjAwNTkxNiAqIHBoaTQpKSkgLSB5KSAvXG4gICAgICAgICAgICAgICAgKDEuMDA3MjI2ICsgcGhpMiAqICgwLjAxNTA4NSAqIDMgKyBwaGk0ICogKC0wLjA0NDQ3NSAqIDcgKyAwLjAyODg3NCAqIDkgKiBwaGkyIC0gMC4wMDU5MTYgKiAxMSAqIHBoaTQpKSk7XG4gICAgICAgIH0gd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uICYmIC0taSA+IDApO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeCAvICgwLjg3MDcgKyAocGhpMiA9IHBoaSAqIHBoaSkgKiAoLTAuMTMxOTc5ICsgcGhpMiAqICgtMC4wMTM3OTEgKyBwaGkyICogcGhpMiAqIHBoaTIgKiAoMC4wMDM5NzEgLSAwLjAwMTUyOSAqIHBoaTIpKSkpLFxuICAgICAgICAgICAgcGhpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgbmF0dXJhbEVhcnRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihuYXR1cmFsRWFydGhSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTc1LjI5NSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuYXR1cmFsRWFydGgyUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBwaGkyID0gcGhpICogcGhpLCBwaGk0ID0gcGhpMiAqIHBoaTIsIHBoaTYgPSBwaGkyICogcGhpNDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxhbWJkYSAqICgwLjg0NzE5IC0gMC4xMzA2MyAqIHBoaTIgKyBwaGk2ICogcGhpNiAqICgtMC4wNDUxNSArIDAuMDU0OTQgKiBwaGkyIC0gMC4wMjMyNiAqIHBoaTQgKyAwLjAwMzMxICogcGhpNikpLFxuICAgICAgICAgICAgcGhpICogKDEuMDExODMgKyBwaGk0ICogcGhpNCAqICgtMC4wMjYyNSArIDAuMDE5MjYgKiBwaGkyIC0gMC4wMDM5NiAqIHBoaTQpKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBuYXR1cmFsRWFydGgyUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBwaGkgPSB5LCBpID0gMjUsIGRlbHRhLCBwaGkyLCBwaGk0LCBwaGk2O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBwaGkyID0gcGhpICogcGhpO1xuICAgICAgICAgICAgcGhpNCA9IHBoaTIgKiBwaGkyO1xuICAgICAgICAgICAgcGhpIC09IGRlbHRhID0gKChwaGkgKiAoMS4wMTE4MyArIHBoaTQgKiBwaGk0ICogKC0wLjAyNjI1ICsgMC4wMTkyNiAqIHBoaTIgLSAwLjAwMzk2ICogcGhpNCkpKSAtIHkpIC9cbiAgICAgICAgICAgICAgICAoMS4wMTE4MyArIHBoaTQgKiBwaGk0ICogKCg5ICogLTAuMDI2MjUpICsgKDExICogMC4wMTkyNikgKiBwaGkyICsgKDEzICogLTAuMDAzOTYpICogcGhpNCkpO1xuICAgICAgICB9IHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbjIgJiYgLS1pID4gMCk7XG4gICAgICAgIHBoaTIgPSBwaGkgKiBwaGk7XG4gICAgICAgIHBoaTQgPSBwaGkyICogcGhpMjtcbiAgICAgICAgcGhpNiA9IHBoaTIgKiBwaGk0O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeCAvICgwLjg0NzE5IC0gMC4xMzA2MyAqIHBoaTIgKyBwaGk2ICogcGhpNiAqICgtMC4wNDUxNSArIDAuMDU0OTQgKiBwaGkyIC0gMC4wMjMyNiAqIHBoaTQgKyAwLjAwMzMxICogcGhpNikpLFxuICAgICAgICAgICAgcGhpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgbmF0dXJhbEVhcnRoMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24obmF0dXJhbEVhcnRoMlJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNzUuMjk1KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5lbGxIYW1tZXJSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxhbWJkYSAqICgxICsgY29zKHBoaSkpIC8gMixcbiAgICAgICAgICAgIDIgKiAocGhpIC0gdGFuKHBoaSAvIDIpKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBuZWxsSGFtbWVyUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBwID0geSAvIDI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBkZWx0YSA9IEluZmluaXR5OyBpIDwgMTAgJiYgYWJzKGRlbHRhKSA+IGVwc2lsb247ICsraSkge1xuICAgICAgICAgICAgdmFyIGMgPSBjb3MoeSAvIDIpO1xuICAgICAgICAgICAgeSAtPSBkZWx0YSA9ICh5IC0gdGFuKHkgLyAyKSAtIHApIC8gKDEgLSAwLjUgLyAoYyAqIGMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgMiAqIHggLyAoMSArIGNvcyh5KSksXG4gICAgICAgICAgICB5XG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgbmVsbEhhbW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24obmVsbEhhbW1lclJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNTIuNjMpO1xuICAgIH07XG4gICAgLy8gQmFzZWQgb24gSmF2YSBpbXBsZW1lbnRhdGlvbiBieSBCb2phbiBTYXZyaWMuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL09TVUNhcnRvZ3JhcGh5L0pNYXBQcm9qTGliL2Jsb2IvbWFzdGVyL3NyYy9jb20vamhsYWJzL21hcC9wcm9qL1BhdHRlcnNvblByb2plY3Rpb24uamF2YVxuICAgIHZhciBwYXR0ZXJzb25LMSA9IDEuMDE0ODtcbiAgICB2YXIgcGF0dGVyc29uSzIgPSAwLjIzMTg1O1xuICAgIHZhciBwYXR0ZXJzb25LMyA9IC0wLjE0NDk5O1xuICAgIHZhciBwYXR0ZXJzb25LNCA9IDAuMDI0MDY7XG4gICAgdmFyIHBhdHRlcnNvbkMxID0gcGF0dGVyc29uSzE7XG4gICAgdmFyIHBhdHRlcnNvbkMyID0gNSAqIHBhdHRlcnNvbksyO1xuICAgIHZhciBwYXR0ZXJzb25DMyA9IDcgKiBwYXR0ZXJzb25LMztcbiAgICB2YXIgcGF0dGVyc29uQzQgPSA5ICogcGF0dGVyc29uSzQ7XG4gICAgdmFyIHBhdHRlcnNvblltYXggPSAxLjc5MDg1NzE4MztcbiAgICBmdW5jdGlvbiBwYXR0ZXJzb25SYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIHBoaTIgPSBwaGkgKiBwaGk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsYW1iZGEsXG4gICAgICAgICAgICBwaGkgKiAocGF0dGVyc29uSzEgKyBwaGkyICogcGhpMiAqIChwYXR0ZXJzb25LMiArIHBoaTIgKiAocGF0dGVyc29uSzMgKyBwYXR0ZXJzb25LNCAqIHBoaTIpKSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcGF0dGVyc29uUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmICh5ID4gcGF0dGVyc29uWW1heClcbiAgICAgICAgICAgIHkgPSBwYXR0ZXJzb25ZbWF4O1xuICAgICAgICBlbHNlIGlmICh5IDwgLXBhdHRlcnNvblltYXgpXG4gICAgICAgICAgICB5ID0gLXBhdHRlcnNvblltYXg7XG4gICAgICAgIHZhciB5YyA9IHksIGRlbHRhO1xuICAgICAgICBkbyB7IC8vIE5ld3Rvbi1SYXBoc29uXG4gICAgICAgICAgICB2YXIgeTIgPSB5YyAqIHljO1xuICAgICAgICAgICAgeWMgLT0gZGVsdGEgPSAoKHljICogKHBhdHRlcnNvbksxICsgeTIgKiB5MiAqIChwYXR0ZXJzb25LMiArIHkyICogKHBhdHRlcnNvbkszICsgcGF0dGVyc29uSzQgKiB5MikpKSkgLSB5KSAvIChwYXR0ZXJzb25DMSArIHkyICogeTIgKiAocGF0dGVyc29uQzIgKyB5MiAqIChwYXR0ZXJzb25DMyArIHBhdHRlcnNvbkM0ICogeTIpKSk7XG4gICAgICAgIH0gd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uKTtcbiAgICAgICAgcmV0dXJuIFt4LCB5Y107XG4gICAgfTtcbiAgICB2YXIgcGF0dGVyc29uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbihwYXR0ZXJzb25SYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTM5LjMxOSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwb2x5Y29uaWNSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgaWYgKGFicyhwaGkpIDwgZXBzaWxvbilcbiAgICAgICAgICAgIHJldHVybiBbbGFtYmRhLCAwXTtcbiAgICAgICAgdmFyIHRhblBoaSA9IHRhbihwaGkpLCBrID0gbGFtYmRhICogc2luKHBoaSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBzaW4oaykgLyB0YW5QaGksXG4gICAgICAgICAgICBwaGkgKyAoMSAtIGNvcyhrKSkgLyB0YW5QaGlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcG9seWNvbmljUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmIChhYnMoeSkgPCBlcHNpbG9uKVxuICAgICAgICAgICAgcmV0dXJuIFt4LCAwXTtcbiAgICAgICAgdmFyIGsgPSB4ICogeCArIHkgKiB5LCBwaGkgPSB5ICogMC41LCBpID0gMTAsIGRlbHRhO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgdGFuUGhpID0gdGFuKHBoaSksIHNlY1BoaSA9IDEgLyBjb3MocGhpKSwgaiA9IGsgLSAyICogeSAqIHBoaSArIHBoaSAqIHBoaTtcbiAgICAgICAgICAgIHBoaSAtPSBkZWx0YSA9ICh0YW5QaGkgKiBqICsgMiAqIChwaGkgLSB5KSkgLyAoMiArIGogKiBzZWNQaGkgKiBzZWNQaGkgKyAyICogKHBoaSAtIHkpICogdGFuUGhpKTtcbiAgICAgICAgfSB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24gJiYgLS1pID4gMCk7XG4gICAgICAgIHRhblBoaSA9IHRhbihwaGkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKGFicyh5KSA8IGFicyhwaGkgKyAxIC8gdGFuUGhpKSA/IGFzaW4oeCAqIHRhblBoaSkgOiBzaWduKHgpICogKGFjb3MoYWJzKHggKiB0YW5QaGkpKSArIGhhbGZQaSkpIC8gc2luKHBoaSksXG4gICAgICAgICAgICBwaGlcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHZhciBwb2x5Y29uaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKHBvbHljb25pY1JhdylcbiAgICAgICAgICAgIC5zY2FsZSgxMDMuNzQpO1xuICAgIH07XG4gICAgLy8gTm90ZTogNi1lbGVtZW50IGFycmF5cyBhcmUgdXNlZCB0byBkZW5vdGUgdGhlIDN4MyBhZmZpbmUgdHJhbnNmb3JtIG1hdHJpeDpcbiAgICAvLyBbYSwgYiwgYyxcbiAgICAvLyAgZCwgZSwgZixcbiAgICAvLyAgMCwgMCwgMV0gLSB0aGlzIHJlZHVuZGFudCByb3cgaXMgbGVmdCBvdXQuXG4gICAgLy8gVHJhbnNmb3JtIG1hdHJpeCBmb3IgW2EwLCBhMV0gLT4gW2IwLCBiMV0uXG4gICAgdmFyIG1hdHJpeCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciB1ID0gc3VidHJhY3QoYVsxXSwgYVswXSksIHYgPSBzdWJ0cmFjdChiWzFdLCBiWzBdKSwgcGhpID0gYW5nbGUkMSh1LCB2KSwgcyA9IGxlbmd0aCh1KSAvIGxlbmd0aCh2KTtcbiAgICAgICAgcmV0dXJuIG11bHRpcGx5KFtcbiAgICAgICAgICAgIDEsIDAsIGFbMF1bMF0sXG4gICAgICAgICAgICAwLCAxLCBhWzBdWzFdXG4gICAgICAgIF0sIG11bHRpcGx5KFtcbiAgICAgICAgICAgIHMsIDAsIDAsXG4gICAgICAgICAgICAwLCBzLCAwXG4gICAgICAgIF0sIG11bHRpcGx5KFtcbiAgICAgICAgICAgIGNvcyhwaGkpLCBzaW4ocGhpKSwgMCxcbiAgICAgICAgICAgIC1zaW4ocGhpKSwgY29zKHBoaSksIDBcbiAgICAgICAgXSwgW1xuICAgICAgICAgICAgMSwgMCwgLWJbMF1bMF0sXG4gICAgICAgICAgICAwLCAxLCAtYlswXVsxXVxuICAgICAgICBdKSkpO1xuICAgIH07XG4gICAgLy8gSW52ZXJ0cyBhIHRyYW5zZm9ybSBtYXRyaXguXG4gICAgZnVuY3Rpb24gaW52ZXJzZShtKSB7XG4gICAgICAgIHZhciBrID0gMSAvIChtWzBdICogbVs0XSAtIG1bMV0gKiBtWzNdKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGsgKiBtWzRdLCAtayAqIG1bMV0sIGsgKiAobVsxXSAqIG1bNV0gLSBtWzJdICogbVs0XSksXG4gICAgICAgICAgICAtayAqIG1bM10sIGsgKiBtWzBdLCBrICogKG1bMl0gKiBtWzNdIC0gbVswXSAqIG1bNV0pXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8vIE11bHRpcGxpZXMgdHdvIDN4MiBtYXRyaWNlcy5cbiAgICBmdW5jdGlvbiBtdWx0aXBseShhLCBiKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBhWzBdICogYlswXSArIGFbMV0gKiBiWzNdLFxuICAgICAgICAgICAgYVswXSAqIGJbMV0gKyBhWzFdICogYls0XSxcbiAgICAgICAgICAgIGFbMF0gKiBiWzJdICsgYVsxXSAqIGJbNV0gKyBhWzJdLFxuICAgICAgICAgICAgYVszXSAqIGJbMF0gKyBhWzRdICogYlszXSxcbiAgICAgICAgICAgIGFbM10gKiBiWzFdICsgYVs0XSAqIGJbNF0sXG4gICAgICAgICAgICBhWzNdICogYlsyXSArIGFbNF0gKiBiWzVdICsgYVs1XVxuICAgICAgICBdO1xuICAgIH1cbiAgICAvLyBTdWJ0cmFjdHMgMkQgdmVjdG9ycy5cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiKSB7XG4gICAgICAgIHJldHVybiBbYVswXSAtIGJbMF0sIGFbMV0gLSBiWzFdXTtcbiAgICB9XG4gICAgLy8gTWFnbml0dWRlIG9mIGEgMkQgdmVjdG9yLlxuICAgIGZ1bmN0aW9uIGxlbmd0aCh2KSB7XG4gICAgICAgIHJldHVybiBzcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xuICAgIH1cbiAgICAvLyBBbmdsZSBiZXR3ZWVuIHR3byAyRCB2ZWN0b3JzLlxuICAgIGZ1bmN0aW9uIGFuZ2xlJDEoYSwgYikge1xuICAgICAgICByZXR1cm4gYXRhbjIoYVswXSAqIGJbMV0gLSBhWzFdICogYlswXSwgYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSk7XG4gICAgfVxuICAgIC8vIENyZWF0ZXMgYSBwb2x5aGVkcmFsIHByb2plY3Rpb24uXG4gICAgLy8gICogcm9vdDogYSBzcGFubmluZyB0cmVlIG9mIHBvbHlnb24gZmFjZXMuICBOb2RlcyBhcmUgYXV0b21hdGljYWxseVxuICAgIC8vICAgIGF1Z21lbnRlZCB3aXRoIGEgdHJhbnNmb3JtIG1hdHJpeC5cbiAgICAvLyAgKiBmYWNlOiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgbm9kZSBmb3IgYSBnaXZlbiB7bGFtYmRhLCBwaGl9XG4gICAgLy8gICAgcG9pbnQgKHJhZGlhbnMpLlxuICAgIC8vICAqIHI6IHJvdGF0aW9uIGFuZ2xlIGZvciBmaW5hbCBwb2x5aGVkcmFsIG5ldC4gIERlZmF1bHRzIHRvIC1waSAvIDYgKGZvclxuICAgIC8vICAgIGJ1dHRlcmZsaWVzKS5cbiAgICB2YXIgcG9seWhlZHJhbCA9IGZ1bmN0aW9uIChyb290LCBmYWNlLCByKSB7XG4gICAgICAgIHIgPSByID09IG51bGwgPyAtcGkgLyA2IDogcjsgLy8gVE9ETyBhdXRvbWF0ZVxuICAgICAgICByZWN1cnNlKHJvb3QsIHsgdHJhbnNmb3JtOiBbXG4gICAgICAgICAgICAgICAgY29zKHIpLCBzaW4ociksIDAsXG4gICAgICAgICAgICAgICAgLXNpbihyKSwgY29zKHIpLCAwXG4gICAgICAgICAgICBdIH0pO1xuICAgICAgICBmdW5jdGlvbiByZWN1cnNlKG5vZGUsIHBhcmVudCkge1xuICAgICAgICAgICAgbm9kZS5lZGdlcyA9IGZhY2VFZGdlcyhub2RlLmZhY2UpO1xuICAgICAgICAgICAgLy8gRmluZCBzaGFyZWQgZWRnZS5cbiAgICAgICAgICAgIGlmIChwYXJlbnQuZmFjZSkge1xuICAgICAgICAgICAgICAgIHZhciBzaGFyZWQgPSBub2RlLnNoYXJlZCA9IHNoYXJlZEVkZ2Uobm9kZS5mYWNlLCBwYXJlbnQuZmFjZSksIG0gPSBtYXRyaXgoc2hhcmVkLm1hcChwYXJlbnQucHJvamVjdCksIHNoYXJlZC5tYXAobm9kZS5wcm9qZWN0KSk7XG4gICAgICAgICAgICAgICAgbm9kZS50cmFuc2Zvcm0gPSBwYXJlbnQudHJhbnNmb3JtID8gbXVsdGlwbHkocGFyZW50LnRyYW5zZm9ybSwgbSkgOiBtO1xuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2Ugc2hhcmVkIGVkZ2UgaW4gcGFyZW50IGVkZ2VzIGFycmF5LlxuICAgICAgICAgICAgICAgIHZhciBlZGdlcyA9IHBhcmVudC5lZGdlcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGVkZ2VzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRFcXVhbCQxKHNoYXJlZFswXSwgZWRnZXNbaV1bMV0pICYmIHBvaW50RXF1YWwkMShzaGFyZWRbMV0sIGVkZ2VzW2ldWzBdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzW2ldID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50RXF1YWwkMShzaGFyZWRbMF0sIGVkZ2VzW2ldWzBdKSAmJiBwb2ludEVxdWFsJDEoc2hhcmVkWzFdLCBlZGdlc1tpXVsxXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlc1tpXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVkZ2VzID0gbm9kZS5lZGdlcztcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gZWRnZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludEVxdWFsJDEoc2hhcmVkWzBdLCBlZGdlc1tpXVswXSkgJiYgcG9pbnRFcXVhbCQxKHNoYXJlZFsxXSwgZWRnZXNbaV1bMV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXNbaV0gPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludEVxdWFsJDEoc2hhcmVkWzBdLCBlZGdlc1tpXVsxXSkgJiYgcG9pbnRFcXVhbCQxKHNoYXJlZFsxXSwgZWRnZXNbaV1bMF0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXNbaV0gPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS50cmFuc2Zvcm0gPSBwYXJlbnQudHJhbnNmb3JtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY3Vyc2UoY2hpbGQsIG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBmYWNlKGxhbWJkYSwgcGhpKSwgcG9pbnQgPSBub2RlLnByb2plY3QoW2xhbWJkYSAqIGRlZ3JlZXMsIHBoaSAqIGRlZ3JlZXNdKSwgdDtcbiAgICAgICAgICAgIGlmICh0ID0gbm9kZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0WzBdICogcG9pbnRbMF0gKyB0WzFdICogcG9pbnRbMV0gKyB0WzJdLFxuICAgICAgICAgICAgICAgICAgICAtKHRbM10gKiBwb2ludFswXSArIHRbNF0gKiBwb2ludFsxXSArIHRbNV0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50WzFdID0gLXBvaW50WzFdO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIE5haXZlIGludmVyc2UhICBBIGZhc3RlciBzb2x1dGlvbiB3b3VsZCB1c2UgYm91bmRpbmcgYm94ZXMsIG9yIGV2ZW4gYVxuICAgICAgICAvLyBwb2x5Z29uYWwgcXVhZHRyZWUuXG4gICAgICAgIGlmIChoYXNJbnZlcnNlKHJvb3QpKVxuICAgICAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IGZhY2VJbnZlcnQocm9vdCwgW3gsIC15XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVzICYmIChjb29yZGluYXRlc1swXSAqPSByYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqPSByYWRpYW5zLCBjb29yZGluYXRlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBmYWNlSW52ZXJ0KG5vZGUsIGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgaW52ZXJ0ID0gbm9kZS5wcm9qZWN0LmludmVydCwgdCA9IG5vZGUudHJhbnNmb3JtLCBwb2ludCA9IGNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICB0ID0gaW52ZXJzZSh0KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IFtcbiAgICAgICAgICAgICAgICAgICAgdFswXSAqIHBvaW50WzBdICsgdFsxXSAqIHBvaW50WzFdICsgdFsyXSxcbiAgICAgICAgICAgICAgICAgICAgKHRbM10gKiBwb2ludFswXSArIHRbNF0gKiBwb2ludFsxXSArIHRbNV0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnZlcnQgJiYgbm9kZSA9PT0gZmFjZURlZ3JlZXMocCA9IGludmVydChwb2ludCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgdmFyIHAsIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHAgPSBmYWNlSW52ZXJ0KGNoaWxkcmVuW2ldLCBjb29yZGluYXRlcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZhY2VEZWdyZWVzKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjZShjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2ogPSBkM0dlby5nZW9Qcm9qZWN0aW9uKGZvcndhcmQpLCBzdHJlYW1fID0gcHJvai5zdHJlYW07XG4gICAgICAgIHByb2ouc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIHJvdGF0ZSA9IHByb2oucm90YXRlKCksIHJvdGF0ZVN0cmVhbSA9IHN0cmVhbV8oc3RyZWFtKSwgc3BoZXJlU3RyZWFtID0gKHByb2oucm90YXRlKFswLCAwXSksIHN0cmVhbV8oc3RyZWFtKSk7XG4gICAgICAgICAgICBwcm9qLnJvdGF0ZShyb3RhdGUpO1xuICAgICAgICAgICAgcm90YXRlU3RyZWFtLnNwaGVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgc3BoZXJlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIG91dGxpbmUoc3BoZXJlU3RyZWFtLCByb290KTtcbiAgICAgICAgICAgICAgICBzcGhlcmVTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgIHNwaGVyZVN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJvdGF0ZVN0cmVhbTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByb2o7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBvdXRsaW5lKHN0cmVhbSwgbm9kZSwgcGFyZW50KSB7XG4gICAgICAgIHZhciBwb2ludCwgZWRnZXMgPSBub2RlLmVkZ2VzLCBuID0gZWRnZXMubGVuZ3RoLCBlZGdlLCBtdWx0aVBvaW50ID0geyB0eXBlOiBcIk11bHRpUG9pbnRcIiwgY29vcmRpbmF0ZXM6IG5vZGUuZmFjZSB9LCBub3RQb2xlcyA9IG5vZGUuZmFjZS5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGFicyhkWzFdKSAhPT0gOTA7IH0pLCBiID0gZDNHZW8uZ2VvQm91bmRzKHsgdHlwZTogXCJNdWx0aVBvaW50XCIsIGNvb3JkaW5hdGVzOiBub3RQb2xlcyB9KSwgaW5zaWRlID0gZmFsc2UsIGogPSAtMSwgZHggPSBiWzFdWzBdIC0gYlswXVswXTtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICB2YXIgYyA9IGR4ID09PSAxODAgfHwgZHggPT09IDM2MFxuICAgICAgICAgICAgPyBbKGJbMF1bMF0gKyBiWzFdWzBdKSAvIDIsIChiWzBdWzFdICsgYlsxXVsxXSkgLyAyXVxuICAgICAgICAgICAgOiBkM0dlby5nZW9DZW50cm9pZChtdWx0aVBvaW50KTtcbiAgICAgICAgLy8gRmlyc3QgZmluZCB0aGUgc2hhcmVkIGVkZ2XigKZcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgIHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VzW2pdID09PSBwYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICArK2o7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBlZGdlID0gZWRnZXNbKGkgKyBqKSAlIG5dO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWRnZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoKHBvaW50ID0gZDNHZW8uZ2VvSW50ZXJwb2xhdGUoZWRnZVswXSwgYykoZXBzaWxvbikpWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCgocG9pbnQgPSBkM0dlby5nZW9JbnRlcnBvbGF0ZShlZGdlWzFdLCBjKShlcHNpbG9uKSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc2lkZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChlZGdlICE9PSBwYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIG91dGxpbmUoc3RyZWFtLCBlZGdlLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUZXN0cyBlcXVhbGl0eSBvZiB0d28gc3BoZXJpY2FsIHBvaW50cy5cbiAgICBmdW5jdGlvbiBwb2ludEVxdWFsJDEoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAmJiBiICYmIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXTtcbiAgICB9XG4gICAgLy8gRmluZHMgYSBzaGFyZWQgZWRnZSBnaXZlbiB0d28gY2xvY2t3aXNlIHBvbHlnb25zLlxuICAgIGZ1bmN0aW9uIHNoYXJlZEVkZ2UoYSwgYikge1xuICAgICAgICB2YXIgeCwgeSwgbiA9IGEubGVuZ3RoLCBmb3VuZCA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICB4ID0gYVtpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBiLmxlbmd0aDsgLS1qID49IDA7KSB7XG4gICAgICAgICAgICAgICAgeSA9IGJbal07XG4gICAgICAgICAgICAgICAgaWYgKHhbMF0gPT09IHlbMF0gJiYgeFsxXSA9PT0geVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2ZvdW5kLCB4XTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBuIGZhY2UgdmVydGljZXMgdG8gYW4gYXJyYXkgb2YgbiArIDEgZWRnZXMuXG4gICAgZnVuY3Rpb24gZmFjZUVkZ2VzKGZhY2UpIHtcbiAgICAgICAgdmFyIG4gPSBmYWNlLmxlbmd0aCwgZWRnZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgYSA9IGZhY2VbbiAtIDFdLCBpID0gMDsgaSA8IG47ICsraSlcbiAgICAgICAgICAgIGVkZ2VzLnB1c2goW2EsIGEgPSBmYWNlW2ldXSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzSW52ZXJzZShub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLnByb2plY3QuaW52ZXJ0IHx8IG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5jaGlsZHJlbi5zb21lKGhhc0ludmVyc2UpO1xuICAgIH1cbiAgICAvLyBUT0RPIGdlbmVyYXRlIG9uLXRoZS1mbHkgdG8gYXZvaWQgZXh0ZXJuYWwgbW9kaWZpY2F0aW9uLlxuICAgIHZhciBvY3RhaGVkcm9uID0gW1xuICAgICAgICBbMCwgOTBdLFxuICAgICAgICBbLTkwLCAwXSwgWzAsIDBdLCBbOTAsIDBdLCBbMTgwLCAwXSxcbiAgICAgICAgWzAsIC05MF1cbiAgICBdO1xuICAgIHZhciBvY3RhaGVkcm9uJDEgPSBbXG4gICAgICAgIFswLCAyLCAxXSxcbiAgICAgICAgWzAsIDMsIDJdLFxuICAgICAgICBbNSwgMSwgMl0sXG4gICAgICAgIFs1LCAyLCAzXSxcbiAgICAgICAgWzAsIDEsIDRdLFxuICAgICAgICBbMCwgNCwgM10sXG4gICAgICAgIFs1LCA0LCAxXSxcbiAgICAgICAgWzUsIDMsIDRdXG4gICAgXS5tYXAoZnVuY3Rpb24gKGZhY2UpIHtcbiAgICAgICAgcmV0dXJuIGZhY2UubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gb2N0YWhlZHJvbltpXTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgdmFyIGJ1dHRlcmZseSA9IGZ1bmN0aW9uIChmYWNlUHJvamVjdGlvbikge1xuICAgICAgICBmYWNlUHJvamVjdGlvbiA9IGZhY2VQcm9qZWN0aW9uIHx8IGZ1bmN0aW9uIChmYWNlKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGQzR2VvLmdlb0NlbnRyb2lkKHsgdHlwZTogXCJNdWx0aVBvaW50XCIsIGNvb3JkaW5hdGVzOiBmYWNlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGQzR2VvLmdlb0dub21vbmljKCkuc2NhbGUoMSkudHJhbnNsYXRlKFswLCAwXSkucm90YXRlKFstY1swXSwgLWNbMV1dKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZhY2VzID0gb2N0YWhlZHJvbiQxLm1hcChmdW5jdGlvbiAoZmFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZmFjZTogZmFjZSwgcHJvamVjdDogZmFjZVByb2plY3Rpb24oZmFjZSkgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIFstMSwgMCwgMCwgMSwgMCwgMSwgNCwgNV0uZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBmYWNlc1tkXTtcbiAgICAgICAgICAgIG5vZGUgJiYgKG5vZGUuY2hpbGRyZW4gfHwgKG5vZGUuY2hpbGRyZW4gPSBbXSkpLnB1c2goZmFjZXNbaV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBvbHloZWRyYWwoZmFjZXNbMF0sIGZ1bmN0aW9uIChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhY2VzW2xhbWJkYSA8IC1waSAvIDIgPyBwaGkgPCAwID8gNiA6IDRcbiAgICAgICAgICAgICAgICA6IGxhbWJkYSA8IDAgPyBwaGkgPCAwID8gMiA6IDBcbiAgICAgICAgICAgICAgICAgICAgOiBsYW1iZGEgPCBwaSAvIDIgPyBwaGkgPCAwID8gMyA6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGhpIDwgMCA/IDcgOiA1XTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5zY2FsZSgxMDEuODU4KVxuICAgICAgICAgICAgLmNlbnRlcihbMCwgNDVdKTtcbiAgICB9O1xuICAgIHZhciBreCA9IDIgLyBzcXJ0KDMpO1xuICAgIGZ1bmN0aW9uIGNvbGxpZ25vbksoYSwgYikge1xuICAgICAgICB2YXIgcCA9IGNvbGxpZ25vblJhdyhhLCBiKTtcbiAgICAgICAgcmV0dXJuIFtwWzBdICoga3gsIHBbMV1dO1xuICAgIH1cbiAgICBjb2xsaWdub25LLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiBjb2xsaWdub25SYXcuaW52ZXJ0KHggLyBreCwgeSk7XG4gICAgfTtcbiAgICB2YXIgY29sbGlnbm9uJDEgPSBmdW5jdGlvbiAoZmFjZVByb2plY3Rpb24pIHtcbiAgICAgICAgZmFjZVByb2plY3Rpb24gPSBmYWNlUHJvamVjdGlvbiB8fCBmdW5jdGlvbiAoZmFjZSkge1xuICAgICAgICAgICAgdmFyIGMgPSBkM0dlby5nZW9DZW50cm9pZCh7IHR5cGU6IFwiTXVsdGlQb2ludFwiLCBjb29yZGluYXRlczogZmFjZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKGNvbGxpZ25vbkspLnRyYW5zbGF0ZShbMCwgMF0pLnNjYWxlKDEpLnJvdGF0ZShjWzFdID4gMCA/IFstY1swXSwgMF0gOiBbMTgwIC0gY1swXSwgMTgwXSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmYWNlcyA9IG9jdGFoZWRyb24kMS5tYXAoZnVuY3Rpb24gKGZhY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGZhY2U6IGZhY2UsIHByb2plY3Q6IGZhY2VQcm9qZWN0aW9uKGZhY2UpIH07XG4gICAgICAgIH0pO1xuICAgICAgICBbLTEsIDAsIDAsIDEsIDAsIDEsIDQsIDVdLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZmFjZXNbZF07XG4gICAgICAgICAgICBub2RlICYmIChub2RlLmNoaWxkcmVuIHx8IChub2RlLmNoaWxkcmVuID0gW10pKS5wdXNoKGZhY2VzW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwb2x5aGVkcmFsKGZhY2VzWzBdLCBmdW5jdGlvbiAobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWNlc1tsYW1iZGEgPCAtcGkgLyAyID8gcGhpIDwgMCA/IDYgOiA0XG4gICAgICAgICAgICAgICAgOiBsYW1iZGEgPCAwID8gcGhpIDwgMCA/IDIgOiAwXG4gICAgICAgICAgICAgICAgICAgIDogbGFtYmRhIDwgcGkgLyAyID8gcGhpIDwgMCA/IDMgOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBoaSA8IDAgPyA3IDogNV07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuc2NhbGUoMTIxLjkwNilcbiAgICAgICAgICAgIC5jZW50ZXIoWzAsIDQ4LjU5MDRdKTtcbiAgICB9O1xuICAgIHZhciB3YXRlcm1hbiA9IGZ1bmN0aW9uIChmYWNlUHJvamVjdGlvbikge1xuICAgICAgICBmYWNlUHJvamVjdGlvbiA9IGZhY2VQcm9qZWN0aW9uIHx8IGZ1bmN0aW9uIChmYWNlKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGZhY2UubGVuZ3RoID09PSA2ID8gZDNHZW8uZ2VvQ2VudHJvaWQoeyB0eXBlOiBcIk11bHRpUG9pbnRcIiwgY29vcmRpbmF0ZXM6IGZhY2UgfSkgOiBmYWNlWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGQzR2VvLmdlb0dub21vbmljKCkuc2NhbGUoMSkudHJhbnNsYXRlKFswLCAwXSkucm90YXRlKFstY1swXSwgLWNbMV1dKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHc1ID0gb2N0YWhlZHJvbiQxLm1hcChmdW5jdGlvbiAoZmFjZSkge1xuICAgICAgICAgICAgdmFyIHh5eiA9IGZhY2UubWFwKGNhcnRlc2lhbiksIG4gPSB4eXoubGVuZ3RoLCBhID0geHl6W24gLSAxXSwgYiwgaGV4YWdvbiA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBiID0geHl6W2ldO1xuICAgICAgICAgICAgICAgIGhleGFnb24ucHVzaChzcGhlcmljYWwoW1xuICAgICAgICAgICAgICAgICAgICBhWzBdICogMC45NDg2ODMyOTgwNTA1MTM4ICsgYlswXSAqIDAuMzE2MjI3NzY2MDE2ODM3OTQsXG4gICAgICAgICAgICAgICAgICAgIGFbMV0gKiAwLjk0ODY4MzI5ODA1MDUxMzggKyBiWzFdICogMC4zMTYyMjc3NjYwMTY4Mzc5NCxcbiAgICAgICAgICAgICAgICAgICAgYVsyXSAqIDAuOTQ4NjgzMjk4MDUwNTEzOCArIGJbMl0gKiAwLjMxNjIyNzc2NjAxNjgzNzk0XG4gICAgICAgICAgICAgICAgXSksIHNwaGVyaWNhbChbXG4gICAgICAgICAgICAgICAgICAgIGJbMF0gKiAwLjk0ODY4MzI5ODA1MDUxMzggKyBhWzBdICogMC4zMTYyMjc3NjYwMTY4Mzc5NCxcbiAgICAgICAgICAgICAgICAgICAgYlsxXSAqIDAuOTQ4NjgzMjk4MDUwNTEzOCArIGFbMV0gKiAwLjMxNjIyNzc2NjAxNjgzNzk0LFxuICAgICAgICAgICAgICAgICAgICBiWzJdICogMC45NDg2ODMyOTgwNTA1MTM4ICsgYVsyXSAqIDAuMzE2MjI3NzY2MDE2ODM3OTRcbiAgICAgICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGV4YWdvbjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb3JuZXJOb3JtYWxzID0gW107XG4gICAgICAgIHZhciBwYXJlbnRzID0gWy0xLCAwLCAwLCAxLCAwLCAxLCA0LCA1XTtcbiAgICAgICAgdzUuZm9yRWFjaChmdW5jdGlvbiAoaGV4YWdvbiwgaikge1xuICAgICAgICAgICAgdmFyIGZhY2UgPSBvY3RhaGVkcm9uJDFbal0sIG4gPSBmYWNlLmxlbmd0aCwgbm9ybWFscyA9IGNvcm5lck5vcm1hbHNbal0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgdzUucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIGZhY2VbaV0sXG4gICAgICAgICAgICAgICAgICAgIGhleGFnb25bKGkgKiAyICsgMikgJSAoMiAqIG4pXSxcbiAgICAgICAgICAgICAgICAgICAgaGV4YWdvblsoaSAqIDIgKyAxKSAlICgyICogbildXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKGopO1xuICAgICAgICAgICAgICAgIG5vcm1hbHMucHVzaChjcm9zcyhjYXJ0ZXNpYW4oaGV4YWdvblsoaSAqIDIgKyAyKSAlICgyICogbildKSwgY2FydGVzaWFuKGhleGFnb25bKGkgKiAyICsgMSkgJSAoMiAqIG4pXSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBmYWNlcyA9IHc1Lm1hcChmdW5jdGlvbiAoZmFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0OiBmYWNlUHJvamVjdGlvbihmYWNlKSxcbiAgICAgICAgICAgICAgICBmYWNlOiBmYWNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZmFjZXNbZF07XG4gICAgICAgICAgICBwYXJlbnQgJiYgKHBhcmVudC5jaGlsZHJlbiB8fCAocGFyZW50LmNoaWxkcmVuID0gW10pKS5wdXNoKGZhY2VzW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGZhY2UobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciBjb3NwaGkgPSBjb3MocGhpKSwgcCA9IFtjb3NwaGkgKiBjb3MobGFtYmRhKSwgY29zcGhpICogc2luKGxhbWJkYSksIHNpbihwaGkpXTtcbiAgICAgICAgICAgIHZhciBoZXhhZ29uID0gbGFtYmRhIDwgLXBpIC8gMiA/IHBoaSA8IDAgPyA2IDogNFxuICAgICAgICAgICAgICAgIDogbGFtYmRhIDwgMCA/IHBoaSA8IDAgPyAyIDogMFxuICAgICAgICAgICAgICAgICAgICA6IGxhbWJkYSA8IHBpIC8gMiA/IHBoaSA8IDAgPyAzIDogMVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwaGkgPCAwID8gNyA6IDU7XG4gICAgICAgICAgICB2YXIgbiA9IGNvcm5lck5vcm1hbHNbaGV4YWdvbl07XG4gICAgICAgICAgICByZXR1cm4gZmFjZXNbZG90KG5bMF0sIHApIDwgMCA/IDggKyAzICogaGV4YWdvblxuICAgICAgICAgICAgICAgIDogZG90KG5bMV0sIHApIDwgMCA/IDggKyAzICogaGV4YWdvbiArIDFcbiAgICAgICAgICAgICAgICAgICAgOiBkb3QoblsyXSwgcCkgPCAwID8gOCArIDMgKiBoZXhhZ29uICsgMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBoZXhhZ29uXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9seWhlZHJhbChmYWNlc1swXSwgZmFjZSlcbiAgICAgICAgICAgIC5zY2FsZSgxMTAuNjI1KVxuICAgICAgICAgICAgLmNlbnRlcihbMCwgNDVdKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gYS5sZW5ndGgsIHMgPSAwOyBpIDwgbjsgKytpKVxuICAgICAgICAgICAgcyArPSBhW2ldICogYltpXTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyb3NzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGFbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV0sXG4gICAgICAgICAgICBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLFxuICAgICAgICAgICAgYVswXSAqIGJbMV0gLSBhWzFdICogYlswXVxuICAgICAgICBdO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0cyAzRCBDYXJ0ZXNpYW4gdG8gc3BoZXJpY2FsIGNvb3JkaW5hdGVzIChkZWdyZWVzKS5cbiAgICBmdW5jdGlvbiBzcGhlcmljYWwoY2FydGVzaWFuKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBhdGFuMihjYXJ0ZXNpYW5bMV0sIGNhcnRlc2lhblswXSkgKiBkZWdyZWVzLFxuICAgICAgICAgICAgYXNpbihtYXgoLTEsIG1pbigxLCBjYXJ0ZXNpYW5bMl0pKSkgKiBkZWdyZWVzXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8vIENvbnZlcnRzIHNwaGVyaWNhbCBjb29yZGluYXRlcyAoZGVncmVlcykgdG8gM0QgQ2FydGVzaWFuLlxuICAgIGZ1bmN0aW9uIGNhcnRlc2lhbihjb29yZGluYXRlcykge1xuICAgICAgICB2YXIgbGFtYmRhID0gY29vcmRpbmF0ZXNbMF0gKiByYWRpYW5zLCBwaGkgPSBjb29yZGluYXRlc1sxXSAqIHJhZGlhbnMsIGNvc3BoaSA9IGNvcyhwaGkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY29zcGhpICogY29zKGxhbWJkYSksXG4gICAgICAgICAgICBjb3NwaGkgKiBzaW4obGFtYmRhKSxcbiAgICAgICAgICAgIHNpbihwaGkpXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHZhciBjbG9ja3dpc2UgPSBmdW5jdGlvbiAocmluZykge1xuICAgICAgICBpZiAoKG4gPSByaW5nLmxlbmd0aCkgPCA0KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgaSA9IDAsIG4sIGFyZWEgPSByaW5nW24gLSAxXVsxXSAqIHJpbmdbMF1bMF0gLSByaW5nW24gLSAxXVswXSAqIHJpbmdbMF1bMV07XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgYXJlYSArPSByaW5nW2kgLSAxXVsxXSAqIHJpbmdbaV1bMF0gLSByaW5nW2kgLSAxXVswXSAqIHJpbmdbaV1bMV07XG4gICAgICAgIHJldHVybiBhcmVhIDw9IDA7XG4gICAgfTtcbiAgICB2YXIgY29udGFpbnMgPSBmdW5jdGlvbiAocmluZywgcG9pbnQpIHtcbiAgICAgICAgdmFyIHggPSBwb2ludFswXSwgeSA9IHBvaW50WzFdLCBjb250YWlucyA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHJpbmcubGVuZ3RoLCBqID0gbiAtIDE7IGkgPCBuOyBqID0gaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGkgPSByaW5nW2ldLCB4aSA9IHBpWzBdLCB5aSA9IHBpWzFdLCBwaiA9IHJpbmdbal0sIHhqID0gcGpbMF0sIHlqID0gcGpbMV07XG4gICAgICAgICAgICBpZiAoKCh5aSA+IHkpIF4gKHlqID4geSkpICYmICh4IDwgKHhqIC0geGkpICogKHkgLSB5aSkgLyAoeWogLSB5aSkgKyB4aSkpXG4gICAgICAgICAgICAgICAgY29udGFpbnMgPSAhY29udGFpbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zO1xuICAgIH07XG4gICAgdmFyIGluZGV4ID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvamVjdGlvbikge1xuICAgICAgICB2YXIgc3RyZWFtID0gcHJvamVjdGlvbi5zdHJlYW0sIHByb2plY3Q7XG4gICAgICAgIGlmICghc3RyZWFtKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwcm9qZWN0aW9uXCIpO1xuICAgICAgICBzd2l0Y2ggKG9iamVjdCAmJiBvYmplY3QudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIkZlYXR1cmVcIjpcbiAgICAgICAgICAgICAgICBwcm9qZWN0ID0gcHJvamVjdEZlYXR1cmU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRmVhdHVyZUNvbGxlY3Rpb25cIjpcbiAgICAgICAgICAgICAgICBwcm9qZWN0ID0gcHJvamVjdEZlYXR1cmVDb2xsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwcm9qZWN0ID0gcHJvamVjdEdlb21ldHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9qZWN0KG9iamVjdCwgc3RyZWFtKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHByb2plY3RGZWF0dXJlQ29sbGVjdGlvbihvLCBzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAgICAgICAgICAgIGZlYXR1cmVzOiBvLmZlYXR1cmVzLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9qZWN0RmVhdHVyZShmLCBzdHJlYW0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvamVjdEZlYXR1cmUobywgc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgICAgIGlkOiBvLmlkLFxuICAgICAgICAgICAgcHJvcGVydGllczogby5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgZ2VvbWV0cnk6IHByb2plY3RHZW9tZXRyeShvLmdlb21ldHJ5LCBzdHJlYW0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2plY3RHZW9tZXRyeUNvbGxlY3Rpb24obywgc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkdlb21ldHJ5Q29sbGVjdGlvblwiLFxuICAgICAgICAgICAgZ2VvbWV0cmllczogby5nZW9tZXRyaWVzLm1hcChmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9qZWN0R2VvbWV0cnkobywgc3RyZWFtKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2plY3RHZW9tZXRyeShvLCBzdHJlYW0pIHtcbiAgICAgICAgaWYgKCFvKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIpXG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdEdlb21ldHJ5Q29sbGVjdGlvbihvLCBzdHJlYW0pO1xuICAgICAgICB2YXIgc2luaztcbiAgICAgICAgc3dpdGNoIChvLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgICAgICAgIHNpbmsgPSBzaW5rUG9pbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgICAgICAgICAgIHNpbmsgPSBzaW5rUG9pbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHNpbmsgPSBzaW5rTGluZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjpcbiAgICAgICAgICAgICAgICBzaW5rID0gc2lua0xpbmU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgICAgICAgICAgIHNpbmsgPSBzaW5rUG9seWdvbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjpcbiAgICAgICAgICAgICAgICBzaW5rID0gc2lua1BvbHlnb247XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU3BoZXJlXCI6XG4gICAgICAgICAgICAgICAgc2luayA9IHNpbmtQb2x5Z29uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZDNHZW8uZ2VvU3RyZWFtKG8sIHN0cmVhbShzaW5rKSk7XG4gICAgICAgIHJldHVybiBzaW5rLnJlc3VsdCgpO1xuICAgIH1cbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgdmFyIGxpbmVzID0gW107XG4gICAgdmFyIHNpbmtQb2ludCA9IHtcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaChbeCwgeV0pO1xuICAgICAgICB9LFxuICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAhcG9pbnRzLmxlbmd0aCA/IG51bGxcbiAgICAgICAgICAgICAgICA6IHBvaW50cy5sZW5ndGggPCAyID8geyB0eXBlOiBcIlBvaW50XCIsIGNvb3JkaW5hdGVzOiBwb2ludHNbMF0gfVxuICAgICAgICAgICAgICAgICAgICA6IHsgdHlwZTogXCJNdWx0aVBvaW50XCIsIGNvb3JkaW5hdGVzOiBwb2ludHMgfTtcbiAgICAgICAgICAgIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNpbmtMaW5lID0ge1xuICAgICAgICBsaW5lU3RhcnQ6IG5vb3AsXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goW3gsIHldKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChwb2ludHMpLCBwb2ludHMgPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gIWxpbmVzLmxlbmd0aCA/IG51bGxcbiAgICAgICAgICAgICAgICA6IGxpbmVzLmxlbmd0aCA8IDIgPyB7IHR5cGU6IFwiTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogbGluZXNbMF0gfVxuICAgICAgICAgICAgICAgICAgICA6IHsgdHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGxpbmVzIH07XG4gICAgICAgICAgICBsaW5lcyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNpbmtQb2x5Z29uID0ge1xuICAgICAgICBwb2x5Z29uU3RhcnQ6IG5vb3AsXG4gICAgICAgIGxpbmVTdGFydDogbm9vcCxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaChbeCwgeV0pO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50c1swXS5zbGljZSgpKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytuIDwgNCk7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChwb2ludHMpLCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogbm9vcCxcbiAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWxpbmVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZhciBwb2x5Z29ucyA9IFtdLCBob2xlcyA9IFtdO1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzL2lzc3Vlcy8xNTU4XG4gICAgICAgICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uIChyaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsb2Nrd2lzZShyaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbnMucHVzaChbcmluZ10pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaG9sZXMucHVzaChyaW5nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaG9sZXMuZm9yRWFjaChmdW5jdGlvbiAoaG9sZSkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IGhvbGVbMF07XG4gICAgICAgICAgICAgICAgcG9seWdvbnMuc29tZShmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMocG9seWdvblswXSwgcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uLnB1c2goaG9sZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pIHx8IHBvbHlnb25zLnB1c2goW2hvbGVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGluZXMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiAhcG9seWdvbnMubGVuZ3RoID8gbnVsbFxuICAgICAgICAgICAgICAgIDogcG9seWdvbnMubGVuZ3RoID4gMSA/IHsgdHlwZTogXCJNdWx0aVBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IHBvbHlnb25zIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7IHR5cGU6IFwiUG9seWdvblwiLCBjb29yZGluYXRlczogcG9seWdvbnNbMF0gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHF1aW5jdW5jaWFsID0gZnVuY3Rpb24gKHByb2plY3QpIHtcbiAgICAgICAgdmFyIGR4ID0gcHJvamVjdChoYWxmUGksIDApWzBdIC0gcHJvamVjdCgtaGFsZlBpLCAwKVswXTtcbiAgICAgICAgZnVuY3Rpb24gcHJvamVjdFF1aW5jdW5jaWFsKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGFicyhsYW1iZGEpIDwgaGFsZlBpLCBwID0gcHJvamVjdCh0ID8gbGFtYmRhIDogbGFtYmRhID4gMCA/IGxhbWJkYSAtIHBpIDogbGFtYmRhICsgcGksIHBoaSksIHggPSAocFswXSAtIHBbMV0pICogc3FydDFfMiwgeSA9IChwWzBdICsgcFsxXSkgKiBzcXJ0MV8yO1xuICAgICAgICAgICAgaWYgKHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgICAgICAgIHZhciBkID0gZHggKiBzcXJ0MV8yLCBzID0geCA+IDAgXiB5ID4gMCA/IC0xIDogMTtcbiAgICAgICAgICAgIHJldHVybiBbcyAqIHggLSBzaWduKHkpICogZCwgcyAqIHkgLSBzaWduKHgpICogZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2plY3QuaW52ZXJ0KVxuICAgICAgICAgICAgcHJvamVjdFF1aW5jdW5jaWFsLmludmVydCA9IGZ1bmN0aW9uICh4MCwgeTApIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9ICh4MCArIHkwKSAqIHNxcnQxXzIsIHkgPSAoeTAgLSB4MCkgKiBzcXJ0MV8yLCB0ID0gYWJzKHgpIDwgMC41ICogZHggJiYgYWJzKHkpIDwgMC41ICogZHg7XG4gICAgICAgICAgICAgICAgaWYgKCF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gZHggKiBzcXJ0MV8yLCBzID0geCA+IDAgXiB5ID4gMCA/IC0xIDogMSwgeDEgPSAtcyAqIHgwICsgKHkgPiAwID8gMSA6IC0xKSAqIGQsIHkxID0gLXMgKiB5MCArICh4ID4gMCA/IDEgOiAtMSkgKiBkO1xuICAgICAgICAgICAgICAgICAgICB4ID0gKC14MSAtIHkxKSAqIHNxcnQxXzI7XG4gICAgICAgICAgICAgICAgICAgIHkgPSAoeDEgLSB5MSkgKiBzcXJ0MV8yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcCA9IHByb2plY3QuaW52ZXJ0KHgsIHkpO1xuICAgICAgICAgICAgICAgIGlmICghdClcbiAgICAgICAgICAgICAgICAgICAgcFswXSArPSB4ID4gMCA/IHBpIDogLXBpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24ocHJvamVjdFF1aW5jdW5jaWFsKVxuICAgICAgICAgICAgLnJvdGF0ZShbLTkwLCAtOTAsIDQ1XSlcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoMTgwIC0gMWUtMyk7XG4gICAgfTtcbiAgICB2YXIgZ3JpbmdvcnRlbiQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcXVpbmN1bmNpYWwoZ3JpbmdvcnRlblJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNzYuNDIzKTtcbiAgICB9O1xuICAgIHZhciBwZWlyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBxdWluY3VuY2lhbChndXlvdVJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxMTEuNDgpO1xuICAgIH07XG4gICAgdmFyIHF1YW50aXplID0gZnVuY3Rpb24gKGlucHV0LCBkaWdpdHMpIHtcbiAgICAgICAgaWYgKCEoMCA8PSAoZGlnaXRzID0gK2RpZ2l0cykgJiYgZGlnaXRzIDw9IDIwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGlnaXRzXCIpO1xuICAgICAgICBmdW5jdGlvbiBxdWFudGl6ZVBvaW50KGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgbiA9IGlucHV0Lmxlbmd0aCwgaSA9IDIsIG91dHB1dCA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIG91dHB1dFswXSA9ICtpbnB1dFswXS50b0ZpeGVkKGRpZ2l0cyk7XG4gICAgICAgICAgICBvdXRwdXRbMV0gPSAraW5wdXRbMV0udG9GaXhlZChkaWdpdHMpO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBuKVxuICAgICAgICAgICAgICAgIG91dHB1dFtpXSA9IGlucHV0W2ldLCArK2k7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHF1YW50aXplUG9pbnRzKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKHF1YW50aXplUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHF1YW50aXplUG9seWdvbihpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcChxdWFudGl6ZVBvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcXVhbnRpemVHZW9tZXRyeShpbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlucHV0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgdmFyIG91dHB1dDtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0geyB0eXBlOiBcIkdlb21ldHJ5Q29sbGVjdGlvblwiLCBnZW9tZXRyaWVzOiBpbnB1dC5nZW9tZXRyaWVzLm1hcChxdWFudGl6ZUdlb21ldHJ5KSB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0geyB0eXBlOiBcIlBvaW50XCIsIGNvb3JkaW5hdGVzOiBxdWFudGl6ZVBvaW50KGlucHV0LmNvb3JkaW5hdGVzKSB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgdHlwZTogaW5wdXQudHlwZSwgY29vcmRpbmF0ZXM6IHF1YW50aXplUG9pbnRzKGlucHV0LmNvb3JkaW5hdGVzKSB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcIlBvbHlnb25cIjpcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0geyB0eXBlOiBpbnB1dC50eXBlLCBjb29yZGluYXRlczogcXVhbnRpemVQb2x5Z29uKGlucHV0LmNvb3JkaW5hdGVzKSB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgdHlwZTogXCJNdWx0aVBvbHlnb25cIiwgY29vcmRpbmF0ZXM6IGlucHV0LmNvb3JkaW5hdGVzLm1hcChxdWFudGl6ZVBvbHlnb24pIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnB1dC5iYm94ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgb3V0cHV0LmJib3ggPSBpbnB1dC5iYm94O1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBxdWFudGl6ZUZlYXR1cmUoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB7IHR5cGU6IFwiRmVhdHVyZVwiLCBwcm9wZXJ0aWVzOiBpbnB1dC5wcm9wZXJ0aWVzLCBnZW9tZXRyeTogcXVhbnRpemVHZW9tZXRyeShpbnB1dC5nZW9tZXRyeSkgfTtcbiAgICAgICAgICAgIGlmIChpbnB1dC5pZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG91dHB1dC5pZCA9IGlucHV0LmlkO1xuICAgICAgICAgICAgaWYgKGlucHV0LmJib3ggIT0gbnVsbClcbiAgICAgICAgICAgICAgICBvdXRwdXQuYmJveCA9IGlucHV0LmJib3g7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKVxuICAgICAgICAgICAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkZlYXR1cmVcIjogcmV0dXJuIHF1YW50aXplRmVhdHVyZShpbnB1dCk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkZlYXR1cmVDb2xsZWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IHsgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLCBmZWF0dXJlczogaW5wdXQuZmVhdHVyZXMubWFwKHF1YW50aXplRmVhdHVyZSkgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmJib3ggIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5iYm94ID0gaW5wdXQuYmJveDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHF1YW50aXplR2VvbWV0cnkoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByZWN0YW5ndWxhclBvbHljb25pY1JhdyhwaGkwKSB7XG4gICAgICAgIHZhciBzaW5QaGkwID0gc2luKHBoaTApO1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgQSA9IHNpblBoaTAgPyB0YW4obGFtYmRhICogc2luUGhpMCAvIDIpIC8gc2luUGhpMCA6IGxhbWJkYSAvIDI7XG4gICAgICAgICAgICBpZiAoIXBoaSlcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgKiBBLCAtcGhpMF07XG4gICAgICAgICAgICB2YXIgRSA9IDIgKiBhdGFuKEEgKiBzaW4ocGhpKSksIGNvdFBoaSA9IDEgLyB0YW4ocGhpKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgc2luKEUpICogY290UGhpLFxuICAgICAgICAgICAgICAgIHBoaSArICgxIC0gY29zKEUpKSAqIGNvdFBoaSAtIHBoaTBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyByZXR1cm4gbnVsbCBmb3IgcG9pbnRzIG91dHNpZGUgb3V0bGluZS5cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgaWYgKGFicyh5ICs9IHBoaTApIDwgZXBzaWxvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NpblBoaTAgPyAyICogYXRhbihzaW5QaGkwICogeCAvIDIpIC8gc2luUGhpMCA6IHgsIDBdO1xuICAgICAgICAgICAgdmFyIGsgPSB4ICogeCArIHkgKiB5LCBwaGkgPSAwLCBpID0gMTAsIGRlbHRhO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciB0YW5QaGkgPSB0YW4ocGhpKSwgc2VjUGhpID0gMSAvIGNvcyhwaGkpLCBqID0gayAtIDIgKiB5ICogcGhpICsgcGhpICogcGhpO1xuICAgICAgICAgICAgICAgIHBoaSAtPSBkZWx0YSA9ICh0YW5QaGkgKiBqICsgMiAqIChwaGkgLSB5KSkgLyAoMiArIGogKiBzZWNQaGkgKiBzZWNQaGkgKyAyICogKHBoaSAtIHkpICogdGFuUGhpKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uICYmIC0taSA+IDApO1xuICAgICAgICAgICAgdmFyIEUgPSB4ICogKHRhblBoaSA9IHRhbihwaGkpKSwgQSA9IHRhbihhYnMoeSkgPCBhYnMocGhpICsgMSAvIHRhblBoaSkgPyBhc2luKEUpICogMC41IDogYWNvcyhFKSAqIDAuNSArIHBpIC8gNCkgLyBzaW4ocGhpKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgc2luUGhpMCA/IDIgKiBhdGFuKHNpblBoaTAgKiBBKSAvIHNpblBoaTAgOiAyICogQSxcbiAgICAgICAgICAgICAgICBwaGlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICB2YXIgcmVjdGFuZ3VsYXJQb2x5Y29uaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwYXJhbGxlbDEocmVjdGFuZ3VsYXJQb2x5Y29uaWNSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTMxLjIxNSk7XG4gICAgfTtcbiAgICB2YXIgSyA9IFtcbiAgICAgICAgWzAuOTk4NiwgLTAuMDYyXSxcbiAgICAgICAgWzEuMDAwMCwgMC4wMDAwXSxcbiAgICAgICAgWzAuOTk4NiwgMC4wNjIwXSxcbiAgICAgICAgWzAuOTk1NCwgMC4xMjQwXSxcbiAgICAgICAgWzAuOTkwMCwgMC4xODYwXSxcbiAgICAgICAgWzAuOTgyMiwgMC4yNDgwXSxcbiAgICAgICAgWzAuOTczMCwgMC4zMTAwXSxcbiAgICAgICAgWzAuOTYwMCwgMC4zNzIwXSxcbiAgICAgICAgWzAuOTQyNywgMC40MzQwXSxcbiAgICAgICAgWzAuOTIxNiwgMC40OTU4XSxcbiAgICAgICAgWzAuODk2MiwgMC41NTcxXSxcbiAgICAgICAgWzAuODY3OSwgMC42MTc2XSxcbiAgICAgICAgWzAuODM1MCwgMC42NzY5XSxcbiAgICAgICAgWzAuNzk4NiwgMC43MzQ2XSxcbiAgICAgICAgWzAuNzU5NywgMC43OTAzXSxcbiAgICAgICAgWzAuNzE4NiwgMC44NDM1XSxcbiAgICAgICAgWzAuNjczMiwgMC44OTM2XSxcbiAgICAgICAgWzAuNjIxMywgMC45Mzk0XSxcbiAgICAgICAgWzAuNTcyMiwgMC45NzYxXSxcbiAgICAgICAgWzAuNTMyMiwgMS4wMDAwXVxuICAgIF07XG4gICAgSy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGRbMV0gKj0gMS4wMTQ0O1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJvYmluc29uUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBpID0gbWluKDE4LCBhYnMocGhpKSAqIDM2IC8gcGkpLCBpMCA9IGZsb29yKGkpLCBkaSA9IGkgLSBpMCwgYXggPSAoayA9IEtbaTBdKVswXSwgYXkgPSBrWzFdLCBieCA9IChrID0gS1srK2kwXSlbMF0sIGJ5ID0ga1sxXSwgY3ggPSAoayA9IEtbbWluKDE5LCArK2kwKV0pWzBdLCBjeSA9IGtbMV0sIGs7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsYW1iZGEgKiAoYnggKyBkaSAqIChjeCAtIGF4KSAvIDIgKyBkaSAqIGRpICogKGN4IC0gMiAqIGJ4ICsgYXgpIC8gMiksXG4gICAgICAgICAgICAocGhpID4gMCA/IGhhbGZQaSA6IC1oYWxmUGkpICogKGJ5ICsgZGkgKiAoY3kgLSBheSkgLyAyICsgZGkgKiBkaSAqIChjeSAtIDIgKiBieSArIGF5KSAvIDIpXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJvYmluc29uUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB5eSA9IHkgLyBoYWxmUGksIHBoaSA9IHl5ICogOTAsIGkgPSBtaW4oMTgsIGFicyhwaGkgLyA1KSksIGkwID0gbWF4KDAsIGZsb29yKGkpKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIGF5ID0gS1tpMF1bMV0sIGJ5ID0gS1tpMCArIDFdWzFdLCBjeSA9IEtbbWluKDE5LCBpMCArIDIpXVsxXSwgdSA9IGN5IC0gYXksIHYgPSBjeSAtIDIgKiBieSArIGF5LCB0ID0gMiAqIChhYnMoeXkpIC0gYnkpIC8gdSwgYyA9IHYgLyB1LCBkaSA9IHQgKiAoMSAtIGMgKiB0ICogKDEgLSAyICogYyAqIHQpKTtcbiAgICAgICAgICAgIGlmIChkaSA+PSAwIHx8IGkwID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcGhpID0gKHkgPj0gMCA/IDUgOiAtNSkgKiAoZGkgKyBpKTtcbiAgICAgICAgICAgICAgICB2YXIgaiA9IDUwLCBkZWx0YTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBtaW4oMTgsIGFicyhwaGkpIC8gNSk7XG4gICAgICAgICAgICAgICAgICAgIGkwID0gZmxvb3IoaSk7XG4gICAgICAgICAgICAgICAgICAgIGRpID0gaSAtIGkwO1xuICAgICAgICAgICAgICAgICAgICBheSA9IEtbaTBdWzFdO1xuICAgICAgICAgICAgICAgICAgICBieSA9IEtbaTAgKyAxXVsxXTtcbiAgICAgICAgICAgICAgICAgICAgY3kgPSBLW21pbigxOSwgaTAgKyAyKV1bMV07XG4gICAgICAgICAgICAgICAgICAgIHBoaSAtPSAoZGVsdGEgPSAoeSA+PSAwID8gaGFsZlBpIDogLWhhbGZQaSkgKiAoYnkgKyBkaSAqIChjeSAtIGF5KSAvIDIgKyBkaSAqIGRpICogKGN5IC0gMiAqIGJ5ICsgYXkpIC8gMikgLSB5KSAqIGRlZ3JlZXM7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24yICYmIC0taiA+IDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgtLWkwID49IDApO1xuICAgICAgICB2YXIgYXggPSBLW2kwXVswXSwgYnggPSBLW2kwICsgMV1bMF0sIGN4ID0gS1ttaW4oMTksIGkwICsgMildWzBdO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeCAvIChieCArIGRpICogKGN4IC0gYXgpIC8gMiArIGRpICogZGkgKiAoY3ggLSAyICogYnggKyBheCkgLyAyKSxcbiAgICAgICAgICAgIHBoaSAqIHJhZGlhbnNcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHZhciByb2JpbnNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24ocm9iaW5zb25SYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTUyLjYzKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHNhdGVsbGl0ZVZlcnRpY2FsUmF3KFApIHtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLCBrID0gKFAgLSAxKSAvIChQIC0gY29zUGhpICogY29zKGxhbWJkYSkpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBrICogY29zUGhpICogc2luKGxhbWJkYSksXG4gICAgICAgICAgICAgICAgayAqIHNpbihwaGkpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciByaG8yID0geCAqIHggKyB5ICogeSwgcmhvID0gc3FydChyaG8yKSwgc2luYyA9IChQIC0gc3FydCgxIC0gcmhvMiAqIChQICsgMSkgLyAoUCAtIDEpKSkgLyAoKFAgLSAxKSAvIHJobyArIHJobyAvIChQIC0gMSkpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBhdGFuMih4ICogc2luYywgcmhvICogc3FydCgxIC0gc2luYyAqIHNpbmMpKSxcbiAgICAgICAgICAgICAgICByaG8gPyBhc2luKHkgKiBzaW5jIC8gcmhvKSA6IDBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzYXRlbGxpdGVSYXcoUCwgb21lZ2EpIHtcbiAgICAgICAgdmFyIHZlcnRpY2FsID0gc2F0ZWxsaXRlVmVydGljYWxSYXcoUCk7XG4gICAgICAgIGlmICghb21lZ2EpXG4gICAgICAgICAgICByZXR1cm4gdmVydGljYWw7XG4gICAgICAgIHZhciBjb3NPbWVnYSA9IGNvcyhvbWVnYSksIHNpbk9tZWdhID0gc2luKG9tZWdhKTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gdmVydGljYWwobGFtYmRhLCBwaGkpLCB5ID0gY29vcmRpbmF0ZXNbMV0sIEEgPSB5ICogc2luT21lZ2EgLyAoUCAtIDEpICsgY29zT21lZ2E7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzWzBdICogY29zT21lZ2EgLyBBLFxuICAgICAgICAgICAgICAgIHkgLyBBXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBrID0gKFAgLSAxKSAvIChQIC0gMSAtIHkgKiBzaW5PbWVnYSk7XG4gICAgICAgICAgICByZXR1cm4gdmVydGljYWwuaW52ZXJ0KGsgKiB4LCBrICogeSAqIGNvc09tZWdhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIHZhciBzYXRlbGxpdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IDIsIG9tZWdhID0gMCwgbSA9IGQzR2VvLmdlb1Byb2plY3Rpb25NdXRhdG9yKHNhdGVsbGl0ZVJhdyksIHAgPSBtKGRpc3RhbmNlLCBvbWVnYSk7XG4gICAgICAgIC8vIEFzIGEgbXVsdGlwbGUgb2YgcmFkaXVzLlxuICAgICAgICBwLmRpc3RhbmNlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlzdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gbShkaXN0YW5jZSA9ICtfLCBvbWVnYSk7XG4gICAgICAgIH07XG4gICAgICAgIHAudGlsdCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9tZWdhICogZGVncmVlcztcbiAgICAgICAgICAgIHJldHVybiBtKGRpc3RhbmNlLCBvbWVnYSA9IF8gKiByYWRpYW5zKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBcbiAgICAgICAgICAgIC5zY2FsZSg0MzIuMTQ3KVxuICAgICAgICAgICAgLmNsaXBBbmdsZShhY29zKDEgLyBkaXN0YW5jZSkgKiBkZWdyZWVzIC0gMWUtNik7XG4gICAgfTtcbiAgICB2YXIgZXBzaWxvbiQxID0gMWUtNDtcbiAgICB2YXIgZXBzaWxvbkludmVyc2UgPSAxZTQ7XG4gICAgdmFyIHgwID0gLTE4MDtcbiAgICB2YXIgeDBlID0geDAgKyBlcHNpbG9uJDE7XG4gICAgdmFyIHgxID0gMTgwO1xuICAgIHZhciB4MWUgPSB4MSAtIGVwc2lsb24kMTtcbiAgICB2YXIgeTAgPSAtOTA7XG4gICAgdmFyIHkwZSA9IHkwICsgZXBzaWxvbiQxO1xuICAgIHZhciB5MSA9IDkwO1xuICAgIHZhciB5MWUgPSB5MSAtIGVwc2lsb24kMTtcbiAgICBmdW5jdGlvbiBub25lbXB0eShjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVhbnRpemUkMSh4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHggKiBlcHNpbG9uSW52ZXJzZSkgLyBlcHNpbG9uSW52ZXJzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUG9pbnQoeSkge1xuICAgICAgICByZXR1cm4geSA9PT0geTAgfHwgeSA9PT0geTEgPyBbMCwgeV0gOiBbeDAsIHF1YW50aXplJDEoeSldOyAvLyBwb2xlIG9yIGFudGltZXJpZGlhbj9cbiAgICB9XG4gICAgZnVuY3Rpb24gY2xhbXBQb2ludChwKSB7XG4gICAgICAgIHZhciB4ID0gcFswXSwgeSA9IHBbMV0sIGNsYW1wZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHggPD0geDBlKVxuICAgICAgICAgICAgeCA9IHgwLCBjbGFtcGVkID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoeCA+PSB4MWUpXG4gICAgICAgICAgICB4ID0geDEsIGNsYW1wZWQgPSB0cnVlO1xuICAgICAgICBpZiAoeSA8PSB5MGUpXG4gICAgICAgICAgICB5ID0geTAsIGNsYW1wZWQgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmICh5ID49IHkxZSlcbiAgICAgICAgICAgIHkgPSB5MSwgY2xhbXBlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBjbGFtcGVkID8gW3gsIHldIDogcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xhbXBQb2ludHMocG9pbnRzKSB7XG4gICAgICAgIHJldHVybiBwb2ludHMubWFwKGNsYW1wUG9pbnQpO1xuICAgIH1cbiAgICAvLyBGb3IgZWFjaCByaW5nLCBkZXRlY3Qgd2hlcmUgaXQgY3Jvc3NlcyB0aGUgYW50aW1lcmlkaWFuIG9yIHBvbGUuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyYWdtZW50cyhyaW5ncywgcG9seWdvbiwgZnJhZ21lbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBtID0gcmluZ3MubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICB2YXIgcmluZyA9IHJpbmdzW2pdLnNsaWNlKCk7XG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBhc3N1bWUgdGhhdCB0aGlzIHJpbmcgZG9lc27igJl0IG5lZWQgYW55IHN0aXRjaGluZy5cbiAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKHsgaW5kZXg6IC0xLCBwb2x5Z29uOiBwb2x5Z29uLCByaW5nOiByaW5nIH0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSByaW5nLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHJpbmdbaV0sIHggPSBwb2ludFswXSwgeSA9IHBvaW50WzFdO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYW4gYW50aW1lcmlkaWFuIG9yIHBvbGFyIHBvaW504oCmXG4gICAgICAgICAgICAgICAgaWYgKHggPD0geDBlIHx8IHggPj0geDFlIHx8IHkgPD0geTBlIHx8IHkgPj0geTFlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpbmdbaV0gPSBjbGFtcFBvaW50KHBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0aHJvdWdoIGFueSBhbnRpbWVyaWRpYW4gb3IgcG9sYXIgcG9pbnRz4oCmXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSBpICsgMTsgayA8IG47ICsraykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ayA9IHJpbmdba10sIHhrID0gcG9pbnRrWzBdLCB5ayA9IHBvaW50a1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4ayA+IHgwZSAmJiB4ayA8IHgxZSAmJiB5ayA+IHkwZSAmJiB5ayA8IHkxZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBqdXN0IGEgc2luZ2xlIGFudGltZXJpZGlhbiBvciBwb2xhciBwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9u4oCZdCBuZWVkIHRvIGN1dCB0aGlzIHJpbmcgaW50byBhIGZyYWdtZW50O1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ganVzdCBsZWF2ZSBpdCBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGsgPT09IGkgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhpcyBpcyBub3QgdGhlIGZpcnN0IHBvaW50IGluIHRoZSByaW5nLFxuICAgICAgICAgICAgICAgICAgICAvLyBjdXQgdGhlIGN1cnJlbnQgZnJhZ21lbnQgc28gdGhhdCBpdCBlbmRzIGF0IHRoZSBjdXJyZW50IHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBwb2ludCBpcyBhbHNvIG5vcm1hbGl6ZWQgZm9yIGxhdGVyIGpvaW5pbmcuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnRCZWZvcmUgPSB7IGluZGV4OiAtMSwgcG9seWdvbjogcG9seWdvbiwgcmluZzogcmluZy5zbGljZSgwLCBpICsgMSkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50QmVmb3JlLnJpbmdbZnJhZ21lbnRCZWZvcmUucmluZy5sZW5ndGggLSAxXSA9IG5vcm1hbGl6ZVBvaW50KHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRzW2ZyYWdtZW50cy5sZW5ndGggLSAxXSA9IGZyYWdtZW50QmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSByaW5nIHN0YXJ0ZWQgd2l0aCBhbiBhbnRpbWVyaWRpYW4gZnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBpZ25vcmUgdGhhdCBmcmFnbWVudCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVtYWluZGVyIG9mIHRoZSByaW5nIGlzIGFuIGFudGltZXJpZGlhbiBmcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSBvbiB0byB0aGUgbmV4dCByaW5nLlxuICAgICAgICAgICAgICAgICAgICBpZiAoayA+PSBuKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgYWRkIHRoZSByZW1haW5pbmcgcmluZyBmcmFnbWVudCBhbmQgY29udGludWUuXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKHsgaW5kZXg6IC0xLCBwb2x5Z29uOiBwb2x5Z29uLCByaW5nOiByaW5nID0gcmluZy5zbGljZShrIC0gMSkgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJpbmdbMF0gPSBub3JtYWxpemVQb2ludChyaW5nWzBdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBuID0gcmluZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5vdyBzdGl0Y2ggdGhlIGZyYWdtZW50cyBiYWNrIHRvZ2V0aGVyIGludG8gcmluZ3MuXG4gICAgZnVuY3Rpb24gc3RpdGNoRnJhZ21lbnRzKGZyYWdtZW50cykge1xuICAgICAgICB2YXIgaSwgbiA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgICAgIC8vIFRvIGNvbm5lY3QgdGhlIGZyYWdtZW50cyBzdGFydC10by1lbmQsIGNyZWF0ZSBhIHNpbXBsZSBpbmRleCBieSBlbmQuXG4gICAgICAgIHZhciBmcmFnbWVudEJ5U3RhcnQgPSB7fSwgZnJhZ21lbnRCeUVuZCA9IHt9LCBmcmFnbWVudCwgc3RhcnQsIHN0YXJ0RnJhZ21lbnQsIGVuZCwgZW5kRnJhZ21lbnQ7XG4gICAgICAgIC8vIEZvciBlYWNoIGZyYWdtZW504oCmXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgc3RhcnQgPSBmcmFnbWVudC5yaW5nWzBdO1xuICAgICAgICAgICAgZW5kID0gZnJhZ21lbnQucmluZ1tmcmFnbWVudC5yaW5nLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBmcmFnbWVudCBpcyBjbG9zZWQsIGFkZCBpdCBhcyBhIHN0YW5kYWxvbmUgcmluZy5cbiAgICAgICAgICAgIGlmIChzdGFydFswXSA9PT0gZW5kWzBdICYmIHN0YXJ0WzFdID09PSBlbmRbMV0pIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5wb2x5Z29uLnB1c2goZnJhZ21lbnQucmluZyk7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnRzW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyYWdtZW50LmluZGV4ID0gaTtcbiAgICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtzdGFydF0gPSBmcmFnbWVudEJ5RW5kW2VuZF0gPSBmcmFnbWVudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgZWFjaCBvcGVuIGZyYWdtZW504oCmXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBmcmFnbWVudC5yaW5nWzBdO1xuICAgICAgICAgICAgICAgIGVuZCA9IGZyYWdtZW50LnJpbmdbZnJhZ21lbnQucmluZy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBzdGFydEZyYWdtZW50ID0gZnJhZ21lbnRCeUVuZFtzdGFydF07XG4gICAgICAgICAgICAgICAgZW5kRnJhZ21lbnQgPSBmcmFnbWVudEJ5U3RhcnRbZW5kXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W3N0YXJ0XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtlbmRdO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgZnJhZ21lbnQgaXMgY2xvc2VkLCBhZGQgaXQgYXMgYSBzdGFuZGFsb25lIHJpbmcuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0WzBdID09PSBlbmRbMF0gJiYgc3RhcnRbMV0gPT09IGVuZFsxXSkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5wb2x5Z29uLnB1c2goZnJhZ21lbnQucmluZyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtzdGFydF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbc3RhcnRGcmFnbWVudC5yaW5nWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRGcmFnbWVudC5yaW5nLnBvcCgpOyAvLyBkcm9wIHRoZSBzaGFyZWQgY29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudHNbc3RhcnRGcmFnbWVudC5pbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHsgaW5kZXg6IC0xLCBwb2x5Z29uOiBzdGFydEZyYWdtZW50LnBvbHlnb24sIHJpbmc6IHN0YXJ0RnJhZ21lbnQucmluZy5jb25jYXQoZnJhZ21lbnQucmluZykgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0RnJhZ21lbnQgPT09IGVuZEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25uZWN0IGJvdGggZW5kcyB0byB0aGlzIHNpbmdsZSBmcmFnbWVudCB0byBjcmVhdGUgYSByaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQucG9seWdvbi5wdXNoKGZyYWdtZW50LnJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuaW5kZXggPSBuKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudHMucHVzaChmcmFnbWVudEJ5U3RhcnRbZnJhZ21lbnQucmluZ1swXV0gPSBmcmFnbWVudEJ5RW5kW2ZyYWdtZW50LnJpbmdbZnJhZ21lbnQucmluZy5sZW5ndGggLSAxXV0gPSBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZW5kRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtlbmRdO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtlbmRGcmFnbWVudC5yaW5nW2VuZEZyYWdtZW50LnJpbmcubGVuZ3RoIC0gMV1dO1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5yaW5nLnBvcCgpOyAvLyBkcm9wIHRoZSBzaGFyZWQgY29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHsgaW5kZXg6IG4rKywgcG9seWdvbjogZW5kRnJhZ21lbnQucG9seWdvbiwgcmluZzogZnJhZ21lbnQucmluZy5jb25jYXQoZW5kRnJhZ21lbnQucmluZykgfTtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRzW2VuZEZyYWdtZW50LmluZGV4XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKGZyYWdtZW50QnlTdGFydFtmcmFnbWVudC5yaW5nWzBdXSA9IGZyYWdtZW50QnlFbmRbZnJhZ21lbnQucmluZ1tmcmFnbWVudC5yaW5nLmxlbmd0aCAtIDFdXSA9IGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LnJpbmcucHVzaChmcmFnbWVudC5yaW5nWzBdKTsgLy8gY2xvc2UgcmluZ1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5wb2x5Z29uLnB1c2goZnJhZ21lbnQucmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0aXRjaEZlYXR1cmUoaW5wdXQpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHsgdHlwZTogXCJGZWF0dXJlXCIsIGdlb21ldHJ5OiBzdGl0Y2hHZW9tZXRyeShpbnB1dC5nZW9tZXRyeSkgfTtcbiAgICAgICAgaWYgKGlucHV0LmlkICE9IG51bGwpXG4gICAgICAgICAgICBvdXRwdXQuaWQgPSBpbnB1dC5pZDtcbiAgICAgICAgaWYgKGlucHV0LmJib3ggIT0gbnVsbClcbiAgICAgICAgICAgIG91dHB1dC5iYm94ID0gaW5wdXQuYmJveDtcbiAgICAgICAgaWYgKGlucHV0LnByb3BlcnRpZXMgIT0gbnVsbClcbiAgICAgICAgICAgIG91dHB1dC5wcm9wZXJ0aWVzID0gaW5wdXQucHJvcGVydGllcztcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RpdGNoR2VvbWV0cnkoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIHZhciBvdXRwdXQsIGZyYWdtZW50cywgaSwgbjtcbiAgICAgICAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0geyB0eXBlOiBcIkdlb21ldHJ5Q29sbGVjdGlvblwiLCBnZW9tZXRyaWVzOiBpbnB1dC5nZW9tZXRyaWVzLm1hcChzdGl0Y2hHZW9tZXRyeSkgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgdHlwZTogXCJQb2ludFwiLCBjb29yZGluYXRlczogY2xhbXBQb2ludChpbnB1dC5jb29yZGluYXRlcykgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6XG4gICAgICAgICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgdHlwZTogaW5wdXQudHlwZSwgY29vcmRpbmF0ZXM6IGNsYW1wUG9pbnRzKGlucHV0LmNvb3JkaW5hdGVzKSB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IHsgdHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGlucHV0LmNvb3JkaW5hdGVzLm1hcChjbGFtcFBvaW50cykgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJQb2x5Z29uXCI6IHtcbiAgICAgICAgICAgICAgICB2YXIgcG9seWdvbiA9IFtdO1xuICAgICAgICAgICAgICAgIGV4dHJhY3RGcmFnbWVudHMoaW5wdXQuY29vcmRpbmF0ZXMsIHBvbHlnb24sIGZyYWdtZW50cyA9IFtdKTtcbiAgICAgICAgICAgICAgICBzdGl0Y2hGcmFnbWVudHMoZnJhZ21lbnRzKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7IHR5cGU6IFwiUG9seWdvblwiLCBjb29yZGluYXRlczogcG9seWdvbiB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnRzID0gW10sIGkgPSAtMSwgbiA9IGlucHV0LmNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgcG9seWdvbnMgPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RGcmFnbWVudHMoaW5wdXQuY29vcmRpbmF0ZXNbaV0sIHBvbHlnb25zW2ldID0gW10sIGZyYWdtZW50cyk7XG4gICAgICAgICAgICAgICAgc3RpdGNoRnJhZ21lbnRzKGZyYWdtZW50cyk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0geyB0eXBlOiBcIk11bHRpUG9seWdvblwiLCBjb29yZGluYXRlczogcG9seWdvbnMuZmlsdGVyKG5vbmVtcHR5KSB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dC5iYm94ICE9IG51bGwpXG4gICAgICAgICAgICBvdXRwdXQuYmJveCA9IGlucHV0LmJib3g7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIHZhciBzdGl0Y2ggPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIHN3aXRjaCAoaW5wdXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIkZlYXR1cmVcIjogcmV0dXJuIHN0aXRjaEZlYXR1cmUoaW5wdXQpO1xuICAgICAgICAgICAgY2FzZSBcIkZlYXR1cmVDb2xsZWN0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0geyB0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsIGZlYXR1cmVzOiBpbnB1dC5mZWF0dXJlcy5tYXAoc3RpdGNoRmVhdHVyZSkgfTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuYmJveCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYmJveCA9IGlucHV0LmJib3g7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBzdGl0Y2hHZW9tZXRyeShpbnB1dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHRpbWVzUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciB0ID0gdGFuKHBoaSAvIDIpLCBzID0gc2luKHF1YXJ0ZXJQaSAqIHQpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbGFtYmRhICogKDAuNzQ0ODIgLSAwLjM0NTg4ICogcyAqIHMpLFxuICAgICAgICAgICAgMS43MDcxMSAqIHRcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdGltZXNSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIHQgPSB5IC8gMS43MDcxMSwgcyA9IHNpbihxdWFydGVyUGkgKiB0KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHggLyAoMC43NDQ4MiAtIDAuMzQ1ODggKiBzICogcyksXG4gICAgICAgICAgICAyICogYXRhbih0KVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIHRpbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbih0aW1lc1JhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNDYuMTUzKTtcbiAgICB9O1xuICAgIC8vIENvbXB1dGUgdGhlIG9yaWdpbiBhcyB0aGUgbWlkcG9pbnQgb2YgdGhlIHR3byByZWZlcmVuY2UgcG9pbnRzLlxuICAgIC8vIFJvdGF0ZSBvbmUgb2YgdGhlIHJlZmVyZW5jZSBwb2ludHMgYnkgdGhlIG9yaWdpbi5cbiAgICAvLyBBcHBseSB0aGUgc3BoZXJpY2FsIGxhdyBvZiBzaW5lcyB0byBjb21wdXRlIGdhbW1hIHJvdGF0aW9uLlxuICAgIHZhciB0d29Qb2ludCA9IGZ1bmN0aW9uIChyYXcsIHAwLCBwMSkge1xuICAgICAgICB2YXIgaSA9IGQzR2VvLmdlb0ludGVycG9sYXRlKHAwLCBwMSksIG8gPSBpKDAuNSksIGEgPSBkM0dlby5nZW9Sb3RhdGlvbihbLW9bMF0sIC1vWzFdXSkocDApLCBiID0gaS5kaXN0YW5jZSAvIDIsIHkgPSAtYXNpbihzaW4oYVsxXSAqIHJhZGlhbnMpIC8gc2luKGIpKSwgUiA9IFstb1swXSwgLW9bMV0sIC0oYVswXSA+IDAgPyBwaSAtIHkgOiB5KSAqIGRlZ3JlZXNdLCBwID0gZDNHZW8uZ2VvUHJvamVjdGlvbihyYXcoYikpLnJvdGF0ZShSKSwgciA9IGQzR2VvLmdlb1JvdGF0aW9uKFIpLCBjZW50ZXIgPSBwLmNlbnRlcjtcbiAgICAgICAgZGVsZXRlIHAucm90YXRlO1xuICAgICAgICBwLmNlbnRlciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGNlbnRlcihyKF8pKSA6IHIuaW52ZXJ0KGNlbnRlcigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoOTApO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdHdvUG9pbnRBemltdXRoYWxSYXcoZCkge1xuICAgICAgICB2YXIgY29zZCA9IGNvcyhkKTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gZDNHZW8uZ2VvR25vbW9uaWNSYXcobGFtYmRhLCBwaGkpO1xuICAgICAgICAgICAgY29vcmRpbmF0ZXNbMF0gKj0gY29zZDtcbiAgICAgICAgICAgIHJldHVybiBjb29yZGluYXRlcztcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gZDNHZW8uZ2VvR25vbW9uaWNSYXcuaW52ZXJ0KHggLyBjb3NkLCB5KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHR3b1BvaW50QXppbXV0aGFsVXNhKCkge1xuICAgICAgICByZXR1cm4gdHdvUG9pbnRBemltdXRoYWwoWy0xNTgsIDIxLjVdLCBbLTc3LCAzOV0pXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDYwKVxuICAgICAgICAgICAgLnNjYWxlKDQwMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHR3b1BvaW50QXppbXV0aGFsKHAwLCBwMSkge1xuICAgICAgICByZXR1cm4gdHdvUG9pbnQodHdvUG9pbnRBemltdXRoYWxSYXcsIHAwLCBwMSk7XG4gICAgfVxuICAgIC8vIFRPRE8gY2xpcCB0byBlbGxpcHNlXG4gICAgZnVuY3Rpb24gdHdvUG9pbnRFcXVpZGlzdGFudFJhdyh6MCkge1xuICAgICAgICBpZiAoISh6MCAqPSAyKSlcbiAgICAgICAgICAgIHJldHVybiBkM0dlby5nZW9BemltdXRoYWxFcXVpZGlzdGFudFJhdztcbiAgICAgICAgdmFyIGxhbWJkYWEgPSAtejAgLyAyLCBsYW1iZGFiID0gLWxhbWJkYWEsIHowMiA9IHowICogejAsIHRhbkxhbWJkYTAgPSB0YW4obGFtYmRhYiksIFMgPSAwLjUgLyBzaW4obGFtYmRhYik7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciB6YSA9IGFjb3MoY29zKHBoaSkgKiBjb3MobGFtYmRhIC0gbGFtYmRhYSkpLCB6YiA9IGFjb3MoY29zKHBoaSkgKiBjb3MobGFtYmRhIC0gbGFtYmRhYikpLCB5cyA9IHBoaSA8IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICB6YSAqPSB6YSwgemIgKj0gemI7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICh6YSAtIHpiKSAvICgyICogejApLFxuICAgICAgICAgICAgICAgIHlzICogc3FydCg0ICogejAyICogemIgLSAoejAyIC0gemEgKyB6YikgKiAoejAyIC0gemEgKyB6YikpIC8gKDIgKiB6MClcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHkyID0geSAqIHksIGNvc3phID0gY29zKHNxcnQoeTIgKyAodCA9IHggKyBsYW1iZGFhKSAqIHQpKSwgY29zemIgPSBjb3Moc3FydCh5MiArICh0ID0geCArIGxhbWJkYWIpICogdCkpLCB0LCBkO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBhdGFuMihkID0gY29zemEgLSBjb3N6YiwgdCA9IChjb3N6YSArIGNvc3piKSAqIHRhbkxhbWJkYTApLFxuICAgICAgICAgICAgICAgICh5IDwgMCA/IC0xIDogMSkgKiBhY29zKHNxcnQodCAqIHQgKyBkICogZCkgKiBTKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHR3b1BvaW50RXF1aWRpc3RhbnRVc2EoKSB7XG4gICAgICAgIHJldHVybiB0d29Qb2ludEVxdWlkaXN0YW50KFstMTU4LCAyMS41XSwgWy03NywgMzldKVxuICAgICAgICAgICAgLmNsaXBBbmdsZSgxMzApXG4gICAgICAgICAgICAuc2NhbGUoMTIyLjU3MSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHR3b1BvaW50RXF1aWRpc3RhbnQocDAsIHAxKSB7XG4gICAgICAgIHJldHVybiB0d29Qb2ludCh0d29Qb2ludEVxdWlkaXN0YW50UmF3LCBwMCwgcDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YW5EZXJHcmludGVuUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGlmIChhYnMocGhpKSA8IGVwc2lsb24pXG4gICAgICAgICAgICByZXR1cm4gW2xhbWJkYSwgMF07XG4gICAgICAgIHZhciBzaW5UaGV0YSA9IGFicyhwaGkgLyBoYWxmUGkpLCB0aGV0YSA9IGFzaW4oc2luVGhldGEpO1xuICAgICAgICBpZiAoYWJzKGxhbWJkYSkgPCBlcHNpbG9uIHx8IGFicyhhYnMocGhpKSAtIGhhbGZQaSkgPCBlcHNpbG9uKVxuICAgICAgICAgICAgcmV0dXJuIFswLCBzaWduKHBoaSkgKiBwaSAqIHRhbih0aGV0YSAvIDIpXTtcbiAgICAgICAgdmFyIGNvc1RoZXRhID0gY29zKHRoZXRhKSwgQSA9IGFicyhwaSAvIGxhbWJkYSAtIGxhbWJkYSAvIHBpKSAvIDIsIEEyID0gQSAqIEEsIEcgPSBjb3NUaGV0YSAvIChzaW5UaGV0YSArIGNvc1RoZXRhIC0gMSksIFAgPSBHICogKDIgLyBzaW5UaGV0YSAtIDEpLCBQMiA9IFAgKiBQLCBQMl9BMiA9IFAyICsgQTIsIEdfUDIgPSBHIC0gUDIsIFEgPSBBMiArIEc7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBzaWduKGxhbWJkYSkgKiBwaSAqIChBICogR19QMiArIHNxcnQoQTIgKiBHX1AyICogR19QMiAtIFAyX0EyICogKEcgKiBHIC0gUDIpKSkgLyBQMl9BMixcbiAgICAgICAgICAgIHNpZ24ocGhpKSAqIHBpICogKFAgKiBRIC0gQSAqIHNxcnQoKEEyICsgMSkgKiBQMl9BMiAtIFEgKiBRKSkgLyBQMl9BMlxuICAgICAgICBdO1xuICAgIH1cbiAgICB2YW5EZXJHcmludGVuUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmIChhYnMoeSkgPCBlcHNpbG9uKVxuICAgICAgICAgICAgcmV0dXJuIFt4LCAwXTtcbiAgICAgICAgaWYgKGFicyh4KSA8IGVwc2lsb24pXG4gICAgICAgICAgICByZXR1cm4gWzAsIGhhbGZQaSAqIHNpbigyICogYXRhbih5IC8gcGkpKV07XG4gICAgICAgIHZhciB4MiA9ICh4IC89IHBpKSAqIHgsIHkyID0gKHkgLz0gcGkpICogeSwgeDJfeTIgPSB4MiArIHkyLCB6ID0geDJfeTIgKiB4Ml95MiwgYzEgPSAtYWJzKHkpICogKDEgKyB4Ml95MiksIGMyID0gYzEgLSAyICogeTIgKyB4MiwgYzMgPSAtMiAqIGMxICsgMSArIDIgKiB5MiArIHosIGQgPSB5MiAvIGMzICsgKDIgKiBjMiAqIGMyICogYzIgLyAoYzMgKiBjMyAqIGMzKSAtIDkgKiBjMSAqIGMyIC8gKGMzICogYzMpKSAvIDI3LCBhMSA9IChjMSAtIGMyICogYzIgLyAoMyAqIGMzKSkgLyBjMywgbTEgPSAyICogc3FydCgtYTEgLyAzKSwgdGhldGExID0gYWNvcygzICogZCAvIChhMSAqIG0xKSkgLyAzO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcGkgKiAoeDJfeTIgLSAxICsgc3FydCgxICsgMiAqICh4MiAtIHkyKSArIHopKSAvICgyICogeCksXG4gICAgICAgICAgICBzaWduKHkpICogcGkgKiAoLW0xICogY29zKHRoZXRhMSArIHBpIC8gMykgLSBjMiAvICgzICogYzMpKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIHZhbkRlckdyaW50ZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKHZhbkRlckdyaW50ZW5SYXcpXG4gICAgICAgICAgICAuc2NhbGUoNzkuNDE4Myk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB2YW5EZXJHcmludGVuMlJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICBpZiAoYWJzKHBoaSkgPCBlcHNpbG9uKVxuICAgICAgICAgICAgcmV0dXJuIFtsYW1iZGEsIDBdO1xuICAgICAgICB2YXIgc2luVGhldGEgPSBhYnMocGhpIC8gaGFsZlBpKSwgdGhldGEgPSBhc2luKHNpblRoZXRhKTtcbiAgICAgICAgaWYgKGFicyhsYW1iZGEpIDwgZXBzaWxvbiB8fCBhYnMoYWJzKHBoaSkgLSBoYWxmUGkpIDwgZXBzaWxvbilcbiAgICAgICAgICAgIHJldHVybiBbMCwgc2lnbihwaGkpICogcGkgKiB0YW4odGhldGEgLyAyKV07XG4gICAgICAgIHZhciBjb3NUaGV0YSA9IGNvcyh0aGV0YSksIEEgPSBhYnMocGkgLyBsYW1iZGEgLSBsYW1iZGEgLyBwaSkgLyAyLCBBMiA9IEEgKiBBLCB4MSA9IGNvc1RoZXRhICogKHNxcnQoMSArIEEyKSAtIEEgKiBjb3NUaGV0YSkgLyAoMSArIEEyICogc2luVGhldGEgKiBzaW5UaGV0YSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBzaWduKGxhbWJkYSkgKiBwaSAqIHgxLFxuICAgICAgICAgICAgc2lnbihwaGkpICogcGkgKiBzcXJ0KDEgLSB4MSAqICgyICogQSArIHgxKSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFuRGVyR3JpbnRlbjJSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKCF4KVxuICAgICAgICAgICAgcmV0dXJuIFswLCBoYWxmUGkgKiBzaW4oMiAqIGF0YW4oeSAvIHBpKSldO1xuICAgICAgICB2YXIgeDEgPSBhYnMoeCAvIHBpKSwgQSA9ICgxIC0geDEgKiB4MSAtICh5IC89IHBpKSAqIHkpIC8gKDIgKiB4MSksIEEyID0gQSAqIEEsIEIgPSBzcXJ0KEEyICsgMSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBzaWduKHgpICogcGkgKiAoQiAtIEEpLFxuICAgICAgICAgICAgc2lnbih5KSAqIGhhbGZQaSAqIHNpbigyICogYXRhbjIoc3FydCgoMSAtIDIgKiBBICogeDEpICogKEEgKyBCKSAtIHgxKSwgc3FydChCICsgQSArIHgxKSkpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICB2YXIgdmFuRGVyR3JpbnRlbjIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKHZhbkRlckdyaW50ZW4yUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDc5LjQxODMpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdmFuRGVyR3JpbnRlbjNSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgaWYgKGFicyhwaGkpIDwgZXBzaWxvbilcbiAgICAgICAgICAgIHJldHVybiBbbGFtYmRhLCAwXTtcbiAgICAgICAgdmFyIHNpblRoZXRhID0gcGhpIC8gaGFsZlBpLCB0aGV0YSA9IGFzaW4oc2luVGhldGEpO1xuICAgICAgICBpZiAoYWJzKGxhbWJkYSkgPCBlcHNpbG9uIHx8IGFicyhhYnMocGhpKSAtIGhhbGZQaSkgPCBlcHNpbG9uKVxuICAgICAgICAgICAgcmV0dXJuIFswLCBwaSAqIHRhbih0aGV0YSAvIDIpXTtcbiAgICAgICAgdmFyIEEgPSAocGkgLyBsYW1iZGEgLSBsYW1iZGEgLyBwaSkgLyAyLCB5MSA9IHNpblRoZXRhIC8gKDEgKyBjb3ModGhldGEpKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHBpICogKHNpZ24obGFtYmRhKSAqIHNxcnQoQSAqIEEgKyAxIC0geTEgKiB5MSkgLSBBKSxcbiAgICAgICAgICAgIHBpICogeTFcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFuRGVyR3JpbnRlbjNSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKCF5KVxuICAgICAgICAgICAgcmV0dXJuIFt4LCAwXTtcbiAgICAgICAgdmFyIHkxID0geSAvIHBpLCBBID0gKHBpICogcGkgKiAoMSAtIHkxICogeTEpIC0geCAqIHgpIC8gKDIgKiBwaSAqIHgpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeCA/IHBpICogKHNpZ24oeCkgKiBzcXJ0KEEgKiBBICsgMSkgLSBBKSA6IDAsXG4gICAgICAgICAgICBoYWxmUGkgKiBzaW4oMiAqIGF0YW4oeTEpKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIHZhbkRlckdyaW50ZW4zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbih2YW5EZXJHcmludGVuM1JhdylcbiAgICAgICAgICAgIC5zY2FsZSg3OS40MTgzKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHZhbkRlckdyaW50ZW40UmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGlmICghcGhpKVxuICAgICAgICAgICAgcmV0dXJuIFtsYW1iZGEsIDBdO1xuICAgICAgICB2YXIgcGhpMCA9IGFicyhwaGkpO1xuICAgICAgICBpZiAoIWxhbWJkYSB8fCBwaGkwID09PSBoYWxmUGkpXG4gICAgICAgICAgICByZXR1cm4gWzAsIHBoaV07XG4gICAgICAgIHZhciBCID0gcGhpMCAvIGhhbGZQaSwgQjIgPSBCICogQiwgQyA9ICg4ICogQiAtIEIyICogKEIyICsgMikgLSA1KSAvICgyICogQjIgKiAoQiAtIDEpKSwgQzIgPSBDICogQywgQkMgPSBCICogQywgQl9DMiA9IEIyICsgQzIgKyAyICogQkMsIEJfM0MgPSBCICsgMyAqIEMsIGxhbWJkYTAgPSBsYW1iZGEgLyBoYWxmUGksIGxhbWJkYTEgPSBsYW1iZGEwICsgMSAvIGxhbWJkYTAsIEQgPSBzaWduKGFicyhsYW1iZGEpIC0gaGFsZlBpKSAqIHNxcnQobGFtYmRhMSAqIGxhbWJkYTEgLSA0KSwgRDIgPSBEICogRCwgRiA9IEJfQzIgKiAoQjIgKyBDMiAqIEQyIC0gMSkgKyAoMSAtIEIyKSAqIChCMiAqIChCXzNDICogQl8zQyArIDQgKiBDMikgKyAxMiAqIEJDICogQzIgKyA0ICogQzIgKiBDMiksIHgxID0gKEQgKiAoQl9DMiArIEMyIC0gMSkgKyAyICogc3FydChGKSkgLyAoNCAqIEJfQzIgKyBEMik7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBzaWduKGxhbWJkYSkgKiBoYWxmUGkgKiB4MSxcbiAgICAgICAgICAgIHNpZ24ocGhpKSAqIGhhbGZQaSAqIHNxcnQoMSArIEQgKiBhYnMoeDEpIC0geDEgKiB4MSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFuRGVyR3JpbnRlbjRSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgdmFyIGRlbHRhO1xuICAgICAgICBpZiAoIXggfHwgIXkpXG4gICAgICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgICB5IC89IHBpO1xuICAgICAgICB2YXIgeDEgPSBzaWduKHgpICogeCAvIGhhbGZQaSwgRCA9ICh4MSAqIHgxIC0gMSArIDQgKiB5ICogeSkgLyBhYnMoeDEpLCBEMiA9IEQgKiBELCBCID0gMiAqIHksIGkgPSA1MDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIEIyID0gQiAqIEIsIEMgPSAoOCAqIEIgLSBCMiAqIChCMiArIDIpIC0gNSkgLyAoMiAqIEIyICogKEIgLSAxKSksIENfID0gKDMgKiBCIC0gQjIgKiBCIC0gMTApIC8gKDIgKiBCMiAqIEIpLCBDMiA9IEMgKiBDLCBCQyA9IEIgKiBDLCBCX0MgPSBCICsgQywgQl9DMiA9IEJfQyAqIEJfQywgQl8zQyA9IEIgKyAzICogQywgRiA9IEJfQzIgKiAoQjIgKyBDMiAqIEQyIC0gMSkgKyAoMSAtIEIyKSAqIChCMiAqIChCXzNDICogQl8zQyArIDQgKiBDMikgKyBDMiAqICgxMiAqIEJDICsgNCAqIEMyKSksIEZfID0gLTIgKiBCX0MgKiAoNCAqIEJDICogQzIgKyAoMSAtIDQgKiBCMiArIDMgKiBCMiAqIEIyKSAqICgxICsgQ18pICsgQzIgKiAoLTYgKyAxNCAqIEIyIC0gRDIgKyAoLTggKyA4ICogQjIgLSAyICogRDIpICogQ18pICsgQkMgKiAoLTggKyAxMiAqIEIyICsgKC0xMCArIDEwICogQjIgLSBEMikgKiBDXykpLCBzcXJ0RiA9IHNxcnQoRiksIGYgPSBEICogKEJfQzIgKyBDMiAtIDEpICsgMiAqIHNxcnRGIC0geDEgKiAoNCAqIEJfQzIgKyBEMiksIGZfID0gRCAqICgyICogQyAqIENfICsgMiAqIEJfQyAqICgxICsgQ18pKSArIEZfIC8gc3FydEYgLSA4ICogQl9DICogKEQgKiAoLTEgKyBDMiArIEJfQzIpICsgMiAqIHNxcnRGKSAqICgxICsgQ18pIC8gKEQyICsgNCAqIEJfQzIpO1xuICAgICAgICAgICAgQiAtPSBkZWx0YSA9IGYgLyBmXztcbiAgICAgICAgfSB3aGlsZSAoZGVsdGEgPiBlcHNpbG9uICYmIC0taSA+IDApO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2lnbih4KSAqIChzcXJ0KEQgKiBEICsgNCkgKyBEKSAqIHBpIC8gNCxcbiAgICAgICAgICAgIGhhbGZQaSAqIEJcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHZhciB2YW5EZXJHcmludGVuNCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24odmFuRGVyR3JpbnRlbjRSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTI3LjE2KTtcbiAgICB9O1xuICAgIHZhciBBID0gNCAqIHBpICsgMyAqIHNxcnQoMyk7XG4gICAgdmFyIEIgPSAyICogc3FydCgyICogcGkgKiBzcXJ0KDMpIC8gQSk7XG4gICAgdmFyIHdhZ25lcjRSYXcgPSBtb2xsd2VpZGVCcm9tbGV5UmF3KEIgKiBzcXJ0KDMpIC8gcGksIEIsIEEgLyA2KTtcbiAgICB2YXIgd2FnbmVyNCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24od2FnbmVyNFJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNzYuODQpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gd2FnbmVyNlJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICByZXR1cm4gW2xhbWJkYSAqIHNxcnQoMSAtIDMgKiBwaGkgKiBwaGkgLyAocGkgKiBwaSkpLCBwaGldO1xuICAgIH1cbiAgICB3YWduZXI2UmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiBbeCAvIHNxcnQoMSAtIDMgKiB5ICogeSAvIChwaSAqIHBpKSksIHldO1xuICAgIH07XG4gICAgdmFyIHdhZ25lcjYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKHdhZ25lcjZSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTUyLjYzKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHdhZ25lcjdSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIHMgPSAwLjkwNjMxICogc2luKHBoaSksIGMwID0gc3FydCgxIC0gcyAqIHMpLCBjMSA9IHNxcnQoMiAvICgxICsgYzAgKiBjb3MobGFtYmRhIC89IDMpKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAyLjY2NzIzICogYzAgKiBjMSAqIHNpbihsYW1iZGEpLFxuICAgICAgICAgICAgMS4yNDEwNCAqIHMgKiBjMVxuICAgICAgICBdO1xuICAgIH1cbiAgICB3YWduZXI3UmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciB0MSA9IHggLyAyLjY2NzIzLCB0MiA9IHkgLyAxLjI0MTA0LCBwID0gc3FydCh0MSAqIHQxICsgdDIgKiB0MiksIGMgPSAyICogYXNpbihwIC8gMik7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAzICogYXRhbjIoeCAqIHRhbihjKSwgMi42NjcyMyAqIHApLFxuICAgICAgICAgICAgcCAmJiBhc2luKHkgKiBzaW4oYykgLyAoMS4yNDEwNCAqIDAuOTA2MzEgKiBwKSlcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIHZhciB3YWduZXI3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZDNHZW8uZ2VvUHJvamVjdGlvbih3YWduZXI3UmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE3Mi42MzIpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gd2llY2hlbFJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgY29zUGhpID0gY29zKHBoaSksIHNpblBoaSA9IGNvcyhsYW1iZGEpICogY29zUGhpLCBzaW4xX1BoaSA9IDEgLSBzaW5QaGksIGNvc0xhbWJkYSA9IGNvcyhsYW1iZGEgPSBhdGFuMihzaW4obGFtYmRhKSAqIGNvc1BoaSwgLXNpbihwaGkpKSksIHNpbkxhbWJkYSA9IHNpbihsYW1iZGEpO1xuICAgICAgICBjb3NQaGkgPSBzcXJ0KDEgLSBzaW5QaGkgKiBzaW5QaGkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgc2luTGFtYmRhICogY29zUGhpIC0gY29zTGFtYmRhICogc2luMV9QaGksXG4gICAgICAgICAgICAtY29zTGFtYmRhICogY29zUGhpIC0gc2luTGFtYmRhICogc2luMV9QaGlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgd2llY2hlbFJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgdyA9ICh4ICogeCArIHkgKiB5KSAvIC0yLCBrID0gc3FydCgtdyAqICgyICsgdykpLCBiID0geSAqIHcgKyB4ICogaywgYSA9IHggKiB3IC0geSAqIGssIEQgPSBzcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYXRhbjIoayAqIGIsIEQgKiAoMSArIHcpKSxcbiAgICAgICAgICAgIEQgPyAtYXNpbihrICogYSAvIEQpIDogMFxuICAgICAgICBdO1xuICAgIH07XG4gICAgdmFyIHdpZWNoZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkM0dlby5nZW9Qcm9qZWN0aW9uKHdpZWNoZWxSYXcpXG4gICAgICAgICAgICAucm90YXRlKFswLCAtOTAsIDQ1XSlcbiAgICAgICAgICAgIC5zY2FsZSgxMjQuNzUpXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDE4MCAtIDFlLTMpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gd2lua2VsM1JhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBhaXRvZmZSYXcobGFtYmRhLCBwaGkpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgKGNvb3JkaW5hdGVzWzBdICsgbGFtYmRhIC8gaGFsZlBpKSAvIDIsXG4gICAgICAgICAgICAoY29vcmRpbmF0ZXNbMV0gKyBwaGkpIC8gMlxuICAgICAgICBdO1xuICAgIH1cbiAgICB3aW5rZWwzUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHZhciBsYW1iZGEgPSB4LCBwaGkgPSB5LCBpID0gMjU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBjb3NwaGkgPSBjb3MocGhpKSwgc2lucGhpID0gc2luKHBoaSksIHNpbl8ycGhpID0gc2luKDIgKiBwaGkpLCBzaW4ycGhpID0gc2lucGhpICogc2lucGhpLCBjb3MycGhpID0gY29zcGhpICogY29zcGhpLCBzaW5sYW1iZGEgPSBzaW4obGFtYmRhKSwgY29zbGFtYmRhXzIgPSBjb3MobGFtYmRhIC8gMiksIHNpbmxhbWJkYV8yID0gc2luKGxhbWJkYSAvIDIpLCBzaW4ybGFtYmRhXzIgPSBzaW5sYW1iZGFfMiAqIHNpbmxhbWJkYV8yLCBDID0gMSAtIGNvczJwaGkgKiBjb3NsYW1iZGFfMiAqIGNvc2xhbWJkYV8yLCBFID0gQyA/IGFjb3MoY29zcGhpICogY29zbGFtYmRhXzIpICogc3FydChGID0gMSAvIEMpIDogRiA9IDAsIEYsIGZ4ID0gMC41ICogKDIgKiBFICogY29zcGhpICogc2lubGFtYmRhXzIgKyBsYW1iZGEgLyBoYWxmUGkpIC0geCwgZnkgPSAwLjUgKiAoRSAqIHNpbnBoaSArIHBoaSkgLSB5LCBkeGRsYW1iZGEgPSAwLjUgKiBGICogKGNvczJwaGkgKiBzaW4ybGFtYmRhXzIgKyBFICogY29zcGhpICogY29zbGFtYmRhXzIgKiBzaW4ycGhpKSArIDAuNSAvIGhhbGZQaSwgZHhkcGhpID0gRiAqIChzaW5sYW1iZGEgKiBzaW5fMnBoaSAvIDQgLSBFICogc2lucGhpICogc2lubGFtYmRhXzIpLCBkeWRsYW1iZGEgPSAwLjEyNSAqIEYgKiAoc2luXzJwaGkgKiBzaW5sYW1iZGFfMiAtIEUgKiBzaW5waGkgKiBjb3MycGhpICogc2lubGFtYmRhKSwgZHlkcGhpID0gMC41ICogRiAqIChzaW4ycGhpICogY29zbGFtYmRhXzIgKyBFICogc2luMmxhbWJkYV8yICogY29zcGhpKSArIDAuNSwgZGVub21pbmF0b3IgPSBkeGRwaGkgKiBkeWRsYW1iZGEgLSBkeWRwaGkgKiBkeGRsYW1iZGEsIGRsYW1iZGEgPSAoZnkgKiBkeGRwaGkgLSBmeCAqIGR5ZHBoaSkgLyBkZW5vbWluYXRvciwgZHBoaSA9IChmeCAqIGR5ZGxhbWJkYSAtIGZ5ICogZHhkbGFtYmRhKSAvIGRlbm9taW5hdG9yO1xuICAgICAgICAgICAgbGFtYmRhIC09IGRsYW1iZGEsIHBoaSAtPSBkcGhpO1xuICAgICAgICB9IHdoaWxlICgoYWJzKGRsYW1iZGEpID4gZXBzaWxvbiB8fCBhYnMoZHBoaSkgPiBlcHNpbG9uKSAmJiAtLWkgPiAwKTtcbiAgICAgICAgcmV0dXJuIFtsYW1iZGEsIHBoaV07XG4gICAgfTtcbiAgICB2YXIgd2lua2VsMyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGQzR2VvLmdlb1Byb2plY3Rpb24od2lua2VsM1JhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNTguODM3KTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZ2VvQWlyeSA9IGFpcnk7XG4gICAgZXhwb3J0cy5nZW9BaXJ5UmF3ID0gYWlyeVJhdztcbiAgICBleHBvcnRzLmdlb0FpdG9mZiA9IGFpdG9mZjtcbiAgICBleHBvcnRzLmdlb0FpdG9mZlJhdyA9IGFpdG9mZlJhdztcbiAgICBleHBvcnRzLmdlb0FybWFkaWxsbyA9IGFybWFkaWxsbztcbiAgICBleHBvcnRzLmdlb0FybWFkaWxsb1JhdyA9IGFybWFkaWxsb1JhdztcbiAgICBleHBvcnRzLmdlb0F1Z3VzdCA9IGF1Z3VzdDtcbiAgICBleHBvcnRzLmdlb0F1Z3VzdFJhdyA9IGF1Z3VzdFJhdztcbiAgICBleHBvcnRzLmdlb0Jha2VyID0gYmFrZXI7XG4gICAgZXhwb3J0cy5nZW9CYWtlclJhdyA9IGJha2VyUmF3O1xuICAgIGV4cG9ydHMuZ2VvQmVyZ2hhdXMgPSBiZXJnaGF1cztcbiAgICBleHBvcnRzLmdlb0JlcmdoYXVzUmF3ID0gYmVyZ2hhdXNSYXc7XG4gICAgZXhwb3J0cy5nZW9Cb2dncyA9IGJvZ2dzO1xuICAgIGV4cG9ydHMuZ2VvQm9nZ3NSYXcgPSBib2dnc1JhdztcbiAgICBleHBvcnRzLmdlb0Jvbm5lID0gYm9ubmU7XG4gICAgZXhwb3J0cy5nZW9Cb25uZVJhdyA9IGJvbm5lUmF3O1xuICAgIGV4cG9ydHMuZ2VvQm90dG9tbGV5ID0gYm90dG9tbGV5O1xuICAgIGV4cG9ydHMuZ2VvQm90dG9tbGV5UmF3ID0gYm90dG9tbGV5UmF3O1xuICAgIGV4cG9ydHMuZ2VvQnJvbWxleSA9IGJyb21sZXk7XG4gICAgZXhwb3J0cy5nZW9Ccm9tbGV5UmF3ID0gYnJvbWxleVJhdztcbiAgICBleHBvcnRzLmdlb0NoYW1iZXJsaW4gPSBjaGFtYmVybGluO1xuICAgIGV4cG9ydHMuZ2VvQ2hhbWJlcmxpblJhdyA9IGNoYW1iZXJsaW5SYXc7XG4gICAgZXhwb3J0cy5nZW9DaGFtYmVybGluQWZyaWNhID0gY2hhbWJlcmxpbkFmcmljYTtcbiAgICBleHBvcnRzLmdlb0NvbGxpZ25vbiA9IGNvbGxpZ25vbjtcbiAgICBleHBvcnRzLmdlb0NvbGxpZ25vblJhdyA9IGNvbGxpZ25vblJhdztcbiAgICBleHBvcnRzLmdlb0NyYWlnID0gY3JhaWc7XG4gICAgZXhwb3J0cy5nZW9DcmFpZ1JhdyA9IGNyYWlnUmF3O1xuICAgIGV4cG9ydHMuZ2VvQ3Jhc3RlciA9IGNyYXN0ZXI7XG4gICAgZXhwb3J0cy5nZW9DcmFzdGVyUmF3ID0gY3Jhc3RlclJhdztcbiAgICBleHBvcnRzLmdlb0N5bGluZHJpY2FsRXF1YWxBcmVhID0gY3lsaW5kcmljYWxFcXVhbEFyZWE7XG4gICAgZXhwb3J0cy5nZW9DeWxpbmRyaWNhbEVxdWFsQXJlYVJhdyA9IGN5bGluZHJpY2FsRXF1YWxBcmVhUmF3O1xuICAgIGV4cG9ydHMuZ2VvQ3lsaW5kcmljYWxTdGVyZW9ncmFwaGljID0gY3lsaW5kcmljYWxTdGVyZW9ncmFwaGljO1xuICAgIGV4cG9ydHMuZ2VvQ3lsaW5kcmljYWxTdGVyZW9ncmFwaGljUmF3ID0gY3lsaW5kcmljYWxTdGVyZW9ncmFwaGljUmF3O1xuICAgIGV4cG9ydHMuZ2VvRWNrZXJ0MSA9IGVja2VydDE7XG4gICAgZXhwb3J0cy5nZW9FY2tlcnQxUmF3ID0gZWNrZXJ0MVJhdztcbiAgICBleHBvcnRzLmdlb0Vja2VydDIgPSBlY2tlcnQyO1xuICAgIGV4cG9ydHMuZ2VvRWNrZXJ0MlJhdyA9IGVja2VydDJSYXc7XG4gICAgZXhwb3J0cy5nZW9FY2tlcnQzID0gZWNrZXJ0MztcbiAgICBleHBvcnRzLmdlb0Vja2VydDNSYXcgPSBlY2tlcnQzUmF3O1xuICAgIGV4cG9ydHMuZ2VvRWNrZXJ0NCA9IGVja2VydDQ7XG4gICAgZXhwb3J0cy5nZW9FY2tlcnQ0UmF3ID0gZWNrZXJ0NFJhdztcbiAgICBleHBvcnRzLmdlb0Vja2VydDUgPSBlY2tlcnQ1O1xuICAgIGV4cG9ydHMuZ2VvRWNrZXJ0NVJhdyA9IGVja2VydDVSYXc7XG4gICAgZXhwb3J0cy5nZW9FY2tlcnQ2ID0gZWNrZXJ0NjtcbiAgICBleHBvcnRzLmdlb0Vja2VydDZSYXcgPSBlY2tlcnQ2UmF3O1xuICAgIGV4cG9ydHMuZ2VvRWlzZW5sb2hyID0gZWlzZW5sb2hyO1xuICAgIGV4cG9ydHMuZ2VvRWlzZW5sb2hyUmF3ID0gZWlzZW5sb2hyUmF3O1xuICAgIGV4cG9ydHMuZ2VvRmFoZXkgPSBmYWhleTtcbiAgICBleHBvcnRzLmdlb0ZhaGV5UmF3ID0gZmFoZXlSYXc7XG4gICAgZXhwb3J0cy5nZW9Gb3VjYXV0ID0gZm91Y2F1dDtcbiAgICBleHBvcnRzLmdlb0ZvdWNhdXRSYXcgPSBmb3VjYXV0UmF3O1xuICAgIGV4cG9ydHMuZ2VvR2lsYmVydCA9IGdpbGJlcnQ7XG4gICAgZXhwb3J0cy5nZW9HaW5nZXJ5ID0gZ2luZ2VyeTtcbiAgICBleHBvcnRzLmdlb0dpbmdlcnlSYXcgPSBnaW5nZXJ5UmF3O1xuICAgIGV4cG9ydHMuZ2VvR2luemJ1cmc0ID0gZ2luemJ1cmc0O1xuICAgIGV4cG9ydHMuZ2VvR2luemJ1cmc0UmF3ID0gZ2luemJ1cmc0UmF3O1xuICAgIGV4cG9ydHMuZ2VvR2luemJ1cmc1ID0gZ2luemJ1cmc1O1xuICAgIGV4cG9ydHMuZ2VvR2luemJ1cmc1UmF3ID0gZ2luemJ1cmc1UmF3O1xuICAgIGV4cG9ydHMuZ2VvR2luemJ1cmc2ID0gZ2luemJ1cmc2O1xuICAgIGV4cG9ydHMuZ2VvR2luemJ1cmc2UmF3ID0gZ2luemJ1cmc2UmF3O1xuICAgIGV4cG9ydHMuZ2VvR2luemJ1cmc4ID0gZ2luemJ1cmc4O1xuICAgIGV4cG9ydHMuZ2VvR2luemJ1cmc4UmF3ID0gZ2luemJ1cmc4UmF3O1xuICAgIGV4cG9ydHMuZ2VvR2luemJ1cmc5ID0gZ2luemJ1cmc5O1xuICAgIGV4cG9ydHMuZ2VvR2luemJ1cmc5UmF3ID0gZ2luemJ1cmc5UmF3O1xuICAgIGV4cG9ydHMuZ2VvR3JpbmdvcnRlbiA9IGdyaW5nb3J0ZW47XG4gICAgZXhwb3J0cy5nZW9HcmluZ29ydGVuUmF3ID0gZ3JpbmdvcnRlblJhdztcbiAgICBleHBvcnRzLmdlb0d1eW91ID0gZ3V5b3U7XG4gICAgZXhwb3J0cy5nZW9HdXlvdVJhdyA9IGd1eW91UmF3O1xuICAgIGV4cG9ydHMuZ2VvSGFtbWVyID0gaGFtbWVyO1xuICAgIGV4cG9ydHMuZ2VvSGFtbWVyUmF3ID0gaGFtbWVyUmF3O1xuICAgIGV4cG9ydHMuZ2VvSGFtbWVyUmV0cm9hemltdXRoYWwgPSBoYW1tZXJSZXRyb2F6aW11dGhhbDtcbiAgICBleHBvcnRzLmdlb0hhbW1lclJldHJvYXppbXV0aGFsUmF3ID0gaGFtbWVyUmV0cm9hemltdXRoYWxSYXc7XG4gICAgZXhwb3J0cy5nZW9IZWFscGl4ID0gaGVhbHBpeDtcbiAgICBleHBvcnRzLmdlb0hlYWxwaXhSYXcgPSBoZWFscGl4UmF3O1xuICAgIGV4cG9ydHMuZ2VvSGlsbCA9IGhpbGw7XG4gICAgZXhwb3J0cy5nZW9IaWxsUmF3ID0gaGlsbFJhdztcbiAgICBleHBvcnRzLmdlb0hvbW9sb3NpbmUgPSBob21vbG9zaW5lO1xuICAgIGV4cG9ydHMuZ2VvSG9tb2xvc2luZVJhdyA9IGhvbW9sb3NpbmVSYXc7XG4gICAgZXhwb3J0cy5nZW9JbnRlcnJ1cHQgPSBpbnRlcnJ1cHQ7XG4gICAgZXhwb3J0cy5nZW9JbnRlcnJ1cHRlZEJvZ2dzID0gYm9nZ3MkMTtcbiAgICBleHBvcnRzLmdlb0ludGVycnVwdGVkSG9tb2xvc2luZSA9IGhvbW9sb3NpbmUkMTtcbiAgICBleHBvcnRzLmdlb0ludGVycnVwdGVkTW9sbHdlaWRlID0gbW9sbHdlaWRlJDE7XG4gICAgZXhwb3J0cy5nZW9JbnRlcnJ1cHRlZE1vbGx3ZWlkZUhlbWlzcGhlcmVzID0gbW9sbHdlaWRlSGVtaXNwaGVyZXM7XG4gICAgZXhwb3J0cy5nZW9JbnRlcnJ1cHRlZFNpbnVNb2xsd2VpZGUgPSBzaW51TW9sbHdlaWRlJDE7XG4gICAgZXhwb3J0cy5nZW9JbnRlcnJ1cHRlZFNpbnVzb2lkYWwgPSBzaW51c29pZGFsJDE7XG4gICAgZXhwb3J0cy5nZW9LYXZyYXlza2l5NyA9IGthdnJheXNraXk3O1xuICAgIGV4cG9ydHMuZ2VvS2F2cmF5c2tpeTdSYXcgPSBrYXZyYXlza2l5N1JhdztcbiAgICBleHBvcnRzLmdlb0xhZ3JhbmdlID0gbGFncmFuZ2U7XG4gICAgZXhwb3J0cy5nZW9MYWdyYW5nZVJhdyA9IGxhZ3JhbmdlUmF3O1xuICAgIGV4cG9ydHMuZ2VvTGFycml2ZWUgPSBsYXJyaXZlZTtcbiAgICBleHBvcnRzLmdlb0xhcnJpdmVlUmF3ID0gbGFycml2ZWVSYXc7XG4gICAgZXhwb3J0cy5nZW9MYXNrb3dza2kgPSBsYXNrb3dza2k7XG4gICAgZXhwb3J0cy5nZW9MYXNrb3dza2lSYXcgPSBsYXNrb3dza2lSYXc7XG4gICAgZXhwb3J0cy5nZW9MaXR0cm93ID0gbGl0dHJvdztcbiAgICBleHBvcnRzLmdlb0xpdHRyb3dSYXcgPSBsaXR0cm93UmF3O1xuICAgIGV4cG9ydHMuZ2VvTG94aW11dGhhbCA9IGxveGltdXRoYWw7XG4gICAgZXhwb3J0cy5nZW9Mb3hpbXV0aGFsUmF3ID0gbG94aW11dGhhbFJhdztcbiAgICBleHBvcnRzLmdlb01pbGxlciA9IG1pbGxlcjtcbiAgICBleHBvcnRzLmdlb01pbGxlclJhdyA9IG1pbGxlclJhdztcbiAgICBleHBvcnRzLmdlb01vZGlmaWVkU3RlcmVvZ3JhcGhpYyA9IG1vZGlmaWVkU3RlcmVvZ3JhcGhpYztcbiAgICBleHBvcnRzLmdlb01vZGlmaWVkU3RlcmVvZ3JhcGhpY1JhdyA9IG1vZGlmaWVkU3RlcmVvZ3JhcGhpY1JhdztcbiAgICBleHBvcnRzLmdlb01vZGlmaWVkU3RlcmVvZ3JhcGhpY0FsYXNrYSA9IG1vZGlmaWVkU3RlcmVvZ3JhcGhpY0FsYXNrYTtcbiAgICBleHBvcnRzLmdlb01vZGlmaWVkU3RlcmVvZ3JhcGhpY0dzNDggPSBtb2RpZmllZFN0ZXJlb2dyYXBoaWNHczQ4O1xuICAgIGV4cG9ydHMuZ2VvTW9kaWZpZWRTdGVyZW9ncmFwaGljR3M1MCA9IG1vZGlmaWVkU3RlcmVvZ3JhcGhpY0dzNTA7XG4gICAgZXhwb3J0cy5nZW9Nb2RpZmllZFN0ZXJlb2dyYXBoaWNNaWxsZXIgPSBtb2RpZmllZFN0ZXJlb2dyYXBoaWNNaWxsZXI7XG4gICAgZXhwb3J0cy5nZW9Nb2RpZmllZFN0ZXJlb2dyYXBoaWNMZWUgPSBtb2RpZmllZFN0ZXJlb2dyYXBoaWNMZWU7XG4gICAgZXhwb3J0cy5nZW9Nb2xsd2VpZGUgPSBtb2xsd2VpZGU7XG4gICAgZXhwb3J0cy5nZW9Nb2xsd2VpZGVSYXcgPSBtb2xsd2VpZGVSYXc7XG4gICAgZXhwb3J0cy5nZW9NdEZsYXRQb2xhclBhcmFib2xpYyA9IG10RmxhdFBvbGFyUGFyYWJvbGljO1xuICAgIGV4cG9ydHMuZ2VvTXRGbGF0UG9sYXJQYXJhYm9saWNSYXcgPSBtdEZsYXRQb2xhclBhcmFib2xpY1JhdztcbiAgICBleHBvcnRzLmdlb010RmxhdFBvbGFyUXVhcnRpYyA9IG10RmxhdFBvbGFyUXVhcnRpYztcbiAgICBleHBvcnRzLmdlb010RmxhdFBvbGFyUXVhcnRpY1JhdyA9IG10RmxhdFBvbGFyUXVhcnRpY1JhdztcbiAgICBleHBvcnRzLmdlb010RmxhdFBvbGFyU2ludXNvaWRhbCA9IG10RmxhdFBvbGFyU2ludXNvaWRhbDtcbiAgICBleHBvcnRzLmdlb010RmxhdFBvbGFyU2ludXNvaWRhbFJhdyA9IG10RmxhdFBvbGFyU2ludXNvaWRhbFJhdztcbiAgICBleHBvcnRzLmdlb05hdHVyYWxFYXJ0aCA9IG5hdHVyYWxFYXJ0aDtcbiAgICBleHBvcnRzLmdlb05hdHVyYWxFYXJ0aFJhdyA9IG5hdHVyYWxFYXJ0aFJhdztcbiAgICBleHBvcnRzLmdlb05hdHVyYWxFYXJ0aDIgPSBuYXR1cmFsRWFydGgyO1xuICAgIGV4cG9ydHMuZ2VvTmF0dXJhbEVhcnRoMlJhdyA9IG5hdHVyYWxFYXJ0aDJSYXc7XG4gICAgZXhwb3J0cy5nZW9OZWxsSGFtbWVyID0gbmVsbEhhbW1lcjtcbiAgICBleHBvcnRzLmdlb05lbGxIYW1tZXJSYXcgPSBuZWxsSGFtbWVyUmF3O1xuICAgIGV4cG9ydHMuZ2VvUGF0dGVyc29uID0gcGF0dGVyc29uO1xuICAgIGV4cG9ydHMuZ2VvUGF0dGVyc29uUmF3ID0gcGF0dGVyc29uUmF3O1xuICAgIGV4cG9ydHMuZ2VvUG9seWNvbmljID0gcG9seWNvbmljO1xuICAgIGV4cG9ydHMuZ2VvUG9seWNvbmljUmF3ID0gcG9seWNvbmljUmF3O1xuICAgIGV4cG9ydHMuZ2VvUG9seWhlZHJhbCA9IHBvbHloZWRyYWw7XG4gICAgZXhwb3J0cy5nZW9Qb2x5aGVkcmFsQnV0dGVyZmx5ID0gYnV0dGVyZmx5O1xuICAgIGV4cG9ydHMuZ2VvUG9seWhlZHJhbENvbGxpZ25vbiA9IGNvbGxpZ25vbiQxO1xuICAgIGV4cG9ydHMuZ2VvUG9seWhlZHJhbFdhdGVybWFuID0gd2F0ZXJtYW47XG4gICAgZXhwb3J0cy5nZW9Qcm9qZWN0ID0gaW5kZXg7XG4gICAgZXhwb3J0cy5nZW9HcmluZ29ydGVuUXVpbmN1bmNpYWwgPSBncmluZ29ydGVuJDE7XG4gICAgZXhwb3J0cy5nZW9QZWlyY2VRdWluY3VuY2lhbCA9IHBlaXJjZTtcbiAgICBleHBvcnRzLmdlb1BpZXJjZVF1aW5jdW5jaWFsID0gcGVpcmNlO1xuICAgIGV4cG9ydHMuZ2VvUXVhbnRpemUgPSBxdWFudGl6ZTtcbiAgICBleHBvcnRzLmdlb1F1aW5jdW5jaWFsID0gcXVpbmN1bmNpYWw7XG4gICAgZXhwb3J0cy5nZW9SZWN0YW5ndWxhclBvbHljb25pYyA9IHJlY3Rhbmd1bGFyUG9seWNvbmljO1xuICAgIGV4cG9ydHMuZ2VvUmVjdGFuZ3VsYXJQb2x5Y29uaWNSYXcgPSByZWN0YW5ndWxhclBvbHljb25pY1JhdztcbiAgICBleHBvcnRzLmdlb1JvYmluc29uID0gcm9iaW5zb247XG4gICAgZXhwb3J0cy5nZW9Sb2JpbnNvblJhdyA9IHJvYmluc29uUmF3O1xuICAgIGV4cG9ydHMuZ2VvU2F0ZWxsaXRlID0gc2F0ZWxsaXRlO1xuICAgIGV4cG9ydHMuZ2VvU2F0ZWxsaXRlUmF3ID0gc2F0ZWxsaXRlUmF3O1xuICAgIGV4cG9ydHMuZ2VvU2ludU1vbGx3ZWlkZSA9IHNpbnVNb2xsd2VpZGU7XG4gICAgZXhwb3J0cy5nZW9TaW51TW9sbHdlaWRlUmF3ID0gc2ludU1vbGx3ZWlkZVJhdztcbiAgICBleHBvcnRzLmdlb1NpbnVzb2lkYWwgPSBzaW51c29pZGFsO1xuICAgIGV4cG9ydHMuZ2VvU2ludXNvaWRhbFJhdyA9IHNpbnVzb2lkYWxSYXc7XG4gICAgZXhwb3J0cy5nZW9TdGl0Y2ggPSBzdGl0Y2g7XG4gICAgZXhwb3J0cy5nZW9UaW1lcyA9IHRpbWVzO1xuICAgIGV4cG9ydHMuZ2VvVGltZXNSYXcgPSB0aW1lc1JhdztcbiAgICBleHBvcnRzLmdlb1R3b1BvaW50QXppbXV0aGFsID0gdHdvUG9pbnRBemltdXRoYWw7XG4gICAgZXhwb3J0cy5nZW9Ud29Qb2ludEF6aW11dGhhbFJhdyA9IHR3b1BvaW50QXppbXV0aGFsUmF3O1xuICAgIGV4cG9ydHMuZ2VvVHdvUG9pbnRBemltdXRoYWxVc2EgPSB0d29Qb2ludEF6aW11dGhhbFVzYTtcbiAgICBleHBvcnRzLmdlb1R3b1BvaW50RXF1aWRpc3RhbnQgPSB0d29Qb2ludEVxdWlkaXN0YW50O1xuICAgIGV4cG9ydHMuZ2VvVHdvUG9pbnRFcXVpZGlzdGFudFJhdyA9IHR3b1BvaW50RXF1aWRpc3RhbnRSYXc7XG4gICAgZXhwb3J0cy5nZW9Ud29Qb2ludEVxdWlkaXN0YW50VXNhID0gdHdvUG9pbnRFcXVpZGlzdGFudFVzYTtcbiAgICBleHBvcnRzLmdlb1ZhbkRlckdyaW50ZW4gPSB2YW5EZXJHcmludGVuO1xuICAgIGV4cG9ydHMuZ2VvVmFuRGVyR3JpbnRlblJhdyA9IHZhbkRlckdyaW50ZW5SYXc7XG4gICAgZXhwb3J0cy5nZW9WYW5EZXJHcmludGVuMiA9IHZhbkRlckdyaW50ZW4yO1xuICAgIGV4cG9ydHMuZ2VvVmFuRGVyR3JpbnRlbjJSYXcgPSB2YW5EZXJHcmludGVuMlJhdztcbiAgICBleHBvcnRzLmdlb1ZhbkRlckdyaW50ZW4zID0gdmFuRGVyR3JpbnRlbjM7XG4gICAgZXhwb3J0cy5nZW9WYW5EZXJHcmludGVuM1JhdyA9IHZhbkRlckdyaW50ZW4zUmF3O1xuICAgIGV4cG9ydHMuZ2VvVmFuRGVyR3JpbnRlbjQgPSB2YW5EZXJHcmludGVuNDtcbiAgICBleHBvcnRzLmdlb1ZhbkRlckdyaW50ZW40UmF3ID0gdmFuRGVyR3JpbnRlbjRSYXc7XG4gICAgZXhwb3J0cy5nZW9XYWduZXI0ID0gd2FnbmVyNDtcbiAgICBleHBvcnRzLmdlb1dhZ25lcjRSYXcgPSB3YWduZXI0UmF3O1xuICAgIGV4cG9ydHMuZ2VvV2FnbmVyNiA9IHdhZ25lcjY7XG4gICAgZXhwb3J0cy5nZW9XYWduZXI2UmF3ID0gd2FnbmVyNlJhdztcbiAgICBleHBvcnRzLmdlb1dhZ25lcjcgPSB3YWduZXI3O1xuICAgIGV4cG9ydHMuZ2VvV2FnbmVyN1JhdyA9IHdhZ25lcjdSYXc7XG4gICAgZXhwb3J0cy5nZW9XaWVjaGVsID0gd2llY2hlbDtcbiAgICBleHBvcnRzLmdlb1dpZWNoZWxSYXcgPSB3aWVjaGVsUmF3O1xuICAgIGV4cG9ydHMuZ2VvV2lua2VsMyA9IHdpbmtlbDM7XG4gICAgZXhwb3J0cy5nZW9XaW5rZWwzUmF3ID0gd2lua2VsM1JhdztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufSkpKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtZ2VvQDEuMTEuOUBkMy1nZW8vZGlzdC9kMy1nZW8uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kMy1nZW9AMS4xMS45QGQzLWdlby9kaXN0L2QzLWdlby5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1nZW8vIHYxLjExLjkgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgICB0cnVlID8gZmFjdG9yeShleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1hcnJheUAxLjIuNEBkMy1hcnJheS9kaXN0L2QzLWFycmF5LmpzXCIpKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGQzQXJyYXkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gQWRkcyBmbG9hdGluZyBwb2ludCBudW1iZXJzIHdpdGggdHdpY2UgdGhlIG5vcm1hbCBwcmVjaXNpb24uXG4gICAgLy8gUmVmZXJlbmNlOiBKLiBSLiBTaGV3Y2h1aywgQWRhcHRpdmUgUHJlY2lzaW9uIEZsb2F0aW5nLVBvaW50IEFyaXRobWV0aWMgYW5kXG4gICAgLy8gRmFzdCBSb2J1c3QgR2VvbWV0cmljIFByZWRpY2F0ZXMsIERpc2NyZXRlICYgQ29tcHV0YXRpb25hbCBHZW9tZXRyeSAxOCgzKVxuICAgIC8vIDMwNeKAkzM2MyAoMTk5NykuXG4gICAgLy8gQ29kZSBhZGFwdGVkIGZyb20gR2VvZ3JhcGhpY0xpYiBieSBDaGFybGVzIEYuIEYuIEthcm5leSxcbiAgICAvLyBodHRwOi8vZ2VvZ3JhcGhpY2xpYi5zb3VyY2Vmb3JnZS5uZXQvXG4gICAgZnVuY3Rpb24gYWRkZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWRkZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEFkZGVyKCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICAgIEFkZGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IEFkZGVyLFxuICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zID0gLy8gcm91bmRlZCB2YWx1ZVxuICAgICAgICAgICAgICAgIHRoaXMudCA9IDA7IC8vIGV4YWN0IGVycm9yXG4gICAgICAgIH0sXG4gICAgICAgIGFkZDogZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICAgIGFkZCh0ZW1wLCB5LCB0aGlzLnQpO1xuICAgICAgICAgICAgYWRkKHRoaXMsIHRlbXAucywgdGhpcy5zKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnMpXG4gICAgICAgICAgICAgICAgdGhpcy50ICs9IHRlbXAudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnMgPSB0ZW1wLnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlT2Y6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnM7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciB0ZW1wID0gbmV3IEFkZGVyO1xuICAgIGZ1bmN0aW9uIGFkZChhZGRlciwgYSwgYikge1xuICAgICAgICB2YXIgeCA9IGFkZGVyLnMgPSBhICsgYiwgYnYgPSB4IC0gYSwgYXYgPSB4IC0gYnY7XG4gICAgICAgIGFkZGVyLnQgPSAoYSAtIGF2KSArIChiIC0gYnYpO1xuICAgIH1cbiAgICB2YXIgZXBzaWxvbiA9IDFlLTY7XG4gICAgdmFyIGVwc2lsb24yID0gMWUtMTI7XG4gICAgdmFyIHBpID0gTWF0aC5QSTtcbiAgICB2YXIgaGFsZlBpID0gcGkgLyAyO1xuICAgIHZhciBxdWFydGVyUGkgPSBwaSAvIDQ7XG4gICAgdmFyIHRhdSA9IHBpICogMjtcbiAgICB2YXIgZGVncmVlcyA9IDE4MCAvIHBpO1xuICAgIHZhciByYWRpYW5zID0gcGkgLyAxODA7XG4gICAgdmFyIGFicyA9IE1hdGguYWJzO1xuICAgIHZhciBhdGFuID0gTWF0aC5hdGFuO1xuICAgIHZhciBhdGFuMiA9IE1hdGguYXRhbjI7XG4gICAgdmFyIGNvcyA9IE1hdGguY29zO1xuICAgIHZhciBjZWlsID0gTWF0aC5jZWlsO1xuICAgIHZhciBleHAgPSBNYXRoLmV4cDtcbiAgICB2YXIgbG9nID0gTWF0aC5sb2c7XG4gICAgdmFyIHBvdyA9IE1hdGgucG93O1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbjtcbiAgICB2YXIgc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA+IDAgPyAxIDogeCA8IDAgPyAtMSA6IDA7IH07XG4gICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG4gICAgdmFyIHRhbiA9IE1hdGgudGFuO1xuICAgIGZ1bmN0aW9uIGFjb3MoeCkge1xuICAgICAgICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzaW4oeCkge1xuICAgICAgICByZXR1cm4geCA+IDEgPyBoYWxmUGkgOiB4IDwgLTEgPyAtaGFsZlBpIDogTWF0aC5hc2luKHgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXZlcnNpbih4KSB7XG4gICAgICAgIHJldHVybiAoeCA9IHNpbih4IC8gMikpICogeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCgpIHsgfVxuICAgIGZ1bmN0aW9uIHN0cmVhbUdlb21ldHJ5KGdlb21ldHJ5LCBzdHJlYW0pIHtcbiAgICAgICAgaWYgKGdlb21ldHJ5ICYmIHN0cmVhbUdlb21ldHJ5VHlwZS5oYXNPd25Qcm9wZXJ0eShnZW9tZXRyeS50eXBlKSkge1xuICAgICAgICAgICAgc3RyZWFtR2VvbWV0cnlUeXBlW2dlb21ldHJ5LnR5cGVdKGdlb21ldHJ5LCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzdHJlYW1PYmplY3RUeXBlID0ge1xuICAgICAgICBGZWF0dXJlOiBmdW5jdGlvbiAob2JqZWN0LCBzdHJlYW0pIHtcbiAgICAgICAgICAgIHN0cmVhbUdlb21ldHJ5KG9iamVjdC5nZW9tZXRyeSwgc3RyZWFtKTtcbiAgICAgICAgfSxcbiAgICAgICAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uIChvYmplY3QsIHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gb2JqZWN0LmZlYXR1cmVzLCBpID0gLTEsIG4gPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1HZW9tZXRyeShmZWF0dXJlc1tpXS5nZW9tZXRyeSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0cmVhbUdlb21ldHJ5VHlwZSA9IHtcbiAgICAgICAgU3BoZXJlOiBmdW5jdGlvbiAob2JqZWN0LCBzdHJlYW0pIHtcbiAgICAgICAgICAgIHN0cmVhbS5zcGhlcmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgUG9pbnQ6IGZ1bmN0aW9uIChvYmplY3QsIHN0cmVhbSkge1xuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KG9iamVjdFswXSwgb2JqZWN0WzFdLCBvYmplY3RbMl0pO1xuICAgICAgICB9LFxuICAgICAgICBNdWx0aVBvaW50OiBmdW5jdGlvbiAob2JqZWN0LCBzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgb2JqZWN0ID0gY29vcmRpbmF0ZXNbaV0sIHN0cmVhbS5wb2ludChvYmplY3RbMF0sIG9iamVjdFsxXSwgb2JqZWN0WzJdKTtcbiAgICAgICAgfSxcbiAgICAgICAgTGluZVN0cmluZzogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICBzdHJlYW1MaW5lKG9iamVjdC5jb29yZGluYXRlcywgc3RyZWFtLCAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbiAob2JqZWN0LCBzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgc3RyZWFtLCAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgUG9seWdvbjogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICBzdHJlYW1Qb2x5Z29uKG9iamVjdC5jb29yZGluYXRlcywgc3RyZWFtKTtcbiAgICAgICAgfSxcbiAgICAgICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbiAob2JqZWN0LCBzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtUG9seWdvbihjb29yZGluYXRlc1tpXSwgc3RyZWFtKTtcbiAgICAgICAgfSxcbiAgICAgICAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbiAob2JqZWN0LCBzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyaWVzID0gb2JqZWN0Lmdlb21ldHJpZXMsIGkgPSAtMSwgbiA9IGdlb21ldHJpZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cmllc1tpXSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gc3RyZWFtTGluZShjb29yZGluYXRlcywgc3RyZWFtLCBjbG9zZWQpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIGNsb3NlZCwgY29vcmRpbmF0ZTtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpXSwgc3RyZWFtLnBvaW50KGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0sIGNvb3JkaW5hdGVbMl0pO1xuICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJlYW1Qb2x5Z29uKGNvb3JkaW5hdGVzLCBzdHJlYW0pIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMSk7XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlb1N0cmVhbShvYmplY3QsIHN0cmVhbSkge1xuICAgICAgICBpZiAob2JqZWN0ICYmIHN0cmVhbU9iamVjdFR5cGUuaGFzT3duUHJvcGVydHkob2JqZWN0LnR5cGUpKSB7XG4gICAgICAgICAgICBzdHJlYW1PYmplY3RUeXBlW29iamVjdC50eXBlXShvYmplY3QsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHJlYW1HZW9tZXRyeShvYmplY3QsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGFyZWFSaW5nU3VtID0gYWRkZXIoKTtcbiAgICB2YXIgYXJlYVN1bSA9IGFkZGVyKCksIGxhbWJkYTAwLCBwaGkwMCwgbGFtYmRhMCwgY29zUGhpMCwgc2luUGhpMDtcbiAgICB2YXIgYXJlYVN0cmVhbSA9IHtcbiAgICAgICAgcG9pbnQ6IG5vb3AsXG4gICAgICAgIGxpbmVTdGFydDogbm9vcCxcbiAgICAgICAgbGluZUVuZDogbm9vcCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhcmVhUmluZ1N1bS5yZXNldCgpO1xuICAgICAgICAgICAgYXJlYVN0cmVhbS5saW5lU3RhcnQgPSBhcmVhUmluZ1N0YXJ0O1xuICAgICAgICAgICAgYXJlYVN0cmVhbS5saW5lRW5kID0gYXJlYVJpbmdFbmQ7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmVhUmluZyA9ICthcmVhUmluZ1N1bTtcbiAgICAgICAgICAgIGFyZWFTdW0uYWRkKGFyZWFSaW5nIDwgMCA/IHRhdSArIGFyZWFSaW5nIDogYXJlYVJpbmcpO1xuICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmxpbmVFbmQgPSB0aGlzLnBvaW50ID0gbm9vcDtcbiAgICAgICAgfSxcbiAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhcmVhU3VtLmFkZCh0YXUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBhcmVhUmluZ1N0YXJ0KCkge1xuICAgICAgICBhcmVhU3RyZWFtLnBvaW50ID0gYXJlYVBvaW50Rmlyc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZWFSaW5nRW5kKCkge1xuICAgICAgICBhcmVhUG9pbnQobGFtYmRhMDAsIHBoaTAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJlYVBvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgYXJlYVN0cmVhbS5wb2ludCA9IGFyZWFQb2ludDtcbiAgICAgICAgbGFtYmRhMDAgPSBsYW1iZGEsIHBoaTAwID0gcGhpO1xuICAgICAgICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gICAgICAgIGxhbWJkYTAgPSBsYW1iZGEsIGNvc1BoaTAgPSBjb3MocGhpID0gcGhpIC8gMiArIHF1YXJ0ZXJQaSksIHNpblBoaTAgPSBzaW4ocGhpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJlYVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgICAgICAgcGhpID0gcGhpIC8gMiArIHF1YXJ0ZXJQaTsgLy8gaGFsZiB0aGUgYW5ndWxhciBkaXN0YW5jZSBmcm9tIHNvdXRoIHBvbGVcbiAgICAgICAgLy8gU3BoZXJpY2FsIGV4Y2VzcyBFIGZvciBhIHNwaGVyaWNhbCB0cmlhbmdsZSB3aXRoIHZlcnRpY2VzOiBzb3V0aCBwb2xlLFxuICAgICAgICAvLyBwcmV2aW91cyBwb2ludCwgY3VycmVudCBwb2ludC4gIFVzZXMgYSBmb3JtdWxhIGRlcml2ZWQgZnJvbSBDYWdub2xp4oCZc1xuICAgICAgICAvLyB0aGVvcmVtLiAgU2VlIFRvZGh1bnRlciwgU3BoZXJpY2FsIFRyaWcuICgxODcxKSwgU2VjLiAxMDMsIEVxLiAoMikuXG4gICAgICAgIHZhciBkTGFtYmRhID0gbGFtYmRhIC0gbGFtYmRhMCwgc2RMYW1iZGEgPSBkTGFtYmRhID49IDAgPyAxIDogLTEsIGFkTGFtYmRhID0gc2RMYW1iZGEgKiBkTGFtYmRhLCBjb3NQaGkgPSBjb3MocGhpKSwgc2luUGhpID0gc2luKHBoaSksIGsgPSBzaW5QaGkwICogc2luUGhpLCB1ID0gY29zUGhpMCAqIGNvc1BoaSArIGsgKiBjb3MoYWRMYW1iZGEpLCB2ID0gayAqIHNkTGFtYmRhICogc2luKGFkTGFtYmRhKTtcbiAgICAgICAgYXJlYVJpbmdTdW0uYWRkKGF0YW4yKHYsIHUpKTtcbiAgICAgICAgLy8gQWR2YW5jZSB0aGUgcHJldmlvdXMgcG9pbnRzLlxuICAgICAgICBsYW1iZGEwID0gbGFtYmRhLCBjb3NQaGkwID0gY29zUGhpLCBzaW5QaGkwID0gc2luUGhpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVhKG9iamVjdCkge1xuICAgICAgICBhcmVhU3VtLnJlc2V0KCk7XG4gICAgICAgIGdlb1N0cmVhbShvYmplY3QsIGFyZWFTdHJlYW0pO1xuICAgICAgICByZXR1cm4gYXJlYVN1bSAqIDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwaGVyaWNhbChjYXJ0ZXNpYW4pIHtcbiAgICAgICAgcmV0dXJuIFthdGFuMihjYXJ0ZXNpYW5bMV0sIGNhcnRlc2lhblswXSksIGFzaW4oY2FydGVzaWFuWzJdKV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcnRlc2lhbihzcGhlcmljYWwpIHtcbiAgICAgICAgdmFyIGxhbWJkYSA9IHNwaGVyaWNhbFswXSwgcGhpID0gc3BoZXJpY2FsWzFdLCBjb3NQaGkgPSBjb3MocGhpKTtcbiAgICAgICAgcmV0dXJuIFtjb3NQaGkgKiBjb3MobGFtYmRhKSwgY29zUGhpICogc2luKGxhbWJkYSksIHNpbihwaGkpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FydGVzaWFuRG90KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FydGVzaWFuQ3Jvc3MoYSwgYikge1xuICAgICAgICByZXR1cm4gW2FbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV0sIGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl0sIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF1dO1xuICAgIH1cbiAgICAvLyBUT0RPIHJldHVybiBhXG4gICAgZnVuY3Rpb24gY2FydGVzaWFuQWRkSW5QbGFjZShhLCBiKSB7XG4gICAgICAgIGFbMF0gKz0gYlswXSwgYVsxXSArPSBiWzFdLCBhWzJdICs9IGJbMl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhcnRlc2lhblNjYWxlKHZlY3Rvciwgaykge1xuICAgICAgICByZXR1cm4gW3ZlY3RvclswXSAqIGssIHZlY3RvclsxXSAqIGssIHZlY3RvclsyXSAqIGtdO1xuICAgIH1cbiAgICAvLyBUT0RPIHJldHVybiBkXG4gICAgZnVuY3Rpb24gY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShkKSB7XG4gICAgICAgIHZhciBsID0gc3FydChkWzBdICogZFswXSArIGRbMV0gKiBkWzFdICsgZFsyXSAqIGRbMl0pO1xuICAgICAgICBkWzBdIC89IGwsIGRbMV0gLz0gbCwgZFsyXSAvPSBsO1xuICAgIH1cbiAgICB2YXIgbGFtYmRhMCQxLCBwaGkwLCBsYW1iZGExLCBwaGkxLCAvLyBib3VuZHNcbiAgICBsYW1iZGEyLCAvLyBwcmV2aW91cyBsYW1iZGEtY29vcmRpbmF0ZVxuICAgIGxhbWJkYTAwJDEsIHBoaTAwJDEsIC8vIGZpcnN0IHBvaW50XG4gICAgcDAsIC8vIHByZXZpb3VzIDNEIHBvaW50XG4gICAgZGVsdGFTdW0gPSBhZGRlcigpLCByYW5nZXMsIHJhbmdlO1xuICAgIHZhciBib3VuZHNTdHJlYW0gPSB7XG4gICAgICAgIHBvaW50OiBib3VuZHNQb2ludCxcbiAgICAgICAgbGluZVN0YXJ0OiBib3VuZHNMaW5lU3RhcnQsXG4gICAgICAgIGxpbmVFbmQ6IGJvdW5kc0xpbmVFbmQsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYm91bmRzU3RyZWFtLnBvaW50ID0gYm91bmRzUmluZ1BvaW50O1xuICAgICAgICAgICAgYm91bmRzU3RyZWFtLmxpbmVTdGFydCA9IGJvdW5kc1JpbmdTdGFydDtcbiAgICAgICAgICAgIGJvdW5kc1N0cmVhbS5saW5lRW5kID0gYm91bmRzUmluZ0VuZDtcbiAgICAgICAgICAgIGRlbHRhU3VtLnJlc2V0KCk7XG4gICAgICAgICAgICBhcmVhU3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhcmVhU3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgICAgIGJvdW5kc1N0cmVhbS5wb2ludCA9IGJvdW5kc1BvaW50O1xuICAgICAgICAgICAgYm91bmRzU3RyZWFtLmxpbmVTdGFydCA9IGJvdW5kc0xpbmVTdGFydDtcbiAgICAgICAgICAgIGJvdW5kc1N0cmVhbS5saW5lRW5kID0gYm91bmRzTGluZUVuZDtcbiAgICAgICAgICAgIGlmIChhcmVhUmluZ1N1bSA8IDApXG4gICAgICAgICAgICAgICAgbGFtYmRhMCQxID0gLShsYW1iZGExID0gMTgwKSwgcGhpMCA9IC0ocGhpMSA9IDkwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGRlbHRhU3VtID4gZXBzaWxvbilcbiAgICAgICAgICAgICAgICBwaGkxID0gOTA7XG4gICAgICAgICAgICBlbHNlIGlmIChkZWx0YVN1bSA8IC1lcHNpbG9uKVxuICAgICAgICAgICAgICAgIHBoaTAgPSAtOTA7XG4gICAgICAgICAgICByYW5nZVswXSA9IGxhbWJkYTAkMSwgcmFuZ2VbMV0gPSBsYW1iZGExO1xuICAgICAgICB9LFxuICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxhbWJkYTAkMSA9IC0obGFtYmRhMSA9IDE4MCksIHBoaTAgPSAtKHBoaTEgPSA5MCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGJvdW5kc1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlID0gW2xhbWJkYTAkMSA9IGxhbWJkYSwgbGFtYmRhMSA9IGxhbWJkYV0pO1xuICAgICAgICBpZiAocGhpIDwgcGhpMClcbiAgICAgICAgICAgIHBoaTAgPSBwaGk7XG4gICAgICAgIGlmIChwaGkgPiBwaGkxKVxuICAgICAgICAgICAgcGhpMSA9IHBoaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBwID0gY2FydGVzaWFuKFtsYW1iZGEgKiByYWRpYW5zLCBwaGkgKiByYWRpYW5zXSk7XG4gICAgICAgIGlmIChwMCkge1xuICAgICAgICAgICAgdmFyIG5vcm1hbCA9IGNhcnRlc2lhbkNyb3NzKHAwLCBwKSwgZXF1YXRvcmlhbCA9IFtub3JtYWxbMV0sIC1ub3JtYWxbMF0sIDBdLCBpbmZsZWN0aW9uID0gY2FydGVzaWFuQ3Jvc3MoZXF1YXRvcmlhbCwgbm9ybWFsKTtcbiAgICAgICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoaW5mbGVjdGlvbik7XG4gICAgICAgICAgICBpbmZsZWN0aW9uID0gc3BoZXJpY2FsKGluZmxlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gbGFtYmRhIC0gbGFtYmRhMiwgc2lnbiA9IGRlbHRhID4gMCA/IDEgOiAtMSwgbGFtYmRhaSA9IGluZmxlY3Rpb25bMF0gKiBkZWdyZWVzICogc2lnbiwgcGhpaSwgYW50aW1lcmlkaWFuID0gYWJzKGRlbHRhKSA+IDE4MDtcbiAgICAgICAgICAgIGlmIChhbnRpbWVyaWRpYW4gXiAoc2lnbiAqIGxhbWJkYTIgPCBsYW1iZGFpICYmIGxhbWJkYWkgPCBzaWduICogbGFtYmRhKSkge1xuICAgICAgICAgICAgICAgIHBoaWkgPSBpbmZsZWN0aW9uWzFdICogZGVncmVlcztcbiAgICAgICAgICAgICAgICBpZiAocGhpaSA+IHBoaTEpXG4gICAgICAgICAgICAgICAgICAgIHBoaTEgPSBwaGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGFtYmRhaSA9IChsYW1iZGFpICsgMzYwKSAlIDM2MCAtIDE4MCwgYW50aW1lcmlkaWFuIF4gKHNpZ24gKiBsYW1iZGEyIDwgbGFtYmRhaSAmJiBsYW1iZGFpIDwgc2lnbiAqIGxhbWJkYSkpIHtcbiAgICAgICAgICAgICAgICBwaGlpID0gLWluZmxlY3Rpb25bMV0gKiBkZWdyZWVzO1xuICAgICAgICAgICAgICAgIGlmIChwaGlpIDwgcGhpMClcbiAgICAgICAgICAgICAgICAgICAgcGhpMCA9IHBoaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGhpIDwgcGhpMClcbiAgICAgICAgICAgICAgICAgICAgcGhpMCA9IHBoaTtcbiAgICAgICAgICAgICAgICBpZiAocGhpID4gcGhpMSlcbiAgICAgICAgICAgICAgICAgICAgcGhpMSA9IHBoaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbnRpbWVyaWRpYW4pIHtcbiAgICAgICAgICAgICAgICBpZiAobGFtYmRhIDwgbGFtYmRhMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUobGFtYmRhMCQxLCBsYW1iZGEpID4gYW5nbGUobGFtYmRhMCQxLCBsYW1iZGExKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbWJkYTEgPSBsYW1iZGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUobGFtYmRhLCBsYW1iZGExKSA+IGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW1iZGEwJDEgPSBsYW1iZGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhbWJkYTEgPj0gbGFtYmRhMCQxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW1iZGEgPCBsYW1iZGEwJDEpXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW1iZGEwJDEgPSBsYW1iZGE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW1iZGEgPiBsYW1iZGExKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFtYmRhMSA9IGxhbWJkYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW1iZGEgPiBsYW1iZGEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUobGFtYmRhMCQxLCBsYW1iZGEpID4gYW5nbGUobGFtYmRhMCQxLCBsYW1iZGExKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW1iZGExID0gbGFtYmRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYSwgbGFtYmRhMSkgPiBhbmdsZShsYW1iZGEwJDEsIGxhbWJkYTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbWJkYTAkMSA9IGxhbWJkYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlID0gW2xhbWJkYTAkMSA9IGxhbWJkYSwgbGFtYmRhMSA9IGxhbWJkYV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwaGkgPCBwaGkwKVxuICAgICAgICAgICAgcGhpMCA9IHBoaTtcbiAgICAgICAgaWYgKHBoaSA+IHBoaTEpXG4gICAgICAgICAgICBwaGkxID0gcGhpO1xuICAgICAgICBwMCA9IHAsIGxhbWJkYTIgPSBsYW1iZGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJvdW5kc0xpbmVTdGFydCgpIHtcbiAgICAgICAgYm91bmRzU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBib3VuZHNMaW5lRW5kKCkge1xuICAgICAgICByYW5nZVswXSA9IGxhbWJkYTAkMSwgcmFuZ2VbMV0gPSBsYW1iZGExO1xuICAgICAgICBib3VuZHNTdHJlYW0ucG9pbnQgPSBib3VuZHNQb2ludDtcbiAgICAgICAgcDAgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBib3VuZHNSaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgaWYgKHAwKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBsYW1iZGEgLSBsYW1iZGEyO1xuICAgICAgICAgICAgZGVsdGFTdW0uYWRkKGFicyhkZWx0YSkgPiAxODAgPyBkZWx0YSArIChkZWx0YSA+IDAgPyAzNjAgOiAtMzYwKSA6IGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhbWJkYTAwJDEgPSBsYW1iZGEsIHBoaTAwJDEgPSBwaGk7XG4gICAgICAgIH1cbiAgICAgICAgYXJlYVN0cmVhbS5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgICAgIGxpbmVQb2ludChsYW1iZGEsIHBoaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJvdW5kc1JpbmdTdGFydCgpIHtcbiAgICAgICAgYXJlYVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm91bmRzUmluZ0VuZCgpIHtcbiAgICAgICAgYm91bmRzUmluZ1BvaW50KGxhbWJkYTAwJDEsIHBoaTAwJDEpO1xuICAgICAgICBhcmVhU3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgaWYgKGFicyhkZWx0YVN1bSkgPiBlcHNpbG9uKVxuICAgICAgICAgICAgbGFtYmRhMCQxID0gLShsYW1iZGExID0gMTgwKTtcbiAgICAgICAgcmFuZ2VbMF0gPSBsYW1iZGEwJDEsIHJhbmdlWzFdID0gbGFtYmRhMTtcbiAgICAgICAgcDAgPSBudWxsO1xuICAgIH1cbiAgICAvLyBGaW5kcyB0aGUgbGVmdC1yaWdodCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBsb25naXR1ZGVzLlxuICAgIC8vIFRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIChsYW1iZGExIC0gbGFtYmRhMCArIDM2MMKwKSAlIDM2MMKwLCBleGNlcHQgdGhhdCB3ZSB3YW50XG4gICAgLy8gdGhlIGRpc3RhbmNlIGJldHdlZW4gwrExODDCsCB0byBiZSAzNjDCsC5cbiAgICBmdW5jdGlvbiBhbmdsZShsYW1iZGEwLCBsYW1iZGExKSB7XG4gICAgICAgIHJldHVybiAobGFtYmRhMSAtPSBsYW1iZGEwKSA8IDAgPyBsYW1iZGExICsgMzYwIDogbGFtYmRhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZ2VDb21wYXJlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiByYW5nZUNvbnRhaW5zKHJhbmdlLCB4KSB7XG4gICAgICAgIHJldHVybiByYW5nZVswXSA8PSByYW5nZVsxXSA/IHJhbmdlWzBdIDw9IHggJiYgeCA8PSByYW5nZVsxXSA6IHggPCByYW5nZVswXSB8fCByYW5nZVsxXSA8IHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJvdW5kcyhmZWF0dXJlKSB7XG4gICAgICAgIHZhciBpLCBuLCBhLCBiLCBtZXJnZWQsIGRlbHRhTWF4LCBkZWx0YTtcbiAgICAgICAgcGhpMSA9IGxhbWJkYTEgPSAtKGxhbWJkYTAkMSA9IHBoaTAgPSBJbmZpbml0eSk7XG4gICAgICAgIHJhbmdlcyA9IFtdO1xuICAgICAgICBnZW9TdHJlYW0oZmVhdHVyZSwgYm91bmRzU3RyZWFtKTtcbiAgICAgICAgLy8gRmlyc3QsIHNvcnQgcmFuZ2VzIGJ5IHRoZWlyIG1pbmltdW0gbG9uZ2l0dWRlcy5cbiAgICAgICAgaWYgKG4gPSByYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByYW5nZXMuc29ydChyYW5nZUNvbXBhcmUpO1xuICAgICAgICAgICAgLy8gVGhlbiwgbWVyZ2UgYW55IHJhbmdlcyB0aGF0IG92ZXJsYXAuXG4gICAgICAgICAgICBmb3IgKGkgPSAxLCBhID0gcmFuZ2VzWzBdLCBtZXJnZWQgPSBbYV07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBiID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZUNvbnRhaW5zKGEsIGJbMF0pIHx8IHJhbmdlQ29udGFpbnMoYSwgYlsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlKGFbMF0sIGJbMV0pID4gYW5nbGUoYVswXSwgYVsxXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBhWzFdID0gYlsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuZ2xlKGJbMF0sIGFbMV0pID4gYW5nbGUoYVswXSwgYVsxXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBhWzBdID0gYlswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZC5wdXNoKGEgPSBiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaW5hbGx5LCBmaW5kIHRoZSBsYXJnZXN0IGdhcCBiZXR3ZWVuIHRoZSBtZXJnZWQgcmFuZ2VzLlxuICAgICAgICAgICAgLy8gVGhlIGZpbmFsIGJvdW5kaW5nIGJveCB3aWxsIGJlIHRoZSBpbnZlcnNlIG9mIHRoaXMgZ2FwLlxuICAgICAgICAgICAgZm9yIChkZWx0YU1heCA9IC1JbmZpbml0eSwgbiA9IG1lcmdlZC5sZW5ndGggLSAxLCBpID0gMCwgYSA9IG1lcmdlZFtuXTsgaSA8PSBuOyBhID0gYiwgKytpKSB7XG4gICAgICAgICAgICAgICAgYiA9IG1lcmdlZFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoKGRlbHRhID0gYW5nbGUoYVsxXSwgYlswXSkpID4gZGVsdGFNYXgpXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhTWF4ID0gZGVsdGEsIGxhbWJkYTAkMSA9IGJbMF0sIGxhbWJkYTEgPSBhWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJhbmdlcyA9IHJhbmdlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGxhbWJkYTAkMSA9PT0gSW5maW5pdHkgfHwgcGhpMCA9PT0gSW5maW5pdHlcbiAgICAgICAgICAgID8gW1tOYU4sIE5hTl0sIFtOYU4sIE5hTl1dXG4gICAgICAgICAgICA6IFtbbGFtYmRhMCQxLCBwaGkwXSwgW2xhbWJkYTEsIHBoaTFdXTtcbiAgICB9XG4gICAgdmFyIFcwLCBXMSwgWDAsIFkwLCBaMCwgWDEsIFkxLCBaMSwgWDIsIFkyLCBaMiwgbGFtYmRhMDAkMiwgcGhpMDAkMiwgLy8gZmlyc3QgcG9pbnRcbiAgICB4MCwgeTAsIHowOyAvLyBwcmV2aW91cyBwb2ludFxuICAgIHZhciBjZW50cm9pZFN0cmVhbSA9IHtcbiAgICAgICAgc3BoZXJlOiBub29wLFxuICAgICAgICBwb2ludDogY2VudHJvaWRQb2ludCxcbiAgICAgICAgbGluZVN0YXJ0OiBjZW50cm9pZExpbmVTdGFydCxcbiAgICAgICAgbGluZUVuZDogY2VudHJvaWRMaW5lRW5kLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVTdGFydCA9IGNlbnRyb2lkUmluZ1N0YXJ0O1xuICAgICAgICAgICAgY2VudHJvaWRTdHJlYW0ubGluZUVuZCA9IGNlbnRyb2lkUmluZ0VuZDtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRMaW5lU3RhcnQ7XG4gICAgICAgICAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBBcml0aG1ldGljIG1lYW4gb2YgQ2FydGVzaWFuIHZlY3RvcnMuXG4gICAgZnVuY3Rpb24gY2VudHJvaWRQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gICAgICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgICAgICAgY2VudHJvaWRQb2ludENhcnRlc2lhbihjb3NQaGkgKiBjb3MobGFtYmRhKSwgY29zUGhpICogc2luKGxhbWJkYSksIHNpbihwaGkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRQb2ludENhcnRlc2lhbih4LCB5LCB6KSB7XG4gICAgICAgICsrVzA7XG4gICAgICAgIFgwICs9ICh4IC0gWDApIC8gVzA7XG4gICAgICAgIFkwICs9ICh5IC0gWTApIC8gVzA7XG4gICAgICAgIFowICs9ICh6IC0gWjApIC8gVzA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkTGluZVN0YXJ0KCkge1xuICAgICAgICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkTGluZVBvaW50Rmlyc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkTGluZVBvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICAgICAgICB2YXIgY29zUGhpID0gY29zKHBoaSk7XG4gICAgICAgIHgwID0gY29zUGhpICogY29zKGxhbWJkYSk7XG4gICAgICAgIHkwID0gY29zUGhpICogc2luKGxhbWJkYSk7XG4gICAgICAgIHowID0gc2luKHBoaSk7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRMaW5lUG9pbnQ7XG4gICAgICAgIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkTGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgICAgICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLCB4ID0gY29zUGhpICogY29zKGxhbWJkYSksIHkgPSBjb3NQaGkgKiBzaW4obGFtYmRhKSwgeiA9IHNpbihwaGkpLCB3ID0gYXRhbjIoc3FydCgodyA9IHkwICogeiAtIHowICogeSkgKiB3ICsgKHcgPSB6MCAqIHggLSB4MCAqIHopICogdyArICh3ID0geDAgKiB5IC0geTAgKiB4KSAqIHcpLCB4MCAqIHggKyB5MCAqIHkgKyB6MCAqIHopO1xuICAgICAgICBXMSArPSB3O1xuICAgICAgICBYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICAgICAgICBZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICAgICAgICBaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICAgICAgICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZExpbmVFbmQoKSB7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbiAgICB9XG4gICAgLy8gU2VlIEouIEUuIEJyb2NrLCBUaGUgSW5lcnRpYSBUZW5zb3IgZm9yIGEgU3BoZXJpY2FsIFRyaWFuZ2xlLFxuICAgIC8vIEouIEFwcGxpZWQgTWVjaGFuaWNzIDQyLCAyMzkgKDE5NzUpLlxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUmluZ1N0YXJ0KCkge1xuICAgICAgICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUmluZ1BvaW50Rmlyc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUmluZ0VuZCgpIHtcbiAgICAgICAgY2VudHJvaWRSaW5nUG9pbnQobGFtYmRhMDAkMiwgcGhpMDAkMik7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICAgICAgICBsYW1iZGEwMCQyID0gbGFtYmRhLCBwaGkwMCQyID0gcGhpO1xuICAgICAgICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRSaW5nUG9pbnQ7XG4gICAgICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgICAgICAgeDAgPSBjb3NQaGkgKiBjb3MobGFtYmRhKTtcbiAgICAgICAgeTAgPSBjb3NQaGkgKiBzaW4obGFtYmRhKTtcbiAgICAgICAgejAgPSBzaW4ocGhpKTtcbiAgICAgICAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICAgICAgICB2YXIgY29zUGhpID0gY29zKHBoaSksIHggPSBjb3NQaGkgKiBjb3MobGFtYmRhKSwgeSA9IGNvc1BoaSAqIHNpbihsYW1iZGEpLCB6ID0gc2luKHBoaSksIGN4ID0geTAgKiB6IC0gejAgKiB5LCBjeSA9IHowICogeCAtIHgwICogeiwgY3ogPSB4MCAqIHkgLSB5MCAqIHgsIG0gPSBzcXJ0KGN4ICogY3ggKyBjeSAqIGN5ICsgY3ogKiBjeiksIHcgPSBhc2luKG0pLCAvLyBsaW5lIHdlaWdodCA9IGFuZ2xlXG4gICAgICAgIHYgPSBtICYmIC13IC8gbTsgLy8gYXJlYSB3ZWlnaHQgbXVsdGlwbGllclxuICAgICAgICBYMiArPSB2ICogY3g7XG4gICAgICAgIFkyICs9IHYgKiBjeTtcbiAgICAgICAgWjIgKz0gdiAqIGN6O1xuICAgICAgICBXMSArPSB3O1xuICAgICAgICBYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICAgICAgICBZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICAgICAgICBaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICAgICAgICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZChvYmplY3QpIHtcbiAgICAgICAgVzAgPSBXMSA9XG4gICAgICAgICAgICBYMCA9IFkwID0gWjAgPVxuICAgICAgICAgICAgICAgIFgxID0gWTEgPSBaMSA9XG4gICAgICAgICAgICAgICAgICAgIFgyID0gWTIgPSBaMiA9IDA7XG4gICAgICAgIGdlb1N0cmVhbShvYmplY3QsIGNlbnRyb2lkU3RyZWFtKTtcbiAgICAgICAgdmFyIHggPSBYMiwgeSA9IFkyLCB6ID0gWjIsIG0gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG4gICAgICAgIC8vIElmIHRoZSBhcmVhLXdlaWdodGVkIGNjZW50cm9pZCBpcyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBsZW5ndGgtd2VpZ2h0ZWQgY2NlbnRyb2lkLlxuICAgICAgICBpZiAobSA8IGVwc2lsb24yKSB7XG4gICAgICAgICAgICB4ID0gWDEsIHkgPSBZMSwgeiA9IFoxO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGZlYXR1cmUgaGFzIHplcm8gbGVuZ3RoLCBmYWxsIGJhY2sgdG8gYXJpdGhtZXRpYyBtZWFuIG9mIHBvaW50IHZlY3RvcnMuXG4gICAgICAgICAgICBpZiAoVzEgPCBlcHNpbG9uKVxuICAgICAgICAgICAgICAgIHggPSBYMCwgeSA9IFkwLCB6ID0gWjA7XG4gICAgICAgICAgICBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgICAgICAgICAgLy8gSWYgdGhlIGZlYXR1cmUgc3RpbGwgaGFzIGFuIHVuZGVmaW5lZCBjY2VudHJvaWQsIHRoZW4gcmV0dXJuLlxuICAgICAgICAgICAgaWYgKG0gPCBlcHNpbG9uMilcbiAgICAgICAgICAgICAgICByZXR1cm4gW05hTiwgTmFOXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2F0YW4yKHksIHgpICogZGVncmVlcywgYXNpbih6IC8gc3FydChtKSkgKiBkZWdyZWVzXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBvc2UoYSwgYikge1xuICAgICAgICBmdW5jdGlvbiBjb21wb3NlKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4ID0gYSh4LCB5KSwgYih4WzBdLCB4WzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5pbnZlcnQgJiYgYi5pbnZlcnQpXG4gICAgICAgICAgICBjb21wb3NlLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHggPSBiLmludmVydCh4LCB5KSwgeCAmJiBhLmludmVydCh4WzBdLCB4WzFdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb21wb3NlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByb3RhdGlvbklkZW50aXR5KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBbYWJzKGxhbWJkYSkgPiBwaSA/IGxhbWJkYSArIE1hdGgucm91bmQoLWxhbWJkYSAvIHRhdSkgKiB0YXUgOiBsYW1iZGEsIHBoaV07XG4gICAgfVxuICAgIHJvdGF0aW9uSWRlbnRpdHkuaW52ZXJ0ID0gcm90YXRpb25JZGVudGl0eTtcbiAgICBmdW5jdGlvbiByb3RhdGVSYWRpYW5zKGRlbHRhTGFtYmRhLCBkZWx0YVBoaSwgZGVsdGFHYW1tYSkge1xuICAgICAgICByZXR1cm4gKGRlbHRhTGFtYmRhICU9IHRhdSkgPyAoZGVsdGFQaGkgfHwgZGVsdGFHYW1tYSA/IGNvbXBvc2Uocm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpLCByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKSlcbiAgICAgICAgICAgIDogcm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpKVxuICAgICAgICAgICAgOiAoZGVsdGFQaGkgfHwgZGVsdGFHYW1tYSA/IHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpXG4gICAgICAgICAgICAgICAgOiByb3RhdGlvbklkZW50aXR5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHJldHVybiBsYW1iZGEgKz0gZGVsdGFMYW1iZGEsIFtsYW1iZGEgPiBwaSA/IGxhbWJkYSAtIHRhdSA6IGxhbWJkYSA8IC1waSA/IGxhbWJkYSArIHRhdSA6IGxhbWJkYSwgcGhpXTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKTtcbiAgICAgICAgcm90YXRpb24uaW52ZXJ0ID0gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKC1kZWx0YUxhbWJkYSk7XG4gICAgICAgIHJldHVybiByb3RhdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSkge1xuICAgICAgICB2YXIgY29zRGVsdGFQaGkgPSBjb3MoZGVsdGFQaGkpLCBzaW5EZWx0YVBoaSA9IHNpbihkZWx0YVBoaSksIGNvc0RlbHRhR2FtbWEgPSBjb3MoZGVsdGFHYW1tYSksIHNpbkRlbHRhR2FtbWEgPSBzaW4oZGVsdGFHYW1tYSk7XG4gICAgICAgIGZ1bmN0aW9uIHJvdGF0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgY29zUGhpID0gY29zKHBoaSksIHggPSBjb3MobGFtYmRhKSAqIGNvc1BoaSwgeSA9IHNpbihsYW1iZGEpICogY29zUGhpLCB6ID0gc2luKHBoaSksIGsgPSB6ICogY29zRGVsdGFQaGkgKyB4ICogc2luRGVsdGFQaGk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGF0YW4yKHkgKiBjb3NEZWx0YUdhbW1hIC0gayAqIHNpbkRlbHRhR2FtbWEsIHggKiBjb3NEZWx0YVBoaSAtIHogKiBzaW5EZWx0YVBoaSksXG4gICAgICAgICAgICAgICAgYXNpbihrICogY29zRGVsdGFHYW1tYSArIHkgKiBzaW5EZWx0YUdhbW1hKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByb3RhdGlvbi5pbnZlcnQgPSBmdW5jdGlvbiAobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSwgeCA9IGNvcyhsYW1iZGEpICogY29zUGhpLCB5ID0gc2luKGxhbWJkYSkgKiBjb3NQaGksIHogPSBzaW4ocGhpKSwgayA9IHogKiBjb3NEZWx0YUdhbW1hIC0geSAqIHNpbkRlbHRhR2FtbWE7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGF0YW4yKHkgKiBjb3NEZWx0YUdhbW1hICsgeiAqIHNpbkRlbHRhR2FtbWEsIHggKiBjb3NEZWx0YVBoaSArIGsgKiBzaW5EZWx0YVBoaSksXG4gICAgICAgICAgICAgICAgYXNpbihrICogY29zRGVsdGFQaGkgLSB4ICogc2luRGVsdGFQaGkpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcm90YXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJvdGF0aW9uKHJvdGF0ZSkge1xuICAgICAgICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKHJvdGF0ZVswXSAqIHJhZGlhbnMsIHJvdGF0ZVsxXSAqIHJhZGlhbnMsIHJvdGF0ZS5sZW5ndGggPiAyID8gcm90YXRlWzJdICogcmFkaWFucyA6IDApO1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICBjb29yZGluYXRlcyA9IHJvdGF0ZShjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XG4gICAgICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gcm90YXRlLmludmVydChjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XG4gICAgICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICAvLyBHZW5lcmF0ZXMgYSBjaXJjbGUgY2VudGVyZWQgYXQgWzDCsCwgMMKwXSwgd2l0aCBhIGdpdmVuIHJhZGl1cyBhbmQgcHJlY2lzaW9uLlxuICAgIGZ1bmN0aW9uIGNpcmNsZVN0cmVhbShzdHJlYW0sIHJhZGl1cywgZGVsdGEsIGRpcmVjdGlvbiwgdDAsIHQxKSB7XG4gICAgICAgIGlmICghZGVsdGEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBjb3NSYWRpdXMgPSBjb3MocmFkaXVzKSwgc2luUmFkaXVzID0gc2luKHJhZGl1cyksIHN0ZXAgPSBkaXJlY3Rpb24gKiBkZWx0YTtcbiAgICAgICAgaWYgKHQwID09IG51bGwpIHtcbiAgICAgICAgICAgIHQwID0gcmFkaXVzICsgZGlyZWN0aW9uICogdGF1O1xuICAgICAgICAgICAgdDEgPSByYWRpdXMgLSBzdGVwIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHQwID0gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgdDApO1xuICAgICAgICAgICAgdDEgPSBjaXJjbGVSYWRpdXMoY29zUmFkaXVzLCB0MSk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID4gMCA/IHQwIDwgdDEgOiB0MCA+IHQxKVxuICAgICAgICAgICAgICAgIHQwICs9IGRpcmVjdGlvbiAqIHRhdTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBwb2ludCwgdCA9IHQwOyBkaXJlY3Rpb24gPiAwID8gdCA+IHQxIDogdCA8IHQxOyB0IC09IHN0ZXApIHtcbiAgICAgICAgICAgIHBvaW50ID0gc3BoZXJpY2FsKFtjb3NSYWRpdXMsIC1zaW5SYWRpdXMgKiBjb3ModCksIC1zaW5SYWRpdXMgKiBzaW4odCldKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIHNpZ25lZCBhbmdsZSBvZiBhIGNhcnRlc2lhbiBwb2ludCByZWxhdGl2ZSB0byBbY29zUmFkaXVzLCAwLCAwXS5cbiAgICBmdW5jdGlvbiBjaXJjbGVSYWRpdXMoY29zUmFkaXVzLCBwb2ludCkge1xuICAgICAgICBwb2ludCA9IGNhcnRlc2lhbihwb2ludCksIHBvaW50WzBdIC09IGNvc1JhZGl1cztcbiAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShwb2ludCk7XG4gICAgICAgIHZhciByYWRpdXMgPSBhY29zKC1wb2ludFsxXSk7XG4gICAgICAgIHJldHVybiAoKC1wb2ludFsyXSA8IDAgPyAtcmFkaXVzIDogcmFkaXVzKSArIHRhdSAtIGVwc2lsb24pICUgdGF1O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaXJjbGUoKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSBjb25zdGFudChbMCwgMF0pLCByYWRpdXMgPSBjb25zdGFudCg5MCksIHByZWNpc2lvbiA9IGNvbnN0YW50KDYpLCByaW5nLCByb3RhdGUsIHN0cmVhbSA9IHsgcG9pbnQ6IHBvaW50IH07XG4gICAgICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgICAgICAgIHJpbmcucHVzaCh4ID0gcm90YXRlKHgsIHkpKTtcbiAgICAgICAgICAgIHhbMF0gKj0gZGVncmVlcywgeFsxXSAqPSBkZWdyZWVzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNpcmNsZSgpIHtcbiAgICAgICAgICAgIHZhciBjID0gY2VudGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHIgPSByYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIHJhZGlhbnMsIHAgPSBwcmVjaXNpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIHJhZGlhbnM7XG4gICAgICAgICAgICByaW5nID0gW107XG4gICAgICAgICAgICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKC1jWzBdICogcmFkaWFucywgLWNbMV0gKiByYWRpYW5zLCAwKS5pbnZlcnQ7XG4gICAgICAgICAgICBjaXJjbGVTdHJlYW0oc3RyZWFtLCByLCBwLCAxKTtcbiAgICAgICAgICAgIGMgPSB7IHR5cGU6IFwiUG9seWdvblwiLCBjb29yZGluYXRlczogW3JpbmddIH07XG4gICAgICAgICAgICByaW5nID0gcm90YXRlID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9XG4gICAgICAgIGNpcmNsZS5jZW50ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2VudGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbK19bMF0sICtfWzFdXSksIGNpcmNsZSkgOiBjZW50ZXI7XG4gICAgICAgIH07XG4gICAgICAgIGNpcmNsZS5yYWRpdXMgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGNpcmNsZSkgOiByYWRpdXM7XG4gICAgICAgIH07XG4gICAgICAgIGNpcmNsZS5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2lzaW9uID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGNpcmNsZSkgOiBwcmVjaXNpb247XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjaXJjbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsaXBCdWZmZXIoKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IFtdLCBsaW5lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICAgICAgbGluZS5wdXNoKFt4LCB5XSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChsaW5lID0gW10pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVFbmQ6IG5vb3AsXG4gICAgICAgICAgICByZWpvaW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChsaW5lcy5wb3AoKS5jb25jYXQobGluZXMuc2hpZnQoKSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3VsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBsaW5lcztcbiAgICAgICAgICAgICAgICBsaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50RXF1YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gYWJzKGFbMF0gLSBiWzBdKSA8IGVwc2lsb24gJiYgYWJzKGFbMV0gLSBiWzFdKSA8IGVwc2lsb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIEludGVyc2VjdGlvbihwb2ludCwgcG9pbnRzLCBvdGhlciwgZW50cnkpIHtcbiAgICAgICAgdGhpcy54ID0gcG9pbnQ7XG4gICAgICAgIHRoaXMueiA9IHBvaW50cztcbiAgICAgICAgdGhpcy5vID0gb3RoZXI7IC8vIGFub3RoZXIgaW50ZXJzZWN0aW9uXG4gICAgICAgIHRoaXMuZSA9IGVudHJ5OyAvLyBpcyBhbiBlbnRyeT9cbiAgICAgICAgdGhpcy52ID0gZmFsc2U7IC8vIHZpc2l0ZWRcbiAgICAgICAgdGhpcy5uID0gdGhpcy5wID0gbnVsbDsgLy8gbmV4dCAmIHByZXZpb3VzXG4gICAgfVxuICAgIC8vIEEgZ2VuZXJhbGl6ZWQgcG9seWdvbiBjbGlwcGluZyBhbGdvcml0aG06IGdpdmVuIGEgcG9seWdvbiB0aGF0IGhhcyBiZWVuIGN1dFxuICAgIC8vIGludG8gaXRzIHZpc2libGUgbGluZSBzZWdtZW50cywgYW5kIHJlam9pbnMgdGhlIHNlZ21lbnRzIGJ5IGludGVycG9sYXRpbmdcbiAgICAvLyBhbG9uZyB0aGUgY2xpcCBlZGdlLlxuICAgIGZ1bmN0aW9uIGNsaXBSZWpvaW4oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gW10sIGNsaXAgPSBbXSwgaSwgbjtcbiAgICAgICAgc2VnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgICAgICAgaWYgKChuID0gc2VnbWVudC5sZW5ndGggLSAxKSA8PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBuLCBwMCA9IHNlZ21lbnRbMF0sIHAxID0gc2VnbWVudFtuXSwgeDtcbiAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgb2YgYSBzZWdtZW50IGFyZSBjb2luY2lkZW50LCB0aGVuIHRyZWF0IGFzIGFcbiAgICAgICAgICAgIC8vIGNsb3NlZCByaW5nLiBUT0RPIGlmIGFsbCByaW5ncyBhcmUgY2xvc2VkLCB0aGVuIHRoZSB3aW5kaW5nIG9yZGVyIG9mIHRoZVxuICAgICAgICAgICAgLy8gZXh0ZXJpb3IgcmluZyBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICAgICAgICAgIGlmIChwb2ludEVxdWFsKHAwLCBwMSkpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSlcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KChwMCA9IHNlZ21lbnRbaV0pWzBdLCBwMFsxXSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJqZWN0LnB1c2goeCA9IG5ldyBJbnRlcnNlY3Rpb24ocDAsIHNlZ21lbnQsIG51bGwsIHRydWUpKTtcbiAgICAgICAgICAgIGNsaXAucHVzaCh4Lm8gPSBuZXcgSW50ZXJzZWN0aW9uKHAwLCBudWxsLCB4LCBmYWxzZSkpO1xuICAgICAgICAgICAgc3ViamVjdC5wdXNoKHggPSBuZXcgSW50ZXJzZWN0aW9uKHAxLCBzZWdtZW50LCBudWxsLCBmYWxzZSkpO1xuICAgICAgICAgICAgY2xpcC5wdXNoKHgubyA9IG5ldyBJbnRlcnNlY3Rpb24ocDEsIG51bGwsIHgsIHRydWUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc3ViamVjdC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNsaXAuc29ydChjb21wYXJlSW50ZXJzZWN0aW9uKTtcbiAgICAgICAgbGluayhzdWJqZWN0KTtcbiAgICAgICAgbGluayhjbGlwKTtcbiAgICAgICAgZm9yIChpID0gMCwgbiA9IGNsaXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICBjbGlwW2ldLmUgPSBzdGFydEluc2lkZSA9ICFzdGFydEluc2lkZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSBzdWJqZWN0WzBdLCBwb2ludHMsIHBvaW50O1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgLy8gRmluZCBmaXJzdCB1bnZpc2l0ZWQgaW50ZXJzZWN0aW9uLlxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBzdGFydCwgaXNTdWJqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50LnYpXG4gICAgICAgICAgICAgICAgaWYgKChjdXJyZW50ID0gY3VycmVudC5uKSA9PT0gc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHBvaW50cyA9IGN1cnJlbnQuejtcbiAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnYgPSBjdXJyZW50Lm8udiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aDsgaSA8IG47ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50Lm4ueCwgMSwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gY3VycmVudC5wLno7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5wLngsIC0xLCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm87XG4gICAgICAgICAgICAgICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgICAgICAgICAgICAgIGlzU3ViamVjdCA9ICFpc1N1YmplY3Q7XG4gICAgICAgICAgICB9IHdoaWxlICghY3VycmVudC52KTtcbiAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbGluayhhcnJheSkge1xuICAgICAgICBpZiAoIShuID0gYXJyYXkubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG4sIGkgPSAwLCBhID0gYXJyYXlbMF0sIGI7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBhLm4gPSBiID0gYXJyYXlbaV07XG4gICAgICAgICAgICBiLnAgPSBhO1xuICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgYS5uID0gYiA9IGFycmF5WzBdO1xuICAgICAgICBiLnAgPSBhO1xuICAgIH1cbiAgICB2YXIgc3VtID0gYWRkZXIoKTtcbiAgICBmdW5jdGlvbiBsb25naXR1ZGUocG9pbnQpIHtcbiAgICAgICAgaWYgKGFicyhwb2ludFswXSkgPD0gcGkpXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRbMF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBzaWduKHBvaW50WzBdKSAqICgoYWJzKHBvaW50WzBdKSArIHBpKSAlIHRhdSAtIHBpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9seWdvbkNvbnRhaW5zKHBvbHlnb24sIHBvaW50KSB7XG4gICAgICAgIHZhciBsYW1iZGEgPSBsb25naXR1ZGUocG9pbnQpLCBwaGkgPSBwb2ludFsxXSwgc2luUGhpID0gc2luKHBoaSksIG5vcm1hbCA9IFtzaW4obGFtYmRhKSwgLWNvcyhsYW1iZGEpLCAwXSwgYW5nbGUgPSAwLCB3aW5kaW5nID0gMDtcbiAgICAgICAgc3VtLnJlc2V0KCk7XG4gICAgICAgIGlmIChzaW5QaGkgPT09IDEpXG4gICAgICAgICAgICBwaGkgPSBoYWxmUGkgKyBlcHNpbG9uO1xuICAgICAgICBlbHNlIGlmIChzaW5QaGkgPT09IC0xKVxuICAgICAgICAgICAgcGhpID0gLWhhbGZQaSAtIGVwc2lsb247XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghKG0gPSAocmluZyA9IHBvbHlnb25baV0pLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgcmluZywgbSwgcG9pbnQwID0gcmluZ1ttIC0gMV0sIGxhbWJkYTAgPSBsb25naXR1ZGUocG9pbnQwKSwgcGhpMCA9IHBvaW50MFsxXSAvIDIgKyBxdWFydGVyUGksIHNpblBoaTAgPSBzaW4ocGhpMCksIGNvc1BoaTAgPSBjb3MocGhpMCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG07ICsraiwgbGFtYmRhMCA9IGxhbWJkYTEsIHNpblBoaTAgPSBzaW5QaGkxLCBjb3NQaGkwID0gY29zUGhpMSwgcG9pbnQwID0gcG9pbnQxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50MSA9IHJpbmdbal0sIGxhbWJkYTEgPSBsb25naXR1ZGUocG9pbnQxKSwgcGhpMSA9IHBvaW50MVsxXSAvIDIgKyBxdWFydGVyUGksIHNpblBoaTEgPSBzaW4ocGhpMSksIGNvc1BoaTEgPSBjb3MocGhpMSksIGRlbHRhID0gbGFtYmRhMSAtIGxhbWJkYTAsIHNpZ24gPSBkZWx0YSA+PSAwID8gMSA6IC0xLCBhYnNEZWx0YSA9IHNpZ24gKiBkZWx0YSwgYW50aW1lcmlkaWFuID0gYWJzRGVsdGEgPiBwaSwgayA9IHNpblBoaTAgKiBzaW5QaGkxO1xuICAgICAgICAgICAgICAgIHN1bS5hZGQoYXRhbjIoayAqIHNpZ24gKiBzaW4oYWJzRGVsdGEpLCBjb3NQaGkwICogY29zUGhpMSArIGsgKiBjb3MoYWJzRGVsdGEpKSk7XG4gICAgICAgICAgICAgICAgYW5nbGUgKz0gYW50aW1lcmlkaWFuID8gZGVsdGEgKyBzaWduICogdGF1IDogZGVsdGE7XG4gICAgICAgICAgICAgICAgLy8gQXJlIHRoZSBsb25naXR1ZGVzIGVpdGhlciBzaWRlIG9mIHRoZSBwb2ludOKAmXMgbWVyaWRpYW4gKGxhbWJkYSksXG4gICAgICAgICAgICAgICAgLy8gYW5kIGFyZSB0aGUgbGF0aXR1ZGVzIHNtYWxsZXIgdGhhbiB0aGUgcGFyYWxsZWwgKHBoaSk/XG4gICAgICAgICAgICAgICAgaWYgKGFudGltZXJpZGlhbiBeIGxhbWJkYTAgPj0gbGFtYmRhIF4gbGFtYmRhMSA+PSBsYW1iZGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyYyA9IGNhcnRlc2lhbkNyb3NzKGNhcnRlc2lhbihwb2ludDApLCBjYXJ0ZXNpYW4ocG9pbnQxKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoYXJjKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGNhcnRlc2lhbkNyb3NzKG5vcm1hbCwgYXJjKTtcbiAgICAgICAgICAgICAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShpbnRlcnNlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGhpQXJjID0gKGFudGltZXJpZGlhbiBeIGRlbHRhID49IDAgPyAtMSA6IDEpICogYXNpbihpbnRlcnNlY3Rpb25bMl0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGhpID4gcGhpQXJjIHx8IHBoaSA9PT0gcGhpQXJjICYmIChhcmNbMF0gfHwgYXJjWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZGluZyArPSBhbnRpbWVyaWRpYW4gXiBkZWx0YSA+PSAwID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpcnN0LCBkZXRlcm1pbmUgd2hldGhlciB0aGUgU291dGggcG9sZSBpcyBpbnNpZGUgb3Igb3V0c2lkZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSXQgaXMgaW5zaWRlIGlmOlxuICAgICAgICAvLyAqIHRoZSBwb2x5Z29uIHdpbmRzIGFyb3VuZCBpdCBpbiBhIGNsb2Nrd2lzZSBkaXJlY3Rpb24uXG4gICAgICAgIC8vICogdGhlIHBvbHlnb24gZG9lcyBub3QgKGN1bXVsYXRpdmVseSkgd2luZCBhcm91bmQgaXQsIGJ1dCBoYXMgYSBuZWdhdGl2ZVxuICAgICAgICAvLyAgIChjb3VudGVyLWNsb2Nrd2lzZSkgYXJlYS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2Vjb25kLCBjb3VudCB0aGUgKHNpZ25lZCkgbnVtYmVyIG9mIHRpbWVzIGEgc2VnbWVudCBjcm9zc2VzIGEgbGFtYmRhXG4gICAgICAgIC8vIGZyb20gdGhlIHBvaW50IHRvIHRoZSBTb3V0aCBwb2xlLiAgSWYgaXQgaXMgemVybywgdGhlbiB0aGUgcG9pbnQgaXMgdGhlXG4gICAgICAgIC8vIHNhbWUgc2lkZSBhcyB0aGUgU291dGggcG9sZS5cbiAgICAgICAgcmV0dXJuIChhbmdsZSA8IC1lcHNpbG9uIHx8IGFuZ2xlIDwgZXBzaWxvbiAmJiBzdW0gPCAtZXBzaWxvbikgXiAod2luZGluZyAmIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGlwKHBvaW50VmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBzdGFydCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNpbmspIHtcbiAgICAgICAgICAgIHZhciBsaW5lID0gY2xpcExpbmUoc2luayksIHJpbmdCdWZmZXIgPSBjbGlwQnVmZmVyKCksIHJpbmdTaW5rID0gY2xpcExpbmUocmluZ0J1ZmZlciksIHBvbHlnb25TdGFydGVkID0gZmFsc2UsIHBvbHlnb24sIHNlZ21lbnRzLCByaW5nO1xuICAgICAgICAgICAgdmFyIGNsaXAgPSB7XG4gICAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICAgICAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXAucG9pbnQgPSBwb2ludFJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGNsaXAubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBjbGlwLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uID0gW107XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgY2xpcC5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGNsaXAubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzID0gZDNBcnJheS5tZXJnZShzZWdtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluc2lkZSA9IHBvbHlnb25Db250YWlucyhwb2x5Z29uLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpcFJlam9pbihzZWdtZW50cywgY29tcGFyZUludGVyc2VjdGlvbiwgc3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBzaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydEluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc2luayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9seWdvblN0YXJ0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5rLnBvbHlnb25FbmQoKSwgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMgPSBwb2x5Z29uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNwaGVyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzaW5rLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgc2luay5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHNpbmsucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmdW5jdGlvbiBwb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgICAgIGlmIChwb2ludFZpc2libGUobGFtYmRhLCBwaGkpKVxuICAgICAgICAgICAgICAgICAgICBzaW5rLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBvaW50TGluZShsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgICAgIGxpbmUucG9pbnQobGFtYmRhLCBwaGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgICAgICAgICAgIGNsaXAucG9pbnQgPSBwb2ludExpbmU7XG4gICAgICAgICAgICAgICAgbGluZS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICAgICAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgICAgICAgICAgIGxpbmUubGluZUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcG9pbnRSaW5nKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICAgICAgcmluZy5wdXNoKFtsYW1iZGEsIHBoaV0pO1xuICAgICAgICAgICAgICAgIHJpbmdTaW5rLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgICAgICAgICAgICByaW5nU2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICByaW5nID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgICAgICAgICAgIHBvaW50UmluZyhyaW5nWzBdWzBdLCByaW5nWzBdWzFdKTtcbiAgICAgICAgICAgICAgICByaW5nU2luay5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgdmFyIGNsZWFuID0gcmluZ1NpbmsuY2xlYW4oKSwgcmluZ1NlZ21lbnRzID0gcmluZ0J1ZmZlci5yZXN1bHQoKSwgaSwgbiA9IHJpbmdTZWdtZW50cy5sZW5ndGgsIG0sIHNlZ21lbnQsIHBvaW50O1xuICAgICAgICAgICAgICAgIHJpbmcucG9wKCk7XG4gICAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKHJpbmcpO1xuICAgICAgICAgICAgICAgIHJpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIE5vIGludGVyc2VjdGlvbnMuXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFuICYgMSkge1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50ID0gcmluZ1NlZ21lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKG0gPSBzZWdtZW50Lmxlbmd0aCAtIDEpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG07ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaW5rLnBvaW50KChwb2ludCA9IHNlZ21lbnRbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlam9pbiBjb25uZWN0ZWQgc2VnbWVudHMuXG4gICAgICAgICAgICAgICAgLy8gVE9ETyByZXVzZSByaW5nQnVmZmVyLnJlam9pbigpP1xuICAgICAgICAgICAgICAgIGlmIChuID4gMSAmJiBjbGVhbiAmIDIpXG4gICAgICAgICAgICAgICAgICAgIHJpbmdTZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5wb3AoKS5jb25jYXQocmluZ1NlZ21lbnRzLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5maWx0ZXIodmFsaWRTZWdtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xpcDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRTZWdtZW50KHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnQubGVuZ3RoID4gMTtcbiAgICB9XG4gICAgLy8gSW50ZXJzZWN0aW9ucyBhcmUgc29ydGVkIGFsb25nIHRoZSBjbGlwIGVkZ2UuIEZvciBib3RoIGFudGltZXJpZGlhbiBjdXR0aW5nXG4gICAgLy8gYW5kIGNpcmNsZSBjbGlwcGluZywgdGhlIHNhbWUgY29tcGFyaXNvbiBpcyB1c2VkLlxuICAgIGZ1bmN0aW9uIGNvbXBhcmVJbnRlcnNlY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gKChhID0gYS54KVswXSA8IDAgPyBhWzFdIC0gaGFsZlBpIC0gZXBzaWxvbiA6IGhhbGZQaSAtIGFbMV0pXG4gICAgICAgICAgICAtICgoYiA9IGIueClbMF0gPCAwID8gYlsxXSAtIGhhbGZQaSAtIGVwc2lsb24gOiBoYWxmUGkgLSBiWzFdKTtcbiAgICB9XG4gICAgdmFyIGNsaXBBbnRpbWVyaWRpYW4gPSBjbGlwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0sIGNsaXBBbnRpbWVyaWRpYW5MaW5lLCBjbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUsIFstcGksIC1oYWxmUGldKTtcbiAgICAvLyBUYWtlcyBhIGxpbmUgYW5kIGN1dHMgaW50byB2aXNpYmxlIHNlZ21lbnRzLiBSZXR1cm4gdmFsdWVzOiAwIC0gdGhlcmUgd2VyZVxuICAgIC8vIGludGVyc2VjdGlvbnMgb3IgdGhlIGxpbmUgd2FzIGVtcHR5OyAxIC0gbm8gaW50ZXJzZWN0aW9uczsgMiAtIHRoZXJlIHdlcmVcbiAgICAvLyBpbnRlcnNlY3Rpb25zLCBhbmQgdGhlIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzIHNob3VsZCBiZSByZWpvaW5lZC5cbiAgICBmdW5jdGlvbiBjbGlwQW50aW1lcmlkaWFuTGluZShzdHJlYW0pIHtcbiAgICAgICAgdmFyIGxhbWJkYTAgPSBOYU4sIHBoaTAgPSBOYU4sIHNpZ24wID0gTmFOLCBjbGVhbjsgLy8gbm8gaW50ZXJzZWN0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGNsZWFuID0gMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKGxhbWJkYTEsIHBoaTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2lnbjEgPSBsYW1iZGExID4gMCA/IHBpIDogLXBpLCBkZWx0YSA9IGFicyhsYW1iZGExIC0gbGFtYmRhMCk7XG4gICAgICAgICAgICAgICAgaWYgKGFicyhkZWx0YSAtIHBpKSA8IGVwc2lsb24pIHsgLy8gbGluZSBjcm9zc2VzIGEgcG9sZVxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMCwgcGhpMCA9IChwaGkwICsgcGhpMSkgLyAyID4gMCA/IGhhbGZQaSA6IC1oYWxmUGkpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjAsIHBoaTApO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludChzaWduMSwgcGhpMCk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGExLCBwaGkwKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWduMCAhPT0gc2lnbjEgJiYgZGVsdGEgPj0gcGkpIHsgLy8gbGluZSBjcm9zc2VzIGFudGltZXJpZGlhblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWJzKGxhbWJkYTAgLSBzaWduMCkgPCBlcHNpbG9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFtYmRhMCAtPSBzaWduMCAqIGVwc2lsb247IC8vIGhhbmRsZSBkZWdlbmVyYWNpZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFicyhsYW1iZGExIC0gc2lnbjEpIDwgZXBzaWxvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbWJkYTEgLT0gc2lnbjEgKiBlcHNpbG9uO1xuICAgICAgICAgICAgICAgICAgICBwaGkwID0gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24wLCBwaGkwKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjEsIHBoaTApO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGEwID0gbGFtYmRhMSwgcGhpMCA9IHBoaTEpO1xuICAgICAgICAgICAgICAgIHNpZ24wID0gc2lnbjE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgbGFtYmRhMCA9IHBoaTAgPSBOYU47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAtIGNsZWFuOyAvLyBpZiBpbnRlcnNlY3Rpb25zLCByZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKSB7XG4gICAgICAgIHZhciBjb3NQaGkwLCBjb3NQaGkxLCBzaW5MYW1iZGEwTGFtYmRhMSA9IHNpbihsYW1iZGEwIC0gbGFtYmRhMSk7XG4gICAgICAgIHJldHVybiBhYnMoc2luTGFtYmRhMExhbWJkYTEpID4gZXBzaWxvblxuICAgICAgICAgICAgPyBhdGFuKChzaW4ocGhpMCkgKiAoY29zUGhpMSA9IGNvcyhwaGkxKSkgKiBzaW4obGFtYmRhMSlcbiAgICAgICAgICAgICAgICAtIHNpbihwaGkxKSAqIChjb3NQaGkwID0gY29zKHBoaTApKSAqIHNpbihsYW1iZGEwKSlcbiAgICAgICAgICAgICAgICAvIChjb3NQaGkwICogY29zUGhpMSAqIHNpbkxhbWJkYTBMYW1iZGExKSlcbiAgICAgICAgICAgIDogKHBoaTAgKyBwaGkxKSAvIDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgICAgICAgdmFyIHBoaTtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgcGhpID0gZGlyZWN0aW9uICogaGFsZlBpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KC1waSwgcGhpKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludCgwLCBwaGkpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBpLCBwaGkpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBpLCAwKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwaSwgLXBoaSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQoMCwgLXBoaSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQoLXBpLCAtcGhpKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludCgtcGksIDApO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KC1waSwgcGhpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhYnMoZnJvbVswXSAtIHRvWzBdKSA+IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHZhciBsYW1iZGEgPSBmcm9tWzBdIDwgdG9bMF0gPyBwaSA6IC1waTtcbiAgICAgICAgICAgIHBoaSA9IGRpcmVjdGlvbiAqIGxhbWJkYSAvIDI7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQoLWxhbWJkYSwgcGhpKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludCgwLCBwaGkpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsaXBDaXJjbGUocmFkaXVzKSB7XG4gICAgICAgIHZhciBjciA9IGNvcyhyYWRpdXMpLCBkZWx0YSA9IDYgKiByYWRpYW5zLCBzbWFsbFJhZGl1cyA9IGNyID4gMCwgbm90SGVtaXNwaGVyZSA9IGFicyhjcikgPiBlcHNpbG9uOyAvLyBUT0RPIG9wdGltaXNlIGZvciB0aGlzIGNvbW1vbiBjYXNlXG4gICAgICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICAgICAgICAgICAgY2lyY2xlU3RyZWFtKHN0cmVhbSwgcmFkaXVzLCBkZWx0YSwgZGlyZWN0aW9uLCBmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdmlzaWJsZShsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcyhsYW1iZGEpICogY29zKHBoaSkgPiBjcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUYWtlcyBhIGxpbmUgYW5kIGN1dHMgaW50byB2aXNpYmxlIHNlZ21lbnRzLiBSZXR1cm4gdmFsdWVzIHVzZWQgZm9yIHBvbHlnb25cbiAgICAgICAgLy8gY2xpcHBpbmc6IDAgLSB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMgb3IgdGhlIGxpbmUgd2FzIGVtcHR5OyAxIC0gbm9cbiAgICAgICAgLy8gaW50ZXJzZWN0aW9ucyAyIC0gdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zLCBhbmQgdGhlIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzXG4gICAgICAgIC8vIHNob3VsZCBiZSByZWpvaW5lZC5cbiAgICAgICAgZnVuY3Rpb24gY2xpcExpbmUoc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQwLCAvLyBwcmV2aW91cyBwb2ludFxuICAgICAgICAgICAgYzAsIC8vIGNvZGUgZm9yIHByZXZpb3VzIHBvaW50XG4gICAgICAgICAgICB2MCwgLy8gdmlzaWJpbGl0eSBvZiBwcmV2aW91cyBwb2ludFxuICAgICAgICAgICAgdjAwLCAvLyB2aXNpYmlsaXR5IG9mIGZpcnN0IHBvaW50XG4gICAgICAgICAgICBjbGVhbjsgLy8gbm8gaW50ZXJzZWN0aW9uc1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdjAwID0gdjAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW4gPSAxO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uIChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQxID0gW2xhbWJkYSwgcGhpXSwgcG9pbnQyLCB2ID0gdmlzaWJsZShsYW1iZGEsIHBoaSksIGMgPSBzbWFsbFJhZGl1c1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB2ID8gMCA6IGNvZGUobGFtYmRhLCBwaGkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHYgPyBjb2RlKGxhbWJkYSArIChsYW1iZGEgPCAwID8gcGkgOiAtcGkpLCBwaGkpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwb2ludDAgJiYgKHYwMCA9IHYwID0gdikpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBkZWdlbmVyYWNpZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gaWdub3JlIGlmIG5vdCBjbGlwcGluZyBwb2x5Z29ucy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQwLCBwb2ludDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwb2ludDIgfHwgcG9pbnRFcXVhbChwb2ludDAsIHBvaW50MikgfHwgcG9pbnRFcXVhbChwb2ludDEsIHBvaW50MikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDFbMF0gKz0gZXBzaWxvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDFbMV0gKz0gZXBzaWxvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gdmlzaWJsZShwb2ludDFbMF0sIHBvaW50MVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHYwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG91dHNpZGUgZ29pbmcgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zaWRlIGdvaW5nIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQwID0gcG9pbnQyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vdEhlbWlzcGhlcmUgJiYgcG9pbnQwICYmIHNtYWxsUmFkaXVzIF4gdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY29kZXMgZm9yIHR3byBwb2ludHMgYXJlIGRpZmZlcmVudCwgb3IgYXJlIGJvdGggemVybyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCB0aGVyZSB0aGlzIHNlZ21lbnQgaW50ZXJzZWN0cyB3aXRoIHRoZSBzbWFsbCBjaXJjbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjICYgYzApICYmICh0ID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwLCB0cnVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNtYWxsUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFsxXVswXSwgdFsxXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodiAmJiAoIXBvaW50MCB8fCAhcG9pbnRFcXVhbChwb2ludDAsIHBvaW50MSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBvaW50MCA9IHBvaW50MSwgdjAgPSB2LCBjMCA9IGM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2MClcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBSZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHMgaWYgdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zIGFuZCB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAvLyBhbmQgbGFzdCBwb2ludHMgd2VyZSB2aXNpYmxlLlxuICAgICAgICAgICAgICAgIGNsZWFuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGVhbiB8ICgodjAwICYmIHYwKSA8PCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEludGVyc2VjdHMgdGhlIGdyZWF0IGNpcmNsZSBiZXR3ZWVuIGEgYW5kIGIgd2l0aCB0aGUgY2xpcCBjaXJjbGUuXG4gICAgICAgIGZ1bmN0aW9uIGludGVyc2VjdChhLCBiLCB0d28pIHtcbiAgICAgICAgICAgIHZhciBwYSA9IGNhcnRlc2lhbihhKSwgcGIgPSBjYXJ0ZXNpYW4oYik7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHR3byBwbGFuZXMsIG4xLnAgPSBkMSBhbmQgbjIucCA9IGQyLlxuICAgICAgICAgICAgLy8gRmluZCBpbnRlcnNlY3Rpb24gbGluZSBwKHQpID0gYzEgbjEgKyBjMiBuMiArIHQgKG4xIOKoryBuMikuXG4gICAgICAgICAgICB2YXIgbjEgPSBbMSwgMCwgMF0sIC8vIG5vcm1hbFxuICAgICAgICAgICAgbjIgPSBjYXJ0ZXNpYW5Dcm9zcyhwYSwgcGIpLCBuMm4yID0gY2FydGVzaWFuRG90KG4yLCBuMiksIG4xbjIgPSBuMlswXSwgLy8gY2FydGVzaWFuRG90KG4xLCBuMiksXG4gICAgICAgICAgICBkZXRlcm1pbmFudCA9IG4ybjIgLSBuMW4yICogbjFuMjtcbiAgICAgICAgICAgIC8vIFR3byBwb2xhciBwb2ludHMuXG4gICAgICAgICAgICBpZiAoIWRldGVybWluYW50KVxuICAgICAgICAgICAgICAgIHJldHVybiAhdHdvICYmIGE7XG4gICAgICAgICAgICB2YXIgYzEgPSBjciAqIG4ybjIgLyBkZXRlcm1pbmFudCwgYzIgPSAtY3IgKiBuMW4yIC8gZGV0ZXJtaW5hbnQsIG4xeG4yID0gY2FydGVzaWFuQ3Jvc3MobjEsIG4yKSwgQSA9IGNhcnRlc2lhblNjYWxlKG4xLCBjMSksIEIgPSBjYXJ0ZXNpYW5TY2FsZShuMiwgYzIpO1xuICAgICAgICAgICAgY2FydGVzaWFuQWRkSW5QbGFjZShBLCBCKTtcbiAgICAgICAgICAgIC8vIFNvbHZlIHxwKHQpfF4yID0gMS5cbiAgICAgICAgICAgIHZhciB1ID0gbjF4bjIsIHcgPSBjYXJ0ZXNpYW5Eb3QoQSwgdSksIHV1ID0gY2FydGVzaWFuRG90KHUsIHUpLCB0MiA9IHcgKiB3IC0gdXUgKiAoY2FydGVzaWFuRG90KEEsIEEpIC0gMSk7XG4gICAgICAgICAgICBpZiAodDIgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciB0ID0gc3FydCh0MiksIHEgPSBjYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgLSB0KSAvIHV1KTtcbiAgICAgICAgICAgIGNhcnRlc2lhbkFkZEluUGxhY2UocSwgQSk7XG4gICAgICAgICAgICBxID0gc3BoZXJpY2FsKHEpO1xuICAgICAgICAgICAgaWYgKCF0d28pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHE7XG4gICAgICAgICAgICAvLyBUd28gaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgICAgICAgICAgIHZhciBsYW1iZGEwID0gYVswXSwgbGFtYmRhMSA9IGJbMF0sIHBoaTAgPSBhWzFdLCBwaGkxID0gYlsxXSwgejtcbiAgICAgICAgICAgIGlmIChsYW1iZGExIDwgbGFtYmRhMClcbiAgICAgICAgICAgICAgICB6ID0gbGFtYmRhMCwgbGFtYmRhMCA9IGxhbWJkYTEsIGxhbWJkYTEgPSB6O1xuICAgICAgICAgICAgdmFyIGRlbHRhID0gbGFtYmRhMSAtIGxhbWJkYTAsIHBvbGFyID0gYWJzKGRlbHRhIC0gcGkpIDwgZXBzaWxvbiwgbWVyaWRpYW4gPSBwb2xhciB8fCBkZWx0YSA8IGVwc2lsb247XG4gICAgICAgICAgICBpZiAoIXBvbGFyICYmIHBoaTEgPCBwaGkwKVxuICAgICAgICAgICAgICAgIHogPSBwaGkwLCBwaGkwID0gcGhpMSwgcGhpMSA9IHo7XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBmaXJzdCBwb2ludCBpcyBiZXR3ZWVuIGEgYW5kIGIuXG4gICAgICAgICAgICBpZiAobWVyaWRpYW5cbiAgICAgICAgICAgICAgICA/IHBvbGFyXG4gICAgICAgICAgICAgICAgICAgID8gcGhpMCArIHBoaTEgPiAwIF4gcVsxXSA8IChhYnMocVswXSAtIGxhbWJkYTApIDwgZXBzaWxvbiA/IHBoaTAgOiBwaGkxKVxuICAgICAgICAgICAgICAgICAgICA6IHBoaTAgPD0gcVsxXSAmJiBxWzFdIDw9IHBoaTFcbiAgICAgICAgICAgICAgICA6IGRlbHRhID4gcGkgXiAobGFtYmRhMCA8PSBxWzBdICYmIHFbMF0gPD0gbGFtYmRhMSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcTEgPSBjYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgKyB0KSAvIHV1KTtcbiAgICAgICAgICAgICAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKHExLCBBKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3EsIHNwaGVyaWNhbChxMSldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEdlbmVyYXRlcyBhIDQtYml0IHZlY3RvciByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIG9mIGEgcG9pbnQgcmVsYXRpdmUgdG9cbiAgICAgICAgLy8gdGhlIHNtYWxsIGNpcmNsZSdzIGJvdW5kaW5nIGJveC5cbiAgICAgICAgZnVuY3Rpb24gY29kZShsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIHIgPSBzbWFsbFJhZGl1cyA/IHJhZGl1cyA6IHBpIC0gcmFkaXVzLCBjb2RlID0gMDtcbiAgICAgICAgICAgIGlmIChsYW1iZGEgPCAtcilcbiAgICAgICAgICAgICAgICBjb2RlIHw9IDE7IC8vIGxlZnRcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhbWJkYSA+IHIpXG4gICAgICAgICAgICAgICAgY29kZSB8PSAyOyAvLyByaWdodFxuICAgICAgICAgICAgaWYgKHBoaSA8IC1yKVxuICAgICAgICAgICAgICAgIGNvZGUgfD0gNDsgLy8gYmVsb3dcbiAgICAgICAgICAgIGVsc2UgaWYgKHBoaSA+IHIpXG4gICAgICAgICAgICAgICAgY29kZSB8PSA4OyAvLyBhYm92ZVxuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsaXAodmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBzbWFsbFJhZGl1cyA/IFswLCAtcmFkaXVzXSA6IFstcGksIHJhZGl1cyAtIHBpXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsaXBMaW5lKGEsIGIsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYnggPSBiWzBdLCBieSA9IGJbMV0sIHQwID0gMCwgdDEgPSAxLCBkeCA9IGJ4IC0gYXgsIGR5ID0gYnkgLSBheSwgcjtcbiAgICAgICAgciA9IHgwIC0gYXg7XG4gICAgICAgIGlmICghZHggJiYgciA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHIgLz0gZHg7XG4gICAgICAgIGlmIChkeCA8IDApIHtcbiAgICAgICAgICAgIGlmIChyIDwgdDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPCB0MSlcbiAgICAgICAgICAgICAgICB0MSA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgICAgICAgICBpZiAociA+IHQxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyID4gdDApXG4gICAgICAgICAgICAgICAgdDAgPSByO1xuICAgICAgICB9XG4gICAgICAgIHIgPSB4MSAtIGF4O1xuICAgICAgICBpZiAoIWR4ICYmIHIgPCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByIC89IGR4O1xuICAgICAgICBpZiAoZHggPCAwKSB7XG4gICAgICAgICAgICBpZiAociA+IHQxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyID4gdDApXG4gICAgICAgICAgICAgICAgdDAgPSByO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgaWYgKHIgPCB0MClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA8IHQxKVxuICAgICAgICAgICAgICAgIHQxID0gcjtcbiAgICAgICAgfVxuICAgICAgICByID0geTAgLSBheTtcbiAgICAgICAgaWYgKCFkeSAmJiByID4gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgciAvPSBkeTtcbiAgICAgICAgaWYgKGR5IDwgMCkge1xuICAgICAgICAgICAgaWYgKHIgPCB0MClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA8IHQxKVxuICAgICAgICAgICAgICAgIHQxID0gcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeSA+IDApIHtcbiAgICAgICAgICAgIGlmIChyID4gdDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPiB0MClcbiAgICAgICAgICAgICAgICB0MCA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgciA9IHkxIC0gYXk7XG4gICAgICAgIGlmICghZHkgJiYgciA8IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHIgLz0gZHk7XG4gICAgICAgIGlmIChkeSA8IDApIHtcbiAgICAgICAgICAgIGlmIChyID4gdDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPiB0MClcbiAgICAgICAgICAgICAgICB0MCA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgICAgICAgICBpZiAociA8IHQwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyIDwgdDEpXG4gICAgICAgICAgICAgICAgdDEgPSByO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0MCA+IDApXG4gICAgICAgICAgICBhWzBdID0gYXggKyB0MCAqIGR4LCBhWzFdID0gYXkgKyB0MCAqIGR5O1xuICAgICAgICBpZiAodDEgPCAxKVxuICAgICAgICAgICAgYlswXSA9IGF4ICsgdDEgKiBkeCwgYlsxXSA9IGF5ICsgdDEgKiBkeTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBjbGlwTWF4ID0gMWU5LCBjbGlwTWluID0gLWNsaXBNYXg7XG4gICAgLy8gVE9ETyBVc2UgZDMtcG9seWdvbuKAmXMgcG9seWdvbkNvbnRhaW5zIGhlcmUgZm9yIHRoZSByaW5nIGNoZWNrP1xuICAgIC8vIFRPRE8gRWxpbWluYXRlIGR1cGxpY2F0ZSBidWZmZXJpbmcgaW4gY2xpcEJ1ZmZlciBhbmQgcG9seWdvbi5wdXNoP1xuICAgIGZ1bmN0aW9uIGNsaXBSZWN0YW5nbGUoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgZnVuY3Rpb24gdmlzaWJsZSh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geDAgPD0geCAmJiB4IDw9IHgxICYmIHkwIDw9IHkgJiYgeSA8PSB5MTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBhID0gMCwgYTEgPSAwO1xuICAgICAgICAgICAgaWYgKGZyb20gPT0gbnVsbFxuICAgICAgICAgICAgICAgIHx8IChhID0gY29ybmVyKGZyb20sIGRpcmVjdGlvbikpICE9PSAoYTEgPSBjb3JuZXIodG8sIGRpcmVjdGlvbikpXG4gICAgICAgICAgICAgICAgfHwgY29tcGFyZVBvaW50KGZyb20sIHRvKSA8IDAgXiBkaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KGEgPT09IDAgfHwgYSA9PT0gMyA/IHgwIDogeDEsIGEgPiAxID8geTEgOiB5MCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChhID0gKGEgKyBkaXJlY3Rpb24gKyA0KSAlIDQpICE9PSBhMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb3JuZXIocCwgZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJzKHBbMF0gLSB4MCkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDAgOiAzXG4gICAgICAgICAgICAgICAgOiBhYnMocFswXSAtIHgxKSA8IGVwc2lsb24gPyBkaXJlY3Rpb24gPiAwID8gMiA6IDFcbiAgICAgICAgICAgICAgICAgICAgOiBhYnMocFsxXSAtIHkwKSA8IGVwc2lsb24gPyBkaXJlY3Rpb24gPiAwID8gMSA6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZGlyZWN0aW9uID4gMCA/IDMgOiAyOyAvLyBhYnMocFsxXSAtIHkxKSA8IGVwc2lsb25cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlUG9pbnQoYS54LCBiLngpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhcmVQb2ludChhLCBiKSB7XG4gICAgICAgICAgICB2YXIgY2EgPSBjb3JuZXIoYSwgMSksIGNiID0gY29ybmVyKGIsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIGNhICE9PSBjYiA/IGNhIC0gY2JcbiAgICAgICAgICAgICAgICA6IGNhID09PSAwID8gYlsxXSAtIGFbMV1cbiAgICAgICAgICAgICAgICAgICAgOiBjYSA9PT0gMSA/IGFbMF0gLSBiWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNhID09PSAyID8gYVsxXSAtIGJbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGJbMF0gLSBhWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgYWN0aXZlU3RyZWFtID0gc3RyZWFtLCBidWZmZXJTdHJlYW0gPSBjbGlwQnVmZmVyKCksIHNlZ21lbnRzLCBwb2x5Z29uLCByaW5nLCB4X18sIHlfXywgdl9fLCAvLyBmaXJzdCBwb2ludFxuICAgICAgICAgICAgeF8sIHlfLCB2XywgLy8gcHJldmlvdXMgcG9pbnRcbiAgICAgICAgICAgIGZpcnN0LCBjbGVhbjtcbiAgICAgICAgICAgIHZhciBjbGlwU3RyZWFtID0ge1xuICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgICAgICAgICAgIHBvbHlnb25TdGFydDogcG9seWdvblN0YXJ0LFxuICAgICAgICAgICAgICAgIHBvbHlnb25FbmQ6IHBvbHlnb25FbmRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpc2libGUoeCwgeSkpXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBvbHlnb25JbnNpZGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpbmRpbmcgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcmluZyA9IHBvbHlnb25baV0sIGogPSAxLCBtID0gcmluZy5sZW5ndGgsIHBvaW50ID0gcmluZ1swXSwgYTAsIGExLCBiMCA9IHBvaW50WzBdLCBiMSA9IHBvaW50WzFdOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhMCA9IGIwLCBhMSA9IGIxLCBwb2ludCA9IHJpbmdbal0sIGIwID0gcG9pbnRbMF0sIGIxID0gcG9pbnRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYTEgPD0geTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYjEgPiB5MSAmJiAoYjAgLSBhMCkgKiAoeTEgLSBhMSkgPiAoYjEgLSBhMSkgKiAoeDAgLSBhMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrd2luZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiMSA8PSB5MSAmJiAoYjAgLSBhMCkgKiAoeTEgLSBhMSkgPCAoYjEgLSBhMSkgKiAoeDAgLSBhMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0td2luZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJ1ZmZlciBnZW9tZXRyeSB3aXRoaW4gYSBwb2x5Z29uIGFuZCB0aGVuIGNsaXAgaXQgZW4gbWFzc2UuXG4gICAgICAgICAgICBmdW5jdGlvbiBwb2x5Z29uU3RhcnQoKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtID0gYnVmZmVyU3RyZWFtLCBzZWdtZW50cyA9IFtdLCBwb2x5Z29uID0gW10sIGNsZWFuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBvbHlnb25FbmQoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gcG9seWdvbkluc2lkZSgpLCBjbGVhbkluc2lkZSA9IGNsZWFuICYmIHN0YXJ0SW5zaWRlLCB2aXNpYmxlID0gKHNlZ21lbnRzID0gZDNBcnJheS5tZXJnZShzZWdtZW50cykpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW5JbnNpZGUgfHwgdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGVhbkluc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBSZWpvaW4oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0gPSBzdHJlYW0sIHNlZ21lbnRzID0gcG9seWdvbiA9IHJpbmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgICAgICAgICAgIGNsaXBTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvbHlnb24pXG4gICAgICAgICAgICAgICAgICAgIHBvbHlnb24ucHVzaChyaW5nID0gW10pO1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2XyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHhfID0geV8gPSBOYU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPIHJhdGhlciB0aGFuIHNwZWNpYWwtY2FzZSBwb2x5Z29ucywgc2ltcGx5IGhhbmRsZSB0aGVtIHNlcGFyYXRlbHkuXG4gICAgICAgICAgICAvLyBJZGVhbGx5LCBjb2luY2lkZW50IGludGVyc2VjdGlvbiBwb2ludHMgc2hvdWxkIGJlIGppdHRlcmVkIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBjbGlwcGluZyBpc3N1ZXMuXG4gICAgICAgICAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50cykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lUG9pbnQoeF9fLCB5X18pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodl9fICYmIHZfKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyU3RyZWFtLnJlam9pbigpO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKGJ1ZmZlclN0cmVhbS5yZXN1bHQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsaXBTdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgICAgICBpZiAodl8pXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsaW5lUG9pbnQoeCwgeSkge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gdmlzaWJsZSh4LCB5KTtcbiAgICAgICAgICAgICAgICBpZiAocG9seWdvbilcbiAgICAgICAgICAgICAgICAgICAgcmluZy5wdXNoKFt4LCB5XSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHhfXyA9IHgsIHlfXyA9IHksIHZfXyA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICYmIHZfKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gW3hfID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeF8pKSwgeV8gPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB5XykpXSwgYiA9IFt4ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeCkpLCB5ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeSkpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGlwTGluZShhLCBiLCB4MCwgeTAsIHgxLCB5MSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoYlswXSwgYlsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHhfID0geCwgeV8gPSB5LCB2XyA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2xpcFN0cmVhbTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0ZW50KCkge1xuICAgICAgICB2YXIgeDAgPSAwLCB5MCA9IDAsIHgxID0gOTYwLCB5MSA9IDUwMCwgY2FjaGUsIGNhY2hlU3RyZWFtLCBjbGlwO1xuICAgICAgICByZXR1cm4gY2xpcCA9IHtcbiAgICAgICAgICAgIHN0cmVhbTogZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IGNsaXBSZWN0YW5nbGUoeDAsIHkwLCB4MSwgeTEpKGNhY2hlU3RyZWFtID0gc3RyZWFtKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHRlbnQ6IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSwgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGwsIGNsaXApIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBsZW5ndGhTdW0gPSBhZGRlcigpLCBsYW1iZGEwJDIsIHNpblBoaTAkMSwgY29zUGhpMCQxO1xuICAgIHZhciBsZW5ndGhTdHJlYW0gPSB7XG4gICAgICAgIHNwaGVyZTogbm9vcCxcbiAgICAgICAgcG9pbnQ6IG5vb3AsXG4gICAgICAgIGxpbmVTdGFydDogbGVuZ3RoTGluZVN0YXJ0LFxuICAgICAgICBsaW5lRW5kOiBub29wLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IG5vb3AsXG4gICAgICAgIHBvbHlnb25FbmQ6IG5vb3BcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxlbmd0aExpbmVTdGFydCgpIHtcbiAgICAgICAgbGVuZ3RoU3RyZWFtLnBvaW50ID0gbGVuZ3RoUG9pbnRGaXJzdDtcbiAgICAgICAgbGVuZ3RoU3RyZWFtLmxpbmVFbmQgPSBsZW5ndGhMaW5lRW5kO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZW5ndGhMaW5lRW5kKCkge1xuICAgICAgICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhTdHJlYW0ubGluZUVuZCA9IG5vb3A7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxlbmd0aFBvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICAgICAgICBsYW1iZGEwJDIgPSBsYW1iZGEsIHNpblBoaTAkMSA9IHNpbihwaGkpLCBjb3NQaGkwJDEgPSBjb3MocGhpKTtcbiAgICAgICAgbGVuZ3RoU3RyZWFtLnBvaW50ID0gbGVuZ3RoUG9pbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxlbmd0aFBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgICAgICAgdmFyIHNpblBoaSA9IHNpbihwaGkpLCBjb3NQaGkgPSBjb3MocGhpKSwgZGVsdGEgPSBhYnMobGFtYmRhIC0gbGFtYmRhMCQyKSwgY29zRGVsdGEgPSBjb3MoZGVsdGEpLCBzaW5EZWx0YSA9IHNpbihkZWx0YSksIHggPSBjb3NQaGkgKiBzaW5EZWx0YSwgeSA9IGNvc1BoaTAkMSAqIHNpblBoaSAtIHNpblBoaTAkMSAqIGNvc1BoaSAqIGNvc0RlbHRhLCB6ID0gc2luUGhpMCQxICogc2luUGhpICsgY29zUGhpMCQxICogY29zUGhpICogY29zRGVsdGE7XG4gICAgICAgIGxlbmd0aFN1bS5hZGQoYXRhbjIoc3FydCh4ICogeCArIHkgKiB5KSwgeikpO1xuICAgICAgICBsYW1iZGEwJDIgPSBsYW1iZGEsIHNpblBoaTAkMSA9IHNpblBoaSwgY29zUGhpMCQxID0gY29zUGhpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZW5ndGgob2JqZWN0KSB7XG4gICAgICAgIGxlbmd0aFN1bS5yZXNldCgpO1xuICAgICAgICBnZW9TdHJlYW0ob2JqZWN0LCBsZW5ndGhTdHJlYW0pO1xuICAgICAgICByZXR1cm4gK2xlbmd0aFN1bTtcbiAgICB9XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gW251bGwsIG51bGxdLCBvYmplY3QgPSB7IHR5cGU6IFwiTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogY29vcmRpbmF0ZXMgfTtcbiAgICBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgICAgIGNvb3JkaW5hdGVzWzBdID0gYTtcbiAgICAgICAgY29vcmRpbmF0ZXNbMV0gPSBiO1xuICAgICAgICByZXR1cm4gbGVuZ3RoKG9iamVjdCk7XG4gICAgfVxuICAgIHZhciBjb250YWluc09iamVjdFR5cGUgPSB7XG4gICAgICAgIEZlYXR1cmU6IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbnNHZW9tZXRyeShvYmplY3QuZ2VvbWV0cnksIHBvaW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBvYmplY3QuZmVhdHVyZXMsIGkgPSAtMSwgbiA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIGlmIChjb250YWluc0dlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBwb2ludCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY29udGFpbnNHZW9tZXRyeVR5cGUgPSB7XG4gICAgICAgIFNwaGVyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIFBvaW50OiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zUG9pbnQob2JqZWN0LmNvb3JkaW5hdGVzLCBwb2ludCk7XG4gICAgICAgIH0sXG4gICAgICAgIE11bHRpUG9pbnQ6IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIGlmIChjb250YWluc1BvaW50KGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBMaW5lU3RyaW5nOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zTGluZShvYmplY3QuY29vcmRpbmF0ZXMsIHBvaW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNMaW5lKGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBQb2x5Z29uOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5zUG9seWdvbihvYmplY3QuY29vcmRpbmF0ZXMsIHBvaW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNQb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cmllcyA9IG9iamVjdC5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIGlmIChjb250YWluc0dlb21ldHJ5KGdlb21ldHJpZXNbaV0sIHBvaW50KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zR2VvbWV0cnkoZ2VvbWV0cnksIHBvaW50KSB7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeSAmJiBjb250YWluc0dlb21ldHJ5VHlwZS5oYXNPd25Qcm9wZXJ0eShnZW9tZXRyeS50eXBlKVxuICAgICAgICAgICAgPyBjb250YWluc0dlb21ldHJ5VHlwZVtnZW9tZXRyeS50eXBlXShnZW9tZXRyeSwgcG9pbnQpXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluc1BvaW50KGNvb3JkaW5hdGVzLCBwb2ludCkge1xuICAgICAgICByZXR1cm4gZGlzdGFuY2UoY29vcmRpbmF0ZXMsIHBvaW50KSA9PT0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGFpbnNMaW5lKGNvb3JkaW5hdGVzLCBwb2ludCkge1xuICAgICAgICB2YXIgYW8sIGJvLCBhYjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGJvID0gZGlzdGFuY2UoY29vcmRpbmF0ZXNbaV0sIHBvaW50KTtcbiAgICAgICAgICAgIGlmIChibyA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIGFiID0gZGlzdGFuY2UoY29vcmRpbmF0ZXNbaV0sIGNvb3JkaW5hdGVzW2kgLSAxXSk7XG4gICAgICAgICAgICAgICAgaWYgKGFiID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBhbyA8PSBhYiAmJlxuICAgICAgICAgICAgICAgICAgICBibyA8PSBhYiAmJlxuICAgICAgICAgICAgICAgICAgICAoYW8gKyBibyAtIGFiKSAqICgxIC0gTWF0aC5wb3coKGFvIC0gYm8pIC8gYWIsIDIpKSA8IGVwc2lsb24yICogYWIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW8gPSBibztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zUG9seWdvbihjb29yZGluYXRlcywgcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuICEhcG9seWdvbkNvbnRhaW5zKGNvb3JkaW5hdGVzLm1hcChyaW5nUmFkaWFucyksIHBvaW50UmFkaWFucyhwb2ludCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByaW5nUmFkaWFucyhyaW5nKSB7XG4gICAgICAgIHJldHVybiByaW5nID0gcmluZy5tYXAocG9pbnRSYWRpYW5zKSwgcmluZy5wb3AoKSwgcmluZztcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRSYWRpYW5zKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBbcG9pbnRbMF0gKiByYWRpYW5zLCBwb2ludFsxXSAqIHJhZGlhbnNdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWlucyhvYmplY3QsIHBvaW50KSB7XG4gICAgICAgIHJldHVybiAob2JqZWN0ICYmIGNvbnRhaW5zT2JqZWN0VHlwZS5oYXNPd25Qcm9wZXJ0eShvYmplY3QudHlwZSlcbiAgICAgICAgICAgID8gY29udGFpbnNPYmplY3RUeXBlW29iamVjdC50eXBlXVxuICAgICAgICAgICAgOiBjb250YWluc0dlb21ldHJ5KShvYmplY3QsIHBvaW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ3JhdGljdWxlWCh5MCwgeTEsIGR5KSB7XG4gICAgICAgIHZhciB5ID0gZDNBcnJheS5yYW5nZSh5MCwgeTEgLSBlcHNpbG9uLCBkeSkuY29uY2F0KHkxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7IHJldHVybiB5Lm1hcChmdW5jdGlvbiAoeSkgeyByZXR1cm4gW3gsIHldOyB9KTsgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ3JhdGljdWxlWSh4MCwgeDEsIGR4KSB7XG4gICAgICAgIHZhciB4ID0gZDNBcnJheS5yYW5nZSh4MCwgeDEgLSBlcHNpbG9uLCBkeCkuY29uY2F0KHgxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh5KSB7IHJldHVybiB4Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gW3gsIHldOyB9KTsgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICAgICAgICB2YXIgeDEsIHgwLCBYMSwgWDAsIHkxLCB5MCwgWTEsIFkwLCBkeCA9IDEwLCBkeSA9IGR4LCBEWCA9IDkwLCBEWSA9IDM2MCwgeCwgeSwgWCwgWSwgcHJlY2lzaW9uID0gMi41O1xuICAgICAgICBmdW5jdGlvbiBncmF0aWN1bGUoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogbGluZXMoKSB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxpbmVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGQzQXJyYXkucmFuZ2UoY2VpbChYMCAvIERYKSAqIERYLCBYMSwgRFgpLm1hcChYKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoZDNBcnJheS5yYW5nZShjZWlsKFkwIC8gRFkpICogRFksIFkxLCBEWSkubWFwKFkpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoZDNBcnJheS5yYW5nZShjZWlsKHgwIC8gZHgpICogZHgsIHgxLCBkeCkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiBhYnMoeCAlIERYKSA+IGVwc2lsb247IH0pLm1hcCh4KSlcbiAgICAgICAgICAgICAgICAuY29uY2F0KGQzQXJyYXkucmFuZ2UoY2VpbCh5MCAvIGR5KSAqIGR5LCB5MSwgZHkpLmZpbHRlcihmdW5jdGlvbiAoeSkgeyByZXR1cm4gYWJzKHkgJSBEWSkgPiBlcHNpbG9uOyB9KS5tYXAoeSkpO1xuICAgICAgICB9XG4gICAgICAgIGdyYXRpY3VsZS5saW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lcygpLm1hcChmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHsgcmV0dXJuIHsgdHlwZTogXCJMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlcyB9OyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZ3JhdGljdWxlLm91dGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBbXG4gICAgICAgICAgICAgICAgICAgIFgoWDApLmNvbmNhdChZKFkxKS5zbGljZSgxKSwgWChYMSkucmV2ZXJzZSgpLnNsaWNlKDEpLCBZKFkwKS5yZXZlcnNlKCkuc2xpY2UoMSkpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgZ3JhdGljdWxlLmV4dGVudCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyYXRpY3VsZS5leHRlbnRNaW5vcigpO1xuICAgICAgICAgICAgcmV0dXJuIGdyYXRpY3VsZS5leHRlbnRNYWpvcihfKS5leHRlbnRNaW5vcihfKTtcbiAgICAgICAgfTtcbiAgICAgICAgZ3JhdGljdWxlLmV4dGVudE1ham9yID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gW1tYMCwgWTBdLCBbWDEsIFkxXV07XG4gICAgICAgICAgICBYMCA9ICtfWzBdWzBdLCBYMSA9ICtfWzFdWzBdO1xuICAgICAgICAgICAgWTAgPSArX1swXVsxXSwgWTEgPSArX1sxXVsxXTtcbiAgICAgICAgICAgIGlmIChYMCA+IFgxKVxuICAgICAgICAgICAgICAgIF8gPSBYMCwgWDAgPSBYMSwgWDEgPSBfO1xuICAgICAgICAgICAgaWYgKFkwID4gWTEpXG4gICAgICAgICAgICAgICAgXyA9IFkwLCBZMCA9IFkxLCBZMSA9IF87XG4gICAgICAgICAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICAgICAgICB9O1xuICAgICAgICBncmF0aWN1bGUuZXh0ZW50TWlub3IgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICAgICAgICAgIHgwID0gK19bMF1bMF0sIHgxID0gK19bMV1bMF07XG4gICAgICAgICAgICB5MCA9ICtfWzBdWzFdLCB5MSA9ICtfWzFdWzFdO1xuICAgICAgICAgICAgaWYgKHgwID4geDEpXG4gICAgICAgICAgICAgICAgXyA9IHgwLCB4MCA9IHgxLCB4MSA9IF87XG4gICAgICAgICAgICBpZiAoeTAgPiB5MSlcbiAgICAgICAgICAgICAgICBfID0geTAsIHkwID0geTEsIHkxID0gXztcbiAgICAgICAgICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gICAgICAgIH07XG4gICAgICAgIGdyYXRpY3VsZS5zdGVwID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JhdGljdWxlLnN0ZXBNaW5vcigpO1xuICAgICAgICAgICAgcmV0dXJuIGdyYXRpY3VsZS5zdGVwTWFqb3IoXykuc3RlcE1pbm9yKF8pO1xuICAgICAgICB9O1xuICAgICAgICBncmF0aWN1bGUuc3RlcE1ham9yID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gW0RYLCBEWV07XG4gICAgICAgICAgICBEWCA9ICtfWzBdLCBEWSA9ICtfWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgICAgICAgfTtcbiAgICAgICAgZ3JhdGljdWxlLnN0ZXBNaW5vciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtkeCwgZHldO1xuICAgICAgICAgICAgZHggPSArX1swXSwgZHkgPSArX1sxXTtcbiAgICAgICAgICAgIHJldHVybiBncmF0aWN1bGU7XG4gICAgICAgIH07XG4gICAgICAgIGdyYXRpY3VsZS5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVjaXNpb247XG4gICAgICAgICAgICBwcmVjaXNpb24gPSArXztcbiAgICAgICAgICAgIHggPSBncmF0aWN1bGVYKHkwLCB5MSwgOTApO1xuICAgICAgICAgICAgeSA9IGdyYXRpY3VsZVkoeDAsIHgxLCBwcmVjaXNpb24pO1xuICAgICAgICAgICAgWCA9IGdyYXRpY3VsZVgoWTAsIFkxLCA5MCk7XG4gICAgICAgICAgICBZID0gZ3JhdGljdWxlWShYMCwgWDEsIHByZWNpc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gZ3JhdGljdWxlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ3JhdGljdWxlXG4gICAgICAgICAgICAuZXh0ZW50TWFqb3IoW1stMTgwLCAtOTAgKyBlcHNpbG9uXSwgWzE4MCwgOTAgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAuZXh0ZW50TWlub3IoW1stMTgwLCAtODAgLSBlcHNpbG9uXSwgWzE4MCwgODAgKyBlcHNpbG9uXV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBncmF0aWN1bGUxMCgpIHtcbiAgICAgICAgcmV0dXJuIGdyYXRpY3VsZSgpKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlKGEsIGIpIHtcbiAgICAgICAgdmFyIHgwID0gYVswXSAqIHJhZGlhbnMsIHkwID0gYVsxXSAqIHJhZGlhbnMsIHgxID0gYlswXSAqIHJhZGlhbnMsIHkxID0gYlsxXSAqIHJhZGlhbnMsIGN5MCA9IGNvcyh5MCksIHN5MCA9IHNpbih5MCksIGN5MSA9IGNvcyh5MSksIHN5MSA9IHNpbih5MSksIGt4MCA9IGN5MCAqIGNvcyh4MCksIGt5MCA9IGN5MCAqIHNpbih4MCksIGt4MSA9IGN5MSAqIGNvcyh4MSksIGt5MSA9IGN5MSAqIHNpbih4MSksIGQgPSAyICogYXNpbihzcXJ0KGhhdmVyc2luKHkxIC0geTApICsgY3kwICogY3kxICogaGF2ZXJzaW4oeDEgLSB4MCkpKSwgayA9IHNpbihkKTtcbiAgICAgICAgdmFyIGludGVycG9sYXRlID0gZCA/IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgQiA9IHNpbih0ICo9IGQpIC8gaywgQSA9IHNpbihkIC0gdCkgLyBrLCB4ID0gQSAqIGt4MCArIEIgKiBreDEsIHkgPSBBICoga3kwICsgQiAqIGt5MSwgeiA9IEEgKiBzeTAgKyBCICogc3kxO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBhdGFuMih5LCB4KSAqIGRlZ3JlZXMsXG4gICAgICAgICAgICAgICAgYXRhbjIoeiwgc3FydCh4ICogeCArIHkgKiB5KSkgKiBkZWdyZWVzXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFt4MCAqIGRlZ3JlZXMsIHkwICogZGVncmVlc107XG4gICAgICAgIH07XG4gICAgICAgIGludGVycG9sYXRlLmRpc3RhbmNlID0gZDtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICB2YXIgYXJlYVN1bSQxID0gYWRkZXIoKSwgYXJlYVJpbmdTdW0kMSA9IGFkZGVyKCksIHgwMCwgeTAwLCB4MCQxLCB5MCQxO1xuICAgIHZhciBhcmVhU3RyZWFtJDEgPSB7XG4gICAgICAgIHBvaW50OiBub29wLFxuICAgICAgICBsaW5lU3RhcnQ6IG5vb3AsXG4gICAgICAgIGxpbmVFbmQ6IG5vb3AsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXJlYVN0cmVhbSQxLmxpbmVTdGFydCA9IGFyZWFSaW5nU3RhcnQkMTtcbiAgICAgICAgICAgIGFyZWFTdHJlYW0kMS5saW5lRW5kID0gYXJlYVJpbmdFbmQkMTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXJlYVN0cmVhbSQxLmxpbmVTdGFydCA9IGFyZWFTdHJlYW0kMS5saW5lRW5kID0gYXJlYVN0cmVhbSQxLnBvaW50ID0gbm9vcDtcbiAgICAgICAgICAgIGFyZWFTdW0kMS5hZGQoYWJzKGFyZWFSaW5nU3VtJDEpKTtcbiAgICAgICAgICAgIGFyZWFSaW5nU3VtJDEucmVzZXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJlYSA9IGFyZWFTdW0kMSAvIDI7XG4gICAgICAgICAgICBhcmVhU3VtJDEucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBhcmVhO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBhcmVhUmluZ1N0YXJ0JDEoKSB7XG4gICAgICAgIGFyZWFTdHJlYW0kMS5wb2ludCA9IGFyZWFQb2ludEZpcnN0JDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZWFQb2ludEZpcnN0JDEoeCwgeSkge1xuICAgICAgICBhcmVhU3RyZWFtJDEucG9pbnQgPSBhcmVhUG9pbnQkMTtcbiAgICAgICAgeDAwID0geDAkMSA9IHgsIHkwMCA9IHkwJDEgPSB5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVhUG9pbnQkMSh4LCB5KSB7XG4gICAgICAgIGFyZWFSaW5nU3VtJDEuYWRkKHkwJDEgKiB4IC0geDAkMSAqIHkpO1xuICAgICAgICB4MCQxID0geCwgeTAkMSA9IHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZWFSaW5nRW5kJDEoKSB7XG4gICAgICAgIGFyZWFQb2ludCQxKHgwMCwgeTAwKTtcbiAgICB9XG4gICAgdmFyIHgwJDIgPSBJbmZpbml0eSwgeTAkMiA9IHgwJDIsIHgxID0gLXgwJDIsIHkxID0geDE7XG4gICAgdmFyIGJvdW5kc1N0cmVhbSQxID0ge1xuICAgICAgICBwb2ludDogYm91bmRzUG9pbnQkMSxcbiAgICAgICAgbGluZVN0YXJ0OiBub29wLFxuICAgICAgICBsaW5lRW5kOiBub29wLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IG5vb3AsXG4gICAgICAgIHBvbHlnb25FbmQ6IG5vb3AsXG4gICAgICAgIHJlc3VsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IFtbeDAkMiwgeTAkMl0sIFt4MSwgeTFdXTtcbiAgICAgICAgICAgIHgxID0geTEgPSAtKHkwJDIgPSB4MCQyID0gSW5maW5pdHkpO1xuICAgICAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gYm91bmRzUG9pbnQkMSh4LCB5KSB7XG4gICAgICAgIGlmICh4IDwgeDAkMilcbiAgICAgICAgICAgIHgwJDIgPSB4O1xuICAgICAgICBpZiAoeCA+IHgxKVxuICAgICAgICAgICAgeDEgPSB4O1xuICAgICAgICBpZiAoeSA8IHkwJDIpXG4gICAgICAgICAgICB5MCQyID0geTtcbiAgICAgICAgaWYgKHkgPiB5MSlcbiAgICAgICAgICAgIHkxID0geTtcbiAgICB9XG4gICAgLy8gVE9ETyBFbmZvcmNlIHBvc2l0aXZlIGFyZWEgZm9yIGV4dGVyaW9yLCBuZWdhdGl2ZSBhcmVhIGZvciBpbnRlcmlvcj9cbiAgICB2YXIgWDAkMSA9IDAsIFkwJDEgPSAwLCBaMCQxID0gMCwgWDEkMSA9IDAsIFkxJDEgPSAwLCBaMSQxID0gMCwgWDIkMSA9IDAsIFkyJDEgPSAwLCBaMiQxID0gMCwgeDAwJDEsIHkwMCQxLCB4MCQzLCB5MCQzO1xuICAgIHZhciBjZW50cm9pZFN0cmVhbSQxID0ge1xuICAgICAgICBwb2ludDogY2VudHJvaWRQb2ludCQxLFxuICAgICAgICBsaW5lU3RhcnQ6IGNlbnRyb2lkTGluZVN0YXJ0JDEsXG4gICAgICAgIGxpbmVFbmQ6IGNlbnRyb2lkTGluZUVuZCQxLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZVN0YXJ0ID0gY2VudHJvaWRSaW5nU3RhcnQkMTtcbiAgICAgICAgICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZUVuZCA9IGNlbnRyb2lkUmluZ0VuZCQxO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludCQxO1xuICAgICAgICAgICAgY2VudHJvaWRTdHJlYW0kMS5saW5lU3RhcnQgPSBjZW50cm9pZExpbmVTdGFydCQxO1xuICAgICAgICAgICAgY2VudHJvaWRTdHJlYW0kMS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kJDE7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNlbnRyb2lkID0gWjIkMSA/IFtYMiQxIC8gWjIkMSwgWTIkMSAvIFoyJDFdXG4gICAgICAgICAgICAgICAgOiBaMSQxID8gW1gxJDEgLyBaMSQxLCBZMSQxIC8gWjEkMV1cbiAgICAgICAgICAgICAgICAgICAgOiBaMCQxID8gW1gwJDEgLyBaMCQxLCBZMCQxIC8gWjAkMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW05hTiwgTmFOXTtcbiAgICAgICAgICAgIFgwJDEgPSBZMCQxID0gWjAkMSA9XG4gICAgICAgICAgICAgICAgWDEkMSA9IFkxJDEgPSBaMSQxID1cbiAgICAgICAgICAgICAgICAgICAgWDIkMSA9IFkyJDEgPSBaMiQxID0gMDtcbiAgICAgICAgICAgIHJldHVybiBjZW50cm9pZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gY2VudHJvaWRQb2ludCQxKHgsIHkpIHtcbiAgICAgICAgWDAkMSArPSB4O1xuICAgICAgICBZMCQxICs9IHk7XG4gICAgICAgICsrWjAkMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRMaW5lU3RhcnQkMSgpIHtcbiAgICAgICAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnRGaXJzdExpbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRGaXJzdExpbmUoeCwgeSkge1xuICAgICAgICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludExpbmU7XG4gICAgICAgIGNlbnRyb2lkUG9pbnQkMSh4MCQzID0geCwgeTAkMyA9IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZFBvaW50TGluZSh4LCB5KSB7XG4gICAgICAgIHZhciBkeCA9IHggLSB4MCQzLCBkeSA9IHkgLSB5MCQzLCB6ID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIFgxJDEgKz0geiAqICh4MCQzICsgeCkgLyAyO1xuICAgICAgICBZMSQxICs9IHogKiAoeTAkMyArIHkpIC8gMjtcbiAgICAgICAgWjEkMSArPSB6O1xuICAgICAgICBjZW50cm9pZFBvaW50JDEoeDAkMyA9IHgsIHkwJDMgPSB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRMaW5lRW5kJDEoKSB7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50JDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUmluZ1N0YXJ0JDEoKSB7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50Rmlyc3RSaW5nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZFJpbmdFbmQkMSgpIHtcbiAgICAgICAgY2VudHJvaWRQb2ludFJpbmcoeDAwJDEsIHkwMCQxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRQb2ludEZpcnN0UmluZyh4LCB5KSB7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50UmluZztcbiAgICAgICAgY2VudHJvaWRQb2ludCQxKHgwMCQxID0geDAkMyA9IHgsIHkwMCQxID0geTAkMyA9IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZFBvaW50UmluZyh4LCB5KSB7XG4gICAgICAgIHZhciBkeCA9IHggLSB4MCQzLCBkeSA9IHkgLSB5MCQzLCB6ID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIFgxJDEgKz0geiAqICh4MCQzICsgeCkgLyAyO1xuICAgICAgICBZMSQxICs9IHogKiAoeTAkMyArIHkpIC8gMjtcbiAgICAgICAgWjEkMSArPSB6O1xuICAgICAgICB6ID0geTAkMyAqIHggLSB4MCQzICogeTtcbiAgICAgICAgWDIkMSArPSB6ICogKHgwJDMgKyB4KTtcbiAgICAgICAgWTIkMSArPSB6ICogKHkwJDMgKyB5KTtcbiAgICAgICAgWjIkMSArPSB6ICogMztcbiAgICAgICAgY2VudHJvaWRQb2ludCQxKHgwJDMgPSB4LCB5MCQzID0geSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFBhdGhDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIFBhdGhDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgX3JhZGl1czogNC41LFxuICAgICAgICBwb2ludFJhZGl1czogZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXMgPSBfLCB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gTmFOO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmUgPT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gTmFOO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCArIHRoaXMuX3JhZGl1cywgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuYXJjKHgsIHksIHRoaXMuX3JhZGl1cywgMCwgdGF1KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXN1bHQ6IG5vb3BcbiAgICB9O1xuICAgIHZhciBsZW5ndGhTdW0kMSA9IGFkZGVyKCksIGxlbmd0aFJpbmcsIHgwMCQyLCB5MDAkMiwgeDAkNCwgeTAkNDtcbiAgICB2YXIgbGVuZ3RoU3RyZWFtJDEgPSB7XG4gICAgICAgIHBvaW50OiBub29wLFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxlbmd0aFN0cmVhbSQxLnBvaW50ID0gbGVuZ3RoUG9pbnRGaXJzdCQxO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobGVuZ3RoUmluZylcbiAgICAgICAgICAgICAgICBsZW5ndGhQb2ludCQxKHgwMCQyLCB5MDAkMik7XG4gICAgICAgICAgICBsZW5ndGhTdHJlYW0kMS5wb2ludCA9IG5vb3A7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGVuZ3RoUmluZyA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxlbmd0aFJpbmcgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSArbGVuZ3RoU3VtJDE7XG4gICAgICAgICAgICBsZW5ndGhTdW0kMS5yZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gbGVuZ3RoUG9pbnRGaXJzdCQxKHgsIHkpIHtcbiAgICAgICAgbGVuZ3RoU3RyZWFtJDEucG9pbnQgPSBsZW5ndGhQb2ludCQxO1xuICAgICAgICB4MDAkMiA9IHgwJDQgPSB4LCB5MDAkMiA9IHkwJDQgPSB5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZW5ndGhQb2ludCQxKHgsIHkpIHtcbiAgICAgICAgeDAkNCAtPSB4LCB5MCQ0IC09IHk7XG4gICAgICAgIGxlbmd0aFN1bSQxLmFkZChzcXJ0KHgwJDQgKiB4MCQ0ICsgeTAkNCAqIHkwJDQpKTtcbiAgICAgICAgeDAkNCA9IHgsIHkwJDQgPSB5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBQYXRoU3RyaW5nKCkge1xuICAgICAgICB0aGlzLl9zdHJpbmcgPSBbXTtcbiAgICB9XG4gICAgUGF0aFN0cmluZy5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9yYWRpdXM6IDQuNSxcbiAgICAgICAgX2NpcmNsZTogY2lyY2xlJDEoNC41KSxcbiAgICAgICAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoKF8gPSArXykgIT09IHRoaXMuX3JhZGl1cylcbiAgICAgICAgICAgICAgICB0aGlzLl9yYWRpdXMgPSBfLCB0aGlzLl9jaXJjbGUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZSA9PT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIlpcIik7XG4gICAgICAgICAgICB0aGlzLl9wb2ludCA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0cmluZy5wdXNoKFwiTVwiLCB4LCBcIixcIiwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIkxcIiwgeCwgXCIsXCIsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2lyY2xlID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUgPSBjaXJjbGUkMSh0aGlzLl9yYWRpdXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIk1cIiwgeCwgXCIsXCIsIHksIHRoaXMuX2NpcmNsZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9zdHJpbmcuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNpcmNsZSQxKHJhZGl1cykge1xuICAgICAgICByZXR1cm4gXCJtMCxcIiArIHJhZGl1c1xuICAgICAgICAgICAgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIC0yICogcmFkaXVzXG4gICAgICAgICAgICArIFwiYVwiICsgcmFkaXVzICsgXCIsXCIgKyByYWRpdXMgKyBcIiAwIDEsMSAwLFwiICsgMiAqIHJhZGl1c1xuICAgICAgICAgICAgKyBcInpcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5kZXgocHJvamVjdGlvbiwgY29udGV4dCkge1xuICAgICAgICB2YXIgcG9pbnRSYWRpdXMgPSA0LjUsIHByb2plY3Rpb25TdHJlYW0sIGNvbnRleHRTdHJlYW07XG4gICAgICAgIGZ1bmN0aW9uIHBhdGgob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludFJhZGl1cyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKCtwb2ludFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgICAgICAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGNvbnRleHRTdHJlYW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0U3RyZWFtLnJlc3VsdCgpO1xuICAgICAgICB9XG4gICAgICAgIHBhdGguYXJlYSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oYXJlYVN0cmVhbSQxKSk7XG4gICAgICAgICAgICByZXR1cm4gYXJlYVN0cmVhbSQxLnJlc3VsdCgpO1xuICAgICAgICB9O1xuICAgICAgICBwYXRoLm1lYXN1cmUgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGxlbmd0aFN0cmVhbSQxKSk7XG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoU3RyZWFtJDEucmVzdWx0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHBhdGguYm91bmRzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShib3VuZHNTdHJlYW0kMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGJvdW5kc1N0cmVhbSQxLnJlc3VsdCgpO1xuICAgICAgICB9O1xuICAgICAgICBwYXRoLmNlbnRyb2lkID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShjZW50cm9pZFN0cmVhbSQxKSk7XG4gICAgICAgICAgICByZXR1cm4gY2VudHJvaWRTdHJlYW0kMS5yZXN1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcGF0aC5wcm9qZWN0aW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByb2plY3Rpb25TdHJlYW0gPSBfID09IG51bGwgPyAocHJvamVjdGlvbiA9IG51bGwsIGlkZW50aXR5KSA6IChwcm9qZWN0aW9uID0gXykuc3RyZWFtLCBwYXRoKSA6IHByb2plY3Rpb247XG4gICAgICAgIH07XG4gICAgICAgIHBhdGguY29udGV4dCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgICAgICBjb250ZXh0U3RyZWFtID0gXyA9PSBudWxsID8gKGNvbnRleHQgPSBudWxsLCBuZXcgUGF0aFN0cmluZykgOiBuZXcgUGF0aENvbnRleHQoY29udGV4dCA9IF8pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb2ludFJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMocG9pbnRSYWRpdXMpO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH07XG4gICAgICAgIHBhdGgucG9pbnRSYWRpdXMgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb2ludFJhZGl1cztcbiAgICAgICAgICAgIHBvaW50UmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiAoY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrXyksICtfKTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGF0aC5wcm9qZWN0aW9uKHByb2plY3Rpb24pLmNvbnRleHQoY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShtZXRob2RzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdHJlYW06IHRyYW5zZm9ybWVyKG1ldGhvZHMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybWVyKG1ldGhvZHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBzID0gbmV3IFRyYW5zZm9ybVN0cmVhbTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKVxuICAgICAgICAgICAgICAgIHNba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgICAgICAgICAgIHMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbSgpIHsgfVxuICAgIFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm1TdHJlYW0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkgeyB0aGlzLnN0cmVhbS5wb2ludCh4LCB5KTsgfSxcbiAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7IHRoaXMuc3RyZWFtLnNwaGVyZSgpOyB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5zdHJlYW0ubGluZVN0YXJ0KCk7IH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5zdHJlYW0ubGluZUVuZCgpOyB9LFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5zdHJlYW0ucG9seWdvblN0YXJ0KCk7IH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgdGhpcy5zdHJlYW0ucG9seWdvbkVuZCgpOyB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBmaXQocHJvamVjdGlvbiwgZml0Qm91bmRzLCBvYmplY3QpIHtcbiAgICAgICAgdmFyIGNsaXAgPSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgJiYgcHJvamVjdGlvbi5jbGlwRXh0ZW50KCk7XG4gICAgICAgIHByb2plY3Rpb24uc2NhbGUoMTUwKS50cmFuc2xhdGUoWzAsIDBdKTtcbiAgICAgICAgaWYgKGNsaXAgIT0gbnVsbClcbiAgICAgICAgICAgIHByb2plY3Rpb24uY2xpcEV4dGVudChudWxsKTtcbiAgICAgICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvbi5zdHJlYW0oYm91bmRzU3RyZWFtJDEpKTtcbiAgICAgICAgZml0Qm91bmRzKGJvdW5kc1N0cmVhbSQxLnJlc3VsdCgpKTtcbiAgICAgICAgaWYgKGNsaXAgIT0gbnVsbClcbiAgICAgICAgICAgIHByb2plY3Rpb24uY2xpcEV4dGVudChjbGlwKTtcbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICB2YXIgdyA9IGV4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSwgaCA9IGV4dGVudFsxXVsxXSAtIGV4dGVudFswXVsxXSwgayA9IE1hdGgubWluKHcgLyAoYlsxXVswXSAtIGJbMF1bMF0pLCBoIC8gKGJbMV1bMV0gLSBiWzBdWzFdKSksIHggPSArZXh0ZW50WzBdWzBdICsgKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLCB5ID0gK2V4dGVudFswXVsxXSArIChoIC0gayAqIChiWzFdWzFdICsgYlswXVsxXSkpIC8gMjtcbiAgICAgICAgICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gICAgICAgIH0sIG9iamVjdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgW1swLCAwXSwgc2l6ZV0sIG9iamVjdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpdFdpZHRoKHByb2plY3Rpb24sIHdpZHRoLCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZpdChwcm9qZWN0aW9uLCBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgdmFyIHcgPSArd2lkdGgsIGsgPSB3IC8gKGJbMV1bMF0gLSBiWzBdWzBdKSwgeCA9ICh3IC0gayAqIChiWzFdWzBdICsgYlswXVswXSkpIC8gMiwgeSA9IC1rICogYlswXVsxXTtcbiAgICAgICAgICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gICAgICAgIH0sIG9iamVjdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpdEhlaWdodChwcm9qZWN0aW9uLCBoZWlnaHQsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICB2YXIgaCA9ICtoZWlnaHQsIGsgPSBoIC8gKGJbMV1bMV0gLSBiWzBdWzFdKSwgeCA9IC1rICogYlswXVswXSwgeSA9IChoIC0gayAqIChiWzFdWzFdICsgYlswXVsxXSkpIC8gMjtcbiAgICAgICAgICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gICAgICAgIH0sIG9iamVjdCk7XG4gICAgfVxuICAgIHZhciBtYXhEZXB0aCA9IDE2LCAvLyBtYXhpbXVtIGRlcHRoIG9mIHN1YmRpdmlzaW9uXG4gICAgY29zTWluRGlzdGFuY2UgPSBjb3MoMzAgKiByYWRpYW5zKTsgLy8gY29zKG1pbmltdW0gYW5ndWxhciBkaXN0YW5jZSlcbiAgICBmdW5jdGlvbiByZXNhbXBsZShwcm9qZWN0LCBkZWx0YTIpIHtcbiAgICAgICAgcmV0dXJuICtkZWx0YTIgPyByZXNhbXBsZSQxKHByb2plY3QsIGRlbHRhMikgOiByZXNhbXBsZU5vbmUocHJvamVjdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2FtcGxlTm9uZShwcm9qZWN0KSB7XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcih7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2FtcGxlJDEocHJvamVjdCwgZGVsdGEyKSB7XG4gICAgICAgIGZ1bmN0aW9uIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDEsIHkxLCBsYW1iZGExLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgZHggPSB4MSAtIHgwLCBkeSA9IHkxIC0geTAsIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgICAgICBpZiAoZDIgPiA0ICogZGVsdGEyICYmIGRlcHRoLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGEwICsgYTEsIGIgPSBiMCArIGIxLCBjID0gYzAgKyBjMSwgbSA9IHNxcnQoYSAqIGEgKyBiICogYiArIGMgKiBjKSwgcGhpMiA9IGFzaW4oYyAvPSBtKSwgbGFtYmRhMiA9IGFicyhhYnMoYykgLSAxKSA8IGVwc2lsb24gfHwgYWJzKGxhbWJkYTAgLSBsYW1iZGExKSA8IGVwc2lsb24gPyAobGFtYmRhMCArIGxhbWJkYTEpIC8gMiA6IGF0YW4yKGIsIGEpLCBwID0gcHJvamVjdChsYW1iZGEyLCBwaGkyKSwgeDIgPSBwWzBdLCB5MiA9IHBbMV0sIGR4MiA9IHgyIC0geDAsIGR5MiA9IHkyIC0geTAsIGR6ID0gZHkgKiBkeDIgLSBkeCAqIGR5MjtcbiAgICAgICAgICAgICAgICBpZiAoZHogKiBkeiAvIGQyID4gZGVsdGEyIC8vIHBlcnBlbmRpY3VsYXIgcHJvamVjdGVkIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIHx8IGFicygoZHggKiBkeDIgKyBkeSAqIGR5MikgLyBkMiAtIDAuNSkgPiAwLjMgLy8gbWlkcG9pbnQgY2xvc2UgdG8gYW4gZW5kXG4gICAgICAgICAgICAgICAgICAgIHx8IGEwICogYTEgKyBiMCAqIGIxICsgYzAgKiBjMSA8IGNvc01pbkRpc3RhbmNlKSB7IC8vIGFuZ3VsYXIgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MiwgeTIsIGxhbWJkYTIsIGEgLz0gbSwgYiAvPSBtLCBjLCBkZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHgyLCB5Mik7XG4gICAgICAgICAgICAgICAgICAgIHJlc2FtcGxlTGluZVRvKHgyLCB5MiwgbGFtYmRhMiwgYSwgYiwgYywgeDEsIHkxLCBsYW1iZGExLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBsYW1iZGEwMCwgeDAwLCB5MDAsIGEwMCwgYjAwLCBjMDAsIC8vIGZpcnN0IHBvaW50XG4gICAgICAgICAgICBsYW1iZGEwLCB4MCwgeTAsIGEwLCBiMCwgYzA7IC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgICAgICB2YXIgcmVzYW1wbGVTdHJlYW0gPSB7XG4gICAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICAgICAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHN0cmVhbS5wb2x5Z29uU3RhcnQoKTsgcmVzYW1wbGVTdHJlYW0ubGluZVN0YXJ0ID0gcmluZ1N0YXJ0OyB9LFxuICAgICAgICAgICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHsgc3RyZWFtLnBvbHlnb25FbmQoKTsgcmVzYW1wbGVTdHJlYW0ubGluZVN0YXJ0ID0gbGluZVN0YXJ0OyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgICAgICAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgICAgICAgICAgICB4MCA9IE5hTjtcbiAgICAgICAgICAgICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IGNhcnRlc2lhbihbbGFtYmRhLCBwaGldKSwgcCA9IHByb2plY3QobGFtYmRhLCBwaGkpO1xuICAgICAgICAgICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDAgPSBwWzBdLCB5MCA9IHBbMV0sIGxhbWJkYTAgPSBsYW1iZGEsIGEwID0gY1swXSwgYjAgPSBjWzFdLCBjMCA9IGNbMl0sIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh4MCwgeTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgICAgICAgICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSByaW5nUG9pbnQ7XG4gICAgICAgICAgICAgICAgcmVzYW1wbGVTdHJlYW0ubGluZUVuZCA9IHJpbmdFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiByaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgICAgICBsaW5lUG9pbnQobGFtYmRhMDAgPSBsYW1iZGEsIHBoaSksIHgwMCA9IHgwLCB5MDAgPSB5MCwgYTAwID0gYTAsIGIwMCA9IGIwLCBjMDAgPSBjMDtcbiAgICAgICAgICAgICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICAgICAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MDAsIHkwMCwgbGFtYmRhMDAsIGEwMCwgYjAwLCBjMDAsIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgIHJlc2FtcGxlU3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICAgICAgICAgIGxpbmVFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNhbXBsZVN0cmVhbTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHRyYW5zZm9ybVJhZGlhbnMgPSB0cmFuc2Zvcm1lcih7XG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ucG9pbnQoeCAqIHJhZGlhbnMsIHkgKiByYWRpYW5zKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVJvdGF0ZShyb3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyKHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHZhciByID0gcm90YXRlKHgsIHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wb2ludChyWzBdLCByWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlVHJhbnNsYXRlKGssIGR4LCBkeSkge1xuICAgICAgICBmdW5jdGlvbiB0cmFuc2Zvcm0oeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIFtkeCArIGsgKiB4LCBkeSAtIGsgKiB5XTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2Zvcm0uaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBbKHggLSBkeCkgLyBrLCAoZHkgLSB5KSAvIGtdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZVJvdGF0ZShrLCBkeCwgZHksIGFscGhhKSB7XG4gICAgICAgIHZhciBjb3NBbHBoYSA9IGNvcyhhbHBoYSksIHNpbkFscGhhID0gc2luKGFscGhhKSwgYSA9IGNvc0FscGhhICogaywgYiA9IHNpbkFscGhhICogaywgYWkgPSBjb3NBbHBoYSAvIGssIGJpID0gc2luQWxwaGEgLyBrLCBjaSA9IChzaW5BbHBoYSAqIGR5IC0gY29zQWxwaGEgKiBkeCkgLyBrLCBmaSA9IChzaW5BbHBoYSAqIGR4ICsgY29zQWxwaGEgKiBkeSkgLyBrO1xuICAgICAgICBmdW5jdGlvbiB0cmFuc2Zvcm0oeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIFthICogeCAtIGIgKiB5ICsgZHgsIGR5IC0gYiAqIHggLSBhICogeV07XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmb3JtLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gW2FpICogeCAtIGJpICogeSArIGNpLCBmaSAtIGJpICogeCAtIGFpICogeV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByb2plY3Rpb24ocHJvamVjdCkge1xuICAgICAgICByZXR1cm4gcHJvamVjdGlvbk11dGF0b3IoZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvamVjdDsgfSkoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSB7XG4gICAgICAgIHZhciBwcm9qZWN0LCBrID0gMTUwLCAvLyBzY2FsZVxuICAgICAgICB4ID0gNDgwLCB5ID0gMjUwLCAvLyB0cmFuc2xhdGVcbiAgICAgICAgbGFtYmRhID0gMCwgcGhpID0gMCwgLy8gY2VudGVyXG4gICAgICAgIGRlbHRhTGFtYmRhID0gMCwgZGVsdGFQaGkgPSAwLCBkZWx0YUdhbW1hID0gMCwgcm90YXRlLCAvLyBwcmUtcm90YXRlXG4gICAgICAgIGFscGhhID0gMCwgLy8gcG9zdC1yb3RhdGVcbiAgICAgICAgdGhldGEgPSBudWxsLCBwcmVjbGlwID0gY2xpcEFudGltZXJpZGlhbiwgLy8gcHJlLWNsaXAgYW5nbGVcbiAgICAgICAgeDAgPSBudWxsLCB5MCwgeDEsIHkxLCBwb3N0Y2xpcCA9IGlkZW50aXR5LCAvLyBwb3N0LWNsaXAgZXh0ZW50XG4gICAgICAgIGRlbHRhMiA9IDAuNSwgLy8gcHJlY2lzaW9uXG4gICAgICAgIHByb2plY3RSZXNhbXBsZSwgcHJvamVjdFRyYW5zZm9ybSwgcHJvamVjdFJvdGF0ZVRyYW5zZm9ybSwgY2FjaGUsIGNhY2hlU3RyZWFtO1xuICAgICAgICBmdW5jdGlvbiBwcm9qZWN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdFJvdGF0ZVRyYW5zZm9ybShwb2ludFswXSAqIHJhZGlhbnMsIHBvaW50WzFdICogcmFkaWFucyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW52ZXJ0KHBvaW50KSB7XG4gICAgICAgICAgICBwb2ludCA9IHByb2plY3RSb3RhdGVUcmFuc2Zvcm0uaW52ZXJ0KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQgJiYgW3BvaW50WzBdICogZGVncmVlcywgcG9pbnRbMV0gKiBkZWdyZWVzXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9qZWN0aW9uLnN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IHRyYW5zZm9ybVJhZGlhbnModHJhbnNmb3JtUm90YXRlKHJvdGF0ZSkocHJlY2xpcChwcm9qZWN0UmVzYW1wbGUocG9zdGNsaXAoY2FjaGVTdHJlYW0gPSBzdHJlYW0pKSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5wcmVjbGlwID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByZWNsaXAgPSBfLCB0aGV0YSA9IHVuZGVmaW5lZCwgcmVzZXQoKSkgOiBwcmVjbGlwO1xuICAgICAgICB9O1xuICAgICAgICBwcm9qZWN0aW9uLnBvc3RjbGlwID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXywgeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCByZXNldCgpKSA6IHBvc3RjbGlwO1xuICAgICAgICB9O1xuICAgICAgICBwcm9qZWN0aW9uLmNsaXBBbmdsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjbGlwID0gK18gPyBjbGlwQ2lyY2xlKHRoZXRhID0gXyAqIHJhZGlhbnMpIDogKHRoZXRhID0gbnVsbCwgY2xpcEFudGltZXJpZGlhbiksIHJlc2V0KCkpIDogdGhldGEgKiBkZWdyZWVzO1xuICAgICAgICB9O1xuICAgICAgICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSkgOiBjbGlwUmVjdGFuZ2xlKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pLCByZXNldCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24uc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoayA9ICtfLCByZWNlbnRlcigpKSA6IGs7XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24udHJhbnNsYXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSArX1swXSwgeSA9ICtfWzFdLCByZWNlbnRlcigpKSA6IFt4LCB5XTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5jZW50ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobGFtYmRhID0gX1swXSAlIDM2MCAqIHJhZGlhbnMsIHBoaSA9IF9bMV0gJSAzNjAgKiByYWRpYW5zLCByZWNlbnRlcigpKSA6IFtsYW1iZGEgKiBkZWdyZWVzLCBwaGkgKiBkZWdyZWVzXTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5yb3RhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVsdGFMYW1iZGEgPSBfWzBdICUgMzYwICogcmFkaWFucywgZGVsdGFQaGkgPSBfWzFdICUgMzYwICogcmFkaWFucywgZGVsdGFHYW1tYSA9IF8ubGVuZ3RoID4gMiA/IF9bMl0gJSAzNjAgKiByYWRpYW5zIDogMCwgcmVjZW50ZXIoKSkgOiBbZGVsdGFMYW1iZGEgKiBkZWdyZWVzLCBkZWx0YVBoaSAqIGRlZ3JlZXMsIGRlbHRhR2FtbWEgKiBkZWdyZWVzXTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5hbmdsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYSA9IF8gJSAzNjAgKiByYWRpYW5zLCByZWNlbnRlcigpKSA6IGFscGhhICogZGVncmVlcztcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJvamVjdFJlc2FtcGxlID0gcmVzYW1wbGUocHJvamVjdFRyYW5zZm9ybSwgZGVsdGEyID0gXyAqIF8pLCByZXNldCgpKSA6IHNxcnQoZGVsdGEyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5maXRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBwcm9qZWN0aW9uLmZpdFNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBwcm9qZWN0aW9uLmZpdFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoLCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5maXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRIZWlnaHQocHJvamVjdGlvbiwgaGVpZ2h0LCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZWNlbnRlcigpIHtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBzY2FsZVRyYW5zbGF0ZVJvdGF0ZShrLCAwLCAwLCBhbHBoYSkuYXBwbHkobnVsbCwgcHJvamVjdChsYW1iZGEsIHBoaSkpLCB0cmFuc2Zvcm0gPSAoYWxwaGEgPyBzY2FsZVRyYW5zbGF0ZVJvdGF0ZSA6IHNjYWxlVHJhbnNsYXRlKShrLCB4IC0gY2VudGVyWzBdLCB5IC0gY2VudGVyWzFdLCBhbHBoYSk7XG4gICAgICAgICAgICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKGRlbHRhTGFtYmRhLCBkZWx0YVBoaSwgZGVsdGFHYW1tYSk7XG4gICAgICAgICAgICBwcm9qZWN0VHJhbnNmb3JtID0gY29tcG9zZShwcm9qZWN0LCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgcHJvamVjdFJvdGF0ZVRyYW5zZm9ybSA9IGNvbXBvc2Uocm90YXRlLCBwcm9qZWN0VHJhbnNmb3JtKTtcbiAgICAgICAgICAgIHByb2plY3RSZXNhbXBsZSA9IHJlc2FtcGxlKHByb2plY3RUcmFuc2Zvcm0sIGRlbHRhMik7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHByb2plY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2plY3QgPSBwcm9qZWN0QXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHByb2plY3Rpb24uaW52ZXJ0ID0gcHJvamVjdC5pbnZlcnQgJiYgaW52ZXJ0O1xuICAgICAgICAgICAgcmV0dXJuIHJlY2VudGVyKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbmljUHJvamVjdGlvbihwcm9qZWN0QXQpIHtcbiAgICAgICAgdmFyIHBoaTAgPSAwLCBwaGkxID0gcGkgLyAzLCBtID0gcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSwgcCA9IG0ocGhpMCwgcGhpMSk7XG4gICAgICAgIHAucGFyYWxsZWxzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gbShwaGkwID0gX1swXSAqIHJhZGlhbnMsIHBoaTEgPSBfWzFdICogcmFkaWFucykgOiBbcGhpMCAqIGRlZ3JlZXMsIHBoaTEgKiBkZWdyZWVzXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN5bGluZHJpY2FsRXF1YWxBcmVhUmF3KHBoaTApIHtcbiAgICAgICAgdmFyIGNvc1BoaTAgPSBjb3MocGhpMCk7XG4gICAgICAgIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGFtYmRhICogY29zUGhpMCwgc2luKHBoaSkgLyBjb3NQaGkwXTtcbiAgICAgICAgfVxuICAgICAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4gW3ggLyBjb3NQaGkwLCBhc2luKHkgKiBjb3NQaGkwKV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25pY0VxdWFsQXJlYVJhdyh5MCwgeTEpIHtcbiAgICAgICAgdmFyIHN5MCA9IHNpbih5MCksIG4gPSAoc3kwICsgc2luKHkxKSkgLyAyO1xuICAgICAgICAvLyBBcmUgdGhlIHBhcmFsbGVscyBzeW1tZXRyaWNhbCBhcm91bmQgdGhlIEVxdWF0b3I/XG4gICAgICAgIGlmIChhYnMobikgPCBlcHNpbG9uKVxuICAgICAgICAgICAgcmV0dXJuIGN5bGluZHJpY2FsRXF1YWxBcmVhUmF3KHkwKTtcbiAgICAgICAgdmFyIGMgPSAxICsgc3kwICogKDIgKiBuIC0gc3kwKSwgcjAgPSBzcXJ0KGMpIC8gbjtcbiAgICAgICAgZnVuY3Rpb24gcHJvamVjdCh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgciA9IHNxcnQoYyAtIDIgKiBuICogc2luKHkpKSAvIG47XG4gICAgICAgICAgICByZXR1cm4gW3IgKiBzaW4oeCAqPSBuKSwgcjAgLSByICogY29zKHgpXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9qZWN0LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgcjB5ID0gcjAgLSB5O1xuICAgICAgICAgICAgcmV0dXJuIFthdGFuMih4LCBhYnMocjB5KSkgLyBuICogc2lnbihyMHkpLCBhc2luKChjIC0gKHggKiB4ICsgcjB5ICogcjB5KSAqIG4gKiBuKSAvICgyICogbikpXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByb2plY3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbmljRXF1YWxBcmVhKCkge1xuICAgICAgICByZXR1cm4gY29uaWNQcm9qZWN0aW9uKGNvbmljRXF1YWxBcmVhUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE1NS40MjQpXG4gICAgICAgICAgICAuY2VudGVyKFswLCAzMy42NDQyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFsYmVycygpIHtcbiAgICAgICAgcmV0dXJuIGNvbmljRXF1YWxBcmVhKClcbiAgICAgICAgICAgIC5wYXJhbGxlbHMoWzI5LjUsIDQ1LjVdKVxuICAgICAgICAgICAgLnNjYWxlKDEwNzApXG4gICAgICAgICAgICAudHJhbnNsYXRlKFs0ODAsIDI1MF0pXG4gICAgICAgICAgICAucm90YXRlKFs5NiwgMF0pXG4gICAgICAgICAgICAuY2VudGVyKFstMC42LCAzOC43XSk7XG4gICAgfVxuICAgIC8vIFRoZSBwcm9qZWN0aW9ucyBtdXN0IGhhdmUgbXV0dWFsbHkgZXhjbHVzaXZlIGNsaXAgcmVnaW9ucyBvbiB0aGUgc3BoZXJlLFxuICAgIC8vIGFzIHRoaXMgd2lsbCBhdm9pZCBlbWl0dGluZyBpbnRlcmxlYXZpbmcgbGluZXMgYW5kIHBvbHlnb25zLlxuICAgIGZ1bmN0aW9uIG11bHRpcGxleChzdHJlYW1zKSB7XG4gICAgICAgIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2ludCh4LCB5KTsgfSxcbiAgICAgICAgICAgIHNwaGVyZTogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnNwaGVyZSgpOyB9LFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7IH0sXG4gICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZUVuZCgpOyB9LFxuICAgICAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7IH0sXG4gICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpOyB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEEgY29tcG9zaXRlIHByb2plY3Rpb24gZm9yIHRoZSBVbml0ZWQgU3RhdGVzLCBjb25maWd1cmVkIGJ5IGRlZmF1bHQgZm9yXG4gICAgLy8gOTYww5c1MDAuIFRoZSBwcm9qZWN0aW9uIGFsc28gd29ya3MgcXVpdGUgd2VsbCBhdCA5NjDDlzYwMCBpZiB5b3UgY2hhbmdlIHRoZVxuICAgIC8vIHNjYWxlIHRvIDEyODUgYW5kIGFkanVzdCB0aGUgdHJhbnNsYXRlIGFjY29yZGluZ2x5LiBUaGUgc2V0IG9mIHN0YW5kYXJkXG4gICAgLy8gcGFyYWxsZWxzIGZvciBlYWNoIHJlZ2lvbiBjb21lcyBmcm9tIFVTR1MsIHdoaWNoIGlzIHB1Ymxpc2hlZCBoZXJlOlxuICAgIC8vIGh0dHA6Ly9lZ3NjLnVzZ3MuZ292L2lzYi9wdWJzL01hcFByb2plY3Rpb25zL3Byb2plY3Rpb25zLmh0bWwjYWxiZXJzXG4gICAgZnVuY3Rpb24gYWxiZXJzVXNhKCkge1xuICAgICAgICB2YXIgY2FjaGUsIGNhY2hlU3RyZWFtLCBsb3dlcjQ4ID0gYWxiZXJzKCksIGxvd2VyNDhQb2ludCwgYWxhc2thID0gY29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWzE1NCwgMF0pLmNlbnRlcihbLTIsIDU4LjVdKS5wYXJhbGxlbHMoWzU1LCA2NV0pLCBhbGFza2FQb2ludCwgLy8gRVBTRzozMzM4XG4gICAgICAgIGhhd2FpaSA9IGNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsxNTcsIDBdKS5jZW50ZXIoWy0zLCAxOS45XSkucGFyYWxsZWxzKFs4LCAxOF0pLCBoYXdhaWlQb2ludCwgLy8gRVNSSToxMDIwMDdcbiAgICAgICAgcG9pbnQsIHBvaW50U3RyZWFtID0geyBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgcG9pbnQgPSBbeCwgeV07IH0gfTtcbiAgICAgICAgZnVuY3Rpb24gYWxiZXJzVXNhKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGNvb3JkaW5hdGVzWzBdLCB5ID0gY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQgPSBudWxsLFxuICAgICAgICAgICAgICAgIChsb3dlcjQ4UG9pbnQucG9pbnQoeCwgeSksIHBvaW50KVxuICAgICAgICAgICAgICAgICAgICB8fCAoYWxhc2thUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KVxuICAgICAgICAgICAgICAgICAgICB8fCAoaGF3YWlpUG9pbnQucG9pbnQoeCwgeSksIHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBhbGJlcnNVc2EuaW52ZXJ0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICB2YXIgayA9IGxvd2VyNDguc2NhbGUoKSwgdCA9IGxvd2VyNDgudHJhbnNsYXRlKCksIHggPSAoY29vcmRpbmF0ZXNbMF0gLSB0WzBdKSAvIGssIHkgPSAoY29vcmRpbmF0ZXNbMV0gLSB0WzFdKSAvIGs7XG4gICAgICAgICAgICByZXR1cm4gKHkgPj0gMC4xMjAgJiYgeSA8IDAuMjM0ICYmIHggPj0gLTAuNDI1ICYmIHggPCAtMC4yMTQgPyBhbGFza2FcbiAgICAgICAgICAgICAgICA6IHkgPj0gMC4xNjYgJiYgeSA8IDAuMjM0ICYmIHggPj0gLTAuMjE0ICYmIHggPCAtMC4xMTUgPyBoYXdhaWlcbiAgICAgICAgICAgICAgICAgICAgOiBsb3dlcjQ4KS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2Euc3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlICYmIGNhY2hlU3RyZWFtID09PSBzdHJlYW0gPyBjYWNoZSA6IGNhY2hlID0gbXVsdGlwbGV4KFtsb3dlcjQ4LnN0cmVhbShjYWNoZVN0cmVhbSA9IHN0cmVhbSksIGFsYXNrYS5zdHJlYW0oc3RyZWFtKSwgaGF3YWlpLnN0cmVhbShzdHJlYW0pXSk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBsb3dlcjQ4LnByZWNpc2lvbigpO1xuICAgICAgICAgICAgbG93ZXI0OC5wcmVjaXNpb24oXyksIGFsYXNrYS5wcmVjaXNpb24oXyksIGhhd2FpaS5wcmVjaXNpb24oXyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLnNjYWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbG93ZXI0OC5zY2FsZSgpO1xuICAgICAgICAgICAgbG93ZXI0OC5zY2FsZShfKSwgYWxhc2thLnNjYWxlKF8gKiAwLjM1KSwgaGF3YWlpLnNjYWxlKF8pO1xuICAgICAgICAgICAgcmV0dXJuIGFsYmVyc1VzYS50cmFuc2xhdGUobG93ZXI0OC50cmFuc2xhdGUoKSk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBsb3dlcjQ4LnRyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksIHggPSArX1swXSwgeSA9ICtfWzFdO1xuICAgICAgICAgICAgbG93ZXI0OFBvaW50ID0gbG93ZXI0OFxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoXylcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjQ1NSAqIGssIHkgLSAwLjIzOCAqIGtdLCBbeCArIDAuNDU1ICogaywgeSArIDAuMjM4ICoga11dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgYWxhc2thUG9pbnQgPSBhbGFza2FcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4zMDcgKiBrLCB5ICsgMC4yMDEgKiBrXSlcbiAgICAgICAgICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjQyNSAqIGsgKyBlcHNpbG9uLCB5ICsgMC4xMjAgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4yMTQgKiBrIC0gZXBzaWxvbiwgeSArIDAuMjM0ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGhhd2FpaVBvaW50ID0gaGF3YWlpXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMjA1ICogaywgeSArIDAuMjEyICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4yMTQgKiBrICsgZXBzaWxvbiwgeSArIDAuMTY2ICogayArIGVwc2lsb25dLCBbeCAtIDAuMTE1ICogayAtIGVwc2lsb24sIHkgKyAwLjIzNCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLmZpdEV4dGVudCA9IGZ1bmN0aW9uIChleHRlbnQsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdEV4dGVudChhbGJlcnNVc2EsIGV4dGVudCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLmZpdFNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0U2l6ZShhbGJlcnNVc2EsIHNpemUsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5maXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0V2lkdGgoYWxiZXJzVXNhLCB3aWR0aCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLmZpdEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdEhlaWdodChhbGJlcnNVc2EsIGhlaWdodCwgb2JqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBhbGJlcnNVc2E7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsYmVyc1VzYS5zY2FsZSgxMDcwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXppbXV0aGFsUmF3KHNjYWxlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGN4ID0gY29zKHgpLCBjeSA9IGNvcyh5KSwgayA9IHNjYWxlKGN4ICogY3kpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBrICogY3kgKiBzaW4oeCksXG4gICAgICAgICAgICAgICAgayAqIHNpbih5KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXppbXV0aGFsSW52ZXJ0KGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHogPSBzcXJ0KHggKiB4ICsgeSAqIHkpLCBjID0gYW5nbGUoeiksIHNjID0gc2luKGMpLCBjYyA9IGNvcyhjKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYXRhbjIoeCAqIHNjLCB6ICogY2MpLFxuICAgICAgICAgICAgICAgIGFzaW4oeiAmJiB5ICogc2MgLyB6KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGF6aW11dGhhbEVxdWFsQXJlYVJhdyA9IGF6aW11dGhhbFJhdyhmdW5jdGlvbiAoY3hjeSkge1xuICAgICAgICByZXR1cm4gc3FydCgyIC8gKDEgKyBjeGN5KSk7XG4gICAgfSk7XG4gICAgYXppbXV0aGFsRXF1YWxBcmVhUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbiAoeikge1xuICAgICAgICByZXR1cm4gMiAqIGFzaW4oeiAvIDIpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGF6aW11dGhhbEVxdWFsQXJlYSgpIHtcbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb24oYXppbXV0aGFsRXF1YWxBcmVhUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDEyNC43NSlcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoMTgwIC0gMWUtMyk7XG4gICAgfVxuICAgIHZhciBhemltdXRoYWxFcXVpZGlzdGFudFJhdyA9IGF6aW11dGhhbFJhdyhmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gKGMgPSBhY29zKGMpKSAmJiBjIC8gc2luKGMpO1xuICAgIH0pO1xuICAgIGF6aW11dGhhbEVxdWlkaXN0YW50UmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbiAoeikge1xuICAgICAgICByZXR1cm4gejtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBhemltdXRoYWxFcXVpZGlzdGFudCgpIHtcbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb24oYXppbXV0aGFsRXF1aWRpc3RhbnRSYXcpXG4gICAgICAgICAgICAuc2NhbGUoNzkuNDE4OClcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoMTgwIC0gMWUtMyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lcmNhdG9yUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBbbGFtYmRhLCBsb2codGFuKChoYWxmUGkgKyBwaGkpIC8gMikpXTtcbiAgICB9XG4gICAgbWVyY2F0b3JSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIFt4LCAyICogYXRhbihleHAoeSkpIC0gaGFsZlBpXTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG1lcmNhdG9yKCkge1xuICAgICAgICByZXR1cm4gbWVyY2F0b3JQcm9qZWN0aW9uKG1lcmNhdG9yUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDk2MSAvIHRhdSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lcmNhdG9yUHJvamVjdGlvbihwcm9qZWN0KSB7XG4gICAgICAgIHZhciBtID0gcHJvamVjdGlvbihwcm9qZWN0KSwgY2VudGVyID0gbS5jZW50ZXIsIHNjYWxlID0gbS5zY2FsZSwgdHJhbnNsYXRlID0gbS50cmFuc2xhdGUsIGNsaXBFeHRlbnQgPSBtLmNsaXBFeHRlbnQsIHgwID0gbnVsbCwgeTAsIHgxLCB5MTsgLy8gY2xpcCBleHRlbnRcbiAgICAgICAgbS5zY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzY2FsZShfKSwgcmVjbGlwKCkpIDogc2NhbGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNsYXRlKF8pLCByZWNsaXAoKSkgOiB0cmFuc2xhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbS5jZW50ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2VudGVyKF8pLCByZWNsaXAoKSkgOiBjZW50ZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbS5jbGlwRXh0ZW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChfID09IG51bGwgPyB4MCA9IHkwID0geDEgPSB5MSA9IG51bGwgOiAoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSkpLCByZWNsaXAoKSkgOiB4MCA9PSBudWxsID8gbnVsbCA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZWNsaXAoKSB7XG4gICAgICAgICAgICB2YXIgayA9IHBpICogc2NhbGUoKSwgdCA9IG0ocm90YXRpb24obS5yb3RhdGUoKSkuaW52ZXJ0KFswLCAwXSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNsaXBFeHRlbnQoeDAgPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gW1t0WzBdIC0gaywgdFsxXSAtIGtdLCBbdFswXSArIGssIHRbMV0gKyBrXV0gOiBwcm9qZWN0ID09PSBtZXJjYXRvclJhd1xuICAgICAgICAgICAgICAgID8gW1tNYXRoLm1heCh0WzBdIC0gaywgeDApLCB5MF0sIFtNYXRoLm1pbih0WzBdICsgaywgeDEpLCB5MV1dXG4gICAgICAgICAgICAgICAgOiBbW3gwLCBNYXRoLm1heCh0WzFdIC0gaywgeTApXSwgW3gxLCBNYXRoLm1pbih0WzFdICsgaywgeTEpXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNsaXAoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGFueSh5KSB7XG4gICAgICAgIHJldHVybiB0YW4oKGhhbGZQaSArIHkpIC8gMik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbmljQ29uZm9ybWFsUmF3KHkwLCB5MSkge1xuICAgICAgICB2YXIgY3kwID0gY29zKHkwKSwgbiA9IHkwID09PSB5MSA/IHNpbih5MCkgOiBsb2coY3kwIC8gY29zKHkxKSkgLyBsb2codGFueSh5MSkgLyB0YW55KHkwKSksIGYgPSBjeTAgKiBwb3codGFueSh5MCksIG4pIC8gbjtcbiAgICAgICAgaWYgKCFuKVxuICAgICAgICAgICAgcmV0dXJuIG1lcmNhdG9yUmF3O1xuICAgICAgICBmdW5jdGlvbiBwcm9qZWN0KHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChmID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh5IDwgLWhhbGZQaSArIGVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgIHkgPSAtaGFsZlBpICsgZXBzaWxvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh5ID4gaGFsZlBpIC0gZXBzaWxvbilcbiAgICAgICAgICAgICAgICAgICAgeSA9IGhhbGZQaSAtIGVwc2lsb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgciA9IGYgLyBwb3codGFueSh5KSwgbik7XG4gICAgICAgICAgICByZXR1cm4gW3IgKiBzaW4obiAqIHgpLCBmIC0gciAqIGNvcyhuICogeCldO1xuICAgICAgICB9XG4gICAgICAgIHByb2plY3QuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBmeSA9IGYgLSB5LCByID0gc2lnbihuKSAqIHNxcnQoeCAqIHggKyBmeSAqIGZ5KTtcbiAgICAgICAgICAgIHJldHVybiBbYXRhbjIoeCwgYWJzKGZ5KSkgLyBuICogc2lnbihmeSksIDIgKiBhdGFuKHBvdyhmIC8gciwgMSAvIG4pKSAtIGhhbGZQaV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcm9qZWN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25pY0NvbmZvcm1hbCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmljUHJvamVjdGlvbihjb25pY0NvbmZvcm1hbFJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxMDkuNSlcbiAgICAgICAgICAgIC5wYXJhbGxlbHMoWzMwLCAzMF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlcXVpcmVjdGFuZ3VsYXJSYXcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgcmV0dXJuIFtsYW1iZGEsIHBoaV07XG4gICAgfVxuICAgIGVxdWlyZWN0YW5ndWxhclJhdy5pbnZlcnQgPSBlcXVpcmVjdGFuZ3VsYXJSYXc7XG4gICAgZnVuY3Rpb24gZXF1aXJlY3Rhbmd1bGFyKCkge1xuICAgICAgICByZXR1cm4gcHJvamVjdGlvbihlcXVpcmVjdGFuZ3VsYXJSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTUyLjYzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uaWNFcXVpZGlzdGFudFJhdyh5MCwgeTEpIHtcbiAgICAgICAgdmFyIGN5MCA9IGNvcyh5MCksIG4gPSB5MCA9PT0geTEgPyBzaW4oeTApIDogKGN5MCAtIGNvcyh5MSkpIC8gKHkxIC0geTApLCBnID0gY3kwIC8gbiArIHkwO1xuICAgICAgICBpZiAoYWJzKG4pIDwgZXBzaWxvbilcbiAgICAgICAgICAgIHJldHVybiBlcXVpcmVjdGFuZ3VsYXJSYXc7XG4gICAgICAgIGZ1bmN0aW9uIHByb2plY3QoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGd5ID0gZyAtIHksIG54ID0gbiAqIHg7XG4gICAgICAgICAgICByZXR1cm4gW2d5ICogc2luKG54KSwgZyAtIGd5ICogY29zKG54KV07XG4gICAgICAgIH1cbiAgICAgICAgcHJvamVjdC5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGd5ID0gZyAtIHk7XG4gICAgICAgICAgICByZXR1cm4gW2F0YW4yKHgsIGFicyhneSkpIC8gbiAqIHNpZ24oZ3kpLCBnIC0gc2lnbihuKSAqIHNxcnQoeCAqIHggKyBneSAqIGd5KV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcm9qZWN0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25pY0VxdWlkaXN0YW50KCkge1xuICAgICAgICByZXR1cm4gY29uaWNQcm9qZWN0aW9uKGNvbmljRXF1aWRpc3RhbnRSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTMxLjE1NClcbiAgICAgICAgICAgIC5jZW50ZXIoWzAsIDEzLjkzODldKTtcbiAgICB9XG4gICAgdmFyIEExID0gMS4zNDAyNjQsIEEyID0gLTAuMDgxMTA2LCBBMyA9IDAuMDAwODkzLCBBNCA9IDAuMDAzNzk2LCBNID0gc3FydCgzKSAvIDIsIGl0ZXJhdGlvbnMgPSAxMjtcbiAgICBmdW5jdGlvbiBlcXVhbEVhcnRoUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHZhciBsID0gYXNpbihNICogc2luKHBoaSkpLCBsMiA9IGwgKiBsLCBsNiA9IGwyICogbDIgKiBsMjtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGxhbWJkYSAqIGNvcyhsKSAvIChNICogKEExICsgMyAqIEEyICogbDIgKyBsNiAqICg3ICogQTMgKyA5ICogQTQgKiBsMikpKSxcbiAgICAgICAgICAgIGwgKiAoQTEgKyBBMiAqIGwyICsgbDYgKiAoQTMgKyBBNCAqIGwyKSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgZXF1YWxFYXJ0aFJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgbCA9IHksIGwyID0gbCAqIGwsIGw2ID0gbDIgKiBsMiAqIGwyO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgZGVsdGEsIGZ5LCBmcHk7IGkgPCBpdGVyYXRpb25zOyArK2kpIHtcbiAgICAgICAgICAgIGZ5ID0gbCAqIChBMSArIEEyICogbDIgKyBsNiAqIChBMyArIEE0ICogbDIpKSAtIHk7XG4gICAgICAgICAgICBmcHkgPSBBMSArIDMgKiBBMiAqIGwyICsgbDYgKiAoNyAqIEEzICsgOSAqIEE0ICogbDIpO1xuICAgICAgICAgICAgbCAtPSBkZWx0YSA9IGZ5IC8gZnB5LCBsMiA9IGwgKiBsLCBsNiA9IGwyICogbDIgKiBsMjtcbiAgICAgICAgICAgIGlmIChhYnMoZGVsdGEpIDwgZXBzaWxvbjIpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIE0gKiB4ICogKEExICsgMyAqIEEyICogbDIgKyBsNiAqICg3ICogQTMgKyA5ICogQTQgKiBsMikpIC8gY29zKGwpLFxuICAgICAgICAgICAgYXNpbihzaW4obCkgLyBNKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZXF1YWxFYXJ0aCgpIHtcbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb24oZXF1YWxFYXJ0aFJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNzcuMTU4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ25vbW9uaWNSYXcoeCwgeSkge1xuICAgICAgICB2YXIgY3kgPSBjb3MoeSksIGsgPSBjb3MoeCkgKiBjeTtcbiAgICAgICAgcmV0dXJuIFtjeSAqIHNpbih4KSAvIGssIHNpbih5KSAvIGtdO1xuICAgIH1cbiAgICBnbm9tb25pY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoYXRhbik7XG4gICAgZnVuY3Rpb24gZ25vbW9uaWMoKSB7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uKGdub21vbmljUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE0NC4wNDkpXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDYwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGVUcmFuc2xhdGUkMShreCwga3ksIHR4LCB0eSkge1xuICAgICAgICByZXR1cm4ga3ggPT09IDEgJiYga3kgPT09IDEgJiYgdHggPT09IDAgJiYgdHkgPT09IDAgPyBpZGVudGl0eSA6IHRyYW5zZm9ybWVyKHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHggKiBreCArIHR4LCB5ICoga3kgKyB0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpZGVudGl0eSQxKCkge1xuICAgICAgICB2YXIgayA9IDEsIHR4ID0gMCwgdHkgPSAwLCBzeCA9IDEsIHN5ID0gMSwgdHJhbnNmb3JtID0gaWRlbnRpdHksIC8vIHNjYWxlLCB0cmFuc2xhdGUgYW5kIHJlZmxlY3RcbiAgICAgICAgeDAgPSBudWxsLCB5MCwgeDEsIHkxLCAvLyBjbGlwIGV4dGVudFxuICAgICAgICBwb3N0Y2xpcCA9IGlkZW50aXR5LCBjYWNoZSwgY2FjaGVTdHJlYW0sIHByb2plY3Rpb247XG4gICAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvamVjdGlvbiA9IHtcbiAgICAgICAgICAgIHN0cmVhbTogZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IHRyYW5zZm9ybShwb3N0Y2xpcChjYWNoZVN0cmVhbSA9IHN0cmVhbSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBvc3RjbGlwOiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXywgeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCByZXNldCgpKSA6IHBvc3RjbGlwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsaXBFeHRlbnQ6IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSkgOiBjbGlwUmVjdGFuZ2xlKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pLCByZXNldCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NhbGU6IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtID0gc2NhbGVUcmFuc2xhdGUkMSgoayA9ICtfKSAqIHN4LCBrICogc3ksIHR4LCB0eSksIHJlc2V0KCkpIDogaztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtID0gc2NhbGVUcmFuc2xhdGUkMShrICogc3gsIGsgKiBzeSwgdHggPSArX1swXSwgdHkgPSArX1sxXSksIHJlc2V0KCkpIDogW3R4LCB0eV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVmbGVjdFg6IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtID0gc2NhbGVUcmFuc2xhdGUkMShrICogKHN4ID0gXyA/IC0xIDogMSksIGsgKiBzeSwgdHgsIHR5KSwgcmVzZXQoKSkgOiBzeCA8IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVmbGVjdFk6IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtID0gc2NhbGVUcmFuc2xhdGUkMShrICogc3gsIGsgKiAoc3kgPSBfID8gLTEgOiAxKSwgdHgsIHR5KSwgcmVzZXQoKSkgOiBzeSA8IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml0RXh0ZW50OiBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXRTaXplOiBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXRXaWR0aDogZnVuY3Rpb24gKHdpZHRoLCBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml0V2lkdGgocHJvamVjdGlvbiwgd2lkdGgsIG9iamVjdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZml0SGVpZ2h0OiBmdW5jdGlvbiAoaGVpZ2h0LCBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbmF0dXJhbEVhcnRoMVJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICB2YXIgcGhpMiA9IHBoaSAqIHBoaSwgcGhpNCA9IHBoaTIgKiBwaGkyO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbGFtYmRhICogKDAuODcwNyAtIDAuMTMxOTc5ICogcGhpMiArIHBoaTQgKiAoLTAuMDEzNzkxICsgcGhpNCAqICgwLjAwMzk3MSAqIHBoaTIgLSAwLjAwMTUyOSAqIHBoaTQpKSksXG4gICAgICAgICAgICBwaGkgKiAoMS4wMDcyMjYgKyBwaGkyICogKDAuMDE1MDg1ICsgcGhpNCAqICgtMC4wNDQ0NzUgKyAwLjAyODg3NCAqIHBoaTIgLSAwLjAwNTkxNiAqIHBoaTQpKSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgbmF0dXJhbEVhcnRoMVJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICB2YXIgcGhpID0geSwgaSA9IDI1LCBkZWx0YTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIHBoaTIgPSBwaGkgKiBwaGksIHBoaTQgPSBwaGkyICogcGhpMjtcbiAgICAgICAgICAgIHBoaSAtPSBkZWx0YSA9IChwaGkgKiAoMS4wMDcyMjYgKyBwaGkyICogKDAuMDE1MDg1ICsgcGhpNCAqICgtMC4wNDQ0NzUgKyAwLjAyODg3NCAqIHBoaTIgLSAwLjAwNTkxNiAqIHBoaTQpKSkgLSB5KSAvXG4gICAgICAgICAgICAgICAgKDEuMDA3MjI2ICsgcGhpMiAqICgwLjAxNTA4NSAqIDMgKyBwaGk0ICogKC0wLjA0NDQ3NSAqIDcgKyAwLjAyODg3NCAqIDkgKiBwaGkyIC0gMC4wMDU5MTYgKiAxMSAqIHBoaTQpKSk7XG4gICAgICAgIH0gd2hpbGUgKGFicyhkZWx0YSkgPiBlcHNpbG9uICYmIC0taSA+IDApO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeCAvICgwLjg3MDcgKyAocGhpMiA9IHBoaSAqIHBoaSkgKiAoLTAuMTMxOTc5ICsgcGhpMiAqICgtMC4wMTM3OTEgKyBwaGkyICogcGhpMiAqIHBoaTIgKiAoMC4wMDM5NzEgLSAwLjAwMTUyOSAqIHBoaTIpKSkpLFxuICAgICAgICAgICAgcGhpXG4gICAgICAgIF07XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuYXR1cmFsRWFydGgxKCkge1xuICAgICAgICByZXR1cm4gcHJvamVjdGlvbihuYXR1cmFsRWFydGgxUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE3NS4yOTUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcnRob2dyYXBoaWNSYXcoeCwgeSkge1xuICAgICAgICByZXR1cm4gW2Nvcyh5KSAqIHNpbih4KSwgc2luKHkpXTtcbiAgICB9XG4gICAgb3J0aG9ncmFwaGljUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChhc2luKTtcbiAgICBmdW5jdGlvbiBvcnRob2dyYXBoaWMoKSB7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uKG9ydGhvZ3JhcGhpY1JhdylcbiAgICAgICAgICAgIC5zY2FsZSgyNDkuNSlcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoOTAgKyBlcHNpbG9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RlcmVvZ3JhcGhpY1Jhdyh4LCB5KSB7XG4gICAgICAgIHZhciBjeSA9IGNvcyh5KSwgayA9IDEgKyBjb3MoeCkgKiBjeTtcbiAgICAgICAgcmV0dXJuIFtjeSAqIHNpbih4KSAvIGssIHNpbih5KSAvIGtdO1xuICAgIH1cbiAgICBzdGVyZW9ncmFwaGljUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbiAoeikge1xuICAgICAgICByZXR1cm4gMiAqIGF0YW4oeik7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gc3RlcmVvZ3JhcGhpYygpIHtcbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb24oc3RlcmVvZ3JhcGhpY1JhdylcbiAgICAgICAgICAgIC5zY2FsZSgyNTApXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDE0Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zdmVyc2VNZXJjYXRvclJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICByZXR1cm4gW2xvZyh0YW4oKGhhbGZQaSArIHBoaSkgLyAyKSksIC1sYW1iZGFdO1xuICAgIH1cbiAgICB0cmFuc3ZlcnNlTWVyY2F0b3JSYXcuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIFsteSwgMiAqIGF0YW4oZXhwKHgpKSAtIGhhbGZQaV07XG4gICAgfTtcbiAgICBmdW5jdGlvbiB0cmFuc3ZlcnNlTWVyY2F0b3IoKSB7XG4gICAgICAgIHZhciBtID0gbWVyY2F0b3JQcm9qZWN0aW9uKHRyYW5zdmVyc2VNZXJjYXRvclJhdyksIGNlbnRlciA9IG0uY2VudGVyLCByb3RhdGUgPSBtLnJvdGF0ZTtcbiAgICAgICAgbS5jZW50ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjZW50ZXIoWy1fWzFdLCBfWzBdXSkgOiAoXyA9IGNlbnRlcigpLCBbX1sxXSwgLV9bMF1dKTtcbiAgICAgICAgfTtcbiAgICAgICAgbS5yb3RhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByb3RhdGUoW19bMF0sIF9bMV0sIF8ubGVuZ3RoID4gMiA/IF9bMl0gKyA5MCA6IDkwXSkgOiAoXyA9IHJvdGF0ZSgpLCBbX1swXSwgX1sxXSwgX1syXSAtIDkwXSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByb3RhdGUoWzAsIDAsIDkwXSlcbiAgICAgICAgICAgIC5zY2FsZSgxNTkuMTU1KTtcbiAgICB9XG4gICAgZXhwb3J0cy5nZW9BbGJlcnMgPSBhbGJlcnM7XG4gICAgZXhwb3J0cy5nZW9BbGJlcnNVc2EgPSBhbGJlcnNVc2E7XG4gICAgZXhwb3J0cy5nZW9BcmVhID0gYXJlYTtcbiAgICBleHBvcnRzLmdlb0F6aW11dGhhbEVxdWFsQXJlYSA9IGF6aW11dGhhbEVxdWFsQXJlYTtcbiAgICBleHBvcnRzLmdlb0F6aW11dGhhbEVxdWFsQXJlYVJhdyA9IGF6aW11dGhhbEVxdWFsQXJlYVJhdztcbiAgICBleHBvcnRzLmdlb0F6aW11dGhhbEVxdWlkaXN0YW50ID0gYXppbXV0aGFsRXF1aWRpc3RhbnQ7XG4gICAgZXhwb3J0cy5nZW9BemltdXRoYWxFcXVpZGlzdGFudFJhdyA9IGF6aW11dGhhbEVxdWlkaXN0YW50UmF3O1xuICAgIGV4cG9ydHMuZ2VvQm91bmRzID0gYm91bmRzO1xuICAgIGV4cG9ydHMuZ2VvQ2VudHJvaWQgPSBjZW50cm9pZDtcbiAgICBleHBvcnRzLmdlb0NpcmNsZSA9IGNpcmNsZTtcbiAgICBleHBvcnRzLmdlb0NsaXBBbnRpbWVyaWRpYW4gPSBjbGlwQW50aW1lcmlkaWFuO1xuICAgIGV4cG9ydHMuZ2VvQ2xpcENpcmNsZSA9IGNsaXBDaXJjbGU7XG4gICAgZXhwb3J0cy5nZW9DbGlwRXh0ZW50ID0gZXh0ZW50O1xuICAgIGV4cG9ydHMuZ2VvQ2xpcFJlY3RhbmdsZSA9IGNsaXBSZWN0YW5nbGU7XG4gICAgZXhwb3J0cy5nZW9Db25pY0NvbmZvcm1hbCA9IGNvbmljQ29uZm9ybWFsO1xuICAgIGV4cG9ydHMuZ2VvQ29uaWNDb25mb3JtYWxSYXcgPSBjb25pY0NvbmZvcm1hbFJhdztcbiAgICBleHBvcnRzLmdlb0NvbmljRXF1YWxBcmVhID0gY29uaWNFcXVhbEFyZWE7XG4gICAgZXhwb3J0cy5nZW9Db25pY0VxdWFsQXJlYVJhdyA9IGNvbmljRXF1YWxBcmVhUmF3O1xuICAgIGV4cG9ydHMuZ2VvQ29uaWNFcXVpZGlzdGFudCA9IGNvbmljRXF1aWRpc3RhbnQ7XG4gICAgZXhwb3J0cy5nZW9Db25pY0VxdWlkaXN0YW50UmF3ID0gY29uaWNFcXVpZGlzdGFudFJhdztcbiAgICBleHBvcnRzLmdlb0NvbnRhaW5zID0gY29udGFpbnM7XG4gICAgZXhwb3J0cy5nZW9EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIGV4cG9ydHMuZ2VvRXF1YWxFYXJ0aCA9IGVxdWFsRWFydGg7XG4gICAgZXhwb3J0cy5nZW9FcXVhbEVhcnRoUmF3ID0gZXF1YWxFYXJ0aFJhdztcbiAgICBleHBvcnRzLmdlb0VxdWlyZWN0YW5ndWxhciA9IGVxdWlyZWN0YW5ndWxhcjtcbiAgICBleHBvcnRzLmdlb0VxdWlyZWN0YW5ndWxhclJhdyA9IGVxdWlyZWN0YW5ndWxhclJhdztcbiAgICBleHBvcnRzLmdlb0dub21vbmljID0gZ25vbW9uaWM7XG4gICAgZXhwb3J0cy5nZW9Hbm9tb25pY1JhdyA9IGdub21vbmljUmF3O1xuICAgIGV4cG9ydHMuZ2VvR3JhdGljdWxlID0gZ3JhdGljdWxlO1xuICAgIGV4cG9ydHMuZ2VvR3JhdGljdWxlMTAgPSBncmF0aWN1bGUxMDtcbiAgICBleHBvcnRzLmdlb0lkZW50aXR5ID0gaWRlbnRpdHkkMTtcbiAgICBleHBvcnRzLmdlb0ludGVycG9sYXRlID0gaW50ZXJwb2xhdGU7XG4gICAgZXhwb3J0cy5nZW9MZW5ndGggPSBsZW5ndGg7XG4gICAgZXhwb3J0cy5nZW9NZXJjYXRvciA9IG1lcmNhdG9yO1xuICAgIGV4cG9ydHMuZ2VvTWVyY2F0b3JSYXcgPSBtZXJjYXRvclJhdztcbiAgICBleHBvcnRzLmdlb05hdHVyYWxFYXJ0aDEgPSBuYXR1cmFsRWFydGgxO1xuICAgIGV4cG9ydHMuZ2VvTmF0dXJhbEVhcnRoMVJhdyA9IG5hdHVyYWxFYXJ0aDFSYXc7XG4gICAgZXhwb3J0cy5nZW9PcnRob2dyYXBoaWMgPSBvcnRob2dyYXBoaWM7XG4gICAgZXhwb3J0cy5nZW9PcnRob2dyYXBoaWNSYXcgPSBvcnRob2dyYXBoaWNSYXc7XG4gICAgZXhwb3J0cy5nZW9QYXRoID0gaW5kZXg7XG4gICAgZXhwb3J0cy5nZW9Qcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcbiAgICBleHBvcnRzLmdlb1Byb2plY3Rpb25NdXRhdG9yID0gcHJvamVjdGlvbk11dGF0b3I7XG4gICAgZXhwb3J0cy5nZW9Sb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIGV4cG9ydHMuZ2VvU3RlcmVvZ3JhcGhpYyA9IHN0ZXJlb2dyYXBoaWM7XG4gICAgZXhwb3J0cy5nZW9TdGVyZW9ncmFwaGljUmF3ID0gc3RlcmVvZ3JhcGhpY1JhdztcbiAgICBleHBvcnRzLmdlb1N0cmVhbSA9IGdlb1N0cmVhbTtcbiAgICBleHBvcnRzLmdlb1RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBleHBvcnRzLmdlb1RyYW5zdmVyc2VNZXJjYXRvciA9IHRyYW5zdmVyc2VNZXJjYXRvcjtcbiAgICBleHBvcnRzLmdlb1RyYW5zdmVyc2VNZXJjYXRvclJhdyA9IHRyYW5zdmVyc2VNZXJjYXRvclJhdztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1nZW9AMS42LjRAZDMtZ2VvL2J1aWxkL2QzLWdlby5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2QzLWdlb0AxLjYuNEBkMy1nZW8vYnVpbGQvZDMtZ2VvLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBodHRwczovL2QzanMub3JnL2QzLWdlby8gVmVyc2lvbiAxLjYuNC4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgdHJ1ZSA/IGZhY3RvcnkoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtYXJyYXlAMS4yLjRAZDMtYXJyYXkvZGlzdC9kMy1hcnJheS5qc1wiKSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cywgZDNBcnJheSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvLyBBZGRzIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgd2l0aCB0d2ljZSB0aGUgbm9ybWFsIHByZWNpc2lvbi5cbiAgICAvLyBSZWZlcmVuY2U6IEouIFIuIFNoZXdjaHVrLCBBZGFwdGl2ZSBQcmVjaXNpb24gRmxvYXRpbmctUG9pbnQgQXJpdGhtZXRpYyBhbmRcbiAgICAvLyBGYXN0IFJvYnVzdCBHZW9tZXRyaWMgUHJlZGljYXRlcywgRGlzY3JldGUgJiBDb21wdXRhdGlvbmFsIEdlb21ldHJ5IDE4KDMpXG4gICAgLy8gMzA14oCTMzYzICgxOTk3KS5cbiAgICAvLyBDb2RlIGFkYXB0ZWQgZnJvbSBHZW9ncmFwaGljTGliIGJ5IENoYXJsZXMgRi4gRi4gS2FybmV5LFxuICAgIC8vIGh0dHA6Ly9nZW9ncmFwaGljbGliLnNvdXJjZWZvcmdlLm5ldC9cbiAgICB2YXIgYWRkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWRkZXI7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBBZGRlcigpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICBBZGRlci5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBBZGRlcixcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucyA9IC8vIHJvdW5kZWQgdmFsdWVcbiAgICAgICAgICAgICAgICB0aGlzLnQgPSAwOyAvLyBleGFjdCBlcnJvclxuICAgICAgICB9LFxuICAgICAgICBhZGQ6IGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICBhZGQodGVtcCwgeSwgdGhpcy50KTtcbiAgICAgICAgICAgIGFkZCh0aGlzLCB0ZW1wLnMsIHRoaXMucyk7XG4gICAgICAgICAgICBpZiAodGhpcy5zKVxuICAgICAgICAgICAgICAgIHRoaXMudCArPSB0ZW1wLnQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5zID0gdGVtcC50O1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZU9mOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgdGVtcCA9IG5ldyBBZGRlcjtcbiAgICBmdW5jdGlvbiBhZGQoYWRkZXIsIGEsIGIpIHtcbiAgICAgICAgdmFyIHggPSBhZGRlci5zID0gYSArIGIsIGJ2ID0geCAtIGEsIGF2ID0geCAtIGJ2O1xuICAgICAgICBhZGRlci50ID0gKGEgLSBhdikgKyAoYiAtIGJ2KTtcbiAgICB9XG4gICAgdmFyIGVwc2lsb24gPSAxZS02O1xuICAgIHZhciBlcHNpbG9uMiA9IDFlLTEyO1xuICAgIHZhciBwaSA9IE1hdGguUEk7XG4gICAgdmFyIGhhbGZQaSA9IHBpIC8gMjtcbiAgICB2YXIgcXVhcnRlclBpID0gcGkgLyA0O1xuICAgIHZhciB0YXUgPSBwaSAqIDI7XG4gICAgdmFyIGRlZ3JlZXMgPSAxODAgLyBwaTtcbiAgICB2YXIgcmFkaWFucyA9IHBpIC8gMTgwO1xuICAgIHZhciBhYnMgPSBNYXRoLmFicztcbiAgICB2YXIgYXRhbiA9IE1hdGguYXRhbjtcbiAgICB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuICAgIHZhciBjb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgY2VpbCA9IE1hdGguY2VpbDtcbiAgICB2YXIgZXhwID0gTWF0aC5leHA7XG4gICAgdmFyIGxvZyA9IE1hdGgubG9nO1xuICAgIHZhciBwb3cgPSBNYXRoLnBvdztcbiAgICB2YXIgc2luID0gTWF0aC5zaW47XG4gICAgdmFyIHNpZ24gPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwOyB9O1xuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciB0YW4gPSBNYXRoLnRhbjtcbiAgICBmdW5jdGlvbiBhY29zKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPiAxID8gMCA6IHggPCAtMSA/IHBpIDogTWF0aC5hY29zKHgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc2luKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPiAxID8gaGFsZlBpIDogeCA8IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGF2ZXJzaW4oeCkge1xuICAgICAgICByZXR1cm4gKHggPSBzaW4oeCAvIDIpKSAqIHg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7IH1cbiAgICBmdW5jdGlvbiBzdHJlYW1HZW9tZXRyeShnZW9tZXRyeSwgc3RyZWFtKSB7XG4gICAgICAgIGlmIChnZW9tZXRyeSAmJiBzdHJlYW1HZW9tZXRyeVR5cGUuaGFzT3duUHJvcGVydHkoZ2VvbWV0cnkudHlwZSkpIHtcbiAgICAgICAgICAgIHN0cmVhbUdlb21ldHJ5VHlwZVtnZW9tZXRyeS50eXBlXShnZW9tZXRyeSwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3RyZWFtT2JqZWN0VHlwZSA9IHtcbiAgICAgICAgRmVhdHVyZTogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICBzdHJlYW1HZW9tZXRyeShvYmplY3QuZ2VvbWV0cnksIHN0cmVhbSk7XG4gICAgICAgIH0sXG4gICAgICAgIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbiAob2JqZWN0LCBzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IG9iamVjdC5mZWF0dXJlcywgaSA9IC0xLCBuID0gZmVhdHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtR2VvbWV0cnkoZmVhdHVyZXNbaV0uZ2VvbWV0cnksIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzdHJlYW1HZW9tZXRyeVR5cGUgPSB7XG4gICAgICAgIFNwaGVyZTogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICBzdHJlYW0uc3BoZXJlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIFBvaW50OiBmdW5jdGlvbiAob2JqZWN0LCBzdHJlYW0pIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5jb29yZGluYXRlcztcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChvYmplY3RbMF0sIG9iamVjdFsxXSwgb2JqZWN0WzJdKTtcbiAgICAgICAgfSxcbiAgICAgICAgTXVsdGlQb2ludDogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIG9iamVjdCA9IGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0ucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gICAgICAgIH0sXG4gICAgICAgIExpbmVTdHJpbmc6IGZ1bmN0aW9uIChvYmplY3QsIHN0cmVhbSkge1xuICAgICAgICAgICAgc3RyZWFtTGluZShvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSwgMCk7XG4gICAgICAgIH0sXG4gICAgICAgIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSwgMCk7XG4gICAgICAgIH0sXG4gICAgICAgIFBvbHlnb246IGZ1bmN0aW9uIChvYmplY3QsIHN0cmVhbSkge1xuICAgICAgICAgICAgc3RyZWFtUG9seWdvbihvYmplY3QuY29vcmRpbmF0ZXMsIHN0cmVhbSk7XG4gICAgICAgIH0sXG4gICAgICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSk7XG4gICAgICAgIH0sXG4gICAgICAgIEdlb21ldHJ5Q29sbGVjdGlvbjogZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgZ2VvbWV0cmllcyA9IG9iamVjdC5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbUdlb21ldHJ5KGdlb21ldHJpZXNbaV0sIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHN0cmVhbUxpbmUoY29vcmRpbmF0ZXMsIHN0cmVhbSwgY2xvc2VkKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGggLSBjbG9zZWQsIGNvb3JkaW5hdGU7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV0sIHN0cmVhbS5wb2ludChjb29yZGluYXRlWzBdLCBjb29yZGluYXRlWzFdLCBjb29yZGluYXRlWzJdKTtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyZWFtUG9seWdvbihjb29yZGluYXRlcywgc3RyZWFtKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0sIDEpO1xuICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgIH1cbiAgICB2YXIgZ2VvU3RyZWFtID0gZnVuY3Rpb24gKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgICAgIGlmIChvYmplY3QgJiYgc3RyZWFtT2JqZWN0VHlwZS5oYXNPd25Qcm9wZXJ0eShvYmplY3QudHlwZSkpIHtcbiAgICAgICAgICAgIHN0cmVhbU9iamVjdFR5cGVbb2JqZWN0LnR5cGVdKG9iamVjdCwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbUdlb21ldHJ5KG9iamVjdCwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGFyZWFSaW5nU3VtID0gYWRkZXIoKTtcbiAgICB2YXIgYXJlYVN1bSA9IGFkZGVyKCk7XG4gICAgdmFyIGxhbWJkYTAwO1xuICAgIHZhciBwaGkwMDtcbiAgICB2YXIgbGFtYmRhMDtcbiAgICB2YXIgY29zUGhpMDtcbiAgICB2YXIgc2luUGhpMDtcbiAgICB2YXIgYXJlYVN0cmVhbSA9IHtcbiAgICAgICAgcG9pbnQ6IG5vb3AsXG4gICAgICAgIGxpbmVTdGFydDogbm9vcCxcbiAgICAgICAgbGluZUVuZDogbm9vcCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhcmVhUmluZ1N1bS5yZXNldCgpO1xuICAgICAgICAgICAgYXJlYVN0cmVhbS5saW5lU3RhcnQgPSBhcmVhUmluZ1N0YXJ0O1xuICAgICAgICAgICAgYXJlYVN0cmVhbS5saW5lRW5kID0gYXJlYVJpbmdFbmQ7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmVhUmluZyA9ICthcmVhUmluZ1N1bTtcbiAgICAgICAgICAgIGFyZWFTdW0uYWRkKGFyZWFSaW5nIDwgMCA/IHRhdSArIGFyZWFSaW5nIDogYXJlYVJpbmcpO1xuICAgICAgICAgICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmxpbmVFbmQgPSB0aGlzLnBvaW50ID0gbm9vcDtcbiAgICAgICAgfSxcbiAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhcmVhU3VtLmFkZCh0YXUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBhcmVhUmluZ1N0YXJ0KCkge1xuICAgICAgICBhcmVhU3RyZWFtLnBvaW50ID0gYXJlYVBvaW50Rmlyc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZWFSaW5nRW5kKCkge1xuICAgICAgICBhcmVhUG9pbnQobGFtYmRhMDAsIHBoaTAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJlYVBvaW50Rmlyc3QobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgYXJlYVN0cmVhbS5wb2ludCA9IGFyZWFQb2ludDtcbiAgICAgICAgbGFtYmRhMDAgPSBsYW1iZGEsIHBoaTAwID0gcGhpO1xuICAgICAgICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gICAgICAgIGxhbWJkYTAgPSBsYW1iZGEsIGNvc1BoaTAgPSBjb3MocGhpID0gcGhpIC8gMiArIHF1YXJ0ZXJQaSksIHNpblBoaTAgPSBzaW4ocGhpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJlYVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgICAgICAgcGhpID0gcGhpIC8gMiArIHF1YXJ0ZXJQaTsgLy8gaGFsZiB0aGUgYW5ndWxhciBkaXN0YW5jZSBmcm9tIHNvdXRoIHBvbGVcbiAgICAgICAgLy8gU3BoZXJpY2FsIGV4Y2VzcyBFIGZvciBhIHNwaGVyaWNhbCB0cmlhbmdsZSB3aXRoIHZlcnRpY2VzOiBzb3V0aCBwb2xlLFxuICAgICAgICAvLyBwcmV2aW91cyBwb2ludCwgY3VycmVudCBwb2ludC4gIFVzZXMgYSBmb3JtdWxhIGRlcml2ZWQgZnJvbSBDYWdub2xp4oCZc1xuICAgICAgICAvLyB0aGVvcmVtLiAgU2VlIFRvZGh1bnRlciwgU3BoZXJpY2FsIFRyaWcuICgxODcxKSwgU2VjLiAxMDMsIEVxLiAoMikuXG4gICAgICAgIHZhciBkTGFtYmRhID0gbGFtYmRhIC0gbGFtYmRhMCwgc2RMYW1iZGEgPSBkTGFtYmRhID49IDAgPyAxIDogLTEsIGFkTGFtYmRhID0gc2RMYW1iZGEgKiBkTGFtYmRhLCBjb3NQaGkgPSBjb3MocGhpKSwgc2luUGhpID0gc2luKHBoaSksIGsgPSBzaW5QaGkwICogc2luUGhpLCB1ID0gY29zUGhpMCAqIGNvc1BoaSArIGsgKiBjb3MoYWRMYW1iZGEpLCB2ID0gayAqIHNkTGFtYmRhICogc2luKGFkTGFtYmRhKTtcbiAgICAgICAgYXJlYVJpbmdTdW0uYWRkKGF0YW4yKHYsIHUpKTtcbiAgICAgICAgLy8gQWR2YW5jZSB0aGUgcHJldmlvdXMgcG9pbnRzLlxuICAgICAgICBsYW1iZGEwID0gbGFtYmRhLCBjb3NQaGkwID0gY29zUGhpLCBzaW5QaGkwID0gc2luUGhpO1xuICAgIH1cbiAgICB2YXIgYXJlYSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgYXJlYVN1bS5yZXNldCgpO1xuICAgICAgICBnZW9TdHJlYW0ob2JqZWN0LCBhcmVhU3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIGFyZWFTdW0gKiAyO1xuICAgIH07XG4gICAgZnVuY3Rpb24gc3BoZXJpY2FsKGNhcnRlc2lhbikge1xuICAgICAgICByZXR1cm4gW2F0YW4yKGNhcnRlc2lhblsxXSwgY2FydGVzaWFuWzBdKSwgYXNpbihjYXJ0ZXNpYW5bMl0pXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FydGVzaWFuKHNwaGVyaWNhbCkge1xuICAgICAgICB2YXIgbGFtYmRhID0gc3BoZXJpY2FsWzBdLCBwaGkgPSBzcGhlcmljYWxbMV0sIGNvc1BoaSA9IGNvcyhwaGkpO1xuICAgICAgICByZXR1cm4gW2Nvc1BoaSAqIGNvcyhsYW1iZGEpLCBjb3NQaGkgKiBzaW4obGFtYmRhKSwgc2luKHBoaSldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYXJ0ZXNpYW5Eb3QoYSwgYikge1xuICAgICAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYXJ0ZXNpYW5Dcm9zcyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBbYVsxXSAqIGJbMl0gLSBhWzJdICogYlsxXSwgYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXSwgYVswXSAqIGJbMV0gLSBhWzFdICogYlswXV07XG4gICAgfVxuICAgIC8vIFRPRE8gcmV0dXJuIGFcbiAgICBmdW5jdGlvbiBjYXJ0ZXNpYW5BZGRJblBsYWNlKGEsIGIpIHtcbiAgICAgICAgYVswXSArPSBiWzBdLCBhWzFdICs9IGJbMV0sIGFbMl0gKz0gYlsyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2FydGVzaWFuU2NhbGUodmVjdG9yLCBrKSB7XG4gICAgICAgIHJldHVybiBbdmVjdG9yWzBdICogaywgdmVjdG9yWzFdICogaywgdmVjdG9yWzJdICoga107XG4gICAgfVxuICAgIC8vIFRPRE8gcmV0dXJuIGRcbiAgICBmdW5jdGlvbiBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGQpIHtcbiAgICAgICAgdmFyIGwgPSBzcXJ0KGRbMF0gKiBkWzBdICsgZFsxXSAqIGRbMV0gKyBkWzJdICogZFsyXSk7XG4gICAgICAgIGRbMF0gLz0gbCwgZFsxXSAvPSBsLCBkWzJdIC89IGw7XG4gICAgfVxuICAgIHZhciBsYW1iZGEwJDE7XG4gICAgdmFyIHBoaTA7XG4gICAgdmFyIGxhbWJkYTE7XG4gICAgdmFyIHBoaTE7XG4gICAgdmFyIGxhbWJkYTI7XG4gICAgdmFyIGxhbWJkYTAwJDE7XG4gICAgdmFyIHBoaTAwJDE7XG4gICAgdmFyIHAwO1xuICAgIHZhciBkZWx0YVN1bSA9IGFkZGVyKCk7XG4gICAgdmFyIHJhbmdlcztcbiAgICB2YXIgcmFuZ2UkMTtcbiAgICB2YXIgYm91bmRzU3RyZWFtID0ge1xuICAgICAgICBwb2ludDogYm91bmRzUG9pbnQsXG4gICAgICAgIGxpbmVTdGFydDogYm91bmRzTGluZVN0YXJ0LFxuICAgICAgICBsaW5lRW5kOiBib3VuZHNMaW5lRW5kLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGJvdW5kc1N0cmVhbS5wb2ludCA9IGJvdW5kc1JpbmdQb2ludDtcbiAgICAgICAgICAgIGJvdW5kc1N0cmVhbS5saW5lU3RhcnQgPSBib3VuZHNSaW5nU3RhcnQ7XG4gICAgICAgICAgICBib3VuZHNTdHJlYW0ubGluZUVuZCA9IGJvdW5kc1JpbmdFbmQ7XG4gICAgICAgICAgICBkZWx0YVN1bS5yZXNldCgpO1xuICAgICAgICAgICAgYXJlYVN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXJlYVN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICBib3VuZHNTdHJlYW0ucG9pbnQgPSBib3VuZHNQb2ludDtcbiAgICAgICAgICAgIGJvdW5kc1N0cmVhbS5saW5lU3RhcnQgPSBib3VuZHNMaW5lU3RhcnQ7XG4gICAgICAgICAgICBib3VuZHNTdHJlYW0ubGluZUVuZCA9IGJvdW5kc0xpbmVFbmQ7XG4gICAgICAgICAgICBpZiAoYXJlYVJpbmdTdW0gPCAwKVxuICAgICAgICAgICAgICAgIGxhbWJkYTAkMSA9IC0obGFtYmRhMSA9IDE4MCksIHBoaTAgPSAtKHBoaTEgPSA5MCk7XG4gICAgICAgICAgICBlbHNlIGlmIChkZWx0YVN1bSA+IGVwc2lsb24pXG4gICAgICAgICAgICAgICAgcGhpMSA9IDkwO1xuICAgICAgICAgICAgZWxzZSBpZiAoZGVsdGFTdW0gPCAtZXBzaWxvbilcbiAgICAgICAgICAgICAgICBwaGkwID0gLTkwO1xuICAgICAgICAgICAgcmFuZ2UkMVswXSA9IGxhbWJkYTAkMSwgcmFuZ2UkMVsxXSA9IGxhbWJkYTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGJvdW5kc1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlJDEgPSBbbGFtYmRhMCQxID0gbGFtYmRhLCBsYW1iZGExID0gbGFtYmRhXSk7XG4gICAgICAgIGlmIChwaGkgPCBwaGkwKVxuICAgICAgICAgICAgcGhpMCA9IHBoaTtcbiAgICAgICAgaWYgKHBoaSA+IHBoaTEpXG4gICAgICAgICAgICBwaGkxID0gcGhpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIHAgPSBjYXJ0ZXNpYW4oW2xhbWJkYSAqIHJhZGlhbnMsIHBoaSAqIHJhZGlhbnNdKTtcbiAgICAgICAgaWYgKHAwKSB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gY2FydGVzaWFuQ3Jvc3MocDAsIHApLCBlcXVhdG9yaWFsID0gW25vcm1hbFsxXSwgLW5vcm1hbFswXSwgMF0sIGluZmxlY3Rpb24gPSBjYXJ0ZXNpYW5Dcm9zcyhlcXVhdG9yaWFsLCBub3JtYWwpO1xuICAgICAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShpbmZsZWN0aW9uKTtcbiAgICAgICAgICAgIGluZmxlY3Rpb24gPSBzcGhlcmljYWwoaW5mbGVjdGlvbik7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBsYW1iZGEgLSBsYW1iZGEyLCBzaWduJCQxID0gZGVsdGEgPiAwID8gMSA6IC0xLCBsYW1iZGFpID0gaW5mbGVjdGlvblswXSAqIGRlZ3JlZXMgKiBzaWduJCQxLCBwaGlpLCBhbnRpbWVyaWRpYW4gPSBhYnMoZGVsdGEpID4gMTgwO1xuICAgICAgICAgICAgaWYgKGFudGltZXJpZGlhbiBeIChzaWduJCQxICogbGFtYmRhMiA8IGxhbWJkYWkgJiYgbGFtYmRhaSA8IHNpZ24kJDEgKiBsYW1iZGEpKSB7XG4gICAgICAgICAgICAgICAgcGhpaSA9IGluZmxlY3Rpb25bMV0gKiBkZWdyZWVzO1xuICAgICAgICAgICAgICAgIGlmIChwaGlpID4gcGhpMSlcbiAgICAgICAgICAgICAgICAgICAgcGhpMSA9IHBoaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsYW1iZGFpID0gKGxhbWJkYWkgKyAzNjApICUgMzYwIC0gMTgwLCBhbnRpbWVyaWRpYW4gXiAoc2lnbiQkMSAqIGxhbWJkYTIgPCBsYW1iZGFpICYmIGxhbWJkYWkgPCBzaWduJCQxICogbGFtYmRhKSkge1xuICAgICAgICAgICAgICAgIHBoaWkgPSAtaW5mbGVjdGlvblsxXSAqIGRlZ3JlZXM7XG4gICAgICAgICAgICAgICAgaWYgKHBoaWkgPCBwaGkwKVxuICAgICAgICAgICAgICAgICAgICBwaGkwID0gcGhpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwaGkgPCBwaGkwKVxuICAgICAgICAgICAgICAgICAgICBwaGkwID0gcGhpO1xuICAgICAgICAgICAgICAgIGlmIChwaGkgPiBwaGkxKVxuICAgICAgICAgICAgICAgICAgICBwaGkxID0gcGhpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFudGltZXJpZGlhbikge1xuICAgICAgICAgICAgICAgIGlmIChsYW1iZGEgPCBsYW1iZGEyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZShsYW1iZGEwJDEsIGxhbWJkYSkgPiBhbmdsZShsYW1iZGEwJDEsIGxhbWJkYTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFtYmRhMSA9IGxhbWJkYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZShsYW1iZGEsIGxhbWJkYTEpID4gYW5nbGUobGFtYmRhMCQxLCBsYW1iZGExKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbWJkYTAkMSA9IGxhbWJkYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobGFtYmRhMSA+PSBsYW1iZGEwJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbWJkYSA8IGxhbWJkYTAkMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbWJkYTAkMSA9IGxhbWJkYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbWJkYSA+IGxhbWJkYTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW1iZGExID0gbGFtYmRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbWJkYSA+IGxhbWJkYTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZShsYW1iZGEwJDEsIGxhbWJkYSkgPiBhbmdsZShsYW1iZGEwJDEsIGxhbWJkYTEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbWJkYTEgPSBsYW1iZGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5nbGUobGFtYmRhLCBsYW1iZGExKSA+IGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFtYmRhMCQxID0gbGFtYmRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2gocmFuZ2UkMSA9IFtsYW1iZGEwJDEgPSBsYW1iZGEsIGxhbWJkYTEgPSBsYW1iZGFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGhpIDwgcGhpMClcbiAgICAgICAgICAgIHBoaTAgPSBwaGk7XG4gICAgICAgIGlmIChwaGkgPiBwaGkxKVxuICAgICAgICAgICAgcGhpMSA9IHBoaTtcbiAgICAgICAgcDAgPSBwLCBsYW1iZGEyID0gbGFtYmRhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBib3VuZHNMaW5lU3RhcnQoKSB7XG4gICAgICAgIGJvdW5kc1N0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm91bmRzTGluZUVuZCgpIHtcbiAgICAgICAgcmFuZ2UkMVswXSA9IGxhbWJkYTAkMSwgcmFuZ2UkMVsxXSA9IGxhbWJkYTE7XG4gICAgICAgIGJvdW5kc1N0cmVhbS5wb2ludCA9IGJvdW5kc1BvaW50O1xuICAgICAgICBwMCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJvdW5kc1JpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICBpZiAocDApIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGxhbWJkYSAtIGxhbWJkYTI7XG4gICAgICAgICAgICBkZWx0YVN1bS5hZGQoYWJzKGRlbHRhKSA+IDE4MCA/IGRlbHRhICsgKGRlbHRhID4gMCA/IDM2MCA6IC0zNjApIDogZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFtYmRhMDAkMSA9IGxhbWJkYSwgcGhpMDAkMSA9IHBoaTtcbiAgICAgICAgfVxuICAgICAgICBhcmVhU3RyZWFtLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICAgICAgbGluZVBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm91bmRzUmluZ1N0YXJ0KCkge1xuICAgICAgICBhcmVhU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBib3VuZHNSaW5nRW5kKCkge1xuICAgICAgICBib3VuZHNSaW5nUG9pbnQobGFtYmRhMDAkMSwgcGhpMDAkMSk7XG4gICAgICAgIGFyZWFTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICBpZiAoYWJzKGRlbHRhU3VtKSA+IGVwc2lsb24pXG4gICAgICAgICAgICBsYW1iZGEwJDEgPSAtKGxhbWJkYTEgPSAxODApO1xuICAgICAgICByYW5nZSQxWzBdID0gbGFtYmRhMCQxLCByYW5nZSQxWzFdID0gbGFtYmRhMTtcbiAgICAgICAgcDAgPSBudWxsO1xuICAgIH1cbiAgICAvLyBGaW5kcyB0aGUgbGVmdC1yaWdodCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBsb25naXR1ZGVzLlxuICAgIC8vIFRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIChsYW1iZGExIC0gbGFtYmRhMCArIDM2MMKwKSAlIDM2MMKwLCBleGNlcHQgdGhhdCB3ZSB3YW50XG4gICAgLy8gdGhlIGRpc3RhbmNlIGJldHdlZW4gwrExODDCsCB0byBiZSAzNjDCsC5cbiAgICBmdW5jdGlvbiBhbmdsZShsYW1iZGEwLCBsYW1iZGExKSB7XG4gICAgICAgIHJldHVybiAobGFtYmRhMSAtPSBsYW1iZGEwKSA8IDAgPyBsYW1iZGExICsgMzYwIDogbGFtYmRhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFuZ2VDb21wYXJlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiByYW5nZUNvbnRhaW5zKHJhbmdlJCQxLCB4KSB7XG4gICAgICAgIHJldHVybiByYW5nZSQkMVswXSA8PSByYW5nZSQkMVsxXSA/IHJhbmdlJCQxWzBdIDw9IHggJiYgeCA8PSByYW5nZSQkMVsxXSA6IHggPCByYW5nZSQkMVswXSB8fCByYW5nZSQkMVsxXSA8IHg7XG4gICAgfVxuICAgIHZhciBib3VuZHMgPSBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICB2YXIgaSwgbiwgYSwgYiwgbWVyZ2VkLCBkZWx0YU1heCwgZGVsdGE7XG4gICAgICAgIHBoaTEgPSBsYW1iZGExID0gLShsYW1iZGEwJDEgPSBwaGkwID0gSW5maW5pdHkpO1xuICAgICAgICByYW5nZXMgPSBbXTtcbiAgICAgICAgZ2VvU3RyZWFtKGZlYXR1cmUsIGJvdW5kc1N0cmVhbSk7XG4gICAgICAgIC8vIEZpcnN0LCBzb3J0IHJhbmdlcyBieSB0aGVpciBtaW5pbXVtIGxvbmdpdHVkZXMuXG4gICAgICAgIGlmIChuID0gcmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmFuZ2VzLnNvcnQocmFuZ2VDb21wYXJlKTtcbiAgICAgICAgICAgIC8vIFRoZW4sIG1lcmdlIGFueSByYW5nZXMgdGhhdCBvdmVybGFwLlxuICAgICAgICAgICAgZm9yIChpID0gMSwgYSA9IHJhbmdlc1swXSwgbWVyZ2VkID0gW2FdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgYiA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VDb250YWlucyhhLCBiWzBdKSB8fCByYW5nZUNvbnRhaW5zKGEsIGJbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZShhWzBdLCBiWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgYVsxXSA9IGJbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmdsZShiWzBdLCBhWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgYVswXSA9IGJbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWQucHVzaChhID0gYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluYWxseSwgZmluZCB0aGUgbGFyZ2VzdCBnYXAgYmV0d2VlbiB0aGUgbWVyZ2VkIHJhbmdlcy5cbiAgICAgICAgICAgIC8vIFRoZSBmaW5hbCBib3VuZGluZyBib3ggd2lsbCBiZSB0aGUgaW52ZXJzZSBvZiB0aGlzIGdhcC5cbiAgICAgICAgICAgIGZvciAoZGVsdGFNYXggPSAtSW5maW5pdHksIG4gPSBtZXJnZWQubGVuZ3RoIC0gMSwgaSA9IDAsIGEgPSBtZXJnZWRbbl07IGkgPD0gbjsgYSA9IGIsICsraSkge1xuICAgICAgICAgICAgICAgIGIgPSBtZXJnZWRbaV07XG4gICAgICAgICAgICAgICAgaWYgKChkZWx0YSA9IGFuZ2xlKGFbMV0sIGJbMF0pKSA+IGRlbHRhTWF4KVxuICAgICAgICAgICAgICAgICAgICBkZWx0YU1heCA9IGRlbHRhLCBsYW1iZGEwJDEgPSBiWzBdLCBsYW1iZGExID0gYVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByYW5nZXMgPSByYW5nZSQxID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGxhbWJkYTAkMSA9PT0gSW5maW5pdHkgfHwgcGhpMCA9PT0gSW5maW5pdHlcbiAgICAgICAgICAgID8gW1tOYU4sIE5hTl0sIFtOYU4sIE5hTl1dXG4gICAgICAgICAgICA6IFtbbGFtYmRhMCQxLCBwaGkwXSwgW2xhbWJkYTEsIHBoaTFdXTtcbiAgICB9O1xuICAgIHZhciBXMDtcbiAgICB2YXIgVzE7XG4gICAgdmFyIFgwO1xuICAgIHZhciBZMDtcbiAgICB2YXIgWjA7XG4gICAgdmFyIFgxO1xuICAgIHZhciBZMTtcbiAgICB2YXIgWjE7XG4gICAgdmFyIFgyO1xuICAgIHZhciBZMjtcbiAgICB2YXIgWjI7XG4gICAgdmFyIGxhbWJkYTAwJDI7XG4gICAgdmFyIHBoaTAwJDI7XG4gICAgdmFyIHgwO1xuICAgIHZhciB5MDtcbiAgICB2YXIgejA7IC8vIHByZXZpb3VzIHBvaW50XG4gICAgdmFyIGNlbnRyb2lkU3RyZWFtID0ge1xuICAgICAgICBzcGhlcmU6IG5vb3AsXG4gICAgICAgIHBvaW50OiBjZW50cm9pZFBvaW50LFxuICAgICAgICBsaW5lU3RhcnQ6IGNlbnRyb2lkTGluZVN0YXJ0LFxuICAgICAgICBsaW5lRW5kOiBjZW50cm9pZExpbmVFbmQsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2VudHJvaWRTdHJlYW0ubGluZVN0YXJ0ID0gY2VudHJvaWRSaW5nU3RhcnQ7XG4gICAgICAgICAgICBjZW50cm9pZFN0cmVhbS5saW5lRW5kID0gY2VudHJvaWRSaW5nRW5kO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjZW50cm9pZFN0cmVhbS5saW5lU3RhcnQgPSBjZW50cm9pZExpbmVTdGFydDtcbiAgICAgICAgICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVFbmQgPSBjZW50cm9pZExpbmVFbmQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEFyaXRobWV0aWMgbWVhbiBvZiBDYXJ0ZXNpYW4gdmVjdG9ycy5cbiAgICBmdW5jdGlvbiBjZW50cm9pZFBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgICAgICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpO1xuICAgICAgICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKGNvc1BoaSAqIGNvcyhsYW1iZGEpLCBjb3NQaGkgKiBzaW4obGFtYmRhKSwgc2luKHBoaSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgsIHksIHopIHtcbiAgICAgICAgKytXMDtcbiAgICAgICAgWDAgKz0gKHggLSBYMCkgLyBXMDtcbiAgICAgICAgWTAgKz0gKHkgLSBZMCkgLyBXMDtcbiAgICAgICAgWjAgKz0gKHogLSBaMCkgLyBXMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRMaW5lU3RhcnQoKSB7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRMaW5lUG9pbnRGaXJzdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRMaW5lUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICAgICAgICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gICAgICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgICAgICAgeDAgPSBjb3NQaGkgKiBjb3MobGFtYmRhKTtcbiAgICAgICAgeTAgPSBjb3NQaGkgKiBzaW4obGFtYmRhKTtcbiAgICAgICAgejAgPSBzaW4ocGhpKTtcbiAgICAgICAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZExpbmVQb2ludDtcbiAgICAgICAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRMaW5lUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICAgICAgICB2YXIgY29zUGhpID0gY29zKHBoaSksIHggPSBjb3NQaGkgKiBjb3MobGFtYmRhKSwgeSA9IGNvc1BoaSAqIHNpbihsYW1iZGEpLCB6ID0gc2luKHBoaSksIHcgPSBhdGFuMihzcXJ0KCh3ID0geTAgKiB6IC0gejAgKiB5KSAqIHcgKyAodyA9IHowICogeCAtIHgwICogeikgKiB3ICsgKHcgPSB4MCAqIHkgLSB5MCAqIHgpICogdyksIHgwICogeCArIHkwICogeSArIHowICogeik7XG4gICAgICAgIFcxICs9IHc7XG4gICAgICAgIFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gICAgICAgIFkxICs9IHcgKiAoeTAgKyAoeTAgPSB5KSk7XG4gICAgICAgIFoxICs9IHcgKiAoejAgKyAoejAgPSB6KSk7XG4gICAgICAgIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkTGluZUVuZCgpIHtcbiAgICAgICAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50O1xuICAgIH1cbiAgICAvLyBTZWUgSi4gRS4gQnJvY2ssIFRoZSBJbmVydGlhIFRlbnNvciBmb3IgYSBTcGhlcmljYWwgVHJpYW5nbGUsXG4gICAgLy8gSi4gQXBwbGllZCBNZWNoYW5pY3MgNDIsIDIzOSAoMTk3NSkuXG4gICAgZnVuY3Rpb24gY2VudHJvaWRSaW5nU3RhcnQoKSB7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRSaW5nUG9pbnRGaXJzdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRSaW5nRW5kKCkge1xuICAgICAgICBjZW50cm9pZFJpbmdQb2ludChsYW1iZGEwMCQyLCBwaGkwMCQyKTtcbiAgICAgICAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZFJpbmdQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGxhbWJkYTAwJDIgPSBsYW1iZGEsIHBoaTAwJDIgPSBwaGk7XG4gICAgICAgIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgICAgICAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFJpbmdQb2ludDtcbiAgICAgICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpO1xuICAgICAgICB4MCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpO1xuICAgICAgICB5MCA9IGNvc1BoaSAqIHNpbihsYW1iZGEpO1xuICAgICAgICB6MCA9IHNpbihwaGkpO1xuICAgICAgICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZFJpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gICAgICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSwgeCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpLCB5ID0gY29zUGhpICogc2luKGxhbWJkYSksIHogPSBzaW4ocGhpKSwgY3ggPSB5MCAqIHogLSB6MCAqIHksIGN5ID0gejAgKiB4IC0geDAgKiB6LCBjeiA9IHgwICogeSAtIHkwICogeCwgbSA9IHNxcnQoY3ggKiBjeCArIGN5ICogY3kgKyBjeiAqIGN6KSwgdyA9IGFzaW4obSksIC8vIGxpbmUgd2VpZ2h0ID0gYW5nbGVcbiAgICAgICAgdiA9IG0gJiYgLXcgLyBtOyAvLyBhcmVhIHdlaWdodCBtdWx0aXBsaWVyXG4gICAgICAgIFgyICs9IHYgKiBjeDtcbiAgICAgICAgWTIgKz0gdiAqIGN5O1xuICAgICAgICBaMiArPSB2ICogY3o7XG4gICAgICAgIFcxICs9IHc7XG4gICAgICAgIFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gICAgICAgIFkxICs9IHcgKiAoeTAgKyAoeTAgPSB5KSk7XG4gICAgICAgIFoxICs9IHcgKiAoejAgKyAoejAgPSB6KSk7XG4gICAgICAgIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG4gICAgfVxuICAgIHZhciBjZW50cm9pZCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgVzAgPSBXMSA9XG4gICAgICAgICAgICBYMCA9IFkwID0gWjAgPVxuICAgICAgICAgICAgICAgIFgxID0gWTEgPSBaMSA9XG4gICAgICAgICAgICAgICAgICAgIFgyID0gWTIgPSBaMiA9IDA7XG4gICAgICAgIGdlb1N0cmVhbShvYmplY3QsIGNlbnRyb2lkU3RyZWFtKTtcbiAgICAgICAgdmFyIHggPSBYMiwgeSA9IFkyLCB6ID0gWjIsIG0gPSB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG4gICAgICAgIC8vIElmIHRoZSBhcmVhLXdlaWdodGVkIGNjZW50cm9pZCBpcyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBsZW5ndGgtd2VpZ2h0ZWQgY2NlbnRyb2lkLlxuICAgICAgICBpZiAobSA8IGVwc2lsb24yKSB7XG4gICAgICAgICAgICB4ID0gWDEsIHkgPSBZMSwgeiA9IFoxO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGZlYXR1cmUgaGFzIHplcm8gbGVuZ3RoLCBmYWxsIGJhY2sgdG8gYXJpdGhtZXRpYyBtZWFuIG9mIHBvaW50IHZlY3RvcnMuXG4gICAgICAgICAgICBpZiAoVzEgPCBlcHNpbG9uKVxuICAgICAgICAgICAgICAgIHggPSBYMCwgeSA9IFkwLCB6ID0gWjA7XG4gICAgICAgICAgICBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgICAgICAgICAgLy8gSWYgdGhlIGZlYXR1cmUgc3RpbGwgaGFzIGFuIHVuZGVmaW5lZCBjY2VudHJvaWQsIHRoZW4gcmV0dXJuLlxuICAgICAgICAgICAgaWYgKG0gPCBlcHNpbG9uMilcbiAgICAgICAgICAgICAgICByZXR1cm4gW05hTiwgTmFOXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2F0YW4yKHksIHgpICogZGVncmVlcywgYXNpbih6IC8gc3FydChtKSkgKiBkZWdyZWVzXTtcbiAgICB9O1xuICAgIHZhciBjb25zdGFudCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBjb21wb3NlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgZnVuY3Rpb24gY29tcG9zZSh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geCA9IGEoeCwgeSksIGIoeFswXSwgeFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuaW52ZXJ0ICYmIGIuaW52ZXJ0KVxuICAgICAgICAgICAgY29tcG9zZS5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4ID0gYi5pbnZlcnQoeCwgeSksIHggJiYgYS5pbnZlcnQoeFswXSwgeFsxXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29tcG9zZTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJvdGF0aW9uSWRlbnRpdHkobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgcmV0dXJuIFtsYW1iZGEgPiBwaSA/IGxhbWJkYSAtIHRhdSA6IGxhbWJkYSA8IC1waSA/IGxhbWJkYSArIHRhdSA6IGxhbWJkYSwgcGhpXTtcbiAgICB9XG4gICAgcm90YXRpb25JZGVudGl0eS5pbnZlcnQgPSByb3RhdGlvbklkZW50aXR5O1xuICAgIGZ1bmN0aW9uIHJvdGF0ZVJhZGlhbnMoZGVsdGFMYW1iZGEsIGRlbHRhUGhpLCBkZWx0YUdhbW1hKSB7XG4gICAgICAgIHJldHVybiAoZGVsdGFMYW1iZGEgJT0gdGF1KSA/IChkZWx0YVBoaSB8fCBkZWx0YUdhbW1hID8gY29tcG9zZShyb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSksIHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpKVxuICAgICAgICAgICAgOiByb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkpXG4gICAgICAgICAgICA6IChkZWx0YVBoaSB8fCBkZWx0YUdhbW1hID8gcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSlcbiAgICAgICAgICAgICAgICA6IHJvdGF0aW9uSWRlbnRpdHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3J3YXJkUm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbWJkYSArPSBkZWx0YUxhbWJkYSwgW2xhbWJkYSA+IHBpID8gbGFtYmRhIC0gdGF1IDogbGFtYmRhIDwgLXBpID8gbGFtYmRhICsgdGF1IDogbGFtYmRhLCBwaGldO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkge1xuICAgICAgICB2YXIgcm90YXRpb24gPSBmb3J3YXJkUm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpO1xuICAgICAgICByb3RhdGlvbi5pbnZlcnQgPSBmb3J3YXJkUm90YXRpb25MYW1iZGEoLWRlbHRhTGFtYmRhKTtcbiAgICAgICAgcmV0dXJuIHJvdGF0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiByb3RhdGlvblBoaUdhbW1hKGRlbHRhUGhpLCBkZWx0YUdhbW1hKSB7XG4gICAgICAgIHZhciBjb3NEZWx0YVBoaSA9IGNvcyhkZWx0YVBoaSksIHNpbkRlbHRhUGhpID0gc2luKGRlbHRhUGhpKSwgY29zRGVsdGFHYW1tYSA9IGNvcyhkZWx0YUdhbW1hKSwgc2luRGVsdGFHYW1tYSA9IHNpbihkZWx0YUdhbW1hKTtcbiAgICAgICAgZnVuY3Rpb24gcm90YXRpb24obGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgIHZhciBjb3NQaGkgPSBjb3MocGhpKSwgeCA9IGNvcyhsYW1iZGEpICogY29zUGhpLCB5ID0gc2luKGxhbWJkYSkgKiBjb3NQaGksIHogPSBzaW4ocGhpKSwgayA9IHogKiBjb3NEZWx0YVBoaSArIHggKiBzaW5EZWx0YVBoaTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYXRhbjIoeSAqIGNvc0RlbHRhR2FtbWEgLSBrICogc2luRGVsdGFHYW1tYSwgeCAqIGNvc0RlbHRhUGhpIC0geiAqIHNpbkRlbHRhUGhpKSxcbiAgICAgICAgICAgICAgICBhc2luKGsgKiBjb3NEZWx0YUdhbW1hICsgeSAqIHNpbkRlbHRhR2FtbWEpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJvdGF0aW9uLmludmVydCA9IGZ1bmN0aW9uIChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLCB4ID0gY29zKGxhbWJkYSkgKiBjb3NQaGksIHkgPSBzaW4obGFtYmRhKSAqIGNvc1BoaSwgeiA9IHNpbihwaGkpLCBrID0geiAqIGNvc0RlbHRhR2FtbWEgLSB5ICogc2luRGVsdGFHYW1tYTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYXRhbjIoeSAqIGNvc0RlbHRhR2FtbWEgKyB6ICogc2luRGVsdGFHYW1tYSwgeCAqIGNvc0RlbHRhUGhpICsgayAqIHNpbkRlbHRhUGhpKSxcbiAgICAgICAgICAgICAgICBhc2luKGsgKiBjb3NEZWx0YVBoaSAtIHggKiBzaW5EZWx0YVBoaSlcbiAgICAgICAgICAgIF07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByb3RhdGlvbjtcbiAgICB9XG4gICAgdmFyIHJvdGF0aW9uID0gZnVuY3Rpb24gKHJvdGF0ZSkge1xuICAgICAgICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKHJvdGF0ZVswXSAqIHJhZGlhbnMsIHJvdGF0ZVsxXSAqIHJhZGlhbnMsIHJvdGF0ZS5sZW5ndGggPiAyID8gcm90YXRlWzJdICogcmFkaWFucyA6IDApO1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICBjb29yZGluYXRlcyA9IHJvdGF0ZShjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XG4gICAgICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yd2FyZC5pbnZlcnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gcm90YXRlLmludmVydChjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogcmFkaWFucyk7XG4gICAgICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3J3YXJkO1xuICAgIH07XG4gICAgLy8gR2VuZXJhdGVzIGEgY2lyY2xlIGNlbnRlcmVkIGF0IFswwrAsIDDCsF0sIHdpdGggYSBnaXZlbiByYWRpdXMgYW5kIHByZWNpc2lvbi5cbiAgICBmdW5jdGlvbiBjaXJjbGVTdHJlYW0oc3RyZWFtLCByYWRpdXMsIGRlbHRhLCBkaXJlY3Rpb24sIHQwLCB0MSkge1xuICAgICAgICBpZiAoIWRlbHRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgY29zUmFkaXVzID0gY29zKHJhZGl1cyksIHNpblJhZGl1cyA9IHNpbihyYWRpdXMpLCBzdGVwID0gZGlyZWN0aW9uICogZGVsdGE7XG4gICAgICAgIGlmICh0MCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0MCA9IHJhZGl1cyArIGRpcmVjdGlvbiAqIHRhdTtcbiAgICAgICAgICAgIHQxID0gcmFkaXVzIC0gc3RlcCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0MCA9IGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHQwKTtcbiAgICAgICAgICAgIHQxID0gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgdDEpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDAgPyB0MCA8IHQxIDogdDAgPiB0MSlcbiAgICAgICAgICAgICAgICB0MCArPSBkaXJlY3Rpb24gKiB0YXU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgcG9pbnQsIHQgPSB0MDsgZGlyZWN0aW9uID4gMCA/IHQgPiB0MSA6IHQgPCB0MTsgdCAtPSBzdGVwKSB7XG4gICAgICAgICAgICBwb2ludCA9IHNwaGVyaWNhbChbY29zUmFkaXVzLCAtc2luUmFkaXVzICogY29zKHQpLCAtc2luUmFkaXVzICogc2luKHQpXSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnRbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBzaWduZWQgYW5nbGUgb2YgYSBjYXJ0ZXNpYW4gcG9pbnQgcmVsYXRpdmUgdG8gW2Nvc1JhZGl1cywgMCwgMF0uXG4gICAgZnVuY3Rpb24gY2lyY2xlUmFkaXVzKGNvc1JhZGl1cywgcG9pbnQpIHtcbiAgICAgICAgcG9pbnQgPSBjYXJ0ZXNpYW4ocG9pbnQpLCBwb2ludFswXSAtPSBjb3NSYWRpdXM7XG4gICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UocG9pbnQpO1xuICAgICAgICB2YXIgcmFkaXVzID0gYWNvcygtcG9pbnRbMV0pO1xuICAgICAgICByZXR1cm4gKCgtcG9pbnRbMl0gPCAwID8gLXJhZGl1cyA6IHJhZGl1cykgKyB0YXUgLSBlcHNpbG9uKSAlIHRhdTtcbiAgICB9XG4gICAgdmFyIGNpcmNsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNlbnRlciA9IGNvbnN0YW50KFswLCAwXSksIHJhZGl1cyA9IGNvbnN0YW50KDkwKSwgcHJlY2lzaW9uID0gY29uc3RhbnQoNiksIHJpbmcsIHJvdGF0ZSwgc3RyZWFtID0geyBwb2ludDogcG9pbnQgfTtcbiAgICAgICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgICAgICAgcmluZy5wdXNoKHggPSByb3RhdGUoeCwgeSkpO1xuICAgICAgICAgICAgeFswXSAqPSBkZWdyZWVzLCB4WzFdICo9IGRlZ3JlZXM7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2lyY2xlKCkge1xuICAgICAgICAgICAgdmFyIGMgPSBjZW50ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgciA9IHJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogcmFkaWFucywgcCA9IHByZWNpc2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogcmFkaWFucztcbiAgICAgICAgICAgIHJpbmcgPSBbXTtcbiAgICAgICAgICAgIHJvdGF0ZSA9IHJvdGF0ZVJhZGlhbnMoLWNbMF0gKiByYWRpYW5zLCAtY1sxXSAqIHJhZGlhbnMsIDApLmludmVydDtcbiAgICAgICAgICAgIGNpcmNsZVN0cmVhbShzdHJlYW0sIHIsIHAsIDEpO1xuICAgICAgICAgICAgYyA9IHsgdHlwZTogXCJQb2x5Z29uXCIsIGNvb3JkaW5hdGVzOiBbcmluZ10gfTtcbiAgICAgICAgICAgIHJpbmcgPSByb3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH1cbiAgICAgICAgY2lyY2xlLmNlbnRlciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjZW50ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFsrX1swXSwgK19bMV1dKSwgY2lyY2xlKSA6IGNlbnRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgY2lyY2xlLnJhZGl1cyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgY2lyY2xlKSA6IHJhZGl1cztcbiAgICAgICAgfTtcbiAgICAgICAgY2lyY2xlLnByZWNpc2lvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcmVjaXNpb24gPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgY2lyY2xlKSA6IHByZWNpc2lvbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9O1xuICAgIHZhciBjbGlwQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGluZXMgPSBbXSwgbGluZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIGxpbmUucHVzaChbeCwgeV0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSA9IFtdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaW5lRW5kOiBub29wLFxuICAgICAgICAgICAgcmVqb2luOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZXMucG9wKCkuY29uY2F0KGxpbmVzLnNoaWZ0KCkpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbGluZXM7XG4gICAgICAgICAgICAgICAgbGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBsaW5lID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGNsaXBMaW5lID0gZnVuY3Rpb24gKGEsIGIsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYnggPSBiWzBdLCBieSA9IGJbMV0sIHQwID0gMCwgdDEgPSAxLCBkeCA9IGJ4IC0gYXgsIGR5ID0gYnkgLSBheSwgcjtcbiAgICAgICAgciA9IHgwIC0gYXg7XG4gICAgICAgIGlmICghZHggJiYgciA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHIgLz0gZHg7XG4gICAgICAgIGlmIChkeCA8IDApIHtcbiAgICAgICAgICAgIGlmIChyIDwgdDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPCB0MSlcbiAgICAgICAgICAgICAgICB0MSA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgICAgICAgICBpZiAociA+IHQxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyID4gdDApXG4gICAgICAgICAgICAgICAgdDAgPSByO1xuICAgICAgICB9XG4gICAgICAgIHIgPSB4MSAtIGF4O1xuICAgICAgICBpZiAoIWR4ICYmIHIgPCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByIC89IGR4O1xuICAgICAgICBpZiAoZHggPCAwKSB7XG4gICAgICAgICAgICBpZiAociA+IHQxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyID4gdDApXG4gICAgICAgICAgICAgICAgdDAgPSByO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgaWYgKHIgPCB0MClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA8IHQxKVxuICAgICAgICAgICAgICAgIHQxID0gcjtcbiAgICAgICAgfVxuICAgICAgICByID0geTAgLSBheTtcbiAgICAgICAgaWYgKCFkeSAmJiByID4gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgciAvPSBkeTtcbiAgICAgICAgaWYgKGR5IDwgMCkge1xuICAgICAgICAgICAgaWYgKHIgPCB0MClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA8IHQxKVxuICAgICAgICAgICAgICAgIHQxID0gcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeSA+IDApIHtcbiAgICAgICAgICAgIGlmIChyID4gdDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPiB0MClcbiAgICAgICAgICAgICAgICB0MCA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgciA9IHkxIC0gYXk7XG4gICAgICAgIGlmICghZHkgJiYgciA8IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHIgLz0gZHk7XG4gICAgICAgIGlmIChkeSA8IDApIHtcbiAgICAgICAgICAgIGlmIChyID4gdDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPiB0MClcbiAgICAgICAgICAgICAgICB0MCA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgICAgICAgICBpZiAociA8IHQwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyIDwgdDEpXG4gICAgICAgICAgICAgICAgdDEgPSByO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0MCA+IDApXG4gICAgICAgICAgICBhWzBdID0gYXggKyB0MCAqIGR4LCBhWzFdID0gYXkgKyB0MCAqIGR5O1xuICAgICAgICBpZiAodDEgPCAxKVxuICAgICAgICAgICAgYlswXSA9IGF4ICsgdDEgKiBkeCwgYlsxXSA9IGF5ICsgdDEgKiBkeTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICB2YXIgcG9pbnRFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhYnMoYVswXSAtIGJbMF0pIDwgZXBzaWxvbiAmJiBhYnMoYVsxXSAtIGJbMV0pIDwgZXBzaWxvbjtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIEludGVyc2VjdGlvbihwb2ludCwgcG9pbnRzLCBvdGhlciwgZW50cnkpIHtcbiAgICAgICAgdGhpcy54ID0gcG9pbnQ7XG4gICAgICAgIHRoaXMueiA9IHBvaW50cztcbiAgICAgICAgdGhpcy5vID0gb3RoZXI7IC8vIGFub3RoZXIgaW50ZXJzZWN0aW9uXG4gICAgICAgIHRoaXMuZSA9IGVudHJ5OyAvLyBpcyBhbiBlbnRyeT9cbiAgICAgICAgdGhpcy52ID0gZmFsc2U7IC8vIHZpc2l0ZWRcbiAgICAgICAgdGhpcy5uID0gdGhpcy5wID0gbnVsbDsgLy8gbmV4dCAmIHByZXZpb3VzXG4gICAgfVxuICAgIC8vIEEgZ2VuZXJhbGl6ZWQgcG9seWdvbiBjbGlwcGluZyBhbGdvcml0aG06IGdpdmVuIGEgcG9seWdvbiB0aGF0IGhhcyBiZWVuIGN1dFxuICAgIC8vIGludG8gaXRzIHZpc2libGUgbGluZSBzZWdtZW50cywgYW5kIHJlam9pbnMgdGhlIHNlZ21lbnRzIGJ5IGludGVycG9sYXRpbmdcbiAgICAvLyBhbG9uZyB0aGUgY2xpcCBlZGdlLlxuICAgIHZhciBjbGlwUG9seWdvbiA9IGZ1bmN0aW9uIChzZWdtZW50cywgY29tcGFyZUludGVyc2VjdGlvbiwgc3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBzdHJlYW0pIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSBbXSwgY2xpcCA9IFtdLCBpLCBuO1xuICAgICAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgICAgICBpZiAoKG4gPSBzZWdtZW50Lmxlbmd0aCAtIDEpIDw9IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIG4sIHAwID0gc2VnbWVudFswXSwgcDEgPSBzZWdtZW50W25dLCB4O1xuICAgICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBvZiBhIHNlZ21lbnQgYXJlIGNvaW5jaWRlbnQsIHRoZW4gdHJlYXQgYXMgYVxuICAgICAgICAgICAgLy8gY2xvc2VkIHJpbmcuIFRPRE8gaWYgYWxsIHJpbmdzIGFyZSBjbG9zZWQsIHRoZW4gdGhlIHdpbmRpbmcgb3JkZXIgb2YgdGhlXG4gICAgICAgICAgICAvLyBleHRlcmlvciByaW5nIHNob3VsZCBiZSBjaGVja2VkLlxuICAgICAgICAgICAgaWYgKHBvaW50RXF1YWwocDAsIHAxKSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKVxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoKHAwID0gc2VnbWVudFtpXSlbMF0sIHAwWzFdKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YmplY3QucHVzaCh4ID0gbmV3IEludGVyc2VjdGlvbihwMCwgc2VnbWVudCwgbnVsbCwgdHJ1ZSkpO1xuICAgICAgICAgICAgY2xpcC5wdXNoKHgubyA9IG5ldyBJbnRlcnNlY3Rpb24ocDAsIG51bGwsIHgsIGZhbHNlKSk7XG4gICAgICAgICAgICBzdWJqZWN0LnB1c2goeCA9IG5ldyBJbnRlcnNlY3Rpb24ocDEsIHNlZ21lbnQsIG51bGwsIGZhbHNlKSk7XG4gICAgICAgICAgICBjbGlwLnB1c2goeC5vID0gbmV3IEludGVyc2VjdGlvbihwMSwgbnVsbCwgeCwgdHJ1ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFzdWJqZWN0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2xpcC5zb3J0KGNvbXBhcmVJbnRlcnNlY3Rpb24pO1xuICAgICAgICBsaW5rKHN1YmplY3QpO1xuICAgICAgICBsaW5rKGNsaXApO1xuICAgICAgICBmb3IgKGkgPSAwLCBuID0gY2xpcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGNsaXBbaV0uZSA9IHN0YXJ0SW5zaWRlID0gIXN0YXJ0SW5zaWRlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IHN1YmplY3RbMF0sIHBvaW50cywgcG9pbnQ7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAvLyBGaW5kIGZpcnN0IHVudmlzaXRlZCBpbnRlcnNlY3Rpb24uXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHN0YXJ0LCBpc1N1YmplY3QgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQudilcbiAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnQgPSBjdXJyZW50Lm4pID09PSBzdGFydClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQudiA9IGN1cnJlbnQuby52ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQubi54LCAxLCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBjdXJyZW50LnAuejtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHBvaW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50LnAueCwgLTEsIHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubztcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICAgICAgICAgICAgaXNTdWJqZWN0ID0gIWlzU3ViamVjdDtcbiAgICAgICAgICAgIH0gd2hpbGUgKCFjdXJyZW50LnYpO1xuICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gbGluayhhcnJheSkge1xuICAgICAgICBpZiAoIShuID0gYXJyYXkubGVuZ3RoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG4sIGkgPSAwLCBhID0gYXJyYXlbMF0sIGI7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBhLm4gPSBiID0gYXJyYXlbaV07XG4gICAgICAgICAgICBiLnAgPSBhO1xuICAgICAgICAgICAgYSA9IGI7XG4gICAgICAgIH1cbiAgICAgICAgYS5uID0gYiA9IGFycmF5WzBdO1xuICAgICAgICBiLnAgPSBhO1xuICAgIH1cbiAgICB2YXIgY2xpcE1heCA9IDFlOTtcbiAgICB2YXIgY2xpcE1pbiA9IC1jbGlwTWF4O1xuICAgIC8vIFRPRE8gVXNlIGQzLXBvbHlnb27igJlzIHBvbHlnb25Db250YWlucyBoZXJlIGZvciB0aGUgcmluZyBjaGVjaz9cbiAgICAvLyBUT0RPIEVsaW1pbmF0ZSBkdXBsaWNhdGUgYnVmZmVyaW5nIGluIGNsaXBCdWZmZXIgYW5kIHBvbHlnb24ucHVzaD9cbiAgICBmdW5jdGlvbiBjbGlwRXh0ZW50KHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIGZ1bmN0aW9uIHZpc2libGUoeCwgeSkge1xuICAgICAgICAgICAgcmV0dXJuIHgwIDw9IHggJiYgeCA8PSB4MSAmJiB5MCA8PSB5ICYmIHkgPD0geTE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgICAgICAgICB2YXIgYSA9IDAsIGExID0gMDtcbiAgICAgICAgICAgIGlmIChmcm9tID09IG51bGxcbiAgICAgICAgICAgICAgICB8fCAoYSA9IGNvcm5lcihmcm9tLCBkaXJlY3Rpb24pKSAhPT0gKGExID0gY29ybmVyKHRvLCBkaXJlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHx8IGNvbXBhcmVQb2ludChmcm9tLCB0bykgPCAwIF4gZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludChhID09PSAwIHx8IGEgPT09IDMgPyB4MCA6IHgxLCBhID4gMSA/IHkxIDogeTApO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoYSA9IChhICsgZGlyZWN0aW9uICsgNCkgJSA0KSAhPT0gYTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHRvWzBdLCB0b1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29ybmVyKHAsIGRpcmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGFicyhwWzBdIC0geDApIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAwIDogM1xuICAgICAgICAgICAgICAgIDogYWJzKHBbMF0gLSB4MSkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDIgOiAxXG4gICAgICAgICAgICAgICAgICAgIDogYWJzKHBbMV0gLSB5MCkgPCBlcHNpbG9uID8gZGlyZWN0aW9uID4gMCA/IDEgOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRpcmVjdGlvbiA+IDAgPyAzIDogMjsgLy8gYWJzKHBbMV0gLSB5MSkgPCBlcHNpbG9uXG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZUludGVyc2VjdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZVBvaW50KGEueCwgYi54KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlUG9pbnQoYSwgYikge1xuICAgICAgICAgICAgdmFyIGNhID0gY29ybmVyKGEsIDEpLCBjYiA9IGNvcm5lcihiLCAxKTtcbiAgICAgICAgICAgIHJldHVybiBjYSAhPT0gY2IgPyBjYSAtIGNiXG4gICAgICAgICAgICAgICAgOiBjYSA9PT0gMCA/IGJbMV0gLSBhWzFdXG4gICAgICAgICAgICAgICAgICAgIDogY2EgPT09IDEgPyBhWzBdIC0gYlswXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjYSA9PT0gMiA/IGFbMV0gLSBiWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBiWzBdIC0gYVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIGFjdGl2ZVN0cmVhbSA9IHN0cmVhbSwgYnVmZmVyU3RyZWFtID0gY2xpcEJ1ZmZlcigpLCBzZWdtZW50cywgcG9seWdvbiwgcmluZywgeF9fLCB5X18sIHZfXywgLy8gZmlyc3QgcG9pbnRcbiAgICAgICAgICAgIHhfLCB5Xywgdl8sIC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgICAgICBmaXJzdCwgY2xlYW47XG4gICAgICAgICAgICB2YXIgY2xpcFN0cmVhbSA9IHtcbiAgICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgICAgICAgICAgICBwb2x5Z29uU3RhcnQ6IHBvbHlnb25TdGFydCxcbiAgICAgICAgICAgICAgICBwb2x5Z29uRW5kOiBwb2x5Z29uRW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuY3Rpb24gcG9pbnQoeCwgeSkge1xuICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlKHgsIHkpKVxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwb2x5Z29uSW5zaWRlKCkge1xuICAgICAgICAgICAgICAgIHZhciB3aW5kaW5nID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHJpbmcgPSBwb2x5Z29uW2ldLCBqID0gMSwgbSA9IHJpbmcubGVuZ3RoLCBwb2ludCA9IHJpbmdbMF0sIGEwLCBhMSwgYjAgPSBwb2ludFswXSwgYjEgPSBwb2ludFsxXTsgaiA8IG07ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYTAgPSBiMCwgYTEgPSBiMSwgcG9pbnQgPSByaW5nW2pdLCBiMCA9IHBvaW50WzBdLCBiMSA9IHBvaW50WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGExIDw9IHkxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIxID4geTEgJiYgKGIwIC0gYTApICogKHkxIC0gYTEpID4gKGIxIC0gYTEpICogKHgwIC0gYTApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3dpbmRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYjEgPD0geTEgJiYgKGIwIC0gYTApICogKHkxIC0gYTEpIDwgKGIxIC0gYTEpICogKHgwIC0gYTApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLXdpbmRpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCdWZmZXIgZ2VvbWV0cnkgd2l0aGluIGEgcG9seWdvbiBhbmQgdGhlbiBjbGlwIGl0IGVuIG1hc3NlLlxuICAgICAgICAgICAgZnVuY3Rpb24gcG9seWdvblN0YXJ0KCkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbSA9IGJ1ZmZlclN0cmVhbSwgc2VnbWVudHMgPSBbXSwgcG9seWdvbiA9IFtdLCBjbGVhbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwb2x5Z29uRW5kKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEluc2lkZSA9IHBvbHlnb25JbnNpZGUoKSwgY2xlYW5JbnNpZGUgPSBjbGVhbiAmJiBzdGFydEluc2lkZSwgdmlzaWJsZSA9IChzZWdtZW50cyA9IGQzQXJyYXkubWVyZ2Uoc2VnbWVudHMpKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNsZWFuSW5zaWRlIHx8IHZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xlYW5JbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlwUG9seWdvbihzZWdtZW50cywgY29tcGFyZUludGVyc2VjdGlvbiwgc3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbSA9IHN0cmVhbSwgc2VnbWVudHMgPSBwb2x5Z29uID0gcmluZyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICAgICAgICAgICAgY2xpcFN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgICAgICAgICAgICBpZiAocG9seWdvbilcbiAgICAgICAgICAgICAgICAgICAgcG9seWdvbi5wdXNoKHJpbmcgPSBbXSk7XG4gICAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZfID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgeF8gPSB5XyA9IE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8gcmF0aGVyIHRoYW4gc3BlY2lhbC1jYXNlIHBvbHlnb25zLCBzaW1wbHkgaGFuZGxlIHRoZW0gc2VwYXJhdGVseS5cbiAgICAgICAgICAgIC8vIElkZWFsbHksIGNvaW5jaWRlbnQgaW50ZXJzZWN0aW9uIHBvaW50cyBzaG91bGQgYmUgaml0dGVyZWQgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIGNsaXBwaW5nIGlzc3Vlcy5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVQb2ludCh4X18sIHlfXyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2X18gJiYgdl8pXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJTdHJlYW0ucmVqb2luKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goYnVmZmVyU3RyZWFtLnJlc3VsdCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xpcFN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgICAgICAgICAgIGlmICh2XylcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpbmVQb2ludCh4LCB5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB2aXNpYmxlKHgsIHkpO1xuICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uKVxuICAgICAgICAgICAgICAgICAgICByaW5nLnB1c2goW3gsIHldKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgeF9fID0geCwgeV9fID0geSwgdl9fID0gdjtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgJiYgdl8pXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBbeF8gPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB4XykpLCB5XyA9IE1hdGgubWF4KGNsaXBNaW4sIE1hdGgubWluKGNsaXBNYXgsIHlfKSldLCBiID0gW3ggPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB4KSksIHkgPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB5KSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaXBMaW5lKGEsIGIsIHgwLCB5MCwgeDEsIHkxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdl8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoYVswXSwgYVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludChiWzBdLCBiWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeF8gPSB4LCB5XyA9IHksIHZfID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGlwU3RyZWFtO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgZXh0ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeDAgPSAwLCB5MCA9IDAsIHgxID0gOTYwLCB5MSA9IDUwMCwgY2FjaGUsIGNhY2hlU3RyZWFtLCBjbGlwO1xuICAgICAgICByZXR1cm4gY2xpcCA9IHtcbiAgICAgICAgICAgIHN0cmVhbTogZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IGNsaXBFeHRlbnQoeDAsIHkwLCB4MSwgeTEpKGNhY2hlU3RyZWFtID0gc3RyZWFtKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBleHRlbnQ6IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSwgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGwsIGNsaXApIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgc3VtID0gYWRkZXIoKTtcbiAgICB2YXIgcG9seWdvbkNvbnRhaW5zID0gZnVuY3Rpb24gKHBvbHlnb24sIHBvaW50KSB7XG4gICAgICAgIHZhciBsYW1iZGEgPSBwb2ludFswXSwgcGhpID0gcG9pbnRbMV0sIG5vcm1hbCA9IFtzaW4obGFtYmRhKSwgLWNvcyhsYW1iZGEpLCAwXSwgYW5nbGUgPSAwLCB3aW5kaW5nID0gMDtcbiAgICAgICAgc3VtLnJlc2V0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghKG0gPSAocmluZyA9IHBvbHlnb25baV0pLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgcmluZywgbSwgcG9pbnQwID0gcmluZ1ttIC0gMV0sIGxhbWJkYTAgPSBwb2ludDBbMF0sIHBoaTAgPSBwb2ludDBbMV0gLyAyICsgcXVhcnRlclBpLCBzaW5QaGkwID0gc2luKHBoaTApLCBjb3NQaGkwID0gY29zKHBoaTApO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtOyArK2osIGxhbWJkYTAgPSBsYW1iZGExLCBzaW5QaGkwID0gc2luUGhpMSwgY29zUGhpMCA9IGNvc1BoaTEsIHBvaW50MCA9IHBvaW50MSkge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludDEgPSByaW5nW2pdLCBsYW1iZGExID0gcG9pbnQxWzBdLCBwaGkxID0gcG9pbnQxWzFdIC8gMiArIHF1YXJ0ZXJQaSwgc2luUGhpMSA9IHNpbihwaGkxKSwgY29zUGhpMSA9IGNvcyhwaGkxKSwgZGVsdGEgPSBsYW1iZGExIC0gbGFtYmRhMCwgc2lnbiQkMSA9IGRlbHRhID49IDAgPyAxIDogLTEsIGFic0RlbHRhID0gc2lnbiQkMSAqIGRlbHRhLCBhbnRpbWVyaWRpYW4gPSBhYnNEZWx0YSA+IHBpLCBrID0gc2luUGhpMCAqIHNpblBoaTE7XG4gICAgICAgICAgICAgICAgc3VtLmFkZChhdGFuMihrICogc2lnbiQkMSAqIHNpbihhYnNEZWx0YSksIGNvc1BoaTAgKiBjb3NQaGkxICsgayAqIGNvcyhhYnNEZWx0YSkpKTtcbiAgICAgICAgICAgICAgICBhbmdsZSArPSBhbnRpbWVyaWRpYW4gPyBkZWx0YSArIHNpZ24kJDEgKiB0YXUgOiBkZWx0YTtcbiAgICAgICAgICAgICAgICAvLyBBcmUgdGhlIGxvbmdpdHVkZXMgZWl0aGVyIHNpZGUgb2YgdGhlIHBvaW504oCZcyBtZXJpZGlhbiAobGFtYmRhKSxcbiAgICAgICAgICAgICAgICAvLyBhbmQgYXJlIHRoZSBsYXRpdHVkZXMgc21hbGxlciB0aGFuIHRoZSBwYXJhbGxlbCAocGhpKT9cbiAgICAgICAgICAgICAgICBpZiAoYW50aW1lcmlkaWFuIF4gbGFtYmRhMCA+PSBsYW1iZGEgXiBsYW1iZGExID49IGxhbWJkYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJjID0gY2FydGVzaWFuQ3Jvc3MoY2FydGVzaWFuKHBvaW50MCksIGNhcnRlc2lhbihwb2ludDEpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FydGVzaWFuTm9ybWFsaXplSW5QbGFjZShhcmMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gY2FydGVzaWFuQ3Jvc3Mobm9ybWFsLCBhcmMpO1xuICAgICAgICAgICAgICAgICAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGludGVyc2VjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwaGlBcmMgPSAoYW50aW1lcmlkaWFuIF4gZGVsdGEgPj0gMCA/IC0xIDogMSkgKiBhc2luKGludGVyc2VjdGlvblsyXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwaGkgPiBwaGlBcmMgfHwgcGhpID09PSBwaGlBcmMgJiYgKGFyY1swXSB8fCBhcmNbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kaW5nICs9IGFudGltZXJpZGlhbiBeIGRlbHRhID49IDAgPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmlyc3QsIGRldGVybWluZSB3aGV0aGVyIHRoZSBTb3V0aCBwb2xlIGlzIGluc2lkZSBvciBvdXRzaWRlOlxuICAgICAgICAvL1xuICAgICAgICAvLyBJdCBpcyBpbnNpZGUgaWY6XG4gICAgICAgIC8vICogdGhlIHBvbHlnb24gd2luZHMgYXJvdW5kIGl0IGluIGEgY2xvY2t3aXNlIGRpcmVjdGlvbi5cbiAgICAgICAgLy8gKiB0aGUgcG9seWdvbiBkb2VzIG5vdCAoY3VtdWxhdGl2ZWx5KSB3aW5kIGFyb3VuZCBpdCwgYnV0IGhhcyBhIG5lZ2F0aXZlXG4gICAgICAgIC8vICAgKGNvdW50ZXItY2xvY2t3aXNlKSBhcmVhLlxuICAgICAgICAvL1xuICAgICAgICAvLyBTZWNvbmQsIGNvdW50IHRoZSAoc2lnbmVkKSBudW1iZXIgb2YgdGltZXMgYSBzZWdtZW50IGNyb3NzZXMgYSBsYW1iZGFcbiAgICAgICAgLy8gZnJvbSB0aGUgcG9pbnQgdG8gdGhlIFNvdXRoIHBvbGUuICBJZiBpdCBpcyB6ZXJvLCB0aGVuIHRoZSBwb2ludCBpcyB0aGVcbiAgICAgICAgLy8gc2FtZSBzaWRlIGFzIHRoZSBTb3V0aCBwb2xlLlxuICAgICAgICByZXR1cm4gKGFuZ2xlIDwgLWVwc2lsb24gfHwgYW5nbGUgPCBlcHNpbG9uICYmIHN1bSA8IC1lcHNpbG9uKSBeICh3aW5kaW5nICYgMSk7XG4gICAgfTtcbiAgICB2YXIgbGVuZ3RoU3VtID0gYWRkZXIoKTtcbiAgICB2YXIgbGFtYmRhMCQyO1xuICAgIHZhciBzaW5QaGkwJDE7XG4gICAgdmFyIGNvc1BoaTAkMTtcbiAgICB2YXIgbGVuZ3RoU3RyZWFtID0ge1xuICAgICAgICBzcGhlcmU6IG5vb3AsXG4gICAgICAgIHBvaW50OiBub29wLFxuICAgICAgICBsaW5lU3RhcnQ6IGxlbmd0aExpbmVTdGFydCxcbiAgICAgICAgbGluZUVuZDogbm9vcCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBub29wLFxuICAgICAgICBwb2x5Z29uRW5kOiBub29wXG4gICAgfTtcbiAgICBmdW5jdGlvbiBsZW5ndGhMaW5lU3RhcnQoKSB7XG4gICAgICAgIGxlbmd0aFN0cmVhbS5wb2ludCA9IGxlbmd0aFBvaW50Rmlyc3Q7XG4gICAgICAgIGxlbmd0aFN0cmVhbS5saW5lRW5kID0gbGVuZ3RoTGluZUVuZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGVuZ3RoTGluZUVuZCgpIHtcbiAgICAgICAgbGVuZ3RoU3RyZWFtLnBvaW50ID0gbGVuZ3RoU3RyZWFtLmxpbmVFbmQgPSBub29wO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZW5ndGhQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgICAgICAgbGFtYmRhMCQyID0gbGFtYmRhLCBzaW5QaGkwJDEgPSBzaW4ocGhpKSwgY29zUGhpMCQxID0gY29zKHBoaSk7XG4gICAgICAgIGxlbmd0aFN0cmVhbS5wb2ludCA9IGxlbmd0aFBvaW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZW5ndGhQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gICAgICAgIHZhciBzaW5QaGkgPSBzaW4ocGhpKSwgY29zUGhpID0gY29zKHBoaSksIGRlbHRhID0gYWJzKGxhbWJkYSAtIGxhbWJkYTAkMiksIGNvc0RlbHRhID0gY29zKGRlbHRhKSwgc2luRGVsdGEgPSBzaW4oZGVsdGEpLCB4ID0gY29zUGhpICogc2luRGVsdGEsIHkgPSBjb3NQaGkwJDEgKiBzaW5QaGkgLSBzaW5QaGkwJDEgKiBjb3NQaGkgKiBjb3NEZWx0YSwgeiA9IHNpblBoaTAkMSAqIHNpblBoaSArIGNvc1BoaTAkMSAqIGNvc1BoaSAqIGNvc0RlbHRhO1xuICAgICAgICBsZW5ndGhTdW0uYWRkKGF0YW4yKHNxcnQoeCAqIHggKyB5ICogeSksIHopKTtcbiAgICAgICAgbGFtYmRhMCQyID0gbGFtYmRhLCBzaW5QaGkwJDEgPSBzaW5QaGksIGNvc1BoaTAkMSA9IGNvc1BoaTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgbGVuZ3RoU3VtLnJlc2V0KCk7XG4gICAgICAgIGdlb1N0cmVhbShvYmplY3QsIGxlbmd0aFN0cmVhbSk7XG4gICAgICAgIHJldHVybiArbGVuZ3RoU3VtO1xuICAgIH07XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gW251bGwsIG51bGxdO1xuICAgIHZhciBvYmplY3QgPSB7IHR5cGU6IFwiTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogY29vcmRpbmF0ZXMgfTtcbiAgICB2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICBjb29yZGluYXRlc1swXSA9IGE7XG4gICAgICAgIGNvb3JkaW5hdGVzWzFdID0gYjtcbiAgICAgICAgcmV0dXJuIGxlbmd0aChvYmplY3QpO1xuICAgIH07XG4gICAgdmFyIGNvbnRhaW5zT2JqZWN0VHlwZSA9IHtcbiAgICAgICAgRmVhdHVyZTogZnVuY3Rpb24gKG9iamVjdCwgcG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWluc0dlb21ldHJ5KG9iamVjdC5nZW9tZXRyeSwgcG9pbnQpO1xuICAgICAgICB9LFxuICAgICAgICBGZWF0dXJlQ29sbGVjdGlvbjogZnVuY3Rpb24gKG9iamVjdCwgcG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IG9iamVjdC5mZWF0dXJlcywgaSA9IC0xLCBuID0gZmVhdHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zR2VvbWV0cnkoZmVhdHVyZXNbaV0uZ2VvbWV0cnksIHBvaW50KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjb250YWluc0dlb21ldHJ5VHlwZSA9IHtcbiAgICAgICAgU3BoZXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgUG9pbnQ6IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbnNQb2ludChvYmplY3QuY29vcmRpbmF0ZXMsIHBvaW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgTXVsdGlQb2ludDogZnVuY3Rpb24gKG9iamVjdCwgcG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zUG9pbnQoY29vcmRpbmF0ZXNbaV0sIHBvaW50KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIExpbmVTdHJpbmc6IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbnNMaW5lKG9iamVjdC5jb29yZGluYXRlcywgcG9pbnQpO1xuICAgICAgICB9LFxuICAgICAgICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIGlmIChjb250YWluc0xpbmUoY29vcmRpbmF0ZXNbaV0sIHBvaW50KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIFBvbHlnb246IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbnNQb2x5Z29uKG9iamVjdC5jb29yZGluYXRlcywgcG9pbnQpO1xuICAgICAgICB9LFxuICAgICAgICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uIChvYmplY3QsIHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIGlmIChjb250YWluc1BvbHlnb24oY29vcmRpbmF0ZXNbaV0sIHBvaW50KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIEdlb21ldHJ5Q29sbGVjdGlvbjogZnVuY3Rpb24gKG9iamVjdCwgcG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyaWVzID0gb2JqZWN0Lmdlb21ldHJpZXMsIGkgPSAtMSwgbiA9IGdlb21ldHJpZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zR2VvbWV0cnkoZ2VvbWV0cmllc1tpXSwgcG9pbnQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gY29udGFpbnNHZW9tZXRyeShnZW9tZXRyeSwgcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5ICYmIGNvbnRhaW5zR2VvbWV0cnlUeXBlLmhhc093blByb3BlcnR5KGdlb21ldHJ5LnR5cGUpXG4gICAgICAgICAgICA/IGNvbnRhaW5zR2VvbWV0cnlUeXBlW2dlb21ldHJ5LnR5cGVdKGdlb21ldHJ5LCBwb2ludClcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQoY29vcmRpbmF0ZXMsIHBvaW50KSB7XG4gICAgICAgIHJldHVybiBkaXN0YW5jZShjb29yZGluYXRlcywgcG9pbnQpID09PSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluc0xpbmUoY29vcmRpbmF0ZXMsIHBvaW50KSB7XG4gICAgICAgIHZhciBhYiA9IGRpc3RhbmNlKGNvb3JkaW5hdGVzWzBdLCBjb29yZGluYXRlc1sxXSksIGFvID0gZGlzdGFuY2UoY29vcmRpbmF0ZXNbMF0sIHBvaW50KSwgb2IgPSBkaXN0YW5jZShwb2ludCwgY29vcmRpbmF0ZXNbMV0pO1xuICAgICAgICByZXR1cm4gYW8gKyBvYiA8PSBhYiArIGVwc2lsb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zUG9seWdvbihjb29yZGluYXRlcywgcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuICEhcG9seWdvbkNvbnRhaW5zKGNvb3JkaW5hdGVzLm1hcChyaW5nUmFkaWFucyksIHBvaW50UmFkaWFucyhwb2ludCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByaW5nUmFkaWFucyhyaW5nKSB7XG4gICAgICAgIHJldHVybiByaW5nID0gcmluZy5tYXAocG9pbnRSYWRpYW5zKSwgcmluZy5wb3AoKSwgcmluZztcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRSYWRpYW5zKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBbcG9pbnRbMF0gKiByYWRpYW5zLCBwb2ludFsxXSAqIHJhZGlhbnNdO1xuICAgIH1cbiAgICB2YXIgY29udGFpbnMgPSBmdW5jdGlvbiAob2JqZWN0LCBwb2ludCkge1xuICAgICAgICByZXR1cm4gKG9iamVjdCAmJiBjb250YWluc09iamVjdFR5cGUuaGFzT3duUHJvcGVydHkob2JqZWN0LnR5cGUpXG4gICAgICAgICAgICA/IGNvbnRhaW5zT2JqZWN0VHlwZVtvYmplY3QudHlwZV1cbiAgICAgICAgICAgIDogY29udGFpbnNHZW9tZXRyeSkob2JqZWN0LCBwb2ludCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBncmF0aWN1bGVYKHkwLCB5MSwgZHkpIHtcbiAgICAgICAgdmFyIHkgPSBkM0FycmF5LnJhbmdlKHkwLCB5MSAtIGVwc2lsb24sIGR5KS5jb25jYXQoeTEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHkubWFwKGZ1bmN0aW9uICh5KSB7IHJldHVybiBbeCwgeV07IH0pOyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBncmF0aWN1bGVZKHgwLCB4MSwgZHgpIHtcbiAgICAgICAgdmFyIHggPSBkM0FycmF5LnJhbmdlKHgwLCB4MSAtIGVwc2lsb24sIGR4KS5jb25jYXQoeDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHkpIHsgcmV0dXJuIHgubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBbeCwgeV07IH0pOyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBncmF0aWN1bGUoKSB7XG4gICAgICAgIHZhciB4MSwgeDAsIFgxLCBYMCwgeTEsIHkwLCBZMSwgWTAsIGR4ID0gMTAsIGR5ID0gZHgsIERYID0gOTAsIERZID0gMzYwLCB4LCB5LCBYLCBZLCBwcmVjaXNpb24gPSAyLjU7XG4gICAgICAgIGZ1bmN0aW9uIGdyYXRpY3VsZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBsaW5lcygpIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbGluZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gZDNBcnJheS5yYW5nZShjZWlsKFgwIC8gRFgpICogRFgsIFgxLCBEWCkubWFwKFgpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChkM0FycmF5LnJhbmdlKGNlaWwoWTAgLyBEWSkgKiBEWSwgWTEsIERZKS5tYXAoWSkpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChkM0FycmF5LnJhbmdlKGNlaWwoeDAgLyBkeCkgKiBkeCwgeDEsIGR4KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGFicyh4ICUgRFgpID4gZXBzaWxvbjsgfSkubWFwKHgpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoZDNBcnJheS5yYW5nZShjZWlsKHkwIC8gZHkpICogZHksIHkxLCBkeSkuZmlsdGVyKGZ1bmN0aW9uICh5KSB7IHJldHVybiBhYnMoeSAlIERZKSA+IGVwc2lsb247IH0pLm1hcCh5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JhdGljdWxlLmxpbmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVzKCkubWFwKGZ1bmN0aW9uIChjb29yZGluYXRlcykgeyByZXR1cm4geyB0eXBlOiBcIkxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzIH07IH0pO1xuICAgICAgICB9O1xuICAgICAgICBncmF0aWN1bGUub3V0bGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgWChYMCkuY29uY2F0KFkoWTEpLnNsaWNlKDEpLCBYKFgxKS5yZXZlcnNlKCkuc2xpY2UoMSksIFkoWTApLnJldmVyc2UoKS5zbGljZSgxKSlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBncmF0aWN1bGUuZXh0ZW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JhdGljdWxlLmV4dGVudE1pbm9yKCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JhdGljdWxlLmV4dGVudE1ham9yKF8pLmV4dGVudE1pbm9yKF8pO1xuICAgICAgICB9O1xuICAgICAgICBncmF0aWN1bGUuZXh0ZW50TWFqb3IgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBbW1gwLCBZMF0sIFtYMSwgWTFdXTtcbiAgICAgICAgICAgIFgwID0gK19bMF1bMF0sIFgxID0gK19bMV1bMF07XG4gICAgICAgICAgICBZMCA9ICtfWzBdWzFdLCBZMSA9ICtfWzFdWzFdO1xuICAgICAgICAgICAgaWYgKFgwID4gWDEpXG4gICAgICAgICAgICAgICAgXyA9IFgwLCBYMCA9IFgxLCBYMSA9IF87XG4gICAgICAgICAgICBpZiAoWTAgPiBZMSlcbiAgICAgICAgICAgICAgICBfID0gWTAsIFkwID0gWTEsIFkxID0gXztcbiAgICAgICAgICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gICAgICAgIH07XG4gICAgICAgIGdyYXRpY3VsZS5leHRlbnRNaW5vciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgICAgICAgICAgeDAgPSArX1swXVswXSwgeDEgPSArX1sxXVswXTtcbiAgICAgICAgICAgIHkwID0gK19bMF1bMV0sIHkxID0gK19bMV1bMV07XG4gICAgICAgICAgICBpZiAoeDAgPiB4MSlcbiAgICAgICAgICAgICAgICBfID0geDAsIHgwID0geDEsIHgxID0gXztcbiAgICAgICAgICAgIGlmICh5MCA+IHkxKVxuICAgICAgICAgICAgICAgIF8gPSB5MCwgeTAgPSB5MSwgeTEgPSBfO1xuICAgICAgICAgICAgcmV0dXJuIGdyYXRpY3VsZS5wcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgZ3JhdGljdWxlLnN0ZXAgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBncmF0aWN1bGUuc3RlcE1pbm9yKCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JhdGljdWxlLnN0ZXBNYWpvcihfKS5zdGVwTWlub3IoXyk7XG4gICAgICAgIH07XG4gICAgICAgIGdyYXRpY3VsZS5zdGVwTWFqb3IgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBbRFgsIERZXTtcbiAgICAgICAgICAgIERYID0gK19bMF0sIERZID0gK19bMV07XG4gICAgICAgICAgICByZXR1cm4gZ3JhdGljdWxlO1xuICAgICAgICB9O1xuICAgICAgICBncmF0aWN1bGUuc3RlcE1pbm9yID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gW2R4LCBkeV07XG4gICAgICAgICAgICBkeCA9ICtfWzBdLCBkeSA9ICtfWzFdO1xuICAgICAgICAgICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgICAgICAgfTtcbiAgICAgICAgZ3JhdGljdWxlLnByZWNpc2lvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWNpc2lvbjtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9ICtfO1xuICAgICAgICAgICAgeCA9IGdyYXRpY3VsZVgoeTAsIHkxLCA5MCk7XG4gICAgICAgICAgICB5ID0gZ3JhdGljdWxlWSh4MCwgeDEsIHByZWNpc2lvbik7XG4gICAgICAgICAgICBYID0gZ3JhdGljdWxlWChZMCwgWTEsIDkwKTtcbiAgICAgICAgICAgIFkgPSBncmF0aWN1bGVZKFgwLCBYMSwgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBncmF0aWN1bGU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBncmF0aWN1bGVcbiAgICAgICAgICAgIC5leHRlbnRNYWpvcihbWy0xODAsIC05MCArIGVwc2lsb25dLCBbMTgwLCA5MCAtIGVwc2lsb25dXSlcbiAgICAgICAgICAgIC5leHRlbnRNaW5vcihbWy0xODAsIC04MCAtIGVwc2lsb25dLCBbMTgwLCA4MCArIGVwc2lsb25dXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdyYXRpY3VsZTEwKCkge1xuICAgICAgICByZXR1cm4gZ3JhdGljdWxlKCkoKTtcbiAgICB9XG4gICAgdmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHgwID0gYVswXSAqIHJhZGlhbnMsIHkwID0gYVsxXSAqIHJhZGlhbnMsIHgxID0gYlswXSAqIHJhZGlhbnMsIHkxID0gYlsxXSAqIHJhZGlhbnMsIGN5MCA9IGNvcyh5MCksIHN5MCA9IHNpbih5MCksIGN5MSA9IGNvcyh5MSksIHN5MSA9IHNpbih5MSksIGt4MCA9IGN5MCAqIGNvcyh4MCksIGt5MCA9IGN5MCAqIHNpbih4MCksIGt4MSA9IGN5MSAqIGNvcyh4MSksIGt5MSA9IGN5MSAqIHNpbih4MSksIGQgPSAyICogYXNpbihzcXJ0KGhhdmVyc2luKHkxIC0geTApICsgY3kwICogY3kxICogaGF2ZXJzaW4oeDEgLSB4MCkpKSwgayA9IHNpbihkKTtcbiAgICAgICAgdmFyIGludGVycG9sYXRlID0gZCA/IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgQiA9IHNpbih0ICo9IGQpIC8gaywgQSA9IHNpbihkIC0gdCkgLyBrLCB4ID0gQSAqIGt4MCArIEIgKiBreDEsIHkgPSBBICoga3kwICsgQiAqIGt5MSwgeiA9IEEgKiBzeTAgKyBCICogc3kxO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBhdGFuMih5LCB4KSAqIGRlZ3JlZXMsXG4gICAgICAgICAgICAgICAgYXRhbjIoeiwgc3FydCh4ICogeCArIHkgKiB5KSkgKiBkZWdyZWVzXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFt4MCAqIGRlZ3JlZXMsIHkwICogZGVncmVlc107XG4gICAgICAgIH07XG4gICAgICAgIGludGVycG9sYXRlLmRpc3RhbmNlID0gZDtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlO1xuICAgIH07XG4gICAgdmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgICB2YXIgYXJlYVN1bSQxID0gYWRkZXIoKTtcbiAgICB2YXIgYXJlYVJpbmdTdW0kMSA9IGFkZGVyKCk7XG4gICAgdmFyIHgwMDtcbiAgICB2YXIgeTAwO1xuICAgIHZhciB4MCQxO1xuICAgIHZhciB5MCQxO1xuICAgIHZhciBhcmVhU3RyZWFtJDEgPSB7XG4gICAgICAgIHBvaW50OiBub29wLFxuICAgICAgICBsaW5lU3RhcnQ6IG5vb3AsXG4gICAgICAgIGxpbmVFbmQ6IG5vb3AsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXJlYVN0cmVhbSQxLmxpbmVTdGFydCA9IGFyZWFSaW5nU3RhcnQkMTtcbiAgICAgICAgICAgIGFyZWFTdHJlYW0kMS5saW5lRW5kID0gYXJlYVJpbmdFbmQkMTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYXJlYVN0cmVhbSQxLmxpbmVTdGFydCA9IGFyZWFTdHJlYW0kMS5saW5lRW5kID0gYXJlYVN0cmVhbSQxLnBvaW50ID0gbm9vcDtcbiAgICAgICAgICAgIGFyZWFTdW0kMS5hZGQoYWJzKGFyZWFSaW5nU3VtJDEpKTtcbiAgICAgICAgICAgIGFyZWFSaW5nU3VtJDEucmVzZXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJlYSA9IGFyZWFTdW0kMSAvIDI7XG4gICAgICAgICAgICBhcmVhU3VtJDEucmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybiBhcmVhO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBhcmVhUmluZ1N0YXJ0JDEoKSB7XG4gICAgICAgIGFyZWFTdHJlYW0kMS5wb2ludCA9IGFyZWFQb2ludEZpcnN0JDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZWFQb2ludEZpcnN0JDEoeCwgeSkge1xuICAgICAgICBhcmVhU3RyZWFtJDEucG9pbnQgPSBhcmVhUG9pbnQkMTtcbiAgICAgICAgeDAwID0geDAkMSA9IHgsIHkwMCA9IHkwJDEgPSB5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVhUG9pbnQkMSh4LCB5KSB7XG4gICAgICAgIGFyZWFSaW5nU3VtJDEuYWRkKHkwJDEgKiB4IC0geDAkMSAqIHkpO1xuICAgICAgICB4MCQxID0geCwgeTAkMSA9IHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZWFSaW5nRW5kJDEoKSB7XG4gICAgICAgIGFyZWFQb2ludCQxKHgwMCwgeTAwKTtcbiAgICB9XG4gICAgdmFyIHgwJDIgPSBJbmZpbml0eTtcbiAgICB2YXIgeTAkMiA9IHgwJDI7XG4gICAgdmFyIHgxID0gLXgwJDI7XG4gICAgdmFyIHkxID0geDE7XG4gICAgdmFyIGJvdW5kc1N0cmVhbSQxID0ge1xuICAgICAgICBwb2ludDogYm91bmRzUG9pbnQkMSxcbiAgICAgICAgbGluZVN0YXJ0OiBub29wLFxuICAgICAgICBsaW5lRW5kOiBub29wLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IG5vb3AsXG4gICAgICAgIHBvbHlnb25FbmQ6IG5vb3AsXG4gICAgICAgIHJlc3VsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IFtbeDAkMiwgeTAkMl0sIFt4MSwgeTFdXTtcbiAgICAgICAgICAgIHgxID0geTEgPSAtKHkwJDIgPSB4MCQyID0gSW5maW5pdHkpO1xuICAgICAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gYm91bmRzUG9pbnQkMSh4LCB5KSB7XG4gICAgICAgIGlmICh4IDwgeDAkMilcbiAgICAgICAgICAgIHgwJDIgPSB4O1xuICAgICAgICBpZiAoeCA+IHgxKVxuICAgICAgICAgICAgeDEgPSB4O1xuICAgICAgICBpZiAoeSA8IHkwJDIpXG4gICAgICAgICAgICB5MCQyID0geTtcbiAgICAgICAgaWYgKHkgPiB5MSlcbiAgICAgICAgICAgIHkxID0geTtcbiAgICB9XG4gICAgLy8gVE9ETyBFbmZvcmNlIHBvc2l0aXZlIGFyZWEgZm9yIGV4dGVyaW9yLCBuZWdhdGl2ZSBhcmVhIGZvciBpbnRlcmlvcj9cbiAgICB2YXIgWDAkMSA9IDA7XG4gICAgdmFyIFkwJDEgPSAwO1xuICAgIHZhciBaMCQxID0gMDtcbiAgICB2YXIgWDEkMSA9IDA7XG4gICAgdmFyIFkxJDEgPSAwO1xuICAgIHZhciBaMSQxID0gMDtcbiAgICB2YXIgWDIkMSA9IDA7XG4gICAgdmFyIFkyJDEgPSAwO1xuICAgIHZhciBaMiQxID0gMDtcbiAgICB2YXIgeDAwJDE7XG4gICAgdmFyIHkwMCQxO1xuICAgIHZhciB4MCQzO1xuICAgIHZhciB5MCQzO1xuICAgIHZhciBjZW50cm9pZFN0cmVhbSQxID0ge1xuICAgICAgICBwb2ludDogY2VudHJvaWRQb2ludCQxLFxuICAgICAgICBsaW5lU3RhcnQ6IGNlbnRyb2lkTGluZVN0YXJ0JDEsXG4gICAgICAgIGxpbmVFbmQ6IGNlbnRyb2lkTGluZUVuZCQxLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZVN0YXJ0ID0gY2VudHJvaWRSaW5nU3RhcnQkMTtcbiAgICAgICAgICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZUVuZCA9IGNlbnRyb2lkUmluZ0VuZCQxO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludCQxO1xuICAgICAgICAgICAgY2VudHJvaWRTdHJlYW0kMS5saW5lU3RhcnQgPSBjZW50cm9pZExpbmVTdGFydCQxO1xuICAgICAgICAgICAgY2VudHJvaWRTdHJlYW0kMS5saW5lRW5kID0gY2VudHJvaWRMaW5lRW5kJDE7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3VsdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNlbnRyb2lkID0gWjIkMSA/IFtYMiQxIC8gWjIkMSwgWTIkMSAvIFoyJDFdXG4gICAgICAgICAgICAgICAgOiBaMSQxID8gW1gxJDEgLyBaMSQxLCBZMSQxIC8gWjEkMV1cbiAgICAgICAgICAgICAgICAgICAgOiBaMCQxID8gW1gwJDEgLyBaMCQxLCBZMCQxIC8gWjAkMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW05hTiwgTmFOXTtcbiAgICAgICAgICAgIFgwJDEgPSBZMCQxID0gWjAkMSA9XG4gICAgICAgICAgICAgICAgWDEkMSA9IFkxJDEgPSBaMSQxID1cbiAgICAgICAgICAgICAgICAgICAgWDIkMSA9IFkyJDEgPSBaMiQxID0gMDtcbiAgICAgICAgICAgIHJldHVybiBjZW50cm9pZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gY2VudHJvaWRQb2ludCQxKHgsIHkpIHtcbiAgICAgICAgWDAkMSArPSB4O1xuICAgICAgICBZMCQxICs9IHk7XG4gICAgICAgICsrWjAkMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRMaW5lU3RhcnQkMSgpIHtcbiAgICAgICAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnRGaXJzdExpbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRGaXJzdExpbmUoeCwgeSkge1xuICAgICAgICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludExpbmU7XG4gICAgICAgIGNlbnRyb2lkUG9pbnQkMSh4MCQzID0geCwgeTAkMyA9IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZFBvaW50TGluZSh4LCB5KSB7XG4gICAgICAgIHZhciBkeCA9IHggLSB4MCQzLCBkeSA9IHkgLSB5MCQzLCB6ID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIFgxJDEgKz0geiAqICh4MCQzICsgeCkgLyAyO1xuICAgICAgICBZMSQxICs9IHogKiAoeTAkMyArIHkpIC8gMjtcbiAgICAgICAgWjEkMSArPSB6O1xuICAgICAgICBjZW50cm9pZFBvaW50JDEoeDAkMyA9IHgsIHkwJDMgPSB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRMaW5lRW5kJDEoKSB7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50JDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNlbnRyb2lkUmluZ1N0YXJ0JDEoKSB7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50Rmlyc3RSaW5nO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZFJpbmdFbmQkMSgpIHtcbiAgICAgICAgY2VudHJvaWRQb2ludFJpbmcoeDAwJDEsIHkwMCQxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudHJvaWRQb2ludEZpcnN0UmluZyh4LCB5KSB7XG4gICAgICAgIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50UmluZztcbiAgICAgICAgY2VudHJvaWRQb2ludCQxKHgwMCQxID0geDAkMyA9IHgsIHkwMCQxID0geTAkMyA9IHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50cm9pZFBvaW50UmluZyh4LCB5KSB7XG4gICAgICAgIHZhciBkeCA9IHggLSB4MCQzLCBkeSA9IHkgLSB5MCQzLCB6ID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIFgxJDEgKz0geiAqICh4MCQzICsgeCkgLyAyO1xuICAgICAgICBZMSQxICs9IHogKiAoeTAkMyArIHkpIC8gMjtcbiAgICAgICAgWjEkMSArPSB6O1xuICAgICAgICB6ID0geTAkMyAqIHggLSB4MCQzICogeTtcbiAgICAgICAgWDIkMSArPSB6ICogKHgwJDMgKyB4KTtcbiAgICAgICAgWTIkMSArPSB6ICogKHkwJDMgKyB5KTtcbiAgICAgICAgWjIkMSArPSB6ICogMztcbiAgICAgICAgY2VudHJvaWRQb2ludCQxKHgwJDMgPSB4LCB5MCQzID0geSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFBhdGhDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIFBhdGhDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgX3JhZGl1czogNC41LFxuICAgICAgICBwb2ludFJhZGl1czogZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXMgPSBfLCB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gTmFOO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmUgPT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gTmFOO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCArIHRoaXMuX3JhZGl1cywgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuYXJjKHgsIHksIHRoaXMuX3JhZGl1cywgMCwgdGF1KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXN1bHQ6IG5vb3BcbiAgICB9O1xuICAgIHZhciBsZW5ndGhTdW0kMSA9IGFkZGVyKCk7XG4gICAgdmFyIGxlbmd0aFJpbmc7XG4gICAgdmFyIHgwMCQyO1xuICAgIHZhciB5MDAkMjtcbiAgICB2YXIgeDAkNDtcbiAgICB2YXIgeTAkNDtcbiAgICB2YXIgbGVuZ3RoU3RyZWFtJDEgPSB7XG4gICAgICAgIHBvaW50OiBub29wLFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxlbmd0aFN0cmVhbSQxLnBvaW50ID0gbGVuZ3RoUG9pbnRGaXJzdCQxO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobGVuZ3RoUmluZylcbiAgICAgICAgICAgICAgICBsZW5ndGhQb2ludCQxKHgwMCQyLCB5MDAkMik7XG4gICAgICAgICAgICBsZW5ndGhTdHJlYW0kMS5wb2ludCA9IG5vb3A7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGVuZ3RoUmluZyA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxlbmd0aFJpbmcgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICByZXN1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSArbGVuZ3RoU3VtJDE7XG4gICAgICAgICAgICBsZW5ndGhTdW0kMS5yZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gbGVuZ3RoUG9pbnRGaXJzdCQxKHgsIHkpIHtcbiAgICAgICAgbGVuZ3RoU3RyZWFtJDEucG9pbnQgPSBsZW5ndGhQb2ludCQxO1xuICAgICAgICB4MDAkMiA9IHgwJDQgPSB4LCB5MDAkMiA9IHkwJDQgPSB5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZW5ndGhQb2ludCQxKHgsIHkpIHtcbiAgICAgICAgeDAkNCAtPSB4LCB5MCQ0IC09IHk7XG4gICAgICAgIGxlbmd0aFN1bSQxLmFkZChzcXJ0KHgwJDQgKiB4MCQ0ICsgeTAkNCAqIHkwJDQpKTtcbiAgICAgICAgeDAkNCA9IHgsIHkwJDQgPSB5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBQYXRoU3RyaW5nKCkge1xuICAgICAgICB0aGlzLl9zdHJpbmcgPSBbXTtcbiAgICB9XG4gICAgUGF0aFN0cmluZy5wcm90b3R5cGUgPSB7XG4gICAgICAgIF9yYWRpdXM6IDQuNSxcbiAgICAgICAgX2NpcmNsZTogY2lyY2xlJDEoNC41KSxcbiAgICAgICAgcG9pbnRSYWRpdXM6IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoKF8gPSArXykgIT09IHRoaXMuX3JhZGl1cylcbiAgICAgICAgICAgICAgICB0aGlzLl9yYWRpdXMgPSBfLCB0aGlzLl9jaXJjbGUgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZSA9PT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIlpcIik7XG4gICAgICAgICAgICB0aGlzLl9wb2ludCA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0cmluZy5wdXNoKFwiTVwiLCB4LCBcIixcIiwgeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIkxcIiwgeCwgXCIsXCIsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2lyY2xlID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaXJjbGUgPSBjaXJjbGUkMSh0aGlzLl9yYWRpdXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIk1cIiwgeCwgXCIsXCIsIHksIHRoaXMuX2NpcmNsZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVzdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9zdHJpbmcuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHJpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNpcmNsZSQxKHJhZGl1cykge1xuICAgICAgICByZXR1cm4gXCJtMCxcIiArIHJhZGl1c1xuICAgICAgICAgICAgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIC0yICogcmFkaXVzXG4gICAgICAgICAgICArIFwiYVwiICsgcmFkaXVzICsgXCIsXCIgKyByYWRpdXMgKyBcIiAwIDEsMSAwLFwiICsgMiAqIHJhZGl1c1xuICAgICAgICAgICAgKyBcInpcIjtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZnVuY3Rpb24gKHByb2plY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHBvaW50UmFkaXVzID0gNC41LCBwcm9qZWN0aW9uU3RyZWFtLCBjb250ZXh0U3RyZWFtO1xuICAgICAgICBmdW5jdGlvbiBwYXRoKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrcG9pbnRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICAgICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShjb250ZXh0U3RyZWFtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dFN0cmVhbS5yZXN1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoLmFyZWEgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgICAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGFyZWFTdHJlYW0kMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFyZWFTdHJlYW0kMS5yZXN1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcGF0aC5tZWFzdXJlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICAgICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShsZW5ndGhTdHJlYW0kMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGxlbmd0aFN0cmVhbSQxLnJlc3VsdCgpO1xuICAgICAgICB9O1xuICAgICAgICBwYXRoLmJvdW5kcyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oYm91bmRzU3RyZWFtJDEpKTtcbiAgICAgICAgICAgIHJldHVybiBib3VuZHNTdHJlYW0kMS5yZXN1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcGF0aC5jZW50cm9pZCA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oY2VudHJvaWRTdHJlYW0kMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNlbnRyb2lkU3RyZWFtJDEucmVzdWx0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHBhdGgucHJvamVjdGlvbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcm9qZWN0aW9uU3RyZWFtID0gXyA9PSBudWxsID8gKHByb2plY3Rpb24gPSBudWxsLCBpZGVudGl0eSkgOiAocHJvamVjdGlvbiA9IF8pLnN0cmVhbSwgcGF0aCkgOiBwcm9qZWN0aW9uO1xuICAgICAgICB9O1xuICAgICAgICBwYXRoLmNvbnRleHQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgICAgICAgY29udGV4dFN0cmVhbSA9IF8gPT0gbnVsbCA/IChjb250ZXh0ID0gbnVsbCwgbmV3IFBhdGhTdHJpbmcpIDogbmV3IFBhdGhDb250ZXh0KGNvbnRleHQgPSBfKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKHBvaW50UmFkaXVzKTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9O1xuICAgICAgICBwYXRoLnBvaW50UmFkaXVzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnRSYWRpdXM7XG4gICAgICAgICAgICBwb2ludFJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogKGNvbnRleHRTdHJlYW0ucG9pbnRSYWRpdXMoK18pLCArXyk7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBhdGgucHJvamVjdGlvbihwcm9qZWN0aW9uKS5jb250ZXh0KGNvbnRleHQpO1xuICAgIH07XG4gICAgdmFyIGNsaXAgPSBmdW5jdGlvbiAocG9pbnRWaXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocm90YXRlLCBzaW5rKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGNsaXBMaW5lKHNpbmspLCByb3RhdGVkU3RhcnQgPSByb3RhdGUuaW52ZXJ0KHN0YXJ0WzBdLCBzdGFydFsxXSksIHJpbmdCdWZmZXIgPSBjbGlwQnVmZmVyKCksIHJpbmdTaW5rID0gY2xpcExpbmUocmluZ0J1ZmZlciksIHBvbHlnb25TdGFydGVkID0gZmFsc2UsIHBvbHlnb24sIHNlZ21lbnRzLCByaW5nO1xuICAgICAgICAgICAgdmFyIGNsaXAgPSB7XG4gICAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICAgICAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXAucG9pbnQgPSBwb2ludFJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGNsaXAubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBjbGlwLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBwb2x5Z29uID0gW107XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsaXAucG9pbnQgPSBwb2ludDtcbiAgICAgICAgICAgICAgICAgICAgY2xpcC5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGNsaXAubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzID0gZDNBcnJheS5tZXJnZShzZWdtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluc2lkZSA9IHBvbHlnb25Db250YWlucyhwb2x5Z29uLCByb3RhdGVkU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBQb2x5Z29uKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHNpbmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0SW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uU3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsucG9seWdvbkVuZCgpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cyA9IHBvbHlnb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3BoZXJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpbmsucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHNpbmspO1xuICAgICAgICAgICAgICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2luay5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gcm90YXRlKGxhbWJkYSwgcGhpKTtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRWaXNpYmxlKGxhbWJkYSA9IHBvaW50WzBdLCBwaGkgPSBwb2ludFsxXSkpXG4gICAgICAgICAgICAgICAgICAgIHNpbmsucG9pbnQobGFtYmRhLCBwaGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcG9pbnRMaW5lKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gcm90YXRlKGxhbWJkYSwgcGhpKTtcbiAgICAgICAgICAgICAgICBsaW5lLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICAgICAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50TGluZTtcbiAgICAgICAgICAgICAgICBsaW5lLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgICAgICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgbGluZS5saW5lRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwb2ludFJpbmcobGFtYmRhLCBwaGkpIHtcbiAgICAgICAgICAgICAgICByaW5nLnB1c2goW2xhbWJkYSwgcGhpXSk7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gcm90YXRlKGxhbWJkYSwgcGhpKTtcbiAgICAgICAgICAgICAgICByaW5nU2luay5wb2ludChwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgICAgICAgICAgIHJpbmdTaW5rLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIHJpbmcgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRSaW5nKHJpbmdbMF1bMF0sIHJpbmdbMF1bMV0pO1xuICAgICAgICAgICAgICAgIHJpbmdTaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICB2YXIgY2xlYW4gPSByaW5nU2luay5jbGVhbigpLCByaW5nU2VnbWVudHMgPSByaW5nQnVmZmVyLnJlc3VsdCgpLCBpLCBuID0gcmluZ1NlZ21lbnRzLmxlbmd0aCwgbSwgc2VnbWVudCwgcG9pbnQ7XG4gICAgICAgICAgICAgICAgcmluZy5wb3AoKTtcbiAgICAgICAgICAgICAgICBwb2x5Z29uLnB1c2gocmluZyk7XG4gICAgICAgICAgICAgICAgcmluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9ucy5cbiAgICAgICAgICAgICAgICBpZiAoY2xlYW4gJiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQgPSByaW5nU2VnbWVudHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmICgobSA9IHNlZ21lbnQubGVuZ3RoIC0gMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsucG9pbnQoKHBvaW50ID0gc2VnbWVudFtpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmVqb2luIGNvbm5lY3RlZCBzZWdtZW50cy5cbiAgICAgICAgICAgICAgICAvLyBUT0RPIHJldXNlIHJpbmdCdWZmZXIucmVqb2luKCk/XG4gICAgICAgICAgICAgICAgaWYgKG4gPiAxICYmIGNsZWFuICYgMilcbiAgICAgICAgICAgICAgICAgICAgcmluZ1NlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLnBvcCgpLmNvbmNhdChyaW5nU2VnbWVudHMuc2hpZnQoKSkpO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLmZpbHRlcih2YWxpZFNlZ21lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGlwO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgZnVuY3Rpb24gdmFsaWRTZWdtZW50KHNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnQubGVuZ3RoID4gMTtcbiAgICB9XG4gICAgLy8gSW50ZXJzZWN0aW9ucyBhcmUgc29ydGVkIGFsb25nIHRoZSBjbGlwIGVkZ2UuIEZvciBib3RoIGFudGltZXJpZGlhbiBjdXR0aW5nXG4gICAgLy8gYW5kIGNpcmNsZSBjbGlwcGluZywgdGhlIHNhbWUgY29tcGFyaXNvbiBpcyB1c2VkLlxuICAgIGZ1bmN0aW9uIGNvbXBhcmVJbnRlcnNlY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gKChhID0gYS54KVswXSA8IDAgPyBhWzFdIC0gaGFsZlBpIC0gZXBzaWxvbiA6IGhhbGZQaSAtIGFbMV0pXG4gICAgICAgICAgICAtICgoYiA9IGIueClbMF0gPCAwID8gYlsxXSAtIGhhbGZQaSAtIGVwc2lsb24gOiBoYWxmUGkgLSBiWzFdKTtcbiAgICB9XG4gICAgdmFyIGNsaXBBbnRpbWVyaWRpYW4gPSBjbGlwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0sIGNsaXBBbnRpbWVyaWRpYW5MaW5lLCBjbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUsIFstcGksIC1oYWxmUGldKTtcbiAgICAvLyBUYWtlcyBhIGxpbmUgYW5kIGN1dHMgaW50byB2aXNpYmxlIHNlZ21lbnRzLiBSZXR1cm4gdmFsdWVzOiAwIC0gdGhlcmUgd2VyZVxuICAgIC8vIGludGVyc2VjdGlvbnMgb3IgdGhlIGxpbmUgd2FzIGVtcHR5OyAxIC0gbm8gaW50ZXJzZWN0aW9uczsgMiAtIHRoZXJlIHdlcmVcbiAgICAvLyBpbnRlcnNlY3Rpb25zLCBhbmQgdGhlIGZpcnN0IGFuZCBsYXN0IHNlZ21lbnRzIHNob3VsZCBiZSByZWpvaW5lZC5cbiAgICBmdW5jdGlvbiBjbGlwQW50aW1lcmlkaWFuTGluZShzdHJlYW0pIHtcbiAgICAgICAgdmFyIGxhbWJkYTAgPSBOYU4sIHBoaTAgPSBOYU4sIHNpZ24wID0gTmFOLCBjbGVhbjsgLy8gbm8gaW50ZXJzZWN0aW9uc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGNsZWFuID0gMTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKGxhbWJkYTEsIHBoaTEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2lnbjEgPSBsYW1iZGExID4gMCA/IHBpIDogLXBpLCBkZWx0YSA9IGFicyhsYW1iZGExIC0gbGFtYmRhMCk7XG4gICAgICAgICAgICAgICAgaWYgKGFicyhkZWx0YSAtIHBpKSA8IGVwc2lsb24pIHsgLy8gbGluZSBjcm9zc2VzIGEgcG9sZVxuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMCwgcGhpMCA9IChwaGkwICsgcGhpMSkgLyAyID4gMCA/IGhhbGZQaSA6IC1oYWxmUGkpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjAsIHBoaTApO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludChzaWduMSwgcGhpMCk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGExLCBwaGkwKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWduMCAhPT0gc2lnbjEgJiYgZGVsdGEgPj0gcGkpIHsgLy8gbGluZSBjcm9zc2VzIGFudGltZXJpZGlhblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWJzKGxhbWJkYTAgLSBzaWduMCkgPCBlcHNpbG9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFtYmRhMCAtPSBzaWduMCAqIGVwc2lsb247IC8vIGhhbmRsZSBkZWdlbmVyYWNpZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFicyhsYW1iZGExIC0gc2lnbjEpIDwgZXBzaWxvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbWJkYTEgLT0gc2lnbjEgKiBlcHNpbG9uO1xuICAgICAgICAgICAgICAgICAgICBwaGkwID0gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24wLCBwaGkwKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjEsIHBoaTApO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGEwID0gbGFtYmRhMSwgcGhpMCA9IHBoaTEpO1xuICAgICAgICAgICAgICAgIHNpZ24wID0gc2lnbjE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgbGFtYmRhMCA9IHBoaTAgPSBOYU47XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xlYW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAtIGNsZWFuOyAvLyBpZiBpbnRlcnNlY3Rpb25zLCByZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKSB7XG4gICAgICAgIHZhciBjb3NQaGkwLCBjb3NQaGkxLCBzaW5MYW1iZGEwTGFtYmRhMSA9IHNpbihsYW1iZGEwIC0gbGFtYmRhMSk7XG4gICAgICAgIHJldHVybiBhYnMoc2luTGFtYmRhMExhbWJkYTEpID4gZXBzaWxvblxuICAgICAgICAgICAgPyBhdGFuKChzaW4ocGhpMCkgKiAoY29zUGhpMSA9IGNvcyhwaGkxKSkgKiBzaW4obGFtYmRhMSlcbiAgICAgICAgICAgICAgICAtIHNpbihwaGkxKSAqIChjb3NQaGkwID0gY29zKHBoaTApKSAqIHNpbihsYW1iZGEwKSlcbiAgICAgICAgICAgICAgICAvIChjb3NQaGkwICogY29zUGhpMSAqIHNpbkxhbWJkYTBMYW1iZGExKSlcbiAgICAgICAgICAgIDogKHBoaTAgKyBwaGkxKSAvIDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsaXBBbnRpbWVyaWRpYW5JbnRlcnBvbGF0ZShmcm9tLCB0bywgZGlyZWN0aW9uLCBzdHJlYW0pIHtcbiAgICAgICAgdmFyIHBoaTtcbiAgICAgICAgaWYgKGZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgcGhpID0gZGlyZWN0aW9uICogaGFsZlBpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KC1waSwgcGhpKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludCgwLCBwaGkpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBpLCBwaGkpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KHBpLCAwKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwaSwgLXBoaSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQoMCwgLXBoaSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQoLXBpLCAtcGhpKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludCgtcGksIDApO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KC1waSwgcGhpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhYnMoZnJvbVswXSAtIHRvWzBdKSA+IGVwc2lsb24pIHtcbiAgICAgICAgICAgIHZhciBsYW1iZGEgPSBmcm9tWzBdIDwgdG9bMF0gPyBwaSA6IC1waTtcbiAgICAgICAgICAgIHBoaSA9IGRpcmVjdGlvbiAqIGxhbWJkYSAvIDI7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQoLWxhbWJkYSwgcGhpKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludCgwLCBwaGkpO1xuICAgICAgICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjbGlwQ2lyY2xlID0gZnVuY3Rpb24gKHJhZGl1cywgZGVsdGEpIHtcbiAgICAgICAgdmFyIGNyID0gY29zKHJhZGl1cyksIHNtYWxsUmFkaXVzID0gY3IgPiAwLCBub3RIZW1pc3BoZXJlID0gYWJzKGNyKSA+IGVwc2lsb247IC8vIFRPRE8gb3B0aW1pc2UgZm9yIHRoaXMgY29tbW9uIGNhc2VcbiAgICAgICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgICAgICAgICBjaXJjbGVTdHJlYW0oc3RyZWFtLCByYWRpdXMsIGRlbHRhLCBkaXJlY3Rpb24sIGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2aXNpYmxlKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29zKGxhbWJkYSkgKiBjb3MocGhpKSA+IGNyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRha2VzIGEgbGluZSBhbmQgY3V0cyBpbnRvIHZpc2libGUgc2VnbWVudHMuIFJldHVybiB2YWx1ZXMgdXNlZCBmb3IgcG9seWdvblxuICAgICAgICAvLyBjbGlwcGluZzogMCAtIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucyBvciB0aGUgbGluZSB3YXMgZW1wdHk7IDEgLSBub1xuICAgICAgICAvLyBpbnRlcnNlY3Rpb25zIDIgLSB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMsIGFuZCB0aGUgZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHNcbiAgICAgICAgLy8gc2hvdWxkIGJlIHJlam9pbmVkLlxuICAgICAgICBmdW5jdGlvbiBjbGlwTGluZShzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBwb2ludDAsIC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgICAgICBjMCwgLy8gY29kZSBmb3IgcHJldmlvdXMgcG9pbnRcbiAgICAgICAgICAgIHYwLCAvLyB2aXNpYmlsaXR5IG9mIHByZXZpb3VzIHBvaW50XG4gICAgICAgICAgICB2MDAsIC8vIHZpc2liaWxpdHkgb2YgZmlyc3QgcG9pbnRcbiAgICAgICAgICAgIGNsZWFuOyAvLyBubyBpbnRlcnNlY3Rpb25zXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2MDAgPSB2MCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IDE7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludDEgPSBbbGFtYmRhLCBwaGldLCBwb2ludDIsIHYgPSB2aXNpYmxlKGxhbWJkYSwgcGhpKSwgYyA9IHNtYWxsUmFkaXVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHYgPyAwIDogY29kZShsYW1iZGEsIHBoaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdiA/IGNvZGUobGFtYmRhICsgKGxhbWJkYSA8IDAgPyBwaSA6IC1waSksIHBoaSkgOiAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBvaW50MCAmJiAodjAwID0gdjAgPSB2KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGRlZ2VuZXJhY2llcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBpZ25vcmUgaWYgbm90IGNsaXBwaW5nIHBvbHlnb25zLlxuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBvaW50MiB8fCBwb2ludEVxdWFsKHBvaW50MCwgcG9pbnQyKSB8fCBwb2ludEVxdWFsKHBvaW50MSwgcG9pbnQyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50MVswXSArPSBlcHNpbG9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50MVsxXSArPSBlcHNpbG9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSB2aXNpYmxlKHBvaW50MVswXSwgcG9pbnQxWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3V0c2lkZSBnb2luZyBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDIgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNpZGUgZ29pbmcgb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MCwgcG9pbnQxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludDAgPSBwb2ludDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm90SGVtaXNwaGVyZSAmJiBwb2ludDAgJiYgc21hbGxSYWRpdXMgXiB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb2RlcyBmb3IgdHdvIHBvaW50cyBhcmUgZGlmZmVyZW50LCBvciBhcmUgYm90aCB6ZXJvLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoZXJlIHRoaXMgc2VnbWVudCBpbnRlcnNlY3RzIHdpdGggdGhlIHNtYWxsIGNpcmNsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGMgJiBjMCkgJiYgKHQgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDAsIHRydWUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc21hbGxSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFswXVswXSwgdFswXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFswXVswXSwgdFswXVsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICYmICghcG9pbnQwIHx8ICFwb2ludEVxdWFsKHBvaW50MCwgcG9pbnQxKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDFbMF0sIHBvaW50MVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9pbnQwID0gcG9pbnQxLCB2MCA9IHYsIGMwID0gYztcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYwKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIFJlam9pbiBmaXJzdCBhbmQgbGFzdCBzZWdtZW50cyBpZiB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMgYW5kIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgIC8vIGFuZCBsYXN0IHBvaW50cyB3ZXJlIHZpc2libGUuXG4gICAgICAgICAgICAgICAgY2xlYW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFuIHwgKCh2MDAgJiYgdjApIDw8IDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW50ZXJzZWN0cyB0aGUgZ3JlYXQgY2lyY2xlIGJldHdlZW4gYSBhbmQgYiB3aXRoIHRoZSBjbGlwIGNpcmNsZS5cbiAgICAgICAgZnVuY3Rpb24gaW50ZXJzZWN0KGEsIGIsIHR3bykge1xuICAgICAgICAgICAgdmFyIHBhID0gY2FydGVzaWFuKGEpLCBwYiA9IGNhcnRlc2lhbihiKTtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdHdvIHBsYW5lcywgbjEucCA9IGQxIGFuZCBuMi5wID0gZDIuXG4gICAgICAgICAgICAvLyBGaW5kIGludGVyc2VjdGlvbiBsaW5lIHAodCkgPSBjMSBuMSArIGMyIG4yICsgdCAobjEg4qivIG4yKS5cbiAgICAgICAgICAgIHZhciBuMSA9IFsxLCAwLCAwXSwgLy8gbm9ybWFsXG4gICAgICAgICAgICBuMiA9IGNhcnRlc2lhbkNyb3NzKHBhLCBwYiksIG4ybjIgPSBjYXJ0ZXNpYW5Eb3QobjIsIG4yKSwgbjFuMiA9IG4yWzBdLCAvLyBjYXJ0ZXNpYW5Eb3QobjEsIG4yKSxcbiAgICAgICAgICAgIGRldGVybWluYW50ID0gbjJuMiAtIG4xbjIgKiBuMW4yO1xuICAgICAgICAgICAgLy8gVHdvIHBvbGFyIHBvaW50cy5cbiAgICAgICAgICAgIGlmICghZGV0ZXJtaW5hbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICF0d28gJiYgYTtcbiAgICAgICAgICAgIHZhciBjMSA9IGNyICogbjJuMiAvIGRldGVybWluYW50LCBjMiA9IC1jciAqIG4xbjIgLyBkZXRlcm1pbmFudCwgbjF4bjIgPSBjYXJ0ZXNpYW5Dcm9zcyhuMSwgbjIpLCBBID0gY2FydGVzaWFuU2NhbGUobjEsIGMxKSwgQiA9IGNhcnRlc2lhblNjYWxlKG4yLCBjMik7XG4gICAgICAgICAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKEEsIEIpO1xuICAgICAgICAgICAgLy8gU29sdmUgfHAodCl8XjIgPSAxLlxuICAgICAgICAgICAgdmFyIHUgPSBuMXhuMiwgdyA9IGNhcnRlc2lhbkRvdChBLCB1KSwgdXUgPSBjYXJ0ZXNpYW5Eb3QodSwgdSksIHQyID0gdyAqIHcgLSB1dSAqIChjYXJ0ZXNpYW5Eb3QoQSwgQSkgLSAxKTtcbiAgICAgICAgICAgIGlmICh0MiA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHQgPSBzcXJ0KHQyKSwgcSA9IGNhcnRlc2lhblNjYWxlKHUsICgtdyAtIHQpIC8gdXUpO1xuICAgICAgICAgICAgY2FydGVzaWFuQWRkSW5QbGFjZShxLCBBKTtcbiAgICAgICAgICAgIHEgPSBzcGhlcmljYWwocSk7XG4gICAgICAgICAgICBpZiAoIXR3bylcbiAgICAgICAgICAgICAgICByZXR1cm4gcTtcbiAgICAgICAgICAgIC8vIFR3byBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICAgICAgICAgICAgdmFyIGxhbWJkYTAgPSBhWzBdLCBsYW1iZGExID0gYlswXSwgcGhpMCA9IGFbMV0sIHBoaTEgPSBiWzFdLCB6O1xuICAgICAgICAgICAgaWYgKGxhbWJkYTEgPCBsYW1iZGEwKVxuICAgICAgICAgICAgICAgIHogPSBsYW1iZGEwLCBsYW1iZGEwID0gbGFtYmRhMSwgbGFtYmRhMSA9IHo7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBsYW1iZGExIC0gbGFtYmRhMCwgcG9sYXIgPSBhYnMoZGVsdGEgLSBwaSkgPCBlcHNpbG9uLCBtZXJpZGlhbiA9IHBvbGFyIHx8IGRlbHRhIDwgZXBzaWxvbjtcbiAgICAgICAgICAgIGlmICghcG9sYXIgJiYgcGhpMSA8IHBoaTApXG4gICAgICAgICAgICAgICAgeiA9IHBoaTAsIHBoaTAgPSBwaGkxLCBwaGkxID0gejtcbiAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhlIGZpcnN0IHBvaW50IGlzIGJldHdlZW4gYSBhbmQgYi5cbiAgICAgICAgICAgIGlmIChtZXJpZGlhblxuICAgICAgICAgICAgICAgID8gcG9sYXJcbiAgICAgICAgICAgICAgICAgICAgPyBwaGkwICsgcGhpMSA+IDAgXiBxWzFdIDwgKGFicyhxWzBdIC0gbGFtYmRhMCkgPCBlcHNpbG9uID8gcGhpMCA6IHBoaTEpXG4gICAgICAgICAgICAgICAgICAgIDogcGhpMCA8PSBxWzFdICYmIHFbMV0gPD0gcGhpMVxuICAgICAgICAgICAgICAgIDogZGVsdGEgPiBwaSBeIChsYW1iZGEwIDw9IHFbMF0gJiYgcVswXSA8PSBsYW1iZGExKSkge1xuICAgICAgICAgICAgICAgIHZhciBxMSA9IGNhcnRlc2lhblNjYWxlKHUsICgtdyArIHQpIC8gdXUpO1xuICAgICAgICAgICAgICAgIGNhcnRlc2lhbkFkZEluUGxhY2UocTEsIEEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbcSwgc3BoZXJpY2FsKHExKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2VuZXJhdGVzIGEgNC1iaXQgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gb2YgYSBwb2ludCByZWxhdGl2ZSB0b1xuICAgICAgICAvLyB0aGUgc21hbGwgY2lyY2xlJ3MgYm91bmRpbmcgYm94LlxuICAgICAgICBmdW5jdGlvbiBjb2RlKGxhbWJkYSwgcGhpKSB7XG4gICAgICAgICAgICB2YXIgciA9IHNtYWxsUmFkaXVzID8gcmFkaXVzIDogcGkgLSByYWRpdXMsIGNvZGUgPSAwO1xuICAgICAgICAgICAgaWYgKGxhbWJkYSA8IC1yKVxuICAgICAgICAgICAgICAgIGNvZGUgfD0gMTsgLy8gbGVmdFxuICAgICAgICAgICAgZWxzZSBpZiAobGFtYmRhID4gcilcbiAgICAgICAgICAgICAgICBjb2RlIHw9IDI7IC8vIHJpZ2h0XG4gICAgICAgICAgICBpZiAocGhpIDwgLXIpXG4gICAgICAgICAgICAgICAgY29kZSB8PSA0OyAvLyBiZWxvd1xuICAgICAgICAgICAgZWxzZSBpZiAocGhpID4gcilcbiAgICAgICAgICAgICAgICBjb2RlIHw9IDg7IC8vIGFib3ZlXG4gICAgICAgICAgICByZXR1cm4gY29kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xpcCh2aXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIHNtYWxsUmFkaXVzID8gWzAsIC1yYWRpdXNdIDogWy1waSwgcmFkaXVzIC0gcGldKTtcbiAgICB9O1xuICAgIHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbiAobWV0aG9kcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RyZWFtOiB0cmFuc2Zvcm1lcihtZXRob2RzKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtZXIobWV0aG9kcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIHMgPSBuZXcgVHJhbnNmb3JtU3RyZWFtO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpXG4gICAgICAgICAgICAgICAgc1trZXldID0gbWV0aG9kc1trZXldO1xuICAgICAgICAgICAgcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtKCkgeyB9XG4gICAgVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IFRyYW5zZm9ybVN0cmVhbSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7IHRoaXMuc3RyZWFtLnBvaW50KHgsIHkpOyB9LFxuICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uICgpIHsgdGhpcy5zdHJlYW0uc3BoZXJlKCk7IH0sXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkgeyB0aGlzLnN0cmVhbS5saW5lU3RhcnQoKTsgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkgeyB0aGlzLnN0cmVhbS5saW5lRW5kKCk7IH0sXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24gKCkgeyB0aGlzLnN0cmVhbS5wb2x5Z29uU3RhcnQoKTsgfSxcbiAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkgeyB0aGlzLnN0cmVhbS5wb2x5Z29uRW5kKCk7IH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCkge1xuICAgICAgICB2YXIgdyA9IGV4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSwgaCA9IGV4dGVudFsxXVsxXSAtIGV4dGVudFswXVsxXSwgY2xpcCA9IHByb2plY3Rpb24uY2xpcEV4dGVudCAmJiBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoKTtcbiAgICAgICAgcHJvamVjdGlvblxuICAgICAgICAgICAgLnNjYWxlKDE1MClcbiAgICAgICAgICAgIC50cmFuc2xhdGUoWzAsIDBdKTtcbiAgICAgICAgaWYgKGNsaXAgIT0gbnVsbClcbiAgICAgICAgICAgIHByb2plY3Rpb24uY2xpcEV4dGVudChudWxsKTtcbiAgICAgICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvbi5zdHJlYW0oYm91bmRzU3RyZWFtJDEpKTtcbiAgICAgICAgdmFyIGIgPSBib3VuZHNTdHJlYW0kMS5yZXN1bHQoKSwgayA9IE1hdGgubWluKHcgLyAoYlsxXVswXSAtIGJbMF1bMF0pLCBoIC8gKGJbMV1bMV0gLSBiWzBdWzFdKSksIHggPSArZXh0ZW50WzBdWzBdICsgKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLCB5ID0gK2V4dGVudFswXVsxXSArIChoIC0gayAqIChiWzFdWzFdICsgYlswXVsxXSkpIC8gMjtcbiAgICAgICAgaWYgKGNsaXAgIT0gbnVsbClcbiAgICAgICAgICAgIHByb2plY3Rpb24uY2xpcEV4dGVudChjbGlwKTtcbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb25cbiAgICAgICAgICAgIC5zY2FsZShrICogMTUwKVxuICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCwgeV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIFtbMCwgMF0sIHNpemVdLCBvYmplY3QpO1xuICAgIH1cbiAgICB2YXIgbWF4RGVwdGggPSAxNjtcbiAgICB2YXIgY29zTWluRGlzdGFuY2UgPSBjb3MoMzAgKiByYWRpYW5zKTsgLy8gY29zKG1pbmltdW0gYW5ndWxhciBkaXN0YW5jZSlcbiAgICB2YXIgcmVzYW1wbGUgPSBmdW5jdGlvbiAocHJvamVjdCwgZGVsdGEyKSB7XG4gICAgICAgIHJldHVybiArZGVsdGEyID8gcmVzYW1wbGUkMShwcm9qZWN0LCBkZWx0YTIpIDogcmVzYW1wbGVOb25lKHByb2plY3QpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVzYW1wbGVOb25lKHByb2plY3QpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyKHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzYW1wbGUkMShwcm9qZWN0LCBkZWx0YTIpIHtcbiAgICAgICAgZnVuY3Rpb24gcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MSwgeTEsIGxhbWJkYTEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBkeCA9IHgxIC0geDAsIGR5ID0geTEgLSB5MCwgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgICAgIGlmIChkMiA+IDQgKiBkZWx0YTIgJiYgZGVwdGgtLSkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gYTAgKyBhMSwgYiA9IGIwICsgYjEsIGMgPSBjMCArIGMxLCBtID0gc3FydChhICogYSArIGIgKiBiICsgYyAqIGMpLCBwaGkyID0gYXNpbihjIC89IG0pLCBsYW1iZGEyID0gYWJzKGFicyhjKSAtIDEpIDwgZXBzaWxvbiB8fCBhYnMobGFtYmRhMCAtIGxhbWJkYTEpIDwgZXBzaWxvbiA/IChsYW1iZGEwICsgbGFtYmRhMSkgLyAyIDogYXRhbjIoYiwgYSksIHAgPSBwcm9qZWN0KGxhbWJkYTIsIHBoaTIpLCB4MiA9IHBbMF0sIHkyID0gcFsxXSwgZHgyID0geDIgLSB4MCwgZHkyID0geTIgLSB5MCwgZHogPSBkeSAqIGR4MiAtIGR4ICogZHkyO1xuICAgICAgICAgICAgICAgIGlmIChkeiAqIGR6IC8gZDIgPiBkZWx0YTIgLy8gcGVycGVuZGljdWxhciBwcm9qZWN0ZWQgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgfHwgYWJzKChkeCAqIGR4MiArIGR5ICogZHkyKSAvIGQyIC0gMC41KSA+IDAuMyAvLyBtaWRwb2ludCBjbG9zZSB0byBhbiBlbmRcbiAgICAgICAgICAgICAgICAgICAgfHwgYTAgKiBhMSArIGIwICogYjEgKyBjMCAqIGMxIDwgY29zTWluRGlzdGFuY2UpIHsgLy8gYW5ndWxhciBkaXN0YW5jZVxuICAgICAgICAgICAgICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgyLCB5MiwgbGFtYmRhMiwgYSAvPSBtLCBiIC89IG0sIGMsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQoeDIsIHkyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDIsIHkyLCBsYW1iZGEyLCBhLCBiLCBjLCB4MSwgeTEsIGxhbWJkYTEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIGxhbWJkYTAwLCB4MDAsIHkwMCwgYTAwLCBiMDAsIGMwMCwgLy8gZmlyc3QgcG9pbnRcbiAgICAgICAgICAgIGxhbWJkYTAsIHgwLCB5MCwgYTAsIGIwLCBjMDsgLy8gcHJldmlvdXMgcG9pbnRcbiAgICAgICAgICAgIHZhciByZXNhbXBsZVN0cmVhbSA9IHtcbiAgICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgICAgICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uICgpIHsgc3RyZWFtLnBvbHlnb25TdGFydCgpOyByZXNhbXBsZVN0cmVhbS5saW5lU3RhcnQgPSByaW5nU3RhcnQ7IH0sXG4gICAgICAgICAgICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24gKCkgeyBzdHJlYW0ucG9seWdvbkVuZCgpOyByZXNhbXBsZVN0cmVhbS5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgICAgICAgICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgICAgICAgICAgIHgwID0gTmFOO1xuICAgICAgICAgICAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGxpbmVQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gY2FydGVzaWFuKFtsYW1iZGEsIHBoaV0pLCBwID0gcHJvamVjdChsYW1iZGEsIHBoaSk7XG4gICAgICAgICAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MCA9IHBbMF0sIHkwID0gcFsxXSwgbGFtYmRhMCA9IGxhbWJkYSwgYTAgPSBjWzBdLCBiMCA9IGNbMV0sIGMwID0gY1syXSwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnBvaW50KHgwLCB5MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgICAgICAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IHJpbmdQb2ludDtcbiAgICAgICAgICAgICAgICByZXNhbXBsZVN0cmVhbS5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgICAgIGxpbmVQb2ludChsYW1iZGEwMCA9IGxhbWJkYSwgcGhpKSwgeDAwID0geDAsIHkwMCA9IHkwLCBhMDAgPSBhMCwgYjAwID0gYjAsIGMwMCA9IGMwO1xuICAgICAgICAgICAgICAgIHJlc2FtcGxlU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgICAgICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgwMCwgeTAwLCBsYW1iZGEwMCwgYTAwLCBiMDAsIGMwMCwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgcmVzYW1wbGVTdHJlYW0ubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgICAgICAgICAgbGluZUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc2FtcGxlU3RyZWFtO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgdHJhbnNmb3JtUmFkaWFucyA9IHRyYW5zZm9ybWVyKHtcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5wb2ludCh4ICogcmFkaWFucywgeSAqIHJhZGlhbnMpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcHJvamVjdGlvbihwcm9qZWN0KSB7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uTXV0YXRvcihmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9qZWN0OyB9KSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpIHtcbiAgICAgICAgdmFyIHByb2plY3QsIGsgPSAxNTAsIC8vIHNjYWxlXG4gICAgICAgIHggPSA0ODAsIHkgPSAyNTAsIC8vIHRyYW5zbGF0ZVxuICAgICAgICBkeCwgZHksIGxhbWJkYSA9IDAsIHBoaSA9IDAsIC8vIGNlbnRlclxuICAgICAgICBkZWx0YUxhbWJkYSA9IDAsIGRlbHRhUGhpID0gMCwgZGVsdGFHYW1tYSA9IDAsIHJvdGF0ZSwgcHJvamVjdFJvdGF0ZSwgLy8gcm90YXRlXG4gICAgICAgIHRoZXRhID0gbnVsbCwgcHJlY2xpcCA9IGNsaXBBbnRpbWVyaWRpYW4sIC8vIGNsaXAgYW5nbGVcbiAgICAgICAgeDAgPSBudWxsLCB5MCwgeDEsIHkxLCBwb3N0Y2xpcCA9IGlkZW50aXR5LCAvLyBjbGlwIGV4dGVudFxuICAgICAgICBkZWx0YTIgPSAwLjUsIHByb2plY3RSZXNhbXBsZSA9IHJlc2FtcGxlKHByb2plY3RUcmFuc2Zvcm0sIGRlbHRhMiksIC8vIHByZWNpc2lvblxuICAgICAgICBjYWNoZSwgY2FjaGVTdHJlYW07XG4gICAgICAgIGZ1bmN0aW9uIHByb2plY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHBvaW50ID0gcHJvamVjdFJvdGF0ZShwb2ludFswXSAqIHJhZGlhbnMsIHBvaW50WzFdICogcmFkaWFucyk7XG4gICAgICAgICAgICByZXR1cm4gW3BvaW50WzBdICogayArIGR4LCBkeSAtIHBvaW50WzFdICoga107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW52ZXJ0KHBvaW50KSB7XG4gICAgICAgICAgICBwb2ludCA9IHByb2plY3RSb3RhdGUuaW52ZXJ0KChwb2ludFswXSAtIGR4KSAvIGssIChkeSAtIHBvaW50WzFdKSAvIGspO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50ICYmIFtwb2ludFswXSAqIGRlZ3JlZXMsIHBvaW50WzFdICogZGVncmVlc107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHJvamVjdFRyYW5zZm9ybSh4LCB5KSB7XG4gICAgICAgICAgICByZXR1cm4geCA9IHByb2plY3QoeCwgeSksIFt4WzBdICogayArIGR4LCBkeSAtIHhbMV0gKiBrXTtcbiAgICAgICAgfVxuICAgICAgICBwcm9qZWN0aW9uLnN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IHRyYW5zZm9ybVJhZGlhbnMocHJlY2xpcChyb3RhdGUsIHByb2plY3RSZXNhbXBsZShwb3N0Y2xpcChjYWNoZVN0cmVhbSA9IHN0cmVhbSkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24uY2xpcEFuZ2xlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByZWNsaXAgPSArXyA/IGNsaXBDaXJjbGUodGhldGEgPSBfICogcmFkaWFucywgNiAqIHJhZGlhbnMpIDogKHRoZXRhID0gbnVsbCwgY2xpcEFudGltZXJpZGlhbiksIHJlc2V0KCkpIDogdGhldGEgKiBkZWdyZWVzO1xuICAgICAgICB9O1xuICAgICAgICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSkgOiBjbGlwRXh0ZW50KHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pLCByZXNldCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24uc2NhbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoayA9ICtfLCByZWNlbnRlcigpKSA6IGs7XG4gICAgICAgIH07XG4gICAgICAgIHByb2plY3Rpb24udHJhbnNsYXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSArX1swXSwgeSA9ICtfWzFdLCByZWNlbnRlcigpKSA6IFt4LCB5XTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5jZW50ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobGFtYmRhID0gX1swXSAlIDM2MCAqIHJhZGlhbnMsIHBoaSA9IF9bMV0gJSAzNjAgKiByYWRpYW5zLCByZWNlbnRlcigpKSA6IFtsYW1iZGEgKiBkZWdyZWVzLCBwaGkgKiBkZWdyZWVzXTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5yb3RhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGVsdGFMYW1iZGEgPSBfWzBdICUgMzYwICogcmFkaWFucywgZGVsdGFQaGkgPSBfWzFdICUgMzYwICogcmFkaWFucywgZGVsdGFHYW1tYSA9IF8ubGVuZ3RoID4gMiA/IF9bMl0gJSAzNjAgKiByYWRpYW5zIDogMCwgcmVjZW50ZXIoKSkgOiBbZGVsdGFMYW1iZGEgKiBkZWdyZWVzLCBkZWx0YVBoaSAqIGRlZ3JlZXMsIGRlbHRhR2FtbWEgKiBkZWdyZWVzXTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5wcmVjaXNpb24gPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJvamVjdFJlc2FtcGxlID0gcmVzYW1wbGUocHJvamVjdFRyYW5zZm9ybSwgZGVsdGEyID0gXyAqIF8pLCByZXNldCgpKSA6IHNxcnQoZGVsdGEyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvamVjdGlvbi5maXRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBwcm9qZWN0aW9uLmZpdFNpemUgPSBmdW5jdGlvbiAoc2l6ZSwgb2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZWNlbnRlcigpIHtcbiAgICAgICAgICAgIHByb2plY3RSb3RhdGUgPSBjb21wb3NlKHJvdGF0ZSA9IHJvdGF0ZVJhZGlhbnMoZGVsdGFMYW1iZGEsIGRlbHRhUGhpLCBkZWx0YUdhbW1hKSwgcHJvamVjdCk7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gcHJvamVjdChsYW1iZGEsIHBoaSk7XG4gICAgICAgICAgICBkeCA9IHggLSBjZW50ZXJbMF0gKiBrO1xuICAgICAgICAgICAgZHkgPSB5ICsgY2VudGVyWzFdICogaztcbiAgICAgICAgICAgIHJldHVybiByZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvamVjdCA9IHByb2plY3RBdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcHJvamVjdGlvbi5pbnZlcnQgPSBwcm9qZWN0LmludmVydCAmJiBpbnZlcnQ7XG4gICAgICAgICAgICByZXR1cm4gcmVjZW50ZXIoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uaWNQcm9qZWN0aW9uKHByb2plY3RBdCkge1xuICAgICAgICB2YXIgcGhpMCA9IDAsIHBoaTEgPSBwaSAvIDMsIG0gPSBwcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpLCBwID0gbShwaGkwLCBwaGkxKTtcbiAgICAgICAgcC5wYXJhbGxlbHMgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBtKHBoaTAgPSBfWzBdICogcmFkaWFucywgcGhpMSA9IF9bMV0gKiByYWRpYW5zKSA6IFtwaGkwICogZGVncmVlcywgcGhpMSAqIGRlZ3JlZXNdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3lsaW5kcmljYWxFcXVhbEFyZWFSYXcocGhpMCkge1xuICAgICAgICB2YXIgY29zUGhpMCA9IGNvcyhwaGkwKTtcbiAgICAgICAgZnVuY3Rpb24gZm9yd2FyZChsYW1iZGEsIHBoaSkge1xuICAgICAgICAgICAgcmV0dXJuIFtsYW1iZGEgKiBjb3NQaGkwLCBzaW4ocGhpKSAvIGNvc1BoaTBdO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiBbeCAvIGNvc1BoaTAsIGFzaW4oeSAqIGNvc1BoaTApXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZvcndhcmQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbmljRXF1YWxBcmVhUmF3KHkwLCB5MSkge1xuICAgICAgICB2YXIgc3kwID0gc2luKHkwKSwgbiA9IChzeTAgKyBzaW4oeTEpKSAvIDI7XG4gICAgICAgIC8vIEFyZSB0aGUgcGFyYWxsZWxzIHN5bW1ldHJpY2FsIGFyb3VuZCB0aGUgRXF1YXRvcj9cbiAgICAgICAgaWYgKGFicyhuKSA8IGVwc2lsb24pXG4gICAgICAgICAgICByZXR1cm4gY3lsaW5kcmljYWxFcXVhbEFyZWFSYXcoeTApO1xuICAgICAgICB2YXIgYyA9IDEgKyBzeTAgKiAoMiAqIG4gLSBzeTApLCByMCA9IHNxcnQoYykgLyBuO1xuICAgICAgICBmdW5jdGlvbiBwcm9qZWN0KHgsIHkpIHtcbiAgICAgICAgICAgIHZhciByID0gc3FydChjIC0gMiAqIG4gKiBzaW4oeSkpIC8gbjtcbiAgICAgICAgICAgIHJldHVybiBbciAqIHNpbih4ICo9IG4pLCByMCAtIHIgKiBjb3MoeCldO1xuICAgICAgICB9XG4gICAgICAgIHByb2plY3QuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciByMHkgPSByMCAtIHk7XG4gICAgICAgICAgICByZXR1cm4gW2F0YW4yKHgsIGFicyhyMHkpKSAvIG4gKiBzaWduKHIweSksIGFzaW4oKGMgLSAoeCAqIHggKyByMHkgKiByMHkpICogbiAqIG4pIC8gKDIgKiBuKSldO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJvamVjdDtcbiAgICB9XG4gICAgdmFyIGNvbmljRXF1YWxBcmVhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29uaWNQcm9qZWN0aW9uKGNvbmljRXF1YWxBcmVhUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDE1NS40MjQpXG4gICAgICAgICAgICAuY2VudGVyKFswLCAzMy42NDQyXSk7XG4gICAgfTtcbiAgICB2YXIgYWxiZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29uaWNFcXVhbEFyZWEoKVxuICAgICAgICAgICAgLnBhcmFsbGVscyhbMjkuNSwgNDUuNV0pXG4gICAgICAgICAgICAuc2NhbGUoMTA3MClcbiAgICAgICAgICAgIC50cmFuc2xhdGUoWzQ4MCwgMjUwXSlcbiAgICAgICAgICAgIC5yb3RhdGUoWzk2LCAwXSlcbiAgICAgICAgICAgIC5jZW50ZXIoWy0wLjYsIDM4LjddKTtcbiAgICB9O1xuICAgIC8vIFRoZSBwcm9qZWN0aW9ucyBtdXN0IGhhdmUgbXV0dWFsbHkgZXhjbHVzaXZlIGNsaXAgcmVnaW9ucyBvbiB0aGUgc3BoZXJlLFxuICAgIC8vIGFzIHRoaXMgd2lsbCBhdm9pZCBlbWl0dGluZyBpbnRlcmxlYXZpbmcgbGluZXMgYW5kIHBvbHlnb25zLlxuICAgIGZ1bmN0aW9uIG11bHRpcGxleChzdHJlYW1zKSB7XG4gICAgICAgIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICAgICAgc3RyZWFtc1tpXS5wb2ludCh4LCB5KTsgfSxcbiAgICAgICAgICAgIHNwaGVyZTogZnVuY3Rpb24gKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgICAgICBzdHJlYW1zW2ldLnNwaGVyZSgpOyB9LFxuICAgICAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7IH0sXG4gICAgICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ubGluZUVuZCgpOyB9LFxuICAgICAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvblN0YXJ0KCk7IH0sXG4gICAgICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbiAoKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKVxuICAgICAgICAgICAgICAgIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpOyB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEEgY29tcG9zaXRlIHByb2plY3Rpb24gZm9yIHRoZSBVbml0ZWQgU3RhdGVzLCBjb25maWd1cmVkIGJ5IGRlZmF1bHQgZm9yXG4gICAgLy8gOTYww5c1MDAuIFRoZSBwcm9qZWN0aW9uIGFsc28gd29ya3MgcXVpdGUgd2VsbCBhdCA5NjDDlzYwMCBpZiB5b3UgY2hhbmdlIHRoZVxuICAgIC8vIHNjYWxlIHRvIDEyODUgYW5kIGFkanVzdCB0aGUgdHJhbnNsYXRlIGFjY29yZGluZ2x5LiBUaGUgc2V0IG9mIHN0YW5kYXJkXG4gICAgLy8gcGFyYWxsZWxzIGZvciBlYWNoIHJlZ2lvbiBjb21lcyBmcm9tIFVTR1MsIHdoaWNoIGlzIHB1Ymxpc2hlZCBoZXJlOlxuICAgIC8vIGh0dHA6Ly9lZ3NjLnVzZ3MuZ292L2lzYi9wdWJzL01hcFByb2plY3Rpb25zL3Byb2plY3Rpb25zLmh0bWwjYWxiZXJzXG4gICAgdmFyIGFsYmVyc1VzYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhY2hlLCBjYWNoZVN0cmVhbSwgbG93ZXI0OCA9IGFsYmVycygpLCBsb3dlcjQ4UG9pbnQsIGFsYXNrYSA9IGNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsxNTQsIDBdKS5jZW50ZXIoWy0yLCA1OC41XSkucGFyYWxsZWxzKFs1NSwgNjVdKSwgYWxhc2thUG9pbnQsIC8vIEVQU0c6MzMzOFxuICAgICAgICBoYXdhaWkgPSBjb25pY0VxdWFsQXJlYSgpLnJvdGF0ZShbMTU3LCAwXSkuY2VudGVyKFstMywgMTkuOV0pLnBhcmFsbGVscyhbOCwgMThdKSwgaGF3YWlpUG9pbnQsIC8vIEVTUkk6MTAyMDA3XG4gICAgICAgIHBvaW50LCBwb2ludFN0cmVhbSA9IHsgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7IHBvaW50ID0gW3gsIHldOyB9IH07XG4gICAgICAgIGZ1bmN0aW9uIGFsYmVyc1VzYShjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIHggPSBjb29yZGluYXRlc1swXSwgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50ID0gbnVsbCxcbiAgICAgICAgICAgICAgICAobG93ZXI0OFBvaW50LnBvaW50KHgsIHkpLCBwb2ludClcbiAgICAgICAgICAgICAgICAgICAgfHwgKGFsYXNrYVBvaW50LnBvaW50KHgsIHkpLCBwb2ludClcbiAgICAgICAgICAgICAgICAgICAgfHwgKGhhd2FpaVBvaW50LnBvaW50KHgsIHkpLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgYWxiZXJzVXNhLmludmVydCA9IGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xuICAgICAgICAgICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksIHQgPSBsb3dlcjQ4LnRyYW5zbGF0ZSgpLCB4ID0gKGNvb3JkaW5hdGVzWzBdIC0gdFswXSkgLyBrLCB5ID0gKGNvb3JkaW5hdGVzWzFdIC0gdFsxXSkgLyBrO1xuICAgICAgICAgICAgcmV0dXJuICh5ID49IDAuMTIwICYmIHkgPCAwLjIzNCAmJiB4ID49IC0wLjQyNSAmJiB4IDwgLTAuMjE0ID8gYWxhc2thXG4gICAgICAgICAgICAgICAgOiB5ID49IDAuMTY2ICYmIHkgPCAwLjIzNCAmJiB4ID49IC0wLjIxNCAmJiB4IDwgLTAuMTE1ID8gaGF3YWlpXG4gICAgICAgICAgICAgICAgICAgIDogbG93ZXI0OCkuaW52ZXJ0KGNvb3JkaW5hdGVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWxiZXJzVXNhLnN0cmVhbSA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IG11bHRpcGxleChbbG93ZXI0OC5zdHJlYW0oY2FjaGVTdHJlYW0gPSBzdHJlYW0pLCBhbGFza2Euc3RyZWFtKHN0cmVhbSksIGhhd2FpaS5zdHJlYW0oc3RyZWFtKV0pO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2EucHJlY2lzaW9uID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbG93ZXI0OC5wcmVjaXNpb24oKTtcbiAgICAgICAgICAgIGxvd2VyNDgucHJlY2lzaW9uKF8pLCBhbGFza2EucHJlY2lzaW9uKF8pLCBoYXdhaWkucHJlY2lzaW9uKF8pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5zY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvd2VyNDguc2NhbGUoKTtcbiAgICAgICAgICAgIGxvd2VyNDguc2NhbGUoXyksIGFsYXNrYS5zY2FsZShfICogMC4zNSksIGhhd2FpaS5zY2FsZShfKTtcbiAgICAgICAgICAgIHJldHVybiBhbGJlcnNVc2EudHJhbnNsYXRlKGxvd2VyNDgudHJhbnNsYXRlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBhbGJlcnNVc2EudHJhbnNsYXRlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gbG93ZXI0OC50cmFuc2xhdGUoKTtcbiAgICAgICAgICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcbiAgICAgICAgICAgIGxvd2VyNDhQb2ludCA9IGxvd2VyNDhcbiAgICAgICAgICAgICAgICAudHJhbnNsYXRlKF8pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC40NTUgKiBrLCB5IC0gMC4yMzggKiBrXSwgW3ggKyAwLjQ1NSAqIGssIHkgKyAwLjIzOCAqIGtdXSlcbiAgICAgICAgICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcbiAgICAgICAgICAgIGFsYXNrYVBvaW50ID0gYWxhc2thXG4gICAgICAgICAgICAgICAgLnRyYW5zbGF0ZShbeCAtIDAuMzA3ICogaywgeSArIDAuMjAxICoga10pXG4gICAgICAgICAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC40MjUgKiBrICsgZXBzaWxvbiwgeSArIDAuMTIwICogayArIGVwc2lsb25dLCBbeCAtIDAuMjE0ICogayAtIGVwc2lsb24sIHkgKyAwLjIzNCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgICAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG4gICAgICAgICAgICBoYXdhaWlQb2ludCA9IGhhd2FpaVxuICAgICAgICAgICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjIwNSAqIGssIHkgKyAwLjIxMiAqIGtdKVxuICAgICAgICAgICAgICAgIC5jbGlwRXh0ZW50KFtbeCAtIDAuMjE0ICogayArIGVwc2lsb24sIHkgKyAwLjE2NiAqIGsgKyBlcHNpbG9uXSwgW3ggLSAwLjExNSAqIGsgLSBlcHNpbG9uLCB5ICsgMC4yMzQgKiBrIC0gZXBzaWxvbl1dKVxuICAgICAgICAgICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5maXRFeHRlbnQgPSBmdW5jdGlvbiAoZXh0ZW50LCBvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQoYWxiZXJzVXNhLCBleHRlbnQsIG9iamVjdCk7XG4gICAgICAgIH07XG4gICAgICAgIGFsYmVyc1VzYS5maXRTaXplID0gZnVuY3Rpb24gKHNpemUsIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpdFNpemUoYWxiZXJzVXNhLCBzaXplLCBvYmplY3QpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGFsYmVyc1VzYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxiZXJzVXNhLnNjYWxlKDEwNzApO1xuICAgIH07XG4gICAgZnVuY3Rpb24gYXppbXV0aGFsUmF3KHNjYWxlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIGN4ID0gY29zKHgpLCBjeSA9IGNvcyh5KSwgayA9IHNjYWxlKGN4ICogY3kpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBrICogY3kgKiBzaW4oeCksXG4gICAgICAgICAgICAgICAgayAqIHNpbih5KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXppbXV0aGFsSW52ZXJ0KGFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdmFyIHogPSBzcXJ0KHggKiB4ICsgeSAqIHkpLCBjID0gYW5nbGUoeiksIHNjID0gc2luKGMpLCBjYyA9IGNvcyhjKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgYXRhbjIoeCAqIHNjLCB6ICogY2MpLFxuICAgICAgICAgICAgICAgIGFzaW4oeiAmJiB5ICogc2MgLyB6KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGF6aW11dGhhbEVxdWFsQXJlYVJhdyA9IGF6aW11dGhhbFJhdyhmdW5jdGlvbiAoY3hjeSkge1xuICAgICAgICByZXR1cm4gc3FydCgyIC8gKDEgKyBjeGN5KSk7XG4gICAgfSk7XG4gICAgYXppbXV0aGFsRXF1YWxBcmVhUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbiAoeikge1xuICAgICAgICByZXR1cm4gMiAqIGFzaW4oeiAvIDIpO1xuICAgIH0pO1xuICAgIHZhciBhemltdXRoYWxFcXVhbEFyZWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uKGF6aW11dGhhbEVxdWFsQXJlYVJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxMjQuNzUpXG4gICAgICAgICAgICAuY2xpcEFuZ2xlKDE4MCAtIDFlLTMpO1xuICAgIH07XG4gICAgdmFyIGF6aW11dGhhbEVxdWlkaXN0YW50UmF3ID0gYXppbXV0aGFsUmF3KGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiAoYyA9IGFjb3MoYykpICYmIGMgLyBzaW4oYyk7XG4gICAgfSk7XG4gICAgYXppbXV0aGFsRXF1aWRpc3RhbnRSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGZ1bmN0aW9uICh6KSB7XG4gICAgICAgIHJldHVybiB6O1xuICAgIH0pO1xuICAgIHZhciBhemltdXRoYWxFcXVpZGlzdGFudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb24oYXppbXV0aGFsRXF1aWRpc3RhbnRSYXcpXG4gICAgICAgICAgICAuc2NhbGUoNzkuNDE4OClcbiAgICAgICAgICAgIC5jbGlwQW5nbGUoMTgwIC0gMWUtMyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBtZXJjYXRvclJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICByZXR1cm4gW2xhbWJkYSwgbG9nKHRhbigoaGFsZlBpICsgcGhpKSAvIDIpKV07XG4gICAgfVxuICAgIG1lcmNhdG9yUmF3LmludmVydCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiBbeCwgMiAqIGF0YW4oZXhwKHkpKSAtIGhhbGZQaV07XG4gICAgfTtcbiAgICB2YXIgbWVyY2F0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtZXJjYXRvclByb2plY3Rpb24obWVyY2F0b3JSYXcpXG4gICAgICAgICAgICAuc2NhbGUoOTYxIC8gdGF1KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG1lcmNhdG9yUHJvamVjdGlvbihwcm9qZWN0KSB7XG4gICAgICAgIHZhciBtID0gcHJvamVjdGlvbihwcm9qZWN0KSwgY2VudGVyID0gbS5jZW50ZXIsIHNjYWxlID0gbS5zY2FsZSwgdHJhbnNsYXRlID0gbS50cmFuc2xhdGUsIGNsaXBFeHRlbnQgPSBtLmNsaXBFeHRlbnQsIHgwID0gbnVsbCwgeTAsIHgxLCB5MTsgLy8gY2xpcCBleHRlbnRcbiAgICAgICAgbS5zY2FsZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzY2FsZShfKSwgcmVjbGlwKCkpIDogc2NhbGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNsYXRlKF8pLCByZWNsaXAoKSkgOiB0cmFuc2xhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbS5jZW50ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2VudGVyKF8pLCByZWNsaXAoKSkgOiBjZW50ZXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbS5jbGlwRXh0ZW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChfID09IG51bGwgPyB4MCA9IHkwID0geDEgPSB5MSA9IG51bGwgOiAoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSkpLCByZWNsaXAoKSkgOiB4MCA9PSBudWxsID8gbnVsbCA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiByZWNsaXAoKSB7XG4gICAgICAgICAgICB2YXIgayA9IHBpICogc2NhbGUoKSwgdCA9IG0ocm90YXRpb24obS5yb3RhdGUoKSkuaW52ZXJ0KFswLCAwXSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNsaXBFeHRlbnQoeDAgPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gW1t0WzBdIC0gaywgdFsxXSAtIGtdLCBbdFswXSArIGssIHRbMV0gKyBrXV0gOiBwcm9qZWN0ID09PSBtZXJjYXRvclJhd1xuICAgICAgICAgICAgICAgID8gW1tNYXRoLm1heCh0WzBdIC0gaywgeDApLCB5MF0sIFtNYXRoLm1pbih0WzBdICsgaywgeDEpLCB5MV1dXG4gICAgICAgICAgICAgICAgOiBbW3gwLCBNYXRoLm1heCh0WzFdIC0gaywgeTApXSwgW3gxLCBNYXRoLm1pbih0WzFdICsgaywgeTEpXV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWNsaXAoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGFueSh5KSB7XG4gICAgICAgIHJldHVybiB0YW4oKGhhbGZQaSArIHkpIC8gMik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbmljQ29uZm9ybWFsUmF3KHkwLCB5MSkge1xuICAgICAgICB2YXIgY3kwID0gY29zKHkwKSwgbiA9IHkwID09PSB5MSA/IHNpbih5MCkgOiBsb2coY3kwIC8gY29zKHkxKSkgLyBsb2codGFueSh5MSkgLyB0YW55KHkwKSksIGYgPSBjeTAgKiBwb3codGFueSh5MCksIG4pIC8gbjtcbiAgICAgICAgaWYgKCFuKVxuICAgICAgICAgICAgcmV0dXJuIG1lcmNhdG9yUmF3O1xuICAgICAgICBmdW5jdGlvbiBwcm9qZWN0KHgsIHkpIHtcbiAgICAgICAgICAgIGlmIChmID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh5IDwgLWhhbGZQaSArIGVwc2lsb24pXG4gICAgICAgICAgICAgICAgICAgIHkgPSAtaGFsZlBpICsgZXBzaWxvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh5ID4gaGFsZlBpIC0gZXBzaWxvbilcbiAgICAgICAgICAgICAgICAgICAgeSA9IGhhbGZQaSAtIGVwc2lsb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgciA9IGYgLyBwb3codGFueSh5KSwgbik7XG4gICAgICAgICAgICByZXR1cm4gW3IgKiBzaW4obiAqIHgpLCBmIC0gciAqIGNvcyhuICogeCldO1xuICAgICAgICB9XG4gICAgICAgIHByb2plY3QuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBmeSA9IGYgLSB5LCByID0gc2lnbihuKSAqIHNxcnQoeCAqIHggKyBmeSAqIGZ5KTtcbiAgICAgICAgICAgIHJldHVybiBbYXRhbjIoeCwgYWJzKGZ5KSkgLyBuICogc2lnbihmeSksIDIgKiBhdGFuKHBvdyhmIC8gciwgMSAvIG4pKSAtIGhhbGZQaV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcm9qZWN0O1xuICAgIH1cbiAgICB2YXIgY29uaWNDb25mb3JtYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb25pY1Byb2plY3Rpb24oY29uaWNDb25mb3JtYWxSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTA5LjUpXG4gICAgICAgICAgICAucGFyYWxsZWxzKFszMCwgMzBdKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGVxdWlyZWN0YW5ndWxhclJhdyhsYW1iZGEsIHBoaSkge1xuICAgICAgICByZXR1cm4gW2xhbWJkYSwgcGhpXTtcbiAgICB9XG4gICAgZXF1aXJlY3Rhbmd1bGFyUmF3LmludmVydCA9IGVxdWlyZWN0YW5ndWxhclJhdztcbiAgICB2YXIgZXF1aXJlY3Rhbmd1bGFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvamVjdGlvbihlcXVpcmVjdGFuZ3VsYXJSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMTUyLjYzKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNvbmljRXF1aWRpc3RhbnRSYXcoeTAsIHkxKSB7XG4gICAgICAgIHZhciBjeTAgPSBjb3MoeTApLCBuID0geTAgPT09IHkxID8gc2luKHkwKSA6IChjeTAgLSBjb3MoeTEpKSAvICh5MSAtIHkwKSwgZyA9IGN5MCAvIG4gKyB5MDtcbiAgICAgICAgaWYgKGFicyhuKSA8IGVwc2lsb24pXG4gICAgICAgICAgICByZXR1cm4gZXF1aXJlY3Rhbmd1bGFyUmF3O1xuICAgICAgICBmdW5jdGlvbiBwcm9qZWN0KHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBneSA9IGcgLSB5LCBueCA9IG4gKiB4O1xuICAgICAgICAgICAgcmV0dXJuIFtneSAqIHNpbihueCksIGcgLSBneSAqIGNvcyhueCldO1xuICAgICAgICB9XG4gICAgICAgIHByb2plY3QuaW52ZXJ0ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHZhciBneSA9IGcgLSB5O1xuICAgICAgICAgICAgcmV0dXJuIFthdGFuMih4LCBhYnMoZ3kpKSAvIG4gKiBzaWduKGd5KSwgZyAtIHNpZ24obikgKiBzcXJ0KHggKiB4ICsgZ3kgKiBneSldO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcHJvamVjdDtcbiAgICB9XG4gICAgdmFyIGNvbmljRXF1aWRpc3RhbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb25pY1Byb2plY3Rpb24oY29uaWNFcXVpZGlzdGFudFJhdylcbiAgICAgICAgICAgIC5zY2FsZSgxMzEuMTU0KVxuICAgICAgICAgICAgLmNlbnRlcihbMCwgMTMuOTM4OV0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ25vbW9uaWNSYXcoeCwgeSkge1xuICAgICAgICB2YXIgY3kgPSBjb3MoeSksIGsgPSBjb3MoeCkgKiBjeTtcbiAgICAgICAgcmV0dXJuIFtjeSAqIHNpbih4KSAvIGssIHNpbih5KSAvIGtdO1xuICAgIH1cbiAgICBnbm9tb25pY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoYXRhbik7XG4gICAgdmFyIGdub21vbmljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvamVjdGlvbihnbm9tb25pY1JhdylcbiAgICAgICAgICAgIC5zY2FsZSgxNDQuMDQ5KVxuICAgICAgICAgICAgLmNsaXBBbmdsZSg2MCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZShreCwga3ksIHR4LCB0eSkge1xuICAgICAgICByZXR1cm4ga3ggPT09IDEgJiYga3kgPT09IDEgJiYgdHggPT09IDAgJiYgdHkgPT09IDAgPyBpZGVudGl0eSA6IHRyYW5zZm9ybWVyKHtcbiAgICAgICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBvaW50KHggKiBreCArIHR4LCB5ICoga3kgKyB0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgaWRlbnRpdHkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGsgPSAxLCB0eCA9IDAsIHR5ID0gMCwgc3ggPSAxLCBzeSA9IDEsIHRyYW5zZm9ybSA9IGlkZW50aXR5LCAvLyBzY2FsZSwgdHJhbnNsYXRlIGFuZCByZWZsZWN0XG4gICAgICAgIHgwID0gbnVsbCwgeTAsIHgxLCB5MSwgY2xpcCA9IGlkZW50aXR5LCAvLyBjbGlwIGV4dGVudFxuICAgICAgICBjYWNoZSwgY2FjaGVTdHJlYW0sIHByb2plY3Rpb247XG4gICAgICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvamVjdGlvbiA9IHtcbiAgICAgICAgICAgIHN0cmVhbTogZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IHRyYW5zZm9ybShjbGlwKGNhY2hlU3RyZWFtID0gc3RyZWFtKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xpcEV4dGVudDogZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjbGlwID0gXyA9PSBudWxsID8gKHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCwgaWRlbnRpdHkpIDogY2xpcEV4dGVudCh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKSwgcmVzZXQoKSkgOiB4MCA9PSBudWxsID8gbnVsbCA6IFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjYWxlOiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zZm9ybSA9IHNjYWxlVHJhbnNsYXRlKChrID0gK18pICogc3gsIGsgKiBzeSwgdHgsIHR5KSwgcmVzZXQoKSkgOiBrO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2Zvcm0gPSBzY2FsZVRyYW5zbGF0ZShrICogc3gsIGsgKiBzeSwgdHggPSArX1swXSwgdHkgPSArX1sxXSksIHJlc2V0KCkpIDogW3R4LCB0eV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVmbGVjdFg6IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtID0gc2NhbGVUcmFuc2xhdGUoayAqIChzeCA9IF8gPyAtMSA6IDEpLCBrICogc3ksIHR4LCB0eSksIHJlc2V0KCkpIDogc3ggPCAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZmxlY3RZOiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zZm9ybSA9IHNjYWxlVHJhbnNsYXRlKGsgKiBzeCwgayAqIChzeSA9IF8gPyAtMSA6IDEpLCB0eCwgdHkpLCByZXNldCgpKSA6IHN5IDwgMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaXRFeHRlbnQ6IGZ1bmN0aW9uIChleHRlbnQsIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaXRFeHRlbnQocHJvamVjdGlvbiwgZXh0ZW50LCBvYmplY3QpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdFNpemU6IGZ1bmN0aW9uIChzaXplLCBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml0U2l6ZShwcm9qZWN0aW9uLCBzaXplLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgZnVuY3Rpb24gb3J0aG9ncmFwaGljUmF3KHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIFtjb3MoeSkgKiBzaW4oeCksIHNpbih5KV07XG4gICAgfVxuICAgIG9ydGhvZ3JhcGhpY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoYXNpbik7XG4gICAgdmFyIG9ydGhvZ3JhcGhpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb2plY3Rpb24ob3J0aG9ncmFwaGljUmF3KVxuICAgICAgICAgICAgLnNjYWxlKDI0OS41KVxuICAgICAgICAgICAgLmNsaXBBbmdsZSg5MCArIGVwc2lsb24pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gc3RlcmVvZ3JhcGhpY1Jhdyh4LCB5KSB7XG4gICAgICAgIHZhciBjeSA9IGNvcyh5KSwgayA9IDEgKyBjb3MoeCkgKiBjeTtcbiAgICAgICAgcmV0dXJuIFtjeSAqIHNpbih4KSAvIGssIHNpbih5KSAvIGtdO1xuICAgIH1cbiAgICBzdGVyZW9ncmFwaGljUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbiAoeikge1xuICAgICAgICByZXR1cm4gMiAqIGF0YW4oeik7XG4gICAgfSk7XG4gICAgdmFyIHN0ZXJlb2dyYXBoaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm9qZWN0aW9uKHN0ZXJlb2dyYXBoaWNSYXcpXG4gICAgICAgICAgICAuc2NhbGUoMjUwKVxuICAgICAgICAgICAgLmNsaXBBbmdsZSgxNDIpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdHJhbnN2ZXJzZU1lcmNhdG9yUmF3KGxhbWJkYSwgcGhpKSB7XG4gICAgICAgIHJldHVybiBbbG9nKHRhbigoaGFsZlBpICsgcGhpKSAvIDIpKSwgLWxhbWJkYV07XG4gICAgfVxuICAgIHRyYW5zdmVyc2VNZXJjYXRvclJhdy5pbnZlcnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4gWy15LCAyICogYXRhbihleHAoeCkpIC0gaGFsZlBpXTtcbiAgICB9O1xuICAgIHZhciB0cmFuc3ZlcnNlTWVyY2F0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gbWVyY2F0b3JQcm9qZWN0aW9uKHRyYW5zdmVyc2VNZXJjYXRvclJhdyksIGNlbnRlciA9IG0uY2VudGVyLCByb3RhdGUgPSBtLnJvdGF0ZTtcbiAgICAgICAgbS5jZW50ZXIgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjZW50ZXIoWy1fWzFdLCBfWzBdXSkgOiAoXyA9IGNlbnRlcigpLCBbX1sxXSwgLV9bMF1dKTtcbiAgICAgICAgfTtcbiAgICAgICAgbS5yb3RhdGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByb3RhdGUoW19bMF0sIF9bMV0sIF8ubGVuZ3RoID4gMiA/IF9bMl0gKyA5MCA6IDkwXSkgOiAoXyA9IHJvdGF0ZSgpLCBbX1swXSwgX1sxXSwgX1syXSAtIDkwXSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByb3RhdGUoWzAsIDAsIDkwXSlcbiAgICAgICAgICAgIC5zY2FsZSgxNTkuMTU1KTtcbiAgICB9O1xuICAgIGV4cG9ydHMuZ2VvQXJlYSA9IGFyZWE7XG4gICAgZXhwb3J0cy5nZW9Cb3VuZHMgPSBib3VuZHM7XG4gICAgZXhwb3J0cy5nZW9DZW50cm9pZCA9IGNlbnRyb2lkO1xuICAgIGV4cG9ydHMuZ2VvQ2lyY2xlID0gY2lyY2xlO1xuICAgIGV4cG9ydHMuZ2VvQ2xpcEV4dGVudCA9IGV4dGVudDtcbiAgICBleHBvcnRzLmdlb0NvbnRhaW5zID0gY29udGFpbnM7XG4gICAgZXhwb3J0cy5nZW9EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIGV4cG9ydHMuZ2VvR3JhdGljdWxlID0gZ3JhdGljdWxlO1xuICAgIGV4cG9ydHMuZ2VvR3JhdGljdWxlMTAgPSBncmF0aWN1bGUxMDtcbiAgICBleHBvcnRzLmdlb0ludGVycG9sYXRlID0gaW50ZXJwb2xhdGU7XG4gICAgZXhwb3J0cy5nZW9MZW5ndGggPSBsZW5ndGg7XG4gICAgZXhwb3J0cy5nZW9QYXRoID0gaW5kZXg7XG4gICAgZXhwb3J0cy5nZW9BbGJlcnMgPSBhbGJlcnM7XG4gICAgZXhwb3J0cy5nZW9BbGJlcnNVc2EgPSBhbGJlcnNVc2E7XG4gICAgZXhwb3J0cy5nZW9BemltdXRoYWxFcXVhbEFyZWEgPSBhemltdXRoYWxFcXVhbEFyZWE7XG4gICAgZXhwb3J0cy5nZW9BemltdXRoYWxFcXVhbEFyZWFSYXcgPSBhemltdXRoYWxFcXVhbEFyZWFSYXc7XG4gICAgZXhwb3J0cy5nZW9BemltdXRoYWxFcXVpZGlzdGFudCA9IGF6aW11dGhhbEVxdWlkaXN0YW50O1xuICAgIGV4cG9ydHMuZ2VvQXppbXV0aGFsRXF1aWRpc3RhbnRSYXcgPSBhemltdXRoYWxFcXVpZGlzdGFudFJhdztcbiAgICBleHBvcnRzLmdlb0NvbmljQ29uZm9ybWFsID0gY29uaWNDb25mb3JtYWw7XG4gICAgZXhwb3J0cy5nZW9Db25pY0NvbmZvcm1hbFJhdyA9IGNvbmljQ29uZm9ybWFsUmF3O1xuICAgIGV4cG9ydHMuZ2VvQ29uaWNFcXVhbEFyZWEgPSBjb25pY0VxdWFsQXJlYTtcbiAgICBleHBvcnRzLmdlb0NvbmljRXF1YWxBcmVhUmF3ID0gY29uaWNFcXVhbEFyZWFSYXc7XG4gICAgZXhwb3J0cy5nZW9Db25pY0VxdWlkaXN0YW50ID0gY29uaWNFcXVpZGlzdGFudDtcbiAgICBleHBvcnRzLmdlb0NvbmljRXF1aWRpc3RhbnRSYXcgPSBjb25pY0VxdWlkaXN0YW50UmF3O1xuICAgIGV4cG9ydHMuZ2VvRXF1aXJlY3Rhbmd1bGFyID0gZXF1aXJlY3Rhbmd1bGFyO1xuICAgIGV4cG9ydHMuZ2VvRXF1aXJlY3Rhbmd1bGFyUmF3ID0gZXF1aXJlY3Rhbmd1bGFyUmF3O1xuICAgIGV4cG9ydHMuZ2VvR25vbW9uaWMgPSBnbm9tb25pYztcbiAgICBleHBvcnRzLmdlb0dub21vbmljUmF3ID0gZ25vbW9uaWNSYXc7XG4gICAgZXhwb3J0cy5nZW9JZGVudGl0eSA9IGlkZW50aXR5JDE7XG4gICAgZXhwb3J0cy5nZW9Qcm9qZWN0aW9uID0gcHJvamVjdGlvbjtcbiAgICBleHBvcnRzLmdlb1Byb2plY3Rpb25NdXRhdG9yID0gcHJvamVjdGlvbk11dGF0b3I7XG4gICAgZXhwb3J0cy5nZW9NZXJjYXRvciA9IG1lcmNhdG9yO1xuICAgIGV4cG9ydHMuZ2VvTWVyY2F0b3JSYXcgPSBtZXJjYXRvclJhdztcbiAgICBleHBvcnRzLmdlb09ydGhvZ3JhcGhpYyA9IG9ydGhvZ3JhcGhpYztcbiAgICBleHBvcnRzLmdlb09ydGhvZ3JhcGhpY1JhdyA9IG9ydGhvZ3JhcGhpY1JhdztcbiAgICBleHBvcnRzLmdlb1N0ZXJlb2dyYXBoaWMgPSBzdGVyZW9ncmFwaGljO1xuICAgIGV4cG9ydHMuZ2VvU3RlcmVvZ3JhcGhpY1JhdyA9IHN0ZXJlb2dyYXBoaWNSYXc7XG4gICAgZXhwb3J0cy5nZW9UcmFuc3ZlcnNlTWVyY2F0b3IgPSB0cmFuc3ZlcnNlTWVyY2F0b3I7XG4gICAgZXhwb3J0cy5nZW9UcmFuc3ZlcnNlTWVyY2F0b3JSYXcgPSB0cmFuc3ZlcnNlTWVyY2F0b3JSYXc7XG4gICAgZXhwb3J0cy5nZW9Sb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIGV4cG9ydHMuZ2VvU3RyZWFtID0gZ2VvU3RyZWFtO1xuICAgIGV4cG9ydHMuZ2VvVHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59KSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1oZXhqc29uQDEuMS4wQGQzLWhleGpzb24vYnVpbGQvZDMtaGV4anNvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2QzLWhleGpzb25AMS4xLjBAZDMtaGV4anNvbi9idWlsZC9kMy1oZXhqc29uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgICB0cnVlID8gZmFjdG9yeShleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1hcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1hcnJheUAxLjIuNEBkMy1hcnJheS9kaXN0L2QzLWFycmF5LmpzXCIpKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGQzQXJyYXkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gTWFpbiByZW5kZXIgbWV0aG9kXG4gICAgZnVuY3Rpb24gcmVuZGVySGV4SlNPTihoZXhqc29uLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIC8vIEdldCB0aGUgbGF5b3V0XG4gICAgICAgIHZhciBsYXlvdXQgPSBoZXhqc29uLmxheW91dDtcbiAgICAgICAgLy8gR2V0IHRoZSBoZXggb2JqZWN0cyBhcyBhbiBhcnJheVxuICAgICAgICB2YXIgaGV4ZXMgPSBbXTtcbiAgICAgICAgdmFyIGhleFJhZGl1cyA9IDA7XG4gICAgICAgIE9iamVjdC5rZXlzKGhleGpzb24uaGV4ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaGV4anNvbi5oZXhlc1trZXldLmtleSA9IGtleTtcbiAgICAgICAgICAgIGhleGVzLnB1c2goaGV4anNvbi5oZXhlc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnNcbiAgICAgICAgdmFyIHFtYXggPSBkM0FycmF5Lm1heChoZXhlcywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuICtkLnE7IH0pLCBxbWluID0gZDNBcnJheS5taW4oaGV4ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiArZC5xOyB9KSwgcm1heCA9IGQzQXJyYXkubWF4KGhleGVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gK2QucjsgfSksIHJtaW4gPSBkM0FycmF5Lm1pbihoZXhlcywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuICtkLnI7IH0pO1xuICAgICAgICB2YXIgcW51bSA9IHFtYXggLSBxbWluICsgMSwgcm51bSA9IHJtYXggLSBybWluICsgMTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1heGltdW0gcmFkaXVzIHRoZSBoZXhhZ29ucyBjYW4gaGF2ZSB0byBmaXQgdGhlIHN2Z1xuICAgICAgICBpZiAobGF5b3V0ID09PSBcIm9kZC1yXCIgfHwgbGF5b3V0ID09PSBcImV2ZW4tclwiKSB7XG4gICAgICAgICAgICBoZXhSYWRpdXMgPSBkM0FycmF5Lm1pbihbKHdpZHRoKSAvICgocW51bSArIDAuNSkgKiBNYXRoLnNxcnQoMykpLFxuICAgICAgICAgICAgICAgIGhlaWdodCAvICgocm51bSArIDEgLyAzKSAqIDEuNSldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhleFJhZGl1cyA9IGQzQXJyYXkubWluKFsoaGVpZ2h0KSAvICgocm51bSArIDAuNSkgKiBNYXRoLnNxcnQoMykpLFxuICAgICAgICAgICAgICAgIHdpZHRoIC8gKChxbnVtICsgMSAvIDMpICogMS41KV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgaGV4YWdvbiB3aWR0aFxuICAgICAgICB2YXIgaGV4V2lkdGggPSBoZXhSYWRpdXMgKiBNYXRoLnNxcnQoMyk7XG4gICAgICAgIC8vIEdldCB0aGUgdmVydGljZXMgYW5kIHBvaW50cyBmb3IgdGhpcyBsYXlvdXRcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2V0VmVydGljZXMobGF5b3V0LCBoZXhXaWR0aCwgaGV4UmFkaXVzKTtcbiAgICAgICAgdmFyIHBvaW50cyA9IGdldFBvaW50cyh2ZXJ0aWNlcyk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdmFsdWVzIG5lZWRlZCB0byByZW5kZXIgZWFjaCBoZXggYW5kIGFkZCB0byBoZXhlc1xuICAgICAgICBoZXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChoZXgpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgY28tb3JkaW5hdGVzIG9mIGVhY2ggaGV4XG4gICAgICAgICAgICBoZXgucWMgPSBoZXgucSAtIHFtaW47XG4gICAgICAgICAgICBoZXgucmMgPSBybWF4IC0gaGV4LnI7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHggYW5kIHkgcG9zaXRpb24gb2YgZWFjaCBoZXggZm9yIHRoaXMgc3ZnXG4gICAgICAgICAgICBoZXgueCA9IGdldFgoaGV4LCBsYXlvdXQsIGhleFdpZHRoLCBoZXhSYWRpdXMpO1xuICAgICAgICAgICAgaGV4LnkgPSBnZXRZKGhleCwgbGF5b3V0LCBoZXhXaWR0aCwgaGV4UmFkaXVzKTtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgdmVydGV4IHBvc2l0aW9ucyBhbmQgcG9pbnRzIHJlbGF0aXZlIHRvIHggYW5kIHlcbiAgICAgICAgICAgIGhleC52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuICAgICAgICAgICAgaGV4LnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoZXhlcztcbiAgICB9XG4gICAgLy8gR2V0IHRoZSB4IHBvc2l0aW9uIGZvciBhIGhleFxuICAgIGZ1bmN0aW9uIGdldFgoaGV4LCBsYXlvdXQsIGhleFdpZHRoLCBoZXhSYWRpdXMpIHtcbiAgICAgICAgdmFyIHggPSAwLCB4T2Zmc2V0ID0gMDtcbiAgICAgICAgc3dpdGNoIChsYXlvdXQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJvZGQtclwiOlxuICAgICAgICAgICAgICAgIHhPZmZzZXQgPSAoaGV4LnJjICUgMiA9PT0gMSkgPyBoZXhXaWR0aCA6IChoZXhXaWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgIHggPSAoaGV4LnFjICogaGV4V2lkdGgpICsgeE9mZnNldDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJldmVuLXJcIjpcbiAgICAgICAgICAgICAgICB4T2Zmc2V0ID0gKGhleC5yYyAlIDIgPT09IDApID8gaGV4V2lkdGggOiAoaGV4V2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICB4ID0gKGhleC5xYyAqIGhleFdpZHRoKSArIHhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib2RkLXFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJldmVuLXFcIjpcbiAgICAgICAgICAgICAgICB4ID0gKGhleC5xYyAqIGhleFJhZGl1cyAqIDEuNSkgKyBoZXhSYWRpdXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgeSBwb3NpdGlvbiBmb3IgYSBoZXhcbiAgICBmdW5jdGlvbiBnZXRZKGhleCwgbGF5b3V0LCBoZXhXaWR0aCwgaGV4UmFkaXVzKSB7XG4gICAgICAgIHZhciB5ID0gMCwgeU9mZnNldCA9IDA7XG4gICAgICAgIHN3aXRjaCAobGF5b3V0KSB7XG4gICAgICAgICAgICBjYXNlIFwib2RkLXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJldmVuLXJcIjpcbiAgICAgICAgICAgICAgICB5ID0gKGhleC5yYyAqIGhleFJhZGl1cyAqIDEuNSkgKyBoZXhSYWRpdXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib2RkLXFcIjpcbiAgICAgICAgICAgICAgICB5T2Zmc2V0ID0gKGhleC5xYyAlIDIgPT09IDEpID8gaGV4V2lkdGggOiAoaGV4V2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICB5ID0gKGhleC5yYyAqIGhleFdpZHRoKSArIHlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXZlbi1xXCI6XG4gICAgICAgICAgICAgICAgeU9mZnNldCA9IChoZXgucWMgJSAyID09PSAwKSA/IGhleFdpZHRoIDogKGhleFdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgeSA9IChoZXgucmMgKiBoZXhXaWR0aCkgKyB5T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIHBvc2l0aW9ucyBvZiB0aGUgdmVydGljZXMgZm9yIHRoZSBoZXg6XG4gICAgLy8gLSBSb3cgbGF5b3V0cyBhcmUgb3JkZXJlZCBmcm9tIHRoZSB0b3Btb3N0IHZlcnRleCBjbG9ja3dpc2VcbiAgICAvLyAtIENvbHVtbiBsYXlvdXRzIGFyZSBvcmRlcmVkIGZyb20gdGhlIGxlZnRtb3N0IHZlcnRleCBjbG9ja3dpc2VcbiAgICBmdW5jdGlvbiBnZXRWZXJ0aWNlcyhsYXlvdXQsIGhleFdpZHRoLCBoZXhSYWRpdXMpIHtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gW107XG4gICAgICAgIHN3aXRjaCAobGF5b3V0KSB7XG4gICAgICAgICAgICBjYXNlIFwib2RkLXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJldmVuLXJcIjpcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHsgeDogMCwgeTogKDAgLSBoZXhSYWRpdXMpIH0pO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goeyB4OiAoMCArIGhleFdpZHRoICogMC41KSwgeTogKDAgLSAwLjUgKiBoZXhSYWRpdXMpIH0pO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goeyB4OiAoMCArIGhleFdpZHRoICogMC41KSwgeTogKDAgKyAwLjUgKiBoZXhSYWRpdXMpIH0pO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goeyB4OiAwLCB5OiAoMCArIGhleFJhZGl1cykgfSk7XG4gICAgICAgICAgICAgICAgdmVydGljZXMucHVzaCh7IHg6ICgwIC0gaGV4V2lkdGggKiAwLjUpLCB5OiAoMCArIDAuNSAqIGhleFJhZGl1cykgfSk7XG4gICAgICAgICAgICAgICAgdmVydGljZXMucHVzaCh7IHg6ICgwIC0gaGV4V2lkdGggKiAwLjUpLCB5OiAoMCAtIDAuNSAqIGhleFJhZGl1cykgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib2RkLXFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJldmVuLXFcIjpcbiAgICAgICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHsgeDogKDAgLSBoZXhSYWRpdXMpLCB5OiAwIH0pO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goeyB4OiAoMCAtIDAuNSAqIGhleFJhZGl1cyksIHk6ICgwIC0gaGV4V2lkdGggKiAwLjUpIH0pO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goeyB4OiAoMCArIDAuNSAqIGhleFJhZGl1cyksIHk6ICgwIC0gaGV4V2lkdGggKiAwLjUpIH0pO1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goeyB4OiAoMCArIGhleFJhZGl1cyksIHk6IDAgfSk7XG4gICAgICAgICAgICAgICAgdmVydGljZXMucHVzaCh7IHg6ICgwICsgMC41ICogaGV4UmFkaXVzKSwgeTogKDAgKyBoZXhXaWR0aCAqIDAuNSkgfSk7XG4gICAgICAgICAgICAgICAgdmVydGljZXMucHVzaCh7IHg6ICgwIC0gMC41ICogaGV4UmFkaXVzKSwgeTogKDAgKyBoZXhXaWR0aCAqIDAuNSkgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlcnRpY2VzO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIHBvaW50cyBhdHRyaWJ1dGUgZm9yIGEgcG9seWdvbiB3aXRoIHRoZXNlIHZlcnRpY2VzXG4gICAgZnVuY3Rpb24gZ2V0UG9pbnRzKHZlcnRpY2VzKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBcIlwiO1xuICAgICAgICB2ZXJ0aWNlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHBvaW50cyArPSB2LnggKyBcIixcIiArIHYueSArIFwiIFwiOyB9KTtcbiAgICAgICAgcmV0dXJuIHBvaW50cy5zdWJzdHJpbmcoMCwgcG9pbnRzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICAvLyBDcmVhdGVzIGEgaGV4anNvbiBncmlkIHdpdGggdGhlIGxheW91dCBhbmQgZGltZW5zaW9ucyBvZiB0aGUgZ2l2ZW4gaGV4anNvblxuICAgIGZ1bmN0aW9uIGdldEdyaWRGb3JIZXhKU09OKGhleGpzb24pIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IEhleEpTT04gb2JqZWN0IGZvciB0aGUgZ3JpZFxuICAgICAgICB2YXIgZ3JpZCA9IHt9O1xuICAgICAgICBncmlkLmxheW91dCA9IGhleGpzb24ubGF5b3V0O1xuICAgICAgICBncmlkLmhleGVzID0ge307XG4gICAgICAgIC8vIEdldCB0aGUgaGV4IG9iamVjdHMgZnJvbSB0aGUgaGV4anNvbiBhcyBhbiBhcnJheVxuICAgICAgICB2YXIgaGV4ZXMgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXMoaGV4anNvbi5oZXhlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBoZXhlcy5wdXNoKGhleGpzb24uaGV4ZXNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIGluIHRoZSBncmlkXG4gICAgICAgIHZhciBxbWF4ID0gZDNBcnJheS5tYXgoaGV4ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiArZC5xOyB9KSwgcW1pbiA9IGQzQXJyYXkubWluKGhleGVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gK2QucTsgfSksIHJtYXggPSBkM0FycmF5Lm1heChoZXhlcywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuICtkLnI7IH0pLCBybWluID0gZDNBcnJheS5taW4oaGV4ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiArZC5yOyB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBoZXhqc29uIGdyaWRcbiAgICAgICAgdmFyIGksIGosIGZrZXk7XG4gICAgICAgIGZvciAoaSA9IHFtaW47IGkgPD0gcW1heDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGogPSBybWluOyBqIDw9IHJtYXg7IGorKykge1xuICAgICAgICAgICAgICAgIGZrZXkgPSBcIlFcIiArIGkgKyBcIlJcIiArIGo7XG4gICAgICAgICAgICAgICAgZ3JpZC5oZXhlc1tma2V5XSA9IHsgcTogaSwgcjogaiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmlkO1xuICAgIH1cbiAgICAvLyBDcmVhdGVzIGEgbGlzdCBvZiBkb3RzIGFsb25nIHRoZSBib3VuZGFyaWVzIGJldHdlZW5cbiAgICAvLyBoZXhlcyB3aGljaCBoYXZlIGRpZmZlcmVudCB2YWx1ZXMgb2YgXCJmaWVsZFwiXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRhcnlEb3RzRm9ySGV4SlNPTihoZXhqc29uLCB3aWR0aCwgaGVpZ2h0LCBmaWVsZCkge1xuICAgICAgICAvLyBHZXQgdGhlIGhleCBvYmplY3RzIGZyb20gdGhlIGhleGpzb24gYXMgYW4gYXJyYXlcbiAgICAgICAgdmFyIGhleGVzID0gW107XG4gICAgICAgIHZhciBsYXlvdXQgPSBoZXhqc29uLmxheW91dDtcbiAgICAgICAgT2JqZWN0LmtleXMoaGV4anNvbi5oZXhlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBoZXhlcy5wdXNoKGhleGpzb24uaGV4ZXNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zXG4gICAgICAgIHZhciBxbWF4ID0gZDNBcnJheS5tYXgoaGV4ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiArZC5xOyB9KSwgcW1pbiA9IGQzQXJyYXkubWluKGhleGVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gK2QucTsgfSksIHJtYXggPSBkM0FycmF5Lm1heChoZXhlcywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuICtkLnI7IH0pLCBybWluID0gZDNBcnJheS5taW4oaGV4ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiArZC5yOyB9KTtcbiAgICAgICAgdmFyIHFudW0gPSBxbWF4IC0gcW1pbiArIDEsIHJudW0gPSBybWF4IC0gcm1pbiArIDE7XG4gICAgICAgIHZhciBoZXhSYWRpdXM7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBtYXhpbXVtIHJhZGl1cyB0aGUgaGV4YWdvbnMgY2FuIGhhdmUgdG8gZml0IHRoZSBzdmdcbiAgICAgICAgaWYgKGxheW91dCA9PT0gXCJvZGQtclwiIHx8IGxheW91dCA9PT0gXCJldmVuLXJcIikge1xuICAgICAgICAgICAgaGV4UmFkaXVzID0gZDNBcnJheS5taW4oWyh3aWR0aCkgLyAoKHFudW0gKyAwLjUpICogTWF0aC5zcXJ0KDMpKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgLyAoKHJudW0gKyAxIC8gMykgKiAxLjUpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZXhSYWRpdXMgPSBkM0FycmF5Lm1pbihbKGhlaWdodCkgLyAoKHJudW0gKyAwLjUpICogTWF0aC5zcXJ0KDMpKSxcbiAgICAgICAgICAgICAgICB3aWR0aCAvICgocW51bSArIDEgLyAzKSAqIDEuNSldKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGhleGFnb24gd2lkdGhcbiAgICAgICAgdmFyIGhleFdpZHRoID0gaGV4UmFkaXVzICogTWF0aC5zcXJ0KDMpO1xuICAgICAgICAvLyBDcmVhdGUgYW4gYXJyYXkgaW50byB3aGljaCB3ZSB3aWxsIHB1dCBwb2ludHMgYWxvbmcgdGhlXG4gICAgICAgIC8vIGJvdW5kYXJpZXMgYmV0d2VlbiBkaWZmZXJpbmcgaGV4ZXMuXG4gICAgICAgIC8vIEVhY2ggZWRnZSBoYXMgZml2ZSBwb2ludHMsIGVxdWFsbHkgc3BhY2VkLlxuICAgICAgICB2YXIgbGluZXMgPSBbXTtcbiAgICAgICAgdmFyIGhleFJhZGl1c1NxdWFyZWQgPSBoZXhSYWRpdXMgKiBoZXhSYWRpdXMgKiA0O1xuICAgICAgICB2YXIgbWF4SGV4ID0gaGV4ZXMubGVuZ3RoO1xuICAgICAgICBpZiAobWF4SGV4ID4gMSkge1xuICAgICAgICAgICAgaGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaGV4KSB7XG4gICAgICAgICAgICAgICAgaGV4LnFjID0gaGV4LnEgLSBxbWluO1xuICAgICAgICAgICAgICAgIGhleC5yYyA9IHJtYXggLSBoZXgucjtcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHggYW5kIHkgcG9zaXRpb24gb2YgZWFjaCBoZXggZm9yIHRoaXMgc3ZnXG4gICAgICAgICAgICAgICAgaGV4LnggPSBnZXRYKGhleCwgbGF5b3V0LCBoZXhXaWR0aCwgaGV4UmFkaXVzKTtcbiAgICAgICAgICAgICAgICBoZXgueSA9IGdldFkoaGV4LCBsYXlvdXQsIGhleFdpZHRoLCBoZXhSYWRpdXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heEhleCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG1heEhleDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZXggPSBoZXhlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVySGV4ID0gaGV4ZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZXhbZmllbGRdICE9PSBvdGhlckhleFtmaWVsZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhoZXgucSAtIG90aGVySGV4LnEpIDw9IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhoZXguciAtIG90aGVySGV4LnIpIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChoZXgueCAtIG90aGVySGV4LngpICogKGhleC54IC0gb3RoZXJIZXgueCkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChoZXgueSAtIG90aGVySGV4LnkpICogKGhleC55IC0gb3RoZXJIZXgueSkpIDwgaGV4UmFkaXVzU3F1YXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5J3JlIG5laWdoYm91cnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pZHBvaW50ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZHBvaW50LnggPSBvdGhlckhleC54ICsgKGhleC54IC0gb3RoZXJIZXgueCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWRwb2ludC55ID0gb3RoZXJIZXgueSArIChoZXgueSAtIG90aGVySGV4LnkpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnAgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbm9tID0gTWF0aC5zcXJ0KDMpICogNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVycC5keCA9IChoZXgueSAtIG90aGVySGV4LnkpIC8gZGVub207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnAuZHkgPSAtKGhleC54IC0gb3RoZXJIZXgueCkgLyBkZW5vbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCh7IHg6IG1pZHBvaW50LnggLSAyICogcGVycC5keCwgeTogbWlkcG9pbnQueSAtIDIgKiBwZXJwLmR5IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHsgeDogbWlkcG9pbnQueCAtIHBlcnAuZHgsIHk6IG1pZHBvaW50LnkgLSBwZXJwLmR5IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHsgeDogbWlkcG9pbnQueCwgeTogbWlkcG9pbnQueSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCh7IHg6IG1pZHBvaW50LnggKyBwZXJwLmR4LCB5OiBtaWRwb2ludC55ICsgcGVycC5keSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCh7IHg6IG1pZHBvaW50LnggKyAyICogcGVycC5keCwgeTogbWlkcG9pbnQueSArIDIgKiBwZXJwLmR5IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIC8vIENyZWF0ZXMgYSBsaXN0IG9mIGxpbmUgc2VnbWVudHMgYWxvbmcgdGhlIGJvdW5kYXJpZXNcbiAgICAvLyBiZXR3ZWVuIGhleGVzIHdoaWNoIGhhdmUgZGlmZmVyZW50IHZhbHVlcyBvZiBcImZpZWxkXCJcbiAgICBmdW5jdGlvbiBnZXRCb3VuZGFyeVNlZ21lbnRzRm9ySGV4SlNPTihoZXhqc29uLCB3aWR0aCwgaGVpZ2h0LCBmaWVsZCkge1xuICAgICAgICAvLyBHZXQgdGhlIGhleCBvYmplY3RzIGZyb20gdGhlIGhleGpzb24gYXMgYW4gYXJyYXlcbiAgICAgICAgdmFyIGhleGVzID0gW107XG4gICAgICAgIHZhciBsYXlvdXQgPSBoZXhqc29uLmxheW91dDtcbiAgICAgICAgT2JqZWN0LmtleXMoaGV4anNvbi5oZXhlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBoZXhlcy5wdXNoKGhleGpzb24uaGV4ZXNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zXG4gICAgICAgIHZhciBxbWF4ID0gZDNBcnJheS5tYXgoaGV4ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiArZC5xOyB9KSwgcW1pbiA9IGQzQXJyYXkubWluKGhleGVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gK2QucTsgfSksIHJtYXggPSBkM0FycmF5Lm1heChoZXhlcywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuICtkLnI7IH0pLCBybWluID0gZDNBcnJheS5taW4oaGV4ZXMsIGZ1bmN0aW9uIChkKSB7IHJldHVybiArZC5yOyB9KTtcbiAgICAgICAgdmFyIHFudW0gPSBxbWF4IC0gcW1pbiArIDEsIHJudW0gPSBybWF4IC0gcm1pbiArIDE7XG4gICAgICAgIHZhciBoZXhSYWRpdXM7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBtYXhpbXVtIHJhZGl1cyB0aGUgaGV4YWdvbnMgY2FuIGhhdmUgdG8gZml0IHRoZSBzdmdcbiAgICAgICAgaWYgKGxheW91dCA9PT0gXCJvZGQtclwiIHx8IGxheW91dCA9PT0gXCJldmVuLXJcIikge1xuICAgICAgICAgICAgaGV4UmFkaXVzID0gZDNBcnJheS5taW4oWyh3aWR0aCkgLyAoKHFudW0gKyAwLjUpICogTWF0aC5zcXJ0KDMpKSxcbiAgICAgICAgICAgICAgICBoZWlnaHQgLyAoKHJudW0gKyAxIC8gMykgKiAxLjUpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZXhSYWRpdXMgPSBkM0FycmF5Lm1pbihbKGhlaWdodCkgLyAoKHJudW0gKyAwLjUpICogTWF0aC5zcXJ0KDMpKSxcbiAgICAgICAgICAgICAgICB3aWR0aCAvICgocW51bSArIDEgLyAzKSAqIDEuNSldKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGhleGFnb24gd2lkdGhcbiAgICAgICAgdmFyIGhleFdpZHRoID0gaGV4UmFkaXVzICogTWF0aC5zcXJ0KDMpO1xuICAgICAgICAvLyBDcmVhdGUgYW4gYXJyYXkgaW50byB3aGljaCB3ZSB3aWxsIHB1dCBwb2ludHMgYWxvbmcgdGhlXG4gICAgICAgIC8vIGJvdW5kYXJpZXMgYmV0d2VlbiBkaWZmZXJpbmcgaGV4ZXMuXG4gICAgICAgIC8vIEVhY2ggc2VnbWVudCB3aWxsIGJlIG9mIHRoZSBmb3JtXG4gICAgICAgIC8vIHt4OiA8c3RhcnQgcG9pbnQgWD4sIHk6IDxzdGFydCBwb2ludCBZPiwgY3g6IDxkaWZmZXJlbmNlIFg+LCBjeTogPGRpZmZlcmVuY2UgWT4gfVxuICAgICAgICAvLyBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGggdGhlIHNpbXBsZSBsaW5lIGRyYXdpbmcgZnVuY3Rpb25hbGl0eSBvZiBkM1xuICAgICAgICAvL1xuICAgICAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgdmFyIGhleFJhZGl1c1NxdWFyZWQgPSBoZXhSYWRpdXMgKiBoZXhSYWRpdXMgKiA0O1xuICAgICAgICB2YXIgbWF4SGV4ID0gaGV4ZXMubGVuZ3RoO1xuICAgICAgICBpZiAobWF4SGV4ID4gMSkge1xuICAgICAgICAgICAgaGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAoaGV4KSB7XG4gICAgICAgICAgICAgICAgaGV4LnFjID0gaGV4LnEgLSBxbWluO1xuICAgICAgICAgICAgICAgIGhleC5yYyA9IHJtYXggLSBoZXgucjtcbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHggYW5kIHkgcG9zaXRpb24gb2YgZWFjaCBoZXggZm9yIHRoaXMgc3ZnXG4gICAgICAgICAgICAgICAgaGV4LnggPSBnZXRYKGhleCwgbGF5b3V0LCBoZXhXaWR0aCwgaGV4UmFkaXVzKTtcbiAgICAgICAgICAgICAgICBoZXgueSA9IGdldFkoaGV4LCBsYXlvdXQsIGhleFdpZHRoLCBoZXhSYWRpdXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heEhleCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG1heEhleDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZXggPSBoZXhlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG90aGVySGV4ID0gaGV4ZXNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZXhbZmllbGRdICE9PSBvdGhlckhleFtmaWVsZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhoZXgucSAtIG90aGVySGV4LnEpIDw9IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhoZXguciAtIG90aGVySGV4LnIpIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKChoZXgueCAtIG90aGVySGV4LngpICogKGhleC54IC0gb3RoZXJIZXgueCkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChoZXgueSAtIG90aGVySGV4LnkpICogKGhleC55IC0gb3RoZXJIZXgueSkpIDwgaGV4UmFkaXVzU3F1YXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5J3JlIG5laWdoYm91cnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pZHBvaW50ID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZHBvaW50LnggPSBvdGhlckhleC54ICsgKGhleC54IC0gb3RoZXJIZXgueCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWRwb2ludC55ID0gb3RoZXJIZXgueSArIChoZXgueSAtIG90aGVySGV4LnkpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlcnAgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9ICsxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGV4W2ZpZWxkXSA8IG90aGVySGV4W2ZpZWxkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gb3RoZXJ3aXNlLCBkaXJlY3Rpb24gd2lsbCBiZSArMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVub20gPSBNYXRoLnNxcnQoMykgKiAyICogZGlyZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJwLmR4ID0gKGhleC55IC0gb3RoZXJIZXgueSkgLyBkZW5vbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVycC5keSA9IC0oaGV4LnggLSBvdGhlckhleC54KSAvIGRlbm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxOiBtaWRwb2ludC54IC0gcGVycC5keCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxOiBtaWRwb2ludC55IC0gcGVycC5keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyOiBtaWRwb2ludC54ICsgcGVycC5keCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyOiBtaWRwb2ludC55ICsgcGVycC5keVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzO1xuICAgIH1cbiAgICBleHBvcnRzLnJlbmRlckhleEpTT04gPSByZW5kZXJIZXhKU09OO1xuICAgIGV4cG9ydHMuZ2V0R3JpZEZvckhleEpTT04gPSBnZXRHcmlkRm9ySGV4SlNPTjtcbiAgICBleHBvcnRzLmdldEJvdW5kYXJ5RG90c0ZvckhleEpTT04gPSBnZXRCb3VuZGFyeURvdHNGb3JIZXhKU09OO1xuICAgIGV4cG9ydHMuZ2V0Qm91bmRhcnlTZWdtZW50c0ZvckhleEpTT04gPSBnZXRCb3VuZGFyeVNlZ21lbnRzRm9ySGV4SlNPTjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1oaWVyYXJjaHlAMS4xLjlAZDMtaGllcmFyY2h5L2Rpc3QvZDMtaGllcmFyY2h5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kMy1oaWVyYXJjaHlAMS4xLjlAZDMtaGllcmFyY2h5L2Rpc3QvZDMtaGllcmFyY2h5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtaGllcmFyY2h5LyB2MS4xLjkgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgICB0cnVlID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgZnVuY3Rpb24gZGVmYXVsdFNlcGFyYXRpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gYS5wYXJlbnQgPT09IGIucGFyZW50ID8gMSA6IDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lYW5YKGNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5yZWR1Y2UobWVhblhSZWR1Y2UsIDApIC8gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZWFuWFJlZHVjZSh4LCBjKSB7XG4gICAgICAgIHJldHVybiB4ICsgYy54O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXhZKGNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVybiAxICsgY2hpbGRyZW4ucmVkdWNlKG1heFlSZWR1Y2UsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXhZUmVkdWNlKHksIGMpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHksIGMueSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxlYWZMZWZ0KG5vZGUpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuO1xuICAgICAgICB3aGlsZSAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKVxuICAgICAgICAgICAgbm9kZSA9IGNoaWxkcmVuWzBdO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGVhZlJpZ2h0KG5vZGUpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuO1xuICAgICAgICB3aGlsZSAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKVxuICAgICAgICAgICAgbm9kZSA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2x1c3RlcigpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRpb24gPSBkZWZhdWx0U2VwYXJhdGlvbiwgZHggPSAxLCBkeSA9IDEsIG5vZGVTaXplID0gZmFsc2U7XG4gICAgICAgIGZ1bmN0aW9uIGNsdXN0ZXIocm9vdCkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzTm9kZSwgeCA9IDA7XG4gICAgICAgICAgICAvLyBGaXJzdCB3YWxrLCBjb21wdXRpbmcgdGhlIGluaXRpYWwgeCAmIHkgdmFsdWVzLlxuICAgICAgICAgICAgcm9vdC5lYWNoQWZ0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnggPSBtZWFuWChjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUueSA9IG1heFkoY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS54ID0gcHJldmlvdXNOb2RlID8geCArPSBzZXBhcmF0aW9uKG5vZGUsIHByZXZpb3VzTm9kZSkgOiAwO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c05vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGxlZnQgPSBsZWFmTGVmdChyb290KSwgcmlnaHQgPSBsZWFmUmlnaHQocm9vdCksIHgwID0gbGVmdC54IC0gc2VwYXJhdGlvbihsZWZ0LCByaWdodCkgLyAyLCB4MSA9IHJpZ2h0LnggKyBzZXBhcmF0aW9uKHJpZ2h0LCBsZWZ0KSAvIDI7XG4gICAgICAgICAgICAvLyBTZWNvbmQgd2Fsaywgbm9ybWFsaXppbmcgeCAmIHkgdG8gdGhlIGRlc2lyZWQgc2l6ZS5cbiAgICAgICAgICAgIHJldHVybiByb290LmVhY2hBZnRlcihub2RlU2l6ZSA/IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS54ID0gKG5vZGUueCAtIHJvb3QueCkgKiBkeDtcbiAgICAgICAgICAgICAgICBub2RlLnkgPSAocm9vdC55IC0gbm9kZS55KSAqIGR5O1xuICAgICAgICAgICAgfSA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS54ID0gKG5vZGUueCAtIHgwKSAvICh4MSAtIHgwKSAqIGR4O1xuICAgICAgICAgICAgICAgIG5vZGUueSA9ICgxIC0gKHJvb3QueSA/IG5vZGUueSAvIHJvb3QueSA6IDEpKSAqIGR5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2x1c3Rlci5zZXBhcmF0aW9uID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNlcGFyYXRpb24gPSB4LCBjbHVzdGVyKSA6IHNlcGFyYXRpb247XG4gICAgICAgIH07XG4gICAgICAgIGNsdXN0ZXIuc2l6ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IGZhbHNlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBjbHVzdGVyKSA6IChub2RlU2l6ZSA/IG51bGwgOiBbZHgsIGR5XSk7XG4gICAgICAgIH07XG4gICAgICAgIGNsdXN0ZXIubm9kZVNpemUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSB0cnVlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBjbHVzdGVyKSA6IChub2RlU2l6ZSA/IFtkeCwgZHldIDogbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbHVzdGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3VudChub2RlKSB7XG4gICAgICAgIHZhciBzdW0gPSAwLCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4sIGkgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGlmICghaSlcbiAgICAgICAgICAgIHN1bSA9IDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdoaWxlICgtLWkgPj0gMClcbiAgICAgICAgICAgICAgICBzdW0gKz0gY2hpbGRyZW5baV0udmFsdWU7XG4gICAgICAgIG5vZGUudmFsdWUgPSBzdW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVfY291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2hBZnRlcihjb3VudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVfZWFjaChjYWxsYmFjaykge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMsIGN1cnJlbnQsIG5leHQgPSBbbm9kZV0sIGNoaWxkcmVuLCBpLCBuO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dC5yZXZlcnNlKCksIG5leHQgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlID0gY3VycmVudC5wb3AoKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUpLCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG5leHQubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVfZWFjaEJlZm9yZShjYWxsYmFjaykge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdLCBjaGlsZHJlbiwgaTtcbiAgICAgICAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobm9kZSksIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbilcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVfZWFjaEFmdGVyKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcywgbm9kZXMgPSBbbm9kZV0sIG5leHQgPSBbXSwgY2hpbGRyZW4sIGksIG47XG4gICAgICAgIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICAgICAgICAgIG5leHQucHVzaChub2RlKSwgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChub2RlID0gbmV4dC5wb3AoKSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVfc3VtKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2hBZnRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHN1bSA9ICt2YWx1ZShub2RlLmRhdGEpIHx8IDAsIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiwgaSA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgtLWkgPj0gMClcbiAgICAgICAgICAgICAgICBzdW0gKz0gY2hpbGRyZW5baV0udmFsdWU7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gc3VtO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9kZV9zb3J0KGNvbXBhcmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaEJlZm9yZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub2RlX3BhdGgoZW5kKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMsIGFuY2VzdG9yID0gbGVhc3RDb21tb25BbmNlc3RvcihzdGFydCwgZW5kKSwgbm9kZXMgPSBbc3RhcnRdO1xuICAgICAgICB3aGlsZSAoc3RhcnQgIT09IGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0LnBhcmVudDtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoZW5kICE9PSBhbmNlc3Rvcikge1xuICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGssIDAsIGVuZCk7XG4gICAgICAgICAgICBlbmQgPSBlbmQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gbGVhc3RDb21tb25BbmNlc3RvcihhLCBiKSB7XG4gICAgICAgIGlmIChhID09PSBiKVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIHZhciBhTm9kZXMgPSBhLmFuY2VzdG9ycygpLCBiTm9kZXMgPSBiLmFuY2VzdG9ycygpLCBjID0gbnVsbDtcbiAgICAgICAgYSA9IGFOb2Rlcy5wb3AoKTtcbiAgICAgICAgYiA9IGJOb2Rlcy5wb3AoKTtcbiAgICAgICAgd2hpbGUgKGEgPT09IGIpIHtcbiAgICAgICAgICAgIGMgPSBhO1xuICAgICAgICAgICAgYSA9IGFOb2Rlcy5wb3AoKTtcbiAgICAgICAgICAgIGIgPSBiTm9kZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVfYW5jZXN0b3JzKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMsIG5vZGVzID0gW25vZGVdO1xuICAgICAgICB3aGlsZSAobm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9kZV9kZXNjZW5kYW50cygpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9kZV9sZWF2ZXMoKSB7XG4gICAgICAgIHZhciBsZWF2ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5lYWNoQmVmb3JlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBsZWF2ZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsZWF2ZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVfbGlua3MoKSB7XG4gICAgICAgIHZhciByb290ID0gdGhpcywgbGlua3MgPSBbXTtcbiAgICAgICAgcm9vdC5lYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gcm9vdCkgeyAvLyBEb27igJl0IGluY2x1ZGUgdGhlIHJvb3TigJlzIHBhcmVudCwgaWYgYW55LlxuICAgICAgICAgICAgICAgIGxpbmtzLnB1c2goeyBzb3VyY2U6IG5vZGUucGFyZW50LCB0YXJnZXQ6IG5vZGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGlua3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhpZXJhcmNoeShkYXRhLCBjaGlsZHJlbikge1xuICAgICAgICB2YXIgcm9vdCA9IG5ldyBOb2RlKGRhdGEpLCB2YWx1ZWQgPSArZGF0YS52YWx1ZSAmJiAocm9vdC52YWx1ZSA9IGRhdGEudmFsdWUpLCBub2RlLCBub2RlcyA9IFtyb290XSwgY2hpbGQsIGNoaWxkcywgaSwgbjtcbiAgICAgICAgaWYgKGNoaWxkcmVuID09IG51bGwpXG4gICAgICAgICAgICBjaGlsZHJlbiA9IGRlZmF1bHRDaGlsZHJlbjtcbiAgICAgICAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlZClcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gK25vZGUuZGF0YS52YWx1ZTtcbiAgICAgICAgICAgIGlmICgoY2hpbGRzID0gY2hpbGRyZW4obm9kZS5kYXRhKSkgJiYgKG4gPSBjaGlsZHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4gPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2goY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldID0gbmV3IE5vZGUoY2hpbGRzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRlcHRoID0gbm9kZS5kZXB0aCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290LmVhY2hCZWZvcmUoY29tcHV0ZUhlaWdodCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vZGVfY29weSgpIHtcbiAgICAgICAgcmV0dXJuIGhpZXJhcmNoeSh0aGlzKS5lYWNoQmVmb3JlKGNvcHlEYXRhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdENoaWxkcmVuKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuY2hpbGRyZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvcHlEYXRhKG5vZGUpIHtcbiAgICAgICAgbm9kZS5kYXRhID0gbm9kZS5kYXRhLmRhdGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXB1dGVIZWlnaHQobm9kZSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICAgICAgZG9cbiAgICAgICAgICAgIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB3aGlsZSAoKG5vZGUgPSBub2RlLnBhcmVudCkgJiYgKG5vZGUuaGVpZ2h0IDwgKytoZWlnaHQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTm9kZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZGVwdGggPVxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICAgIE5vZGUucHJvdG90eXBlID0gaGllcmFyY2h5LnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IE5vZGUsXG4gICAgICAgIGNvdW50OiBub2RlX2NvdW50LFxuICAgICAgICBlYWNoOiBub2RlX2VhY2gsXG4gICAgICAgIGVhY2hBZnRlcjogbm9kZV9lYWNoQWZ0ZXIsXG4gICAgICAgIGVhY2hCZWZvcmU6IG5vZGVfZWFjaEJlZm9yZSxcbiAgICAgICAgc3VtOiBub2RlX3N1bSxcbiAgICAgICAgc29ydDogbm9kZV9zb3J0LFxuICAgICAgICBwYXRoOiBub2RlX3BhdGgsXG4gICAgICAgIGFuY2VzdG9yczogbm9kZV9hbmNlc3RvcnMsXG4gICAgICAgIGRlc2NlbmRhbnRzOiBub2RlX2Rlc2NlbmRhbnRzLFxuICAgICAgICBsZWF2ZXM6IG5vZGVfbGVhdmVzLFxuICAgICAgICBsaW5rczogbm9kZV9saW5rcyxcbiAgICAgICAgY29weTogbm9kZV9jb3B5XG4gICAgfTtcbiAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gICAgZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xuICAgICAgICB2YXIgbSA9IGFycmF5Lmxlbmd0aCwgdCwgaTtcbiAgICAgICAgd2hpbGUgKG0pIHtcbiAgICAgICAgICAgIGkgPSBNYXRoLnJhbmRvbSgpICogbS0tIHwgMDtcbiAgICAgICAgICAgIHQgPSBhcnJheVttXTtcbiAgICAgICAgICAgIGFycmF5W21dID0gYXJyYXlbaV07XG4gICAgICAgICAgICBhcnJheVtpXSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNsb3NlKGNpcmNsZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBuID0gKGNpcmNsZXMgPSBzaHVmZmxlKHNsaWNlLmNhbGwoY2lyY2xlcykpKS5sZW5ndGgsIEIgPSBbXSwgcCwgZTtcbiAgICAgICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICAgICAgICBwID0gY2lyY2xlc1tpXTtcbiAgICAgICAgICAgIGlmIChlICYmIGVuY2xvc2VzV2VhayhlLCBwKSlcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZSA9IGVuY2xvc2VCYXNpcyhCID0gZXh0ZW5kQmFzaXMoQiwgcCkpLCBpID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0ZW5kQmFzaXMoQiwgcCkge1xuICAgICAgICB2YXIgaSwgajtcbiAgICAgICAgaWYgKGVuY2xvc2VzV2Vha0FsbChwLCBCKSlcbiAgICAgICAgICAgIHJldHVybiBbcF07XG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlIHRoZW4gQiBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVsZW1lbnQuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBCLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoZW5jbG9zZXNOb3QocCwgQltpXSlcbiAgICAgICAgICAgICAgICAmJiBlbmNsb3Nlc1dlYWtBbGwoZW5jbG9zZUJhc2lzMihCW2ldLCBwKSwgQikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW0JbaV0sIHBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGdldCBoZXJlIHRoZW4gQiBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIGVsZW1lbnRzLlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgQi5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgQi5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGlmIChlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbaV0sIEJbal0pLCBwKVxuICAgICAgICAgICAgICAgICAgICAmJiBlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbaV0sIHApLCBCW2pdKVxuICAgICAgICAgICAgICAgICAgICAmJiBlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbal0sIHApLCBCW2ldKVxuICAgICAgICAgICAgICAgICAgICAmJiBlbmNsb3Nlc1dlYWtBbGwoZW5jbG9zZUJhc2lzMyhCW2ldLCBCW2pdLCBwKSwgQikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtCW2ldLCBCW2pdLCBwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUgdGhlbiBzb21ldGhpbmcgaXMgdmVyeSB3cm9uZy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNsb3Nlc05vdChhLCBiKSB7XG4gICAgICAgIHZhciBkciA9IGEuciAtIGIuciwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICAgICAgICByZXR1cm4gZHIgPCAwIHx8IGRyICogZHIgPCBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jbG9zZXNXZWFrKGEsIGIpIHtcbiAgICAgICAgdmFyIGRyID0gYS5yIC0gYi5yICsgMWUtNiwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICAgICAgICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jbG9zZXNXZWFrQWxsKGEsIEIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBCLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIWVuY2xvc2VzV2VhayhhLCBCW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jbG9zZUJhc2lzKEIpIHtcbiAgICAgICAgc3dpdGNoIChCLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gZW5jbG9zZUJhc2lzMShCWzBdKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGVuY2xvc2VCYXNpczIoQlswXSwgQlsxXSk7XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiBlbmNsb3NlQmFzaXMzKEJbMF0sIEJbMV0sIEJbMl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY2xvc2VCYXNpczEoYSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogYS54LFxuICAgICAgICAgICAgeTogYS55LFxuICAgICAgICAgICAgcjogYS5yXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY2xvc2VCYXNpczIoYSwgYikge1xuICAgICAgICB2YXIgeDEgPSBhLngsIHkxID0gYS55LCByMSA9IGEuciwgeDIgPSBiLngsIHkyID0gYi55LCByMiA9IGIuciwgeDIxID0geDIgLSB4MSwgeTIxID0geTIgLSB5MSwgcjIxID0gcjIgLSByMSwgbCA9IE1hdGguc3FydCh4MjEgKiB4MjEgKyB5MjEgKiB5MjEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogKHgxICsgeDIgKyB4MjEgLyBsICogcjIxKSAvIDIsXG4gICAgICAgICAgICB5OiAoeTEgKyB5MiArIHkyMSAvIGwgKiByMjEpIC8gMixcbiAgICAgICAgICAgIHI6IChsICsgcjEgKyByMikgLyAyXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY2xvc2VCYXNpczMoYSwgYiwgYykge1xuICAgICAgICB2YXIgeDEgPSBhLngsIHkxID0gYS55LCByMSA9IGEuciwgeDIgPSBiLngsIHkyID0gYi55LCByMiA9IGIuciwgeDMgPSBjLngsIHkzID0gYy55LCByMyA9IGMuciwgYTIgPSB4MSAtIHgyLCBhMyA9IHgxIC0geDMsIGIyID0geTEgLSB5MiwgYjMgPSB5MSAtIHkzLCBjMiA9IHIyIC0gcjEsIGMzID0gcjMgLSByMSwgZDEgPSB4MSAqIHgxICsgeTEgKiB5MSAtIHIxICogcjEsIGQyID0gZDEgLSB4MiAqIHgyIC0geTIgKiB5MiArIHIyICogcjIsIGQzID0gZDEgLSB4MyAqIHgzIC0geTMgKiB5MyArIHIzICogcjMsIGFiID0gYTMgKiBiMiAtIGEyICogYjMsIHhhID0gKGIyICogZDMgLSBiMyAqIGQyKSAvIChhYiAqIDIpIC0geDEsIHhiID0gKGIzICogYzIgLSBiMiAqIGMzKSAvIGFiLCB5YSA9IChhMyAqIGQyIC0gYTIgKiBkMykgLyAoYWIgKiAyKSAtIHkxLCB5YiA9IChhMiAqIGMzIC0gYTMgKiBjMikgLyBhYiwgQSA9IHhiICogeGIgKyB5YiAqIHliIC0gMSwgQiA9IDIgKiAocjEgKyB4YSAqIHhiICsgeWEgKiB5YiksIEMgPSB4YSAqIHhhICsgeWEgKiB5YSAtIHIxICogcjEsIHIgPSAtKEEgPyAoQiArIE1hdGguc3FydChCICogQiAtIDQgKiBBICogQykpIC8gKDIgKiBBKSA6IEMgLyBCKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHgxICsgeGEgKyB4YiAqIHIsXG4gICAgICAgICAgICB5OiB5MSArIHlhICsgeWIgKiByLFxuICAgICAgICAgICAgcjogclxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwbGFjZShiLCBhLCBjKSB7XG4gICAgICAgIHZhciBkeCA9IGIueCAtIGEueCwgeCwgYTIsIGR5ID0gYi55IC0gYS55LCB5LCBiMiwgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgaWYgKGQyKSB7XG4gICAgICAgICAgICBhMiA9IGEuciArIGMuciwgYTIgKj0gYTI7XG4gICAgICAgICAgICBiMiA9IGIuciArIGMuciwgYjIgKj0gYjI7XG4gICAgICAgICAgICBpZiAoYTIgPiBiMikge1xuICAgICAgICAgICAgICAgIHggPSAoZDIgKyBiMiAtIGEyKSAvICgyICogZDIpO1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgYjIgLyBkMiAtIHggKiB4KSk7XG4gICAgICAgICAgICAgICAgYy54ID0gYi54IC0geCAqIGR4IC0geSAqIGR5O1xuICAgICAgICAgICAgICAgIGMueSA9IGIueSAtIHggKiBkeSArIHkgKiBkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSAoZDIgKyBhMiAtIGIyKSAvICgyICogZDIpO1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgYTIgLyBkMiAtIHggKiB4KSk7XG4gICAgICAgICAgICAgICAgYy54ID0gYS54ICsgeCAqIGR4IC0geSAqIGR5O1xuICAgICAgICAgICAgICAgIGMueSA9IGEueSArIHggKiBkeSArIHkgKiBkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGMueCA9IGEueCArIGMucjtcbiAgICAgICAgICAgIGMueSA9IGEueTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgICAgICAgdmFyIGRyID0gYS5yICsgYi5yIC0gMWUtNiwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICAgICAgICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NvcmUobm9kZSkge1xuICAgICAgICB2YXIgYSA9IG5vZGUuXywgYiA9IG5vZGUubmV4dC5fLCBhYiA9IGEuciArIGIuciwgZHggPSAoYS54ICogYi5yICsgYi54ICogYS5yKSAvIGFiLCBkeSA9IChhLnkgKiBiLnIgKyBiLnkgKiBhLnIpIC8gYWI7XG4gICAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTm9kZSQxKGNpcmNsZSkge1xuICAgICAgICB0aGlzLl8gPSBjaXJjbGU7XG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYWNrRW5jbG9zZShjaXJjbGVzKSB7XG4gICAgICAgIGlmICghKG4gPSBjaXJjbGVzLmxlbmd0aCkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgdmFyIGEsIGIsIGMsIG4sIGFhLCBjYSwgaSwgaiwgaywgc2osIHNrO1xuICAgICAgICAvLyBQbGFjZSB0aGUgZmlyc3QgY2lyY2xlLlxuICAgICAgICBhID0gY2lyY2xlc1swXSwgYS54ID0gMCwgYS55ID0gMDtcbiAgICAgICAgaWYgKCEobiA+IDEpKVxuICAgICAgICAgICAgcmV0dXJuIGEucjtcbiAgICAgICAgLy8gUGxhY2UgdGhlIHNlY29uZCBjaXJjbGUuXG4gICAgICAgIGIgPSBjaXJjbGVzWzFdLCBhLnggPSAtYi5yLCBiLnggPSBhLnIsIGIueSA9IDA7XG4gICAgICAgIGlmICghKG4gPiAyKSlcbiAgICAgICAgICAgIHJldHVybiBhLnIgKyBiLnI7XG4gICAgICAgIC8vIFBsYWNlIHRoZSB0aGlyZCBjaXJjbGUuXG4gICAgICAgIHBsYWNlKGIsIGEsIGMgPSBjaXJjbGVzWzJdKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgZnJvbnQtY2hhaW4gdXNpbmcgdGhlIGZpcnN0IHRocmVlIGNpcmNsZXMgYSwgYiBhbmQgYy5cbiAgICAgICAgYSA9IG5ldyBOb2RlJDEoYSksIGIgPSBuZXcgTm9kZSQxKGIpLCBjID0gbmV3IE5vZGUkMShjKTtcbiAgICAgICAgYS5uZXh0ID0gYy5wcmV2aW91cyA9IGI7XG4gICAgICAgIGIubmV4dCA9IGEucHJldmlvdXMgPSBjO1xuICAgICAgICBjLm5leHQgPSBiLnByZXZpb3VzID0gYTtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBwbGFjZSBlYWNoIHJlbWFpbmluZyBjaXJjbGXigKZcbiAgICAgICAgcGFjazogZm9yIChpID0gMzsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgcGxhY2UoYS5fLCBiLl8sIGMgPSBjaXJjbGVzW2ldKSwgYyA9IG5ldyBOb2RlJDEoYyk7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGludGVyc2VjdGluZyBjaXJjbGUgb24gdGhlIGZyb250LWNoYWluLCBpZiBhbnkuXG4gICAgICAgICAgICAvLyDigJxDbG9zZW5lc3PigJ0gaXMgZGV0ZXJtaW5lZCBieSBsaW5lYXIgZGlzdGFuY2UgYWxvbmcgdGhlIGZyb250LWNoYWluLlxuICAgICAgICAgICAgLy8g4oCcQWhlYWTigJ0gb3Ig4oCcYmVoaW5k4oCdIGlzIGxpa2V3aXNlIGRldGVybWluZWQgYnkgbGluZWFyIGRpc3RhbmNlLlxuICAgICAgICAgICAgaiA9IGIubmV4dCwgayA9IGEucHJldmlvdXMsIHNqID0gYi5fLnIsIHNrID0gYS5fLnI7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKHNqIDw9IHNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGouXywgYy5fKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGosIGEubmV4dCA9IGIsIGIucHJldmlvdXMgPSBhLCAtLWk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBwYWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNqICs9IGouXy5yLCBqID0gai5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoay5fLCBjLl8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gaywgYS5uZXh0ID0gYiwgYi5wcmV2aW91cyA9IGEsIC0taTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHBhY2s7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2sgKz0gay5fLnIsIGsgPSBrLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGogIT09IGsubmV4dCk7XG4gICAgICAgICAgICAvLyBTdWNjZXNzISBJbnNlcnQgdGhlIG5ldyBjaXJjbGUgYyBiZXR3ZWVuIGEgYW5kIGIuXG4gICAgICAgICAgICBjLnByZXZpb3VzID0gYSwgYy5uZXh0ID0gYiwgYS5uZXh0ID0gYi5wcmV2aW91cyA9IGIgPSBjO1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbmV3IGNsb3Nlc3QgY2lyY2xlIHBhaXIgdG8gdGhlIGNlbnRyb2lkLlxuICAgICAgICAgICAgYWEgPSBzY29yZShhKTtcbiAgICAgICAgICAgIHdoaWxlICgoYyA9IGMubmV4dCkgIT09IGIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGNhID0gc2NvcmUoYykpIDwgYWEpIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IGMsIGFhID0gY2E7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IGEubmV4dDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHRoZSBlbmNsb3NpbmcgY2lyY2xlIG9mIHRoZSBmcm9udCBjaGFpbi5cbiAgICAgICAgYSA9IFtiLl9dLCBjID0gYjtcbiAgICAgICAgd2hpbGUgKChjID0gYy5uZXh0KSAhPT0gYilcbiAgICAgICAgICAgIGEucHVzaChjLl8pO1xuICAgICAgICBjID0gZW5jbG9zZShhKTtcbiAgICAgICAgLy8gVHJhbnNsYXRlIHRoZSBjaXJjbGVzIHRvIHB1dCB0aGUgZW5jbG9zaW5nIGNpcmNsZSBhcm91bmQgdGhlIG9yaWdpbi5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSlcbiAgICAgICAgICAgIGEgPSBjaXJjbGVzW2ldLCBhLnggLT0gYy54LCBhLnkgLT0gYy55O1xuICAgICAgICByZXR1cm4gYy5yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaWJsaW5ncyhjaXJjbGVzKSB7XG4gICAgICAgIHBhY2tFbmNsb3NlKGNpcmNsZXMpO1xuICAgICAgICByZXR1cm4gY2lyY2xlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gb3B0aW9uYWwoZikge1xuICAgICAgICByZXR1cm4gZiA9PSBudWxsID8gbnVsbCA6IHJlcXVpcmVkKGYpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXF1aXJlZChmKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZiAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yO1xuICAgICAgICByZXR1cm4gZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uc3RhbnRaZXJvKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRSYWRpdXMoZCkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGQudmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmRleCgpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IG51bGwsIGR4ID0gMSwgZHkgPSAxLCBwYWRkaW5nID0gY29uc3RhbnRaZXJvO1xuICAgICAgICBmdW5jdGlvbiBwYWNrKHJvb3QpIHtcbiAgICAgICAgICAgIHJvb3QueCA9IGR4IC8gMiwgcm9vdC55ID0gZHkgLyAyO1xuICAgICAgICAgICAgaWYgKHJhZGl1cykge1xuICAgICAgICAgICAgICAgIHJvb3QuZWFjaEJlZm9yZShyYWRpdXNMZWFmKHJhZGl1cykpXG4gICAgICAgICAgICAgICAgICAgIC5lYWNoQWZ0ZXIocGFja0NoaWxkcmVuKHBhZGRpbmcsIDAuNSkpXG4gICAgICAgICAgICAgICAgICAgIC5lYWNoQmVmb3JlKHRyYW5zbGF0ZUNoaWxkKDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvb3QuZWFjaEJlZm9yZShyYWRpdXNMZWFmKGRlZmF1bHRSYWRpdXMpKVxuICAgICAgICAgICAgICAgICAgICAuZWFjaEFmdGVyKHBhY2tDaGlsZHJlbihjb25zdGFudFplcm8sIDEpKVxuICAgICAgICAgICAgICAgICAgICAuZWFjaEFmdGVyKHBhY2tDaGlsZHJlbihwYWRkaW5nLCByb290LnIgLyBNYXRoLm1pbihkeCwgZHkpKSlcbiAgICAgICAgICAgICAgICAgICAgLmVhY2hCZWZvcmUodHJhbnNsYXRlQ2hpbGQoTWF0aC5taW4oZHgsIGR5KSAvICgyICogcm9vdC5yKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgcGFjay5yYWRpdXMgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gb3B0aW9uYWwoeCksIHBhY2spIDogcmFkaXVzO1xuICAgICAgICB9O1xuICAgICAgICBwYWNrLnNpemUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZHggPSAreFswXSwgZHkgPSAreFsxXSwgcGFjaykgOiBbZHgsIGR5XTtcbiAgICAgICAgfTtcbiAgICAgICAgcGFjay5wYWRkaW5nID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmcgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgcGFjaykgOiBwYWRkaW5nO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFkaXVzTGVhZihyYWRpdXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBub2RlLnIgPSBNYXRoLm1heCgwLCArcmFkaXVzKG5vZGUpIHx8IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYWNrQ2hpbGRyZW4ocGFkZGluZywgaykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4sIGksIG4gPSBjaGlsZHJlbi5sZW5ndGgsIHIgPSBwYWRkaW5nKG5vZGUpICogayB8fCAwLCBlO1xuICAgICAgICAgICAgICAgIGlmIChyKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baV0uciArPSByO1xuICAgICAgICAgICAgICAgIGUgPSBwYWNrRW5jbG9zZShjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgaWYgKHIpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5yIC09IHI7XG4gICAgICAgICAgICAgICAgbm9kZS5yID0gZSArIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZUNoaWxkKGspIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICBub2RlLnIgKj0gaztcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBub2RlLnggPSBwYXJlbnQueCArIGsgKiBub2RlLng7XG4gICAgICAgICAgICAgICAgbm9kZS55ID0gcGFyZW50LnkgKyBrICogbm9kZS55O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiByb3VuZE5vZGUobm9kZSkge1xuICAgICAgICBub2RlLngwID0gTWF0aC5yb3VuZChub2RlLngwKTtcbiAgICAgICAgbm9kZS55MCA9IE1hdGgucm91bmQobm9kZS55MCk7XG4gICAgICAgIG5vZGUueDEgPSBNYXRoLnJvdW5kKG5vZGUueDEpO1xuICAgICAgICBub2RlLnkxID0gTWF0aC5yb3VuZChub2RlLnkxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJlZW1hcERpY2UocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgICB2YXIgbm9kZXMgPSBwYXJlbnQuY2hpbGRyZW4sIG5vZGUsIGkgPSAtMSwgbiA9IG5vZGVzLmxlbmd0aCwgayA9IHBhcmVudC52YWx1ZSAmJiAoeDEgLSB4MCkgLyBwYXJlbnQudmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUueTAgPSB5MCwgbm9kZS55MSA9IHkxO1xuICAgICAgICAgICAgbm9kZS54MCA9IHgwLCBub2RlLngxID0geDAgKz0gbm9kZS52YWx1ZSAqIGs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGFydGl0aW9uKCkge1xuICAgICAgICB2YXIgZHggPSAxLCBkeSA9IDEsIHBhZGRpbmcgPSAwLCByb3VuZCA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBwYXJ0aXRpb24ocm9vdCkge1xuICAgICAgICAgICAgdmFyIG4gPSByb290LmhlaWdodCArIDE7XG4gICAgICAgICAgICByb290LngwID1cbiAgICAgICAgICAgICAgICByb290LnkwID0gcGFkZGluZztcbiAgICAgICAgICAgIHJvb3QueDEgPSBkeDtcbiAgICAgICAgICAgIHJvb3QueTEgPSBkeSAvIG47XG4gICAgICAgICAgICByb290LmVhY2hCZWZvcmUocG9zaXRpb25Ob2RlKGR5LCBuKSk7XG4gICAgICAgICAgICBpZiAocm91bmQpXG4gICAgICAgICAgICAgICAgcm9vdC5lYWNoQmVmb3JlKHJvdW5kTm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwb3NpdGlvbk5vZGUoZHksIG4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyZWVtYXBEaWNlKG5vZGUsIG5vZGUueDAsIGR5ICogKG5vZGUuZGVwdGggKyAxKSAvIG4sIG5vZGUueDEsIGR5ICogKG5vZGUuZGVwdGggKyAyKSAvIG4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgeDAgPSBub2RlLngwLCB5MCA9IG5vZGUueTAsIHgxID0gbm9kZS54MSAtIHBhZGRpbmcsIHkxID0gbm9kZS55MSAtIHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgaWYgKHgxIDwgeDApXG4gICAgICAgICAgICAgICAgICAgIHgwID0geDEgPSAoeDAgKyB4MSkgLyAyO1xuICAgICAgICAgICAgICAgIGlmICh5MSA8IHkwKVxuICAgICAgICAgICAgICAgICAgICB5MCA9IHkxID0gKHkwICsgeTEpIC8gMjtcbiAgICAgICAgICAgICAgICBub2RlLngwID0geDA7XG4gICAgICAgICAgICAgICAgbm9kZS55MCA9IHkwO1xuICAgICAgICAgICAgICAgIG5vZGUueDEgPSB4MTtcbiAgICAgICAgICAgICAgICBub2RlLnkxID0geTE7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHBhcnRpdGlvbi5yb3VuZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3VuZCA9ICEheCwgcGFydGl0aW9uKSA6IHJvdW5kO1xuICAgICAgICB9O1xuICAgICAgICBwYXJ0aXRpb24uc2l6ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBwYXJ0aXRpb24pIDogW2R4LCBkeV07XG4gICAgICAgIH07XG4gICAgICAgIHBhcnRpdGlvbi5wYWRkaW5nID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmcgPSAreCwgcGFydGl0aW9uKSA6IHBhZGRpbmc7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYXJ0aXRpb247XG4gICAgfVxuICAgIHZhciBrZXlQcmVmaXggPSBcIiRcIiwgLy8gUHJvdGVjdCBhZ2FpbnN0IGtleXMgbGlrZSDigJxfX3Byb3RvX1/igJ0uXG4gICAgcHJlcm9vdCA9IHsgZGVwdGg6IC0xIH0sIGFtYmlndW91cyA9IHt9O1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRJZChkKSB7XG4gICAgICAgIHJldHVybiBkLmlkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyZW50SWQoZCkge1xuICAgICAgICByZXR1cm4gZC5wYXJlbnRJZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyYXRpZnkoKSB7XG4gICAgICAgIHZhciBpZCA9IGRlZmF1bHRJZCwgcGFyZW50SWQgPSBkZWZhdWx0UGFyZW50SWQ7XG4gICAgICAgIGZ1bmN0aW9uIHN0cmF0aWZ5KGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBkLCBpLCBuID0gZGF0YS5sZW5ndGgsIHJvb3QsIHBhcmVudCwgbm9kZSwgbm9kZXMgPSBuZXcgQXJyYXkobiksIG5vZGVJZCwgbm9kZUtleSwgbm9kZUJ5S2V5ID0ge307XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZCA9IGRhdGFbaV0sIG5vZGUgPSBub2Rlc1tpXSA9IG5ldyBOb2RlKGQpO1xuICAgICAgICAgICAgICAgIGlmICgobm9kZUlkID0gaWQoZCwgaSwgZGF0YSkpICE9IG51bGwgJiYgKG5vZGVJZCArPSBcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlS2V5ID0ga2V5UHJlZml4ICsgKG5vZGUuaWQgPSBub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICBub2RlQnlLZXlbbm9kZUtleV0gPSBub2RlS2V5IGluIG5vZGVCeUtleSA/IGFtYmlndW91cyA6IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZUlkID0gcGFyZW50SWQoZGF0YVtpXSwgaSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVJZCA9PSBudWxsIHx8ICEobm9kZUlkICs9IFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgcm9vdHNcIik7XG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gbm9kZUJ5S2V5W2tleVByZWZpeCArIG5vZGVJZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZzogXCIgKyBub2RlSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ID09PSBhbWJpZ3VvdXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbWJpZ3VvdXM6IFwiICsgbm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudC5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4gPSBbbm9kZV07XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm9vdClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyByb290XCIpO1xuICAgICAgICAgICAgcm9vdC5wYXJlbnQgPSBwcmVyb290O1xuICAgICAgICAgICAgcm9vdC5lYWNoQmVmb3JlKGZ1bmN0aW9uIChub2RlKSB7IG5vZGUuZGVwdGggPSBub2RlLnBhcmVudC5kZXB0aCArIDE7IC0tbjsgfSkuZWFjaEJlZm9yZShjb21wdXRlSGVpZ2h0KTtcbiAgICAgICAgICAgIHJvb3QucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChuID4gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjeWNsZVwiKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9XG4gICAgICAgIHN0cmF0aWZ5LmlkID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGlkID0gcmVxdWlyZWQoeCksIHN0cmF0aWZ5KSA6IGlkO1xuICAgICAgICB9O1xuICAgICAgICBzdHJhdGlmeS5wYXJlbnRJZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYXJlbnRJZCA9IHJlcXVpcmVkKHgpLCBzdHJhdGlmeSkgOiBwYXJlbnRJZDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN0cmF0aWZ5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0U2VwYXJhdGlvbiQxKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEucGFyZW50ID09PSBiLnBhcmVudCA/IDEgOiAyO1xuICAgIH1cbiAgICAvLyBmdW5jdGlvbiByYWRpYWxTZXBhcmF0aW9uKGEsIGIpIHtcbiAgICAvLyAgIHJldHVybiAoYS5wYXJlbnQgPT09IGIucGFyZW50ID8gMSA6IDIpIC8gYS5kZXB0aDtcbiAgICAvLyB9XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHRyYXZlcnNlIHRoZSBsZWZ0IGNvbnRvdXIgb2YgYSBzdWJ0cmVlIChvclxuICAgIC8vIHN1YmZvcmVzdCkuIEl0IHJldHVybnMgdGhlIHN1Y2Nlc3NvciBvZiB2IG9uIHRoaXMgY29udG91ci4gVGhpcyBzdWNjZXNzb3IgaXNcbiAgICAvLyBlaXRoZXIgZ2l2ZW4gYnkgdGhlIGxlZnRtb3N0IGNoaWxkIG9mIHYgb3IgYnkgdGhlIHRocmVhZCBvZiB2LiBUaGUgZnVuY3Rpb25cbiAgICAvLyByZXR1cm5zIG51bGwgaWYgYW5kIG9ubHkgaWYgdiBpcyBvbiB0aGUgaGlnaGVzdCBsZXZlbCBvZiBpdHMgc3VidHJlZS5cbiAgICBmdW5jdGlvbiBuZXh0TGVmdCh2KSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gICAgICAgIHJldHVybiBjaGlsZHJlbiA/IGNoaWxkcmVuWzBdIDogdi50O1xuICAgIH1cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdvcmtzIGFuYWxvZ291c2x5IHRvIG5leHRMZWZ0LlxuICAgIGZ1bmN0aW9uIG5leHRSaWdodCh2KSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gICAgICAgIHJldHVybiBjaGlsZHJlbiA/IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdIDogdi50O1xuICAgIH1cbiAgICAvLyBTaGlmdHMgdGhlIGN1cnJlbnQgc3VidHJlZSByb290ZWQgYXQgdysuIFRoaXMgaXMgZG9uZSBieSBpbmNyZWFzaW5nXG4gICAgLy8gcHJlbGltKHcrKSBhbmQgbW9kKHcrKSBieSBzaGlmdC5cbiAgICBmdW5jdGlvbiBtb3ZlU3VidHJlZSh3bSwgd3AsIHNoaWZ0KSB7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBzaGlmdCAvICh3cC5pIC0gd20uaSk7XG4gICAgICAgIHdwLmMgLT0gY2hhbmdlO1xuICAgICAgICB3cC5zICs9IHNoaWZ0O1xuICAgICAgICB3bS5jICs9IGNoYW5nZTtcbiAgICAgICAgd3AueiArPSBzaGlmdDtcbiAgICAgICAgd3AubSArPSBzaGlmdDtcbiAgICB9XG4gICAgLy8gQWxsIG90aGVyIHNoaWZ0cywgYXBwbGllZCB0byB0aGUgc21hbGxlciBzdWJ0cmVlcyBiZXR3ZWVuIHctIGFuZCB3KywgYXJlXG4gICAgLy8gcGVyZm9ybWVkIGJ5IHRoaXMgZnVuY3Rpb24uIFRvIHByZXBhcmUgdGhlIHNoaWZ0cywgd2UgaGF2ZSB0byBhZGp1c3RcbiAgICAvLyBjaGFuZ2UodyspLCBzaGlmdCh3KyksIGFuZCBjaGFuZ2Uody0pLlxuICAgIGZ1bmN0aW9uIGV4ZWN1dGVTaGlmdHModikge1xuICAgICAgICB2YXIgc2hpZnQgPSAwLCBjaGFuZ2UgPSAwLCBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sIGkgPSBjaGlsZHJlbi5sZW5ndGgsIHc7XG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgICAgdyA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgdy56ICs9IHNoaWZ0O1xuICAgICAgICAgICAgdy5tICs9IHNoaWZ0O1xuICAgICAgICAgICAgc2hpZnQgKz0gdy5zICsgKGNoYW5nZSArPSB3LmMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHZpLeKAmXMgYW5jZXN0b3IgaXMgYSBzaWJsaW5nIG9mIHYsIHJldHVybnMgdmkt4oCZcyBhbmNlc3Rvci4gT3RoZXJ3aXNlLFxuICAgIC8vIHJldHVybnMgdGhlIHNwZWNpZmllZCAoZGVmYXVsdCkgYW5jZXN0b3IuXG4gICAgZnVuY3Rpb24gbmV4dEFuY2VzdG9yKHZpbSwgdiwgYW5jZXN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHZpbS5hLnBhcmVudCA9PT0gdi5wYXJlbnQgPyB2aW0uYSA6IGFuY2VzdG9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUcmVlTm9kZShub2RlLCBpKSB7XG4gICAgICAgIHRoaXMuXyA9IG5vZGU7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuQSA9IG51bGw7IC8vIGRlZmF1bHQgYW5jZXN0b3JcbiAgICAgICAgdGhpcy5hID0gdGhpczsgLy8gYW5jZXN0b3JcbiAgICAgICAgdGhpcy56ID0gMDsgLy8gcHJlbGltXG4gICAgICAgIHRoaXMubSA9IDA7IC8vIG1vZFxuICAgICAgICB0aGlzLmMgPSAwOyAvLyBjaGFuZ2VcbiAgICAgICAgdGhpcy5zID0gMDsgLy8gc2hpZnRcbiAgICAgICAgdGhpcy50ID0gbnVsbDsgLy8gdGhyZWFkXG4gICAgICAgIHRoaXMuaSA9IGk7IC8vIG51bWJlclxuICAgIH1cbiAgICBUcmVlTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5vZGUucHJvdG90eXBlKTtcbiAgICBmdW5jdGlvbiB0cmVlUm9vdChyb290KSB7XG4gICAgICAgIHZhciB0cmVlID0gbmV3IFRyZWVOb2RlKHJvb3QsIDApLCBub2RlLCBub2RlcyA9IFt0cmVlXSwgY2hpbGQsIGNoaWxkcmVuLCBpLCBuO1xuICAgICAgICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4gPSBub2RlLl8uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuID0gbmV3IEFycmF5KG4gPSBjaGlsZHJlbi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXSA9IG5ldyBUcmVlTm9kZShjaGlsZHJlbltpXSwgaSkpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAodHJlZS5wYXJlbnQgPSBuZXcgVHJlZU5vZGUobnVsbCwgMCkpLmNoaWxkcmVuID0gW3RyZWVdO1xuICAgICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG4gICAgLy8gTm9kZS1saW5rIHRyZWUgZGlhZ3JhbSB1c2luZyB0aGUgUmVpbmdvbGQtVGlsZm9yZCBcInRpZHlcIiBhbGdvcml0aG1cbiAgICBmdW5jdGlvbiB0cmVlKCkge1xuICAgICAgICB2YXIgc2VwYXJhdGlvbiA9IGRlZmF1bHRTZXBhcmF0aW9uJDEsIGR4ID0gMSwgZHkgPSAxLCBub2RlU2l6ZSA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIHRyZWUocm9vdCkge1xuICAgICAgICAgICAgdmFyIHQgPSB0cmVlUm9vdChyb290KTtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGxheW91dCB1c2luZyBCdWNoaGVpbSBldCBhbC7igJlzIGFsZ29yaXRobS5cbiAgICAgICAgICAgIHQuZWFjaEFmdGVyKGZpcnN0V2FsayksIHQucGFyZW50Lm0gPSAtdC56O1xuICAgICAgICAgICAgdC5lYWNoQmVmb3JlKHNlY29uZFdhbGspO1xuICAgICAgICAgICAgLy8gSWYgYSBmaXhlZCBub2RlIHNpemUgaXMgc3BlY2lmaWVkLCBzY2FsZSB4IGFuZCB5LlxuICAgICAgICAgICAgaWYgKG5vZGVTaXplKVxuICAgICAgICAgICAgICAgIHJvb3QuZWFjaEJlZm9yZShzaXplTm9kZSk7XG4gICAgICAgICAgICAvLyBJZiBhIGZpeGVkIHRyZWUgc2l6ZSBpcyBzcGVjaWZpZWQsIHNjYWxlIHggYW5kIHkgYmFzZWQgb24gdGhlIGV4dGVudC5cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGxlZnQtbW9zdCwgcmlnaHQtbW9zdCwgYW5kIGRlcHRoLW1vc3Qgbm9kZXMgZm9yIGV4dGVudHMuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHJvb3QsIHJpZ2h0ID0gcm9vdCwgYm90dG9tID0gcm9vdDtcbiAgICAgICAgICAgICAgICByb290LmVhY2hCZWZvcmUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUueCA8IGxlZnQueClcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS54ID4gcmlnaHQueClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZGVwdGggPiBib3R0b20uZGVwdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gPSBub2RlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBzID0gbGVmdCA9PT0gcmlnaHQgPyAxIDogc2VwYXJhdGlvbihsZWZ0LCByaWdodCkgLyAyLCB0eCA9IHMgLSBsZWZ0LngsIGt4ID0gZHggLyAocmlnaHQueCArIHMgKyB0eCksIGt5ID0gZHkgLyAoYm90dG9tLmRlcHRoIHx8IDEpO1xuICAgICAgICAgICAgICAgIHJvb3QuZWFjaEJlZm9yZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnggPSAobm9kZS54ICsgdHgpICoga3g7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBreTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGVzIGEgcHJlbGltaW5hcnkgeC1jb29yZGluYXRlIGZvciB2LiBCZWZvcmUgdGhhdCwgRklSU1QgV0FMSyBpc1xuICAgICAgICAvLyBhcHBsaWVkIHJlY3Vyc2l2ZWx5IHRvIHRoZSBjaGlsZHJlbiBvZiB2LCBhcyB3ZWxsIGFzIHRoZSBmdW5jdGlvblxuICAgICAgICAvLyBBUFBPUlRJT04uIEFmdGVyIHNwYWNpbmcgb3V0IHRoZSBjaGlsZHJlbiBieSBjYWxsaW5nIEVYRUNVVEUgU0hJRlRTLCB0aGVcbiAgICAgICAgLy8gbm9kZSB2IGlzIHBsYWNlZCB0byB0aGUgbWlkcG9pbnQgb2YgaXRzIG91dGVybW9zdCBjaGlsZHJlbi5cbiAgICAgICAgZnVuY3Rpb24gZmlyc3RXYWxrKHYpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sIHNpYmxpbmdzID0gdi5wYXJlbnQuY2hpbGRyZW4sIHcgPSB2LmkgPyBzaWJsaW5nc1t2LmkgLSAxXSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBleGVjdXRlU2hpZnRzKHYpO1xuICAgICAgICAgICAgICAgIHZhciBtaWRwb2ludCA9IChjaGlsZHJlblswXS56ICsgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0ueikgLyAyO1xuICAgICAgICAgICAgICAgIGlmICh3KSB7XG4gICAgICAgICAgICAgICAgICAgIHYueiA9IHcueiArIHNlcGFyYXRpb24odi5fLCB3Ll8pO1xuICAgICAgICAgICAgICAgICAgICB2Lm0gPSB2LnogLSBtaWRwb2ludDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHYueiA9IG1pZHBvaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHcpIHtcbiAgICAgICAgICAgICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHYucGFyZW50LkEgPSBhcHBvcnRpb24odiwgdywgdi5wYXJlbnQuQSB8fCBzaWJsaW5nc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZXMgYWxsIHJlYWwgeC1jb29yZGluYXRlcyBieSBzdW1taW5nIHVwIHRoZSBtb2RpZmllcnMgcmVjdXJzaXZlbHkuXG4gICAgICAgIGZ1bmN0aW9uIHNlY29uZFdhbGsodikge1xuICAgICAgICAgICAgdi5fLnggPSB2LnogKyB2LnBhcmVudC5tO1xuICAgICAgICAgICAgdi5tICs9IHYucGFyZW50Lm07XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGNvcmUgb2YgdGhlIGFsZ29yaXRobS4gSGVyZSwgYSBuZXcgc3VidHJlZSBpcyBjb21iaW5lZCB3aXRoIHRoZVxuICAgICAgICAvLyBwcmV2aW91cyBzdWJ0cmVlcy4gVGhyZWFkcyBhcmUgdXNlZCB0byB0cmF2ZXJzZSB0aGUgaW5zaWRlIGFuZCBvdXRzaWRlXG4gICAgICAgIC8vIGNvbnRvdXJzIG9mIHRoZSBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlIHVwIHRvIHRoZSBoaWdoZXN0IGNvbW1vbiBsZXZlbC4gVGhlXG4gICAgICAgIC8vIHZlcnRpY2VzIHVzZWQgZm9yIHRoZSB0cmF2ZXJzYWxzIGFyZSB2aSssIHZpLSwgdm8tLCBhbmQgdm8rLCB3aGVyZSB0aGVcbiAgICAgICAgLy8gc3VwZXJzY3JpcHQgbyBtZWFucyBvdXRzaWRlIGFuZCBpIG1lYW5zIGluc2lkZSwgdGhlIHN1YnNjcmlwdCAtIG1lYW5zIGxlZnRcbiAgICAgICAgLy8gc3VidHJlZSBhbmQgKyBtZWFucyByaWdodCBzdWJ0cmVlLiBGb3Igc3VtbWluZyB1cCB0aGUgbW9kaWZpZXJzIGFsb25nIHRoZVxuICAgICAgICAvLyBjb250b3VyLCB3ZSB1c2UgcmVzcGVjdGl2ZSB2YXJpYWJsZXMgc2krLCBzaS0sIHNvLSwgYW5kIHNvKy4gV2hlbmV2ZXIgdHdvXG4gICAgICAgIC8vIG5vZGVzIG9mIHRoZSBpbnNpZGUgY29udG91cnMgY29uZmxpY3QsIHdlIGNvbXB1dGUgdGhlIGxlZnQgb25lIG9mIHRoZVxuICAgICAgICAvLyBncmVhdGVzdCB1bmNvbW1vbiBhbmNlc3RvcnMgdXNpbmcgdGhlIGZ1bmN0aW9uIEFOQ0VTVE9SIGFuZCBjYWxsIE1PVkVcbiAgICAgICAgLy8gU1VCVFJFRSB0byBzaGlmdCB0aGUgc3VidHJlZSBhbmQgcHJlcGFyZSB0aGUgc2hpZnRzIG9mIHNtYWxsZXIgc3VidHJlZXMuXG4gICAgICAgIC8vIEZpbmFsbHksIHdlIGFkZCBhIG5ldyB0aHJlYWQgKGlmIG5lY2Vzc2FyeSkuXG4gICAgICAgIGZ1bmN0aW9uIGFwcG9ydGlvbih2LCB3LCBhbmNlc3Rvcikge1xuICAgICAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlwID0gdiwgdm9wID0gdiwgdmltID0gdywgdm9tID0gdmlwLnBhcmVudC5jaGlsZHJlblswXSwgc2lwID0gdmlwLm0sIHNvcCA9IHZvcC5tLCBzaW0gPSB2aW0ubSwgc29tID0gdm9tLm0sIHNoaWZ0O1xuICAgICAgICAgICAgICAgIHdoaWxlICh2aW0gPSBuZXh0UmlnaHQodmltKSwgdmlwID0gbmV4dExlZnQodmlwKSwgdmltICYmIHZpcCkge1xuICAgICAgICAgICAgICAgICAgICB2b20gPSBuZXh0TGVmdCh2b20pO1xuICAgICAgICAgICAgICAgICAgICB2b3AgPSBuZXh0UmlnaHQodm9wKTtcbiAgICAgICAgICAgICAgICAgICAgdm9wLmEgPSB2O1xuICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IHZpbS56ICsgc2ltIC0gdmlwLnogLSBzaXAgKyBzZXBhcmF0aW9uKHZpbS5fLCB2aXAuXyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGlmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVTdWJ0cmVlKG5leHRBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSwgdiwgc2hpZnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lwICs9IHNoaWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc29wICs9IHNoaWZ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNpbSArPSB2aW0ubTtcbiAgICAgICAgICAgICAgICAgICAgc2lwICs9IHZpcC5tO1xuICAgICAgICAgICAgICAgICAgICBzb20gKz0gdm9tLm07XG4gICAgICAgICAgICAgICAgICAgIHNvcCArPSB2b3AubTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZpbSAmJiAhbmV4dFJpZ2h0KHZvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdm9wLnQgPSB2aW07XG4gICAgICAgICAgICAgICAgICAgIHZvcC5tICs9IHNpbSAtIHNvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZpcCAmJiAhbmV4dExlZnQodm9tKSkge1xuICAgICAgICAgICAgICAgICAgICB2b20udCA9IHZpcDtcbiAgICAgICAgICAgICAgICAgICAgdm9tLm0gKz0gc2lwIC0gc29tO1xuICAgICAgICAgICAgICAgICAgICBhbmNlc3RvciA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFuY2VzdG9yO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNpemVOb2RlKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUueCAqPSBkeDtcbiAgICAgICAgICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBkeTtcbiAgICAgICAgfVxuICAgICAgICB0cmVlLnNlcGFyYXRpb24gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2VwYXJhdGlvbiA9IHgsIHRyZWUpIDogc2VwYXJhdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgdHJlZS5zaXplID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVTaXplID0gZmFsc2UsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHRyZWUpIDogKG5vZGVTaXplID8gbnVsbCA6IFtkeCwgZHldKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJlZS5ub2RlU2l6ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IHRydWUsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHRyZWUpIDogKG5vZGVTaXplID8gW2R4LCBkeV0gOiBudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyZWVtYXBTbGljZShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIHZhciBub2RlcyA9IHBhcmVudC5jaGlsZHJlbiwgbm9kZSwgaSA9IC0xLCBuID0gbm9kZXMubGVuZ3RoLCBrID0gcGFyZW50LnZhbHVlICYmICh5MSAtIHkwKSAvIHBhcmVudC52YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS54MCA9IHgwLCBub2RlLngxID0geDE7XG4gICAgICAgICAgICBub2RlLnkwID0geTAsIG5vZGUueTEgPSB5MCArPSBub2RlLnZhbHVlICogaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcGhpID0gKDEgKyBNYXRoLnNxcnQoNSkpIC8gMjtcbiAgICBmdW5jdGlvbiBzcXVhcmlmeVJhdGlvKHJhdGlvLCBwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIHZhciByb3dzID0gW10sIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLCByb3csIG5vZGVWYWx1ZSwgaTAgPSAwLCBpMSA9IDAsIG4gPSBub2Rlcy5sZW5ndGgsIGR4LCBkeSwgdmFsdWUgPSBwYXJlbnQudmFsdWUsIHN1bVZhbHVlLCBtaW5WYWx1ZSwgbWF4VmFsdWUsIG5ld1JhdGlvLCBtaW5SYXRpbywgYWxwaGEsIGJldGE7XG4gICAgICAgIHdoaWxlIChpMCA8IG4pIHtcbiAgICAgICAgICAgIGR4ID0geDEgLSB4MCwgZHkgPSB5MSAtIHkwO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgbmV4dCBub24tZW1wdHkgbm9kZS5cbiAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgc3VtVmFsdWUgPSBub2Rlc1tpMSsrXS52YWx1ZTtcbiAgICAgICAgICAgIHdoaWxlICghc3VtVmFsdWUgJiYgaTEgPCBuKTtcbiAgICAgICAgICAgIG1pblZhbHVlID0gbWF4VmFsdWUgPSBzdW1WYWx1ZTtcbiAgICAgICAgICAgIGFscGhhID0gTWF0aC5tYXgoZHkgLyBkeCwgZHggLyBkeSkgLyAodmFsdWUgKiByYXRpbyk7XG4gICAgICAgICAgICBiZXRhID0gc3VtVmFsdWUgKiBzdW1WYWx1ZSAqIGFscGhhO1xuICAgICAgICAgICAgbWluUmF0aW8gPSBNYXRoLm1heChtYXhWYWx1ZSAvIGJldGEsIGJldGEgLyBtaW5WYWx1ZSk7XG4gICAgICAgICAgICAvLyBLZWVwIGFkZGluZyBub2RlcyB3aGlsZSB0aGUgYXNwZWN0IHJhdGlvIG1haW50YWlucyBvciBpbXByb3Zlcy5cbiAgICAgICAgICAgIGZvciAoOyBpMSA8IG47ICsraTEpIHtcbiAgICAgICAgICAgICAgICBzdW1WYWx1ZSArPSBub2RlVmFsdWUgPSBub2Rlc1tpMV0udmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVWYWx1ZSA8IG1pblZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IG5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVZhbHVlID4gbWF4VmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIG1heFZhbHVlID0gbm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIGJldGEgPSBzdW1WYWx1ZSAqIHN1bVZhbHVlICogYWxwaGE7XG4gICAgICAgICAgICAgICAgbmV3UmF0aW8gPSBNYXRoLm1heChtYXhWYWx1ZSAvIGJldGEsIGJldGEgLyBtaW5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1JhdGlvID4gbWluUmF0aW8pIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtVmFsdWUgLT0gbm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWluUmF0aW8gPSBuZXdSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIGFuZCByZWNvcmQgdGhlIHJvdyBvcmllbnRhdGlvbi5cbiAgICAgICAgICAgIHJvd3MucHVzaChyb3cgPSB7IHZhbHVlOiBzdW1WYWx1ZSwgZGljZTogZHggPCBkeSwgY2hpbGRyZW46IG5vZGVzLnNsaWNlKGkwLCBpMSkgfSk7XG4gICAgICAgICAgICBpZiAocm93LmRpY2UpXG4gICAgICAgICAgICAgICAgdHJlZW1hcERpY2Uocm93LCB4MCwgeTAsIHgxLCB2YWx1ZSA/IHkwICs9IGR5ICogc3VtVmFsdWUgLyB2YWx1ZSA6IHkxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0cmVlbWFwU2xpY2Uocm93LCB4MCwgeTAsIHZhbHVlID8geDAgKz0gZHggKiBzdW1WYWx1ZSAvIHZhbHVlIDogeDEsIHkxKTtcbiAgICAgICAgICAgIHZhbHVlIC09IHN1bVZhbHVlLCBpMCA9IGkxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dzO1xuICAgIH1cbiAgICB2YXIgc3F1YXJpZnkgPSAoZnVuY3Rpb24gY3VzdG9tKHJhdGlvKSB7XG4gICAgICAgIGZ1bmN0aW9uIHNxdWFyaWZ5KHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgICAgIHNxdWFyaWZ5UmF0aW8ocmF0aW8sIHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpO1xuICAgICAgICB9XG4gICAgICAgIHNxdWFyaWZ5LnJhdGlvID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXN0b20oKHggPSAreCkgPiAxID8geCA6IDEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3F1YXJpZnk7XG4gICAgfSkocGhpKTtcbiAgICBmdW5jdGlvbiBpbmRleCQxKCkge1xuICAgICAgICB2YXIgdGlsZSA9IHNxdWFyaWZ5LCByb3VuZCA9IGZhbHNlLCBkeCA9IDEsIGR5ID0gMSwgcGFkZGluZ1N0YWNrID0gWzBdLCBwYWRkaW5nSW5uZXIgPSBjb25zdGFudFplcm8sIHBhZGRpbmdUb3AgPSBjb25zdGFudFplcm8sIHBhZGRpbmdSaWdodCA9IGNvbnN0YW50WmVybywgcGFkZGluZ0JvdHRvbSA9IGNvbnN0YW50WmVybywgcGFkZGluZ0xlZnQgPSBjb25zdGFudFplcm87XG4gICAgICAgIGZ1bmN0aW9uIHRyZWVtYXAocm9vdCkge1xuICAgICAgICAgICAgcm9vdC54MCA9XG4gICAgICAgICAgICAgICAgcm9vdC55MCA9IDA7XG4gICAgICAgICAgICByb290LngxID0gZHg7XG4gICAgICAgICAgICByb290LnkxID0gZHk7XG4gICAgICAgICAgICByb290LmVhY2hCZWZvcmUocG9zaXRpb25Ob2RlKTtcbiAgICAgICAgICAgIHBhZGRpbmdTdGFjayA9IFswXTtcbiAgICAgICAgICAgIGlmIChyb3VuZClcbiAgICAgICAgICAgICAgICByb290LmVhY2hCZWZvcmUocm91bmROb2RlKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBvc2l0aW9uTm9kZShub2RlKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHBhZGRpbmdTdGFja1tub2RlLmRlcHRoXSwgeDAgPSBub2RlLngwICsgcCwgeTAgPSBub2RlLnkwICsgcCwgeDEgPSBub2RlLngxIC0gcCwgeTEgPSBub2RlLnkxIC0gcDtcbiAgICAgICAgICAgIGlmICh4MSA8IHgwKVxuICAgICAgICAgICAgICAgIHgwID0geDEgPSAoeDAgKyB4MSkgLyAyO1xuICAgICAgICAgICAgaWYgKHkxIDwgeTApXG4gICAgICAgICAgICAgICAgeTAgPSB5MSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICAgICAgICBub2RlLngwID0geDA7XG4gICAgICAgICAgICBub2RlLnkwID0geTA7XG4gICAgICAgICAgICBub2RlLngxID0geDE7XG4gICAgICAgICAgICBub2RlLnkxID0geTE7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHAgPSBwYWRkaW5nU3RhY2tbbm9kZS5kZXB0aCArIDFdID0gcGFkZGluZ0lubmVyKG5vZGUpIC8gMjtcbiAgICAgICAgICAgICAgICB4MCArPSBwYWRkaW5nTGVmdChub2RlKSAtIHA7XG4gICAgICAgICAgICAgICAgeTAgKz0gcGFkZGluZ1RvcChub2RlKSAtIHA7XG4gICAgICAgICAgICAgICAgeDEgLT0gcGFkZGluZ1JpZ2h0KG5vZGUpIC0gcDtcbiAgICAgICAgICAgICAgICB5MSAtPSBwYWRkaW5nQm90dG9tKG5vZGUpIC0gcDtcbiAgICAgICAgICAgICAgICBpZiAoeDEgPCB4MClcbiAgICAgICAgICAgICAgICAgICAgeDAgPSB4MSA9ICh4MCArIHgxKSAvIDI7XG4gICAgICAgICAgICAgICAgaWYgKHkxIDwgeTApXG4gICAgICAgICAgICAgICAgICAgIHkwID0geTEgPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgICAgICAgICAgIHRpbGUobm9kZSwgeDAsIHkwLCB4MSwgeTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWVtYXAucm91bmQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIXgsIHRyZWVtYXApIDogcm91bmQ7XG4gICAgICAgIH07XG4gICAgICAgIHRyZWVtYXAuc2l6ZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCB0cmVlbWFwKSA6IFtkeCwgZHldO1xuICAgICAgICB9O1xuICAgICAgICB0cmVlbWFwLnRpbGUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGlsZSA9IHJlcXVpcmVkKHgpLCB0cmVlbWFwKSA6IHRpbGU7XG4gICAgICAgIH07XG4gICAgICAgIHRyZWVtYXAucGFkZGluZyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRyZWVtYXAucGFkZGluZ0lubmVyKHgpLnBhZGRpbmdPdXRlcih4KSA6IHRyZWVtYXAucGFkZGluZ0lubmVyKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRyZWVtYXAucGFkZGluZ0lubmVyID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdJbm5lcjtcbiAgICAgICAgfTtcbiAgICAgICAgdHJlZW1hcC5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0cmVlbWFwLnBhZGRpbmdUb3AoeCkucGFkZGluZ1JpZ2h0KHgpLnBhZGRpbmdCb3R0b20oeCkucGFkZGluZ0xlZnQoeCkgOiB0cmVlbWFwLnBhZGRpbmdUb3AoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJlZW1hcC5wYWRkaW5nVG9wID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdUb3AgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nVG9wO1xuICAgICAgICB9O1xuICAgICAgICB0cmVlbWFwLnBhZGRpbmdSaWdodCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nUmlnaHQgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nUmlnaHQ7XG4gICAgICAgIH07XG4gICAgICAgIHRyZWVtYXAucGFkZGluZ0JvdHRvbSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nQm90dG9tID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ0JvdHRvbTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJlZW1hcC5wYWRkaW5nTGVmdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nTGVmdCA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdMZWZ0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmluYXJ5KHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLCBpLCBuID0gbm9kZXMubGVuZ3RoLCBzdW0sIHN1bXMgPSBuZXcgQXJyYXkobiArIDEpO1xuICAgICAgICBmb3IgKHN1bXNbMF0gPSBzdW0gPSBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgc3Vtc1tpICsgMV0gPSBzdW0gKz0gbm9kZXNbaV0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcGFydGl0aW9uKDAsIG4sIHBhcmVudC52YWx1ZSwgeDAsIHkwLCB4MSwgeTEpO1xuICAgICAgICBmdW5jdGlvbiBwYXJ0aXRpb24oaSwgaiwgdmFsdWUsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICAgICAgbm9kZS54MCA9IHgwLCBub2RlLnkwID0geTA7XG4gICAgICAgICAgICAgICAgbm9kZS54MSA9IHgxLCBub2RlLnkxID0geTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlT2Zmc2V0ID0gc3Vtc1tpXSwgdmFsdWVUYXJnZXQgPSAodmFsdWUgLyAyKSArIHZhbHVlT2Zmc2V0LCBrID0gaSArIDEsIGhpID0gaiAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoayA8IGhpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pZCA9IGsgKyBoaSA+Pj4gMTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vtc1ttaWRdIDwgdmFsdWVUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgIGsgPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHZhbHVlVGFyZ2V0IC0gc3Vtc1trIC0gMV0pIDwgKHN1bXNba10gLSB2YWx1ZVRhcmdldCkgJiYgaSArIDEgPCBrKVxuICAgICAgICAgICAgICAgIC0taztcbiAgICAgICAgICAgIHZhciB2YWx1ZUxlZnQgPSBzdW1zW2tdIC0gdmFsdWVPZmZzZXQsIHZhbHVlUmlnaHQgPSB2YWx1ZSAtIHZhbHVlTGVmdDtcbiAgICAgICAgICAgIGlmICgoeDEgLSB4MCkgPiAoeTEgLSB5MCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgeGsgPSAoeDAgKiB2YWx1ZVJpZ2h0ICsgeDEgKiB2YWx1ZUxlZnQpIC8gdmFsdWU7XG4gICAgICAgICAgICAgICAgcGFydGl0aW9uKGksIGssIHZhbHVlTGVmdCwgeDAsIHkwLCB4aywgeTEpO1xuICAgICAgICAgICAgICAgIHBhcnRpdGlvbihrLCBqLCB2YWx1ZVJpZ2h0LCB4aywgeTAsIHgxLCB5MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgeWsgPSAoeTAgKiB2YWx1ZVJpZ2h0ICsgeTEgKiB2YWx1ZUxlZnQpIC8gdmFsdWU7XG4gICAgICAgICAgICAgICAgcGFydGl0aW9uKGksIGssIHZhbHVlTGVmdCwgeDAsIHkwLCB4MSwgeWspO1xuICAgICAgICAgICAgICAgIHBhcnRpdGlvbihrLCBqLCB2YWx1ZVJpZ2h0LCB4MCwgeWssIHgxLCB5MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2xpY2VEaWNlKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgKHBhcmVudC5kZXB0aCAmIDEgPyB0cmVlbWFwU2xpY2UgOiB0cmVlbWFwRGljZSkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSk7XG4gICAgfVxuICAgIHZhciByZXNxdWFyaWZ5ID0gKGZ1bmN0aW9uIGN1c3RvbShyYXRpbykge1xuICAgICAgICBmdW5jdGlvbiByZXNxdWFyaWZ5KHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgICAgIGlmICgocm93cyA9IHBhcmVudC5fc3F1YXJpZnkpICYmIChyb3dzLnJhdGlvID09PSByYXRpbykpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93cywgcm93LCBub2RlcywgaSwgaiA9IC0xLCBuLCBtID0gcm93cy5sZW5ndGgsIHZhbHVlID0gcGFyZW50LnZhbHVlO1xuICAgICAgICAgICAgICAgIHdoaWxlICgrK2ogPCBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IHJvd3Nbal0sIG5vZGVzID0gcm93LmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSByb3cudmFsdWUgPSAwLCBuID0gbm9kZXMubGVuZ3RoOyBpIDwgbjsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93LnZhbHVlICs9IG5vZGVzW2ldLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocm93LmRpY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlbWFwRGljZShyb3csIHgwLCB5MCwgeDEsIHkwICs9ICh5MSAtIHkwKSAqIHJvdy52YWx1ZSAvIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZW1hcFNsaWNlKHJvdywgeDAsIHkwLCB4MCArPSAoeDEgLSB4MCkgKiByb3cudmFsdWUgLyB2YWx1ZSwgeTEpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAtPSByb3cudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Ll9zcXVhcmlmeSA9IHJvd3MgPSBzcXVhcmlmeVJhdGlvKHJhdGlvLCBwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKTtcbiAgICAgICAgICAgICAgICByb3dzLnJhdGlvID0gcmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzcXVhcmlmeS5yYXRpbyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tKCh4ID0gK3gpID4gMSA/IHggOiAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlc3F1YXJpZnk7XG4gICAgfSkocGhpKTtcbiAgICBleHBvcnRzLmNsdXN0ZXIgPSBjbHVzdGVyO1xuICAgIGV4cG9ydHMuaGllcmFyY2h5ID0gaGllcmFyY2h5O1xuICAgIGV4cG9ydHMucGFjayA9IGluZGV4O1xuICAgIGV4cG9ydHMucGFja0VuY2xvc2UgPSBlbmNsb3NlO1xuICAgIGV4cG9ydHMucGFja1NpYmxpbmdzID0gc2libGluZ3M7XG4gICAgZXhwb3J0cy5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgZXhwb3J0cy5zdHJhdGlmeSA9IHN0cmF0aWZ5O1xuICAgIGV4cG9ydHMudHJlZSA9IHRyZWU7XG4gICAgZXhwb3J0cy50cmVlbWFwID0gaW5kZXgkMTtcbiAgICBleHBvcnRzLnRyZWVtYXBCaW5hcnkgPSBiaW5hcnk7XG4gICAgZXhwb3J0cy50cmVlbWFwRGljZSA9IHRyZWVtYXBEaWNlO1xuICAgIGV4cG9ydHMudHJlZW1hcFJlc3F1YXJpZnkgPSByZXNxdWFyaWZ5O1xuICAgIGV4cG9ydHMudHJlZW1hcFNsaWNlID0gdHJlZW1hcFNsaWNlO1xuICAgIGV4cG9ydHMudHJlZW1hcFNsaWNlRGljZSA9IHNsaWNlRGljZTtcbiAgICBleHBvcnRzLnRyZWVtYXBTcXVhcmlmeSA9IHNxdWFyaWZ5O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2QzLXBhdGhAMS4wLjlAZDMtcGF0aC9kaXN0L2QzLXBhdGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2QzLXBhdGhAMS4wLjlAZDMtcGF0aC9kaXN0L2QzLXBhdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1wYXRoLyB2MS4wLjkgQ29weXJpZ2h0IDIwMTkgTWlrZSBCb3N0b2NrXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgICB0cnVlID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIHBpID0gTWF0aC5QSSwgdGF1ID0gMiAqIHBpLCBlcHNpbG9uID0gMWUtNiwgdGF1RXBzaWxvbiA9IHRhdSAtIGVwc2lsb247XG4gICAgZnVuY3Rpb24gUGF0aCgpIHtcbiAgICAgICAgdGhpcy5feDAgPSB0aGlzLl95MCA9IC8vIHN0YXJ0IG9mIGN1cnJlbnQgc3VicGF0aFxuICAgICAgICAgICAgdGhpcy5feDEgPSB0aGlzLl95MSA9IG51bGw7IC8vIGVuZCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgICAgICAgdGhpcy5fID0gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoO1xuICAgIH1cbiAgICBQYXRoLnByb3RvdHlwZSA9IHBhdGgucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogUGF0aCxcbiAgICAgICAgbW92ZVRvOiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZVBhdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl94MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3gxID0gdGhpcy5feDAsIHRoaXMuX3kxID0gdGhpcy5feTA7XG4gICAgICAgICAgICAgICAgdGhpcy5fICs9IFwiWlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsaW5lVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLl8gKz0gXCJMXCIgKyAodGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MSA9ICt5KTtcbiAgICAgICAgfSxcbiAgICAgICAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24gKHgxLCB5MSwgeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5fICs9IFwiUVwiICsgKCt4MSkgKyBcIixcIiArICgreTEpICsgXCIsXCIgKyAodGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MSA9ICt5KTtcbiAgICAgICAgfSxcbiAgICAgICAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgICAgICAgICB0aGlzLl8gKz0gXCJDXCIgKyAoK3gxKSArIFwiLFwiICsgKCt5MSkgKyBcIixcIiArICgreDIpICsgXCIsXCIgKyAoK3kyKSArIFwiLFwiICsgKHRoaXMuX3gxID0gK3gpICsgXCIsXCIgKyAodGhpcy5feTEgPSAreSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFyY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHIpIHtcbiAgICAgICAgICAgIHgxID0gK3gxLCB5MSA9ICt5MSwgeDIgPSAreDIsIHkyID0gK3kyLCByID0gK3I7XG4gICAgICAgICAgICB2YXIgeDAgPSB0aGlzLl94MSwgeTAgPSB0aGlzLl95MSwgeDIxID0geDIgLSB4MSwgeTIxID0geTIgLSB5MSwgeDAxID0geDAgLSB4MSwgeTAxID0geTAgLSB5MSwgbDAxXzIgPSB4MDEgKiB4MDEgKyB5MDEgKiB5MDE7XG4gICAgICAgICAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICAgICAgICAgIGlmIChyIDwgMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZWdhdGl2ZSByYWRpdXM6IFwiICsgcik7XG4gICAgICAgICAgICAvLyBJcyB0aGlzIHBhdGggZW1wdHk/IE1vdmUgdG8gKHgxLHkxKS5cbiAgICAgICAgICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuXyArPSBcIk1cIiArICh0aGlzLl94MSA9IHgxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3IsIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4MCx5MCk/IERvIG5vdGhpbmcuXG4gICAgICAgICAgICBlbHNlIGlmICghKGwwMV8yID4gZXBzaWxvbikpXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgLy8gT3IsIGFyZSAoeDAseTApLCAoeDEseTEpIGFuZCAoeDIseTIpIGNvbGxpbmVhcj9cbiAgICAgICAgICAgIC8vIEVxdWl2YWxlbnRseSwgaXMgKHgxLHkxKSBjb2luY2lkZW50IHdpdGggKHgyLHkyKT9cbiAgICAgICAgICAgIC8vIE9yLCBpcyB0aGUgcmFkaXVzIHplcm8/IExpbmUgdG8gKHgxLHkxKS5cbiAgICAgICAgICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoeTAxICogeDIxIC0geTIxICogeDAxKSA+IGVwc2lsb24pIHx8ICFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fICs9IFwiTFwiICsgKHRoaXMuX3gxID0geDEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGRyYXcgYW4gYXJjIVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHgyMCA9IHgyIC0geDAsIHkyMCA9IHkyIC0geTAsIGwyMV8yID0geDIxICogeDIxICsgeTIxICogeTIxLCBsMjBfMiA9IHgyMCAqIHgyMCArIHkyMCAqIHkyMCwgbDIxID0gTWF0aC5zcXJ0KGwyMV8yKSwgbDAxID0gTWF0aC5zcXJ0KGwwMV8yKSwgbCA9IHIgKiBNYXRoLnRhbigocGkgLSBNYXRoLmFjb3MoKGwyMV8yICsgbDAxXzIgLSBsMjBfMikgLyAoMiAqIGwyMSAqIGwwMSkpKSAvIDIpLCB0MDEgPSBsIC8gbDAxLCB0MjEgPSBsIC8gbDIxO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzdGFydCB0YW5nZW50IGlzIG5vdCBjb2luY2lkZW50IHdpdGggKHgwLHkwKSwgbGluZSB0by5cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModDAxIC0gMSkgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuXyArPSBcIkxcIiArICh4MSArIHQwMSAqIHgwMSkgKyBcIixcIiArICh5MSArIHQwMSAqIHkwMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuXyArPSBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiwwLDAsXCIgKyAoKyh5MDEgKiB4MjAgPiB4MDEgKiB5MjApKSArIFwiLFwiICsgKHRoaXMuX3gxID0geDEgKyB0MjEgKiB4MjEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSArIHQyMSAqIHkyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFyYzogZnVuY3Rpb24gKHgsIHksIHIsIGEwLCBhMSwgY2N3KSB7XG4gICAgICAgICAgICB4ID0gK3gsIHkgPSAreSwgciA9ICtyLCBjY3cgPSAhIWNjdztcbiAgICAgICAgICAgIHZhciBkeCA9IHIgKiBNYXRoLmNvcyhhMCksIGR5ID0gciAqIE1hdGguc2luKGEwKSwgeDAgPSB4ICsgZHgsIHkwID0geSArIGR5LCBjdyA9IDEgXiBjY3csIGRhID0gY2N3ID8gYTAgLSBhMSA6IGExIC0gYTA7XG4gICAgICAgICAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICAgICAgICAgIGlmIChyIDwgMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZWdhdGl2ZSByYWRpdXM6IFwiICsgcik7XG4gICAgICAgICAgICAvLyBJcyB0aGlzIHBhdGggZW1wdHk/IE1vdmUgdG8gKHgwLHkwKS5cbiAgICAgICAgICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuXyArPSBcIk1cIiArIHgwICsgXCIsXCIgKyB5MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9yLCBpcyAoeDAseTApIG5vdCBjb2luY2lkZW50IHdpdGggdGhlIHByZXZpb3VzIHBvaW50PyBMaW5lIHRvICh4MCx5MCkuXG4gICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyh0aGlzLl94MSAtIHgwKSA+IGVwc2lsb24gfHwgTWF0aC5hYnModGhpcy5feTEgLSB5MCkgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fICs9IFwiTFwiICsgeDAgKyBcIixcIiArIHkwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSXMgdGhpcyBhcmMgZW1wdHk/IFdl4oCZcmUgZG9uZS5cbiAgICAgICAgICAgIGlmICghcilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBEb2VzIHRoZSBhbmdsZSBnbyB0aGUgd3Jvbmcgd2F5PyBGbGlwIHRoZSBkaXJlY3Rpb24uXG4gICAgICAgICAgICBpZiAoZGEgPCAwKVxuICAgICAgICAgICAgICAgIGRhID0gZGEgJSB0YXUgKyB0YXU7XG4gICAgICAgICAgICAvLyBJcyB0aGlzIGEgY29tcGxldGUgY2lyY2xlPyBEcmF3IHR3byBhcmNzIHRvIGNvbXBsZXRlIHRoZSBjaXJjbGUuXG4gICAgICAgICAgICBpZiAoZGEgPiB0YXVFcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsMSxcIiArIGN3ICsgXCIsXCIgKyAoeCAtIGR4KSArIFwiLFwiICsgKHkgLSBkeSkgKyBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiwwLDEsXCIgKyBjdyArIFwiLFwiICsgKHRoaXMuX3gxID0geDApICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJcyB0aGlzIGFyYyBub24tZW1wdHk/IERyYXcgYW4gYXJjIVxuICAgICAgICAgICAgZWxzZSBpZiAoZGEgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fICs9IFwiQVwiICsgciArIFwiLFwiICsgciArIFwiLDAsXCIgKyAoKyhkYSA+PSBwaSkpICsgXCIsXCIgKyBjdyArIFwiLFwiICsgKHRoaXMuX3gxID0geCArIHIgKiBNYXRoLmNvcyhhMSkpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5ICsgciAqIE1hdGguc2luKGExKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgICAgICAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDAgPSB0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kwID0gdGhpcy5feTEgPSAreSkgKyBcImhcIiArICgrdykgKyBcInZcIiArICgraCkgKyBcImhcIiArICgtdykgKyBcIlpcIjtcbiAgICAgICAgfSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl87XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGV4cG9ydHMucGF0aCA9IHBhdGg7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtc2Fua2V5QDAuOS4xQGQzLXNhbmtleS9kaXN0L2QzLXNhbmtleS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZDMtc2Fua2V5QDAuOS4xQGQzLXNhbmtleS9kaXN0L2QzLXNhbmtleS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zYW5rZXkgdjAuOS4xIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICAgdHJ1ZSA/IGZhY3RvcnkoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtYXJyYXlAMS4yLjRAZDMtYXJyYXkvZGlzdC9kMy1hcnJheS5qc1wiKSwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtY29sbGVjdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1jb2xsZWN0aW9uQDEuMC43QGQzLWNvbGxlY3Rpb24vZGlzdC9kMy1jb2xsZWN0aW9uLmpzXCIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1zaGFwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1zaGFwZUAxLjMuN0BkMy1zaGFwZS9kaXN0L2QzLXNoYXBlLmpzXCIpKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMsIGQzQXJyYXksIGQzQ29sbGVjdGlvbiwgZDNTaGFwZSkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICBmdW5jdGlvbiB0YXJnZXREZXB0aChkKSB7XG4gICAgICAgIHJldHVybiBkLnRhcmdldC5kZXB0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGVmdChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmRlcHRoO1xuICAgIH1cbiAgICBmdW5jdGlvbiByaWdodChub2RlLCBuKSB7XG4gICAgICAgIHJldHVybiBuIC0gMSAtIG5vZGUuaGVpZ2h0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBqdXN0aWZ5KG5vZGUsIG4pIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuc291cmNlTGlua3MubGVuZ3RoID8gbm9kZS5kZXB0aCA6IG4gLSAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW50ZXIobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS50YXJnZXRMaW5rcy5sZW5ndGggPyBub2RlLmRlcHRoXG4gICAgICAgICAgICA6IG5vZGUuc291cmNlTGlua3MubGVuZ3RoID8gZDNBcnJheS5taW4obm9kZS5zb3VyY2VMaW5rcywgdGFyZ2V0RGVwdGgpIC0gMVxuICAgICAgICAgICAgICAgIDogMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzY2VuZGluZ1NvdXJjZUJyZWFkdGgoYSwgYikge1xuICAgICAgICByZXR1cm4gYXNjZW5kaW5nQnJlYWR0aChhLnNvdXJjZSwgYi5zb3VyY2UpIHx8IGEuaW5kZXggLSBiLmluZGV4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc2NlbmRpbmdUYXJnZXRCcmVhZHRoKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFzY2VuZGluZ0JyZWFkdGgoYS50YXJnZXQsIGIudGFyZ2V0KSB8fCBhLmluZGV4IC0gYi5pbmRleDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNjZW5kaW5nQnJlYWR0aChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnkwIC0gYi55MDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsdWUoZCkge1xuICAgICAgICByZXR1cm4gZC52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdElkKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuaW5kZXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHROb2RlcyhncmFwaCkge1xuICAgICAgICByZXR1cm4gZ3JhcGgubm9kZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRMaW5rcyhncmFwaCkge1xuICAgICAgICByZXR1cm4gZ3JhcGgubGlua3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmQobm9kZUJ5SWQsIGlkKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZUJ5SWQuZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZzogXCIgKyBpZCk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTYW5rZXkoKSB7XG4gICAgICAgIHZhciB4MCA9IDAsIHkwID0gMCwgeDEgPSAxLCB5MSA9IDEsIC8vIGV4dGVudFxuICAgICAgICBkeCA9IDI0LCAvLyBub2RlV2lkdGhcbiAgICAgICAgcHkgPSA4LCAvLyBub2RlUGFkZGluZ1xuICAgICAgICBpZCA9IGRlZmF1bHRJZCwgYWxpZ24gPSBqdXN0aWZ5LCBzb3J0LCBub2RlcyA9IGRlZmF1bHROb2RlcywgbGlua3MgPSBkZWZhdWx0TGlua3MsIGl0ZXJhdGlvbnMgPSA2O1xuICAgICAgICBmdW5jdGlvbiBzYW5rZXkoKSB7XG4gICAgICAgICAgICB2YXIgZ3JhcGggPSB7IG5vZGVzOiBub2Rlcy5hcHBseShudWxsLCBhcmd1bWVudHMpLCBsaW5rczogbGlua3MuYXBwbHkobnVsbCwgYXJndW1lbnRzKSB9O1xuICAgICAgICAgICAgY29tcHV0ZU5vZGVMaW5rcyhncmFwaCk7XG4gICAgICAgICAgICBjb21wdXRlTm9kZVZhbHVlcyhncmFwaCk7XG4gICAgICAgICAgICBjb21wdXRlTm9kZURlcHRocyhncmFwaCk7XG4gICAgICAgICAgICBjb21wdXRlTm9kZUJyZWFkdGhzKGdyYXBoKTtcbiAgICAgICAgICAgIGNvbXB1dGVMaW5rQnJlYWR0aHMoZ3JhcGgpO1xuICAgICAgICAgICAgcmV0dXJuIGdyYXBoO1xuICAgICAgICB9XG4gICAgICAgIHNhbmtleS51cGRhdGUgPSBmdW5jdGlvbiAoZ3JhcGgpIHtcbiAgICAgICAgICAgIGNvbXB1dGVMaW5rQnJlYWR0aHMoZ3JhcGgpO1xuICAgICAgICAgICAgcmV0dXJuIGdyYXBoO1xuICAgICAgICB9O1xuICAgICAgICBzYW5rZXkubm9kZUlkID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGlkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgc2Fua2V5KSA6IGlkO1xuICAgICAgICB9O1xuICAgICAgICBzYW5rZXkubm9kZUFsaWduID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFsaWduID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgc2Fua2V5KSA6IGFsaWduO1xuICAgICAgICB9O1xuICAgICAgICBzYW5rZXkubm9kZVNvcnQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydCA9IF8sIHNhbmtleSkgOiBzb3J0O1xuICAgICAgICB9O1xuICAgICAgICBzYW5rZXkubm9kZVdpZHRoID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR4ID0gK18sIHNhbmtleSkgOiBkeDtcbiAgICAgICAgfTtcbiAgICAgICAgc2Fua2V5Lm5vZGVQYWRkaW5nID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHB5ID0gK18sIHNhbmtleSkgOiBweTtcbiAgICAgICAgfTtcbiAgICAgICAgc2Fua2V5Lm5vZGVzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgc2Fua2V5KSA6IG5vZGVzO1xuICAgICAgICB9O1xuICAgICAgICBzYW5rZXkubGlua3MgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobGlua3MgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBzYW5rZXkpIDogbGlua3M7XG4gICAgICAgIH07XG4gICAgICAgIHNhbmtleS5zaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0geTAgPSAwLCB4MSA9ICtfWzBdLCB5MSA9ICtfWzFdLCBzYW5rZXkpIDogW3gxIC0geDAsIHkxIC0geTBdO1xuICAgICAgICB9O1xuICAgICAgICBzYW5rZXkuZXh0ZW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gK19bMF1bMF0sIHgxID0gK19bMV1bMF0sIHkwID0gK19bMF1bMV0sIHkxID0gK19bMV1bMV0sIHNhbmtleSkgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgICAgICAgfTtcbiAgICAgICAgc2Fua2V5Lml0ZXJhdGlvbnMgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaXRlcmF0aW9ucyA9ICtfLCBzYW5rZXkpIDogaXRlcmF0aW9ucztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUG9wdWxhdGUgdGhlIHNvdXJjZUxpbmtzIGFuZCB0YXJnZXRMaW5rcyBmb3IgZWFjaCBub2RlLlxuICAgICAgICAvLyBBbHNvLCBpZiB0aGUgc291cmNlIGFuZCB0YXJnZXQgYXJlIG5vdCBvYmplY3RzLCBhc3N1bWUgdGhleSBhcmUgaW5kaWNlcy5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZU5vZGVMaW5rcyhncmFwaCkge1xuICAgICAgICAgICAgZ3JhcGgubm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgICAgICAgICAgICAgIG5vZGUuaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIG5vZGUuc291cmNlTGlua3MgPSBbXTtcbiAgICAgICAgICAgICAgICBub2RlLnRhcmdldExpbmtzID0gW107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBub2RlQnlJZCA9IGQzQ29sbGVjdGlvbi5tYXAoZ3JhcGgubm9kZXMsIGlkKTtcbiAgICAgICAgICAgIGdyYXBoLmxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmssIGkpIHtcbiAgICAgICAgICAgICAgICBsaW5rLmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gbGluay5zb3VyY2UsIHRhcmdldCA9IGxpbmsudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBsaW5rLnNvdXJjZSA9IGZpbmQobm9kZUJ5SWQsIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGxpbmsudGFyZ2V0ID0gZmluZChub2RlQnlJZCwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBzb3VyY2Uuc291cmNlTGlua3MucHVzaChsaW5rKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQudGFyZ2V0TGlua3MucHVzaChsaW5rKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHZhbHVlIChzaXplKSBvZiBlYWNoIG5vZGUgYnkgc3VtbWluZyB0aGUgYXNzb2NpYXRlZCBsaW5rcy5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZU5vZGVWYWx1ZXMoZ3JhcGgpIHtcbiAgICAgICAgICAgIGdyYXBoLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gTWF0aC5tYXgoZDNBcnJheS5zdW0obm9kZS5zb3VyY2VMaW5rcywgdmFsdWUpLCBkM0FycmF5LnN1bShub2RlLnRhcmdldExpbmtzLCB2YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0aXZlbHkgYXNzaWduIHRoZSBkZXB0aCAoeC1wb3NpdGlvbikgZm9yIGVhY2ggbm9kZS5cbiAgICAgICAgLy8gTm9kZXMgYXJlIGFzc2lnbmVkIHRoZSBtYXhpbXVtIGRlcHRoIG9mIGluY29taW5nIG5laWdoYm9ycyBwbHVzIG9uZTtcbiAgICAgICAgLy8gbm9kZXMgd2l0aCBubyBpbmNvbWluZyBsaW5rcyBhcmUgYXNzaWduZWQgZGVwdGggemVybywgd2hpbGVcbiAgICAgICAgLy8gbm9kZXMgd2l0aCBubyBvdXRnb2luZyBsaW5rcyBhcmUgYXNzaWduZWQgdGhlIG1heGltdW0gZGVwdGguXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVOb2RlRGVwdGhzKGdyYXBoKSB7XG4gICAgICAgICAgICB2YXIgbm9kZXMsIG5leHQsIHgsIG4gPSBncmFwaC5ub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKG5vZGVzID0gZ3JhcGgubm9kZXMsIG5leHQgPSBbXSwgeCA9IDA7IG5vZGVzLmxlbmd0aDsgKyt4LCBub2RlcyA9IG5leHQsIG5leHQgPSBbXSkge1xuICAgICAgICAgICAgICAgIGlmICh4ID4gbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2lyY3VsYXIgbGlua1wiKTtcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZGVwdGggPSB4O1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNvdXJjZUxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmluZGV4T2YobGluay50YXJnZXQpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQucHVzaChsaW5rLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChub2RlcyA9IGdyYXBoLm5vZGVzLCBuZXh0ID0gW10sIHggPSAwOyBub2Rlcy5sZW5ndGg7ICsreCwgbm9kZXMgPSBuZXh0LCBuZXh0ID0gW10pIHtcbiAgICAgICAgICAgICAgICBpZiAoeCA+IG4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNpcmN1bGFyIGxpbmtcIik7XG4gICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmhlaWdodCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudGFyZ2V0TGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuaW5kZXhPZihsaW5rLnNvdXJjZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5wdXNoKGxpbmsuc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIga3ggPSAoeDEgLSB4MCAtIGR4KSAvICh4IC0gMSk7XG4gICAgICAgICAgICBncmFwaC5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS54MSA9IChub2RlLngwID0geDAgKyBNYXRoLm1heCgwLCBNYXRoLm1pbih4IC0gMSwgTWF0aC5mbG9vcihhbGlnbi5jYWxsKG51bGwsIG5vZGUsIHgpKSkpICoga3gpICsgZHg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlTm9kZUJyZWFkdGhzKGdyYXBoKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IGQzQ29sbGVjdGlvbi5uZXN0KClcbiAgICAgICAgICAgICAgICAua2V5KGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLngwOyB9KVxuICAgICAgICAgICAgICAgIC5zb3J0S2V5cyhkM0FycmF5LmFzY2VuZGluZylcbiAgICAgICAgICAgICAgICAuZW50cmllcyhncmFwaC5ub2RlcylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLnZhbHVlczsgfSk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaW5pdGlhbGl6ZU5vZGVCcmVhZHRoKCk7XG4gICAgICAgICAgICByZXNvbHZlQ29sbGlzaW9ucygpO1xuICAgICAgICAgICAgZm9yICh2YXIgYWxwaGEgPSAwLjksIG4gPSBpdGVyYXRpb25zOyBuID4gMDsgLS1uLCBhbHBoYSAqPSAwLjkpIHtcbiAgICAgICAgICAgICAgICByZWxheFJpZ2h0VG9MZWZ0KGFscGhhKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlQ29sbGlzaW9ucygpO1xuICAgICAgICAgICAgICAgIHJlbGF4TGVmdFRvUmlnaHQoYWxwaGEpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVDb2xsaXNpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBpbml0aWFsaXplTm9kZUJyZWFkdGgoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGt5ID0gZDNBcnJheS5taW4oY29sdW1ucywgZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoeTEgLSB5MCAtIChub2Rlcy5sZW5ndGggLSAxKSAqIHB5KSAvIGQzQXJyYXkuc3VtKG5vZGVzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChub2Rlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc29ydCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc29ydChzb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS55MSA9IChub2RlLnkwID0gaSkgKyBub2RlLnZhbHVlICoga3k7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdyYXBoLmxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluay53aWR0aCA9IGxpbmsudmFsdWUgKiBreTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlbGF4TGVmdFRvUmlnaHQoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSBub2RlLnkwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYyA9IHRzbGliXzEuX192YWx1ZXMobm9kZS5zb3VyY2VMaW5rcy5zb3J0KGFzY2VuZGluZ1RhcmdldEJyZWFkdGgpKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2UgPSBfZC52YWx1ZSwgdGFyZ2V0ID0gX2UudGFyZ2V0LCB3aWR0aCA9IF9lLndpZHRoLCB2YWx1ZV8xID0gX2UudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZV8xID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSAoZV8yID0gdm9pZCAwLCB0c2xpYl8xLl9fdmFsdWVzKHRhcmdldC50YXJnZXRMaW5rcykpLCBfZyA9IF9mLm5leHQoKTsgIV9nLmRvbmU7IF9nID0gX2YubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfaCA9IF9nLnZhbHVlLCBzb3VyY2UgPSBfaC5zb3VyY2UsIHdpZHRoXzEgPSBfaC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeSArPSB3aWR0aF8xICsgcHkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2cgJiYgIV9nLmRvbmUgJiYgKF9iID0gX2YucmV0dXJuKSkgX2IuY2FsbChfZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5ID0gKHkgLSBkeSAtIHRhcmdldC55MCkgKiBhbHBoYSAqICh2YWx1ZV8xIC8gTWF0aC5taW4obm9kZS52YWx1ZSwgdGFyZ2V0LnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQueTAgKz0gZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQueTEgKz0gZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArPSB3aWR0aCArIHB5IC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gcmVsYXhSaWdodFRvTGVmdChhbHBoYSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbnMuc2xpY2UoKS5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVfMywgX2EsIGVfNCwgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IG5vZGUueTA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9jID0gdHNsaWJfMS5fX3ZhbHVlcyhub2RlLnRhcmdldExpbmtzLnNvcnQoYXNjZW5kaW5nU291cmNlQnJlYWR0aCkpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZSA9IF9kLnZhbHVlLCBzb3VyY2UgPSBfZS5zb3VyY2UsIHdpZHRoID0gX2Uud2lkdGgsIHZhbHVlXzIgPSBfZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlXzIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IChlXzQgPSB2b2lkIDAsIHRzbGliXzEuX192YWx1ZXMoc291cmNlLnNvdXJjZUxpbmtzKSksIF9nID0gX2YubmV4dCgpOyAhX2cuZG9uZTsgX2cgPSBfZi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9oID0gX2cudmFsdWUsIHRhcmdldCA9IF9oLnRhcmdldCwgd2lkdGhfMiA9IF9oLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBub2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5ICs9IHdpZHRoXzIgKyBweSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZyAmJiAhX2cuZG9uZSAmJiAoX2IgPSBfZi5yZXR1cm4pKSBfYi5jYWxsKF9mKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSAoeSAtIGR5IC0gc291cmNlLnkwKSAqIGFscGhhICogKHZhbHVlXzIgLyBNYXRoLm1pbihub2RlLnZhbHVlLCBzb3VyY2UudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS55MCArPSBkeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS55MSArPSBkeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHdpZHRoICsgcHkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlQ29sbGlzaW9ucygpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlLCBkeSwgeSA9IHkwLCBuID0gbm9kZXMubGVuZ3RoLCBpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQdXNoIGFueSBvdmVybGFwcGluZyBub2RlcyBkb3duLlxuICAgICAgICAgICAgICAgICAgICBpZiAoc29ydCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMuc29ydChhc2NlbmRpbmdCcmVhZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSB5IC0gbm9kZS55MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeSA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS55MCArPSBkeSwgbm9kZS55MSArPSBkeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBub2RlLnkxICsgcHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJvdHRvbW1vc3Qgbm9kZSBnb2VzIG91dHNpZGUgdGhlIGJvdW5kcywgcHVzaCBpdCBiYWNrIHVwLlxuICAgICAgICAgICAgICAgICAgICBkeSA9IHkgLSBweSAtIHkxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gKG5vZGUueTAgLT0gZHkpLCBub2RlLnkxIC09IGR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVzaCBhbnkgb3ZlcmxhcHBpbmcgbm9kZXMgYmFjayB1cC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IG4gLSAyOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeSA9IG5vZGUueTEgKyBweSAtIHk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR5ID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS55MCAtPSBkeSwgbm9kZS55MSAtPSBkeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gbm9kZS55MDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVMaW5rQnJlYWR0aHMoZ3JhcGgpIHtcbiAgICAgICAgICAgIGdyYXBoLm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnNvdXJjZUxpbmtzLnNvcnQoYXNjZW5kaW5nVGFyZ2V0QnJlYWR0aCk7XG4gICAgICAgICAgICAgICAgbm9kZS50YXJnZXRMaW5rcy5zb3J0KGFzY2VuZGluZ1NvdXJjZUJyZWFkdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncmFwaC5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHkwID0gbm9kZS55MCwgeTEgPSB5MDtcbiAgICAgICAgICAgICAgICBub2RlLnNvdXJjZUxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluay55MCA9IHkwICsgbGluay53aWR0aCAvIDIsIHkwICs9IGxpbmsud2lkdGg7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbm9kZS50YXJnZXRMaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmsueTEgPSB5MSArIGxpbmsud2lkdGggLyAyLCB5MSArPSBsaW5rLndpZHRoO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNhbmtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaG9yaXpvbnRhbFNvdXJjZShkKSB7XG4gICAgICAgIHJldHVybiBbZC5zb3VyY2UueDEsIGQueTBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBob3Jpem9udGFsVGFyZ2V0KGQpIHtcbiAgICAgICAgcmV0dXJuIFtkLnRhcmdldC54MCwgZC55MV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNhbmtleUxpbmtIb3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gZDNTaGFwZS5saW5rSG9yaXpvbnRhbCgpXG4gICAgICAgICAgICAuc291cmNlKGhvcml6b250YWxTb3VyY2UpXG4gICAgICAgICAgICAudGFyZ2V0KGhvcml6b250YWxUYXJnZXQpO1xuICAgIH1cbiAgICBleHBvcnRzLnNhbmtleSA9IFNhbmtleTtcbiAgICBleHBvcnRzLnNhbmtleUNlbnRlciA9IGNlbnRlcjtcbiAgICBleHBvcnRzLnNhbmtleUxlZnQgPSBsZWZ0O1xuICAgIGV4cG9ydHMuc2Fua2V5UmlnaHQgPSByaWdodDtcbiAgICBleHBvcnRzLnNhbmtleUp1c3RpZnkgPSBqdXN0aWZ5O1xuICAgIGV4cG9ydHMuc2Fua2V5TGlua0hvcml6b250YWwgPSBzYW5rZXlMaW5rSG9yaXpvbnRhbDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1zaGFwZUAxLjMuN0BkMy1zaGFwZS9kaXN0L2QzLXNoYXBlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kMy1zaGFwZUAxLjMuN0BkMy1zaGFwZS9kaXN0L2QzLXNoYXBlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtc2hhcGUvIHYxLjMuNyBDb3B5cmlnaHQgMjAxOSBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgIHRydWUgPyBmYWN0b3J5KGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLXBhdGggKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtcGF0aEAxLjAuOUBkMy1wYXRoL2Rpc3QvZDMtcGF0aC5qc1wiKSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBkM1BhdGgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY29uc3RhbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIGFicyA9IE1hdGguYWJzO1xuICAgIHZhciBhdGFuMiA9IE1hdGguYXRhbjI7XG4gICAgdmFyIGNvcyA9IE1hdGguY29zO1xuICAgIHZhciBtYXggPSBNYXRoLm1heDtcbiAgICB2YXIgbWluID0gTWF0aC5taW47XG4gICAgdmFyIHNpbiA9IE1hdGguc2luO1xuICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgIHZhciBlcHNpbG9uID0gMWUtMTI7XG4gICAgdmFyIHBpID0gTWF0aC5QSTtcbiAgICB2YXIgaGFsZlBpID0gcGkgLyAyO1xuICAgIHZhciB0YXUgPSAyICogcGk7XG4gICAgZnVuY3Rpb24gYWNvcyh4KSB7XG4gICAgICAgIHJldHVybiB4ID4gMSA/IDAgOiB4IDwgLTEgPyBwaSA6IE1hdGguYWNvcyh4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNpbih4KSB7XG4gICAgICAgIHJldHVybiB4ID49IDEgPyBoYWxmUGkgOiB4IDw9IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJjSW5uZXJSYWRpdXMoZCkge1xuICAgICAgICByZXR1cm4gZC5pbm5lclJhZGl1cztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJjT3V0ZXJSYWRpdXMoZCkge1xuICAgICAgICByZXR1cm4gZC5vdXRlclJhZGl1cztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJjU3RhcnRBbmdsZShkKSB7XG4gICAgICAgIHJldHVybiBkLnN0YXJ0QW5nbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyY0VuZEFuZ2xlKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZW5kQW5nbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyY1BhZEFuZ2xlKGQpIHtcbiAgICAgICAgcmV0dXJuIGQgJiYgZC5wYWRBbmdsZTsgLy8gTm90ZTogb3B0aW9uYWwhXG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVyc2VjdCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgICAgdmFyIHgxMCA9IHgxIC0geDAsIHkxMCA9IHkxIC0geTAsIHgzMiA9IHgzIC0geDIsIHkzMiA9IHkzIC0geTIsIHQgPSB5MzIgKiB4MTAgLSB4MzIgKiB5MTA7XG4gICAgICAgIGlmICh0ICogdCA8IGVwc2lsb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHQgPSAoeDMyICogKHkwIC0geTIpIC0geTMyICogKHgwIC0geDIpKSAvIHQ7XG4gICAgICAgIHJldHVybiBbeDAgKyB0ICogeDEwLCB5MCArIHQgKiB5MTBdO1xuICAgIH1cbiAgICAvLyBDb21wdXRlIHBlcnBlbmRpY3VsYXIgb2Zmc2V0IGxpbmUgb2YgbGVuZ3RoIHJjLlxuICAgIC8vIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vQ2lyY2xlLUxpbmVJbnRlcnNlY3Rpb24uaHRtbFxuICAgIGZ1bmN0aW9uIGNvcm5lclRhbmdlbnRzKHgwLCB5MCwgeDEsIHkxLCByMSwgcmMsIGN3KSB7XG4gICAgICAgIHZhciB4MDEgPSB4MCAtIHgxLCB5MDEgPSB5MCAtIHkxLCBsbyA9IChjdyA/IHJjIDogLXJjKSAvIHNxcnQoeDAxICogeDAxICsgeTAxICogeTAxKSwgb3ggPSBsbyAqIHkwMSwgb3kgPSAtbG8gKiB4MDEsIHgxMSA9IHgwICsgb3gsIHkxMSA9IHkwICsgb3ksIHgxMCA9IHgxICsgb3gsIHkxMCA9IHkxICsgb3ksIHgwMCA9ICh4MTEgKyB4MTApIC8gMiwgeTAwID0gKHkxMSArIHkxMCkgLyAyLCBkeCA9IHgxMCAtIHgxMSwgZHkgPSB5MTAgLSB5MTEsIGQyID0gZHggKiBkeCArIGR5ICogZHksIHIgPSByMSAtIHJjLCBEID0geDExICogeTEwIC0geDEwICogeTExLCBkID0gKGR5IDwgMCA/IC0xIDogMSkgKiBzcXJ0KG1heCgwLCByICogciAqIGQyIC0gRCAqIEQpKSwgY3gwID0gKEQgKiBkeSAtIGR4ICogZCkgLyBkMiwgY3kwID0gKC1EICogZHggLSBkeSAqIGQpIC8gZDIsIGN4MSA9IChEICogZHkgKyBkeCAqIGQpIC8gZDIsIGN5MSA9ICgtRCAqIGR4ICsgZHkgKiBkKSAvIGQyLCBkeDAgPSBjeDAgLSB4MDAsIGR5MCA9IGN5MCAtIHkwMCwgZHgxID0gY3gxIC0geDAwLCBkeTEgPSBjeTEgLSB5MDA7XG4gICAgICAgIC8vIFBpY2sgdGhlIGNsb3NlciBvZiB0aGUgdHdvIGludGVyc2VjdGlvbiBwb2ludHMuXG4gICAgICAgIC8vIFRPRE8gSXMgdGhlcmUgYSBmYXN0ZXIgd2F5IHRvIGRldGVybWluZSB3aGljaCBpbnRlcnNlY3Rpb24gdG8gdXNlP1xuICAgICAgICBpZiAoZHgwICogZHgwICsgZHkwICogZHkwID4gZHgxICogZHgxICsgZHkxICogZHkxKVxuICAgICAgICAgICAgY3gwID0gY3gxLCBjeTAgPSBjeTE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjeDogY3gwLFxuICAgICAgICAgICAgY3k6IGN5MCxcbiAgICAgICAgICAgIHgwMTogLW94LFxuICAgICAgICAgICAgeTAxOiAtb3ksXG4gICAgICAgICAgICB4MTE6IGN4MCAqIChyMSAvIHIgLSAxKSxcbiAgICAgICAgICAgIHkxMTogY3kwICogKHIxIC8gciAtIDEpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyYygpIHtcbiAgICAgICAgdmFyIGlubmVyUmFkaXVzID0gYXJjSW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzID0gYXJjT3V0ZXJSYWRpdXMsIGNvcm5lclJhZGl1cyA9IGNvbnN0YW50KDApLCBwYWRSYWRpdXMgPSBudWxsLCBzdGFydEFuZ2xlID0gYXJjU3RhcnRBbmdsZSwgZW5kQW5nbGUgPSBhcmNFbmRBbmdsZSwgcGFkQW5nbGUgPSBhcmNQYWRBbmdsZSwgY29udGV4dCA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIGFyYygpIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIsIHIsIHIwID0gK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHIxID0gK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGEwID0gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLCBhMSA9IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmUGksIGRhID0gYWJzKGExIC0gYTApLCBjdyA9IGExID4gYTA7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHQpXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGJ1ZmZlciA9IGQzUGF0aC5wYXRoKCk7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgb3V0ZXIgcmFkaXVzIGlzIGFsd2F5cyBsYXJnZXIgdGhhbiB0aGUgaW5uZXIgcmFkaXVzLlxuICAgICAgICAgICAgaWYgKHIxIDwgcjApXG4gICAgICAgICAgICAgICAgciA9IHIxLCByMSA9IHIwLCByMCA9IHI7XG4gICAgICAgICAgICAvLyBJcyBpdCBhIHBvaW50P1xuICAgICAgICAgICAgaWYgKCEocjEgPiBlcHNpbG9uKSlcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgICAgIC8vIE9yIGlzIGl0IGEgY2lyY2xlIG9yIGFubnVsdXM/XG4gICAgICAgICAgICBlbHNlIGlmIChkYSA+IHRhdSAtIGVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhyMSAqIGNvcyhhMCksIHIxICogc2luKGEwKSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwLCBhMSwgIWN3KTtcbiAgICAgICAgICAgICAgICBpZiAocjAgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHIwICogY29zKGExKSwgcjAgKiBzaW4oYTEpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExLCBhMCwgY3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9yIGlzIGl0IGEgY2lyY3VsYXIgb3IgYW5udWxhciBzZWN0b3I/XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYTAxID0gYTAsIGExMSA9IGExLCBhMDAgPSBhMCwgYTEwID0gYTEsIGRhMCA9IGRhLCBkYTEgPSBkYSwgYXAgPSBwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC8gMiwgcnAgPSAoYXAgPiBlcHNpbG9uKSAmJiAocGFkUmFkaXVzID8gK3BhZFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogc3FydChyMCAqIHIwICsgcjEgKiByMSkpLCByYyA9IG1pbihhYnMocjEgLSByMCkgLyAyLCArY29ybmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLCByYzAgPSByYywgcmMxID0gcmMsIHQwLCB0MTtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBwYWRkaW5nPyBOb3RlIHRoYXQgc2luY2UgcjEg4omlIHIwLCBkYTEg4omlIGRhMC5cbiAgICAgICAgICAgICAgICBpZiAocnAgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMCA9IGFzaW4ocnAgLyByMCAqIHNpbihhcCkpLCBwMSA9IGFzaW4ocnAgLyByMSAqIHNpbihhcCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGRhMCAtPSBwMCAqIDIpID4gZXBzaWxvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHAwICo9IChjdyA/IDEgOiAtMSksIGEwMCArPSBwMCwgYTEwIC09IHAwO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkYTAgPSAwLCBhMDAgPSBhMTAgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGRhMSAtPSBwMSAqIDIpID4gZXBzaWxvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHAxICo9IChjdyA/IDEgOiAtMSksIGEwMSArPSBwMSwgYTExIC09IHAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkYTEgPSAwLCBhMDEgPSBhMTEgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgeDAxID0gcjEgKiBjb3MoYTAxKSwgeTAxID0gcjEgKiBzaW4oYTAxKSwgeDEwID0gcjAgKiBjb3MoYTEwKSwgeTEwID0gcjAgKiBzaW4oYTEwKTtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSByb3VuZGVkIGNvcm5lcnM/XG4gICAgICAgICAgICAgICAgaWYgKHJjID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDExID0gcjEgKiBjb3MoYTExKSwgeTExID0gcjEgKiBzaW4oYTExKSwgeDAwID0gcjAgKiBjb3MoYTAwKSwgeTAwID0gcjAgKiBzaW4oYTAwKSwgb2M7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3RyaWN0IHRoZSBjb3JuZXIgcmFkaXVzIGFjY29yZGluZyB0byB0aGUgc2VjdG9yIGFuZ2xlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZGEgPCBwaSAmJiAob2MgPSBpbnRlcnNlY3QoeDAxLCB5MDEsIHgwMCwgeTAwLCB4MTEsIHkxMSwgeDEwLCB5MTApKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF4ID0geDAxIC0gb2NbMF0sIGF5ID0geTAxIC0gb2NbMV0sIGJ4ID0geDExIC0gb2NbMF0sIGJ5ID0geTExIC0gb2NbMV0sIGtjID0gMSAvIHNpbihhY29zKChheCAqIGJ4ICsgYXkgKiBieSkgLyAoc3FydChheCAqIGF4ICsgYXkgKiBheSkgKiBzcXJ0KGJ4ICogYnggKyBieSAqIGJ5KSkpIC8gMiksIGxjID0gc3FydChvY1swXSAqIG9jWzBdICsgb2NbMV0gKiBvY1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYzAgPSBtaW4ocmMsIChyMCAtIGxjKSAvIChrYyAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJjMSA9IG1pbihyYywgKHIxIC0gbGMpIC8gKGtjICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElzIHRoZSBzZWN0b3IgY29sbGFwc2VkIHRvIGEgbGluZT9cbiAgICAgICAgICAgICAgICBpZiAoIShkYTEgPiBlcHNpbG9uKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeDAxLCB5MDEpO1xuICAgICAgICAgICAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgb3V0ZXIgcmluZyBoYXZlIHJvdW5kZWQgY29ybmVycz9cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyYzEgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDAwLCB5MDAsIHgwMSwgeTAxLCByMSwgcmMxLCBjdyk7XG4gICAgICAgICAgICAgICAgICAgIHQxID0gY29ybmVyVGFuZ2VudHMoeDExLCB5MTEsIHgxMCwgeTEwLCByMSwgcmMxLCBjdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhdmUgdGhlIGNvcm5lcnMgbWVyZ2VkP1xuICAgICAgICAgICAgICAgICAgICBpZiAocmMxIDwgcmMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMxLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQwLnkxMSwgdDAueDExKSwgIWN3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhdGFuMih0MC5jeSArIHQwLnkxMSwgdDAuY3ggKyB0MC54MTEpLCBhdGFuMih0MS5jeSArIHQxLnkxMSwgdDEuY3ggKyB0MS54MTEpLCAhY3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hcmModDEuY3gsIHQxLmN5LCByYzEsIGF0YW4yKHQxLnkxMSwgdDEueDExKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE9yIGlzIHRoZSBvdXRlciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4MDEsIHkwMSksIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMDEsIGExMSwgIWN3KTtcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGVyZSBubyBpbm5lciByaW5nLCBhbmQgaXTigJlzIGEgY2lyY3VsYXIgc2VjdG9yP1xuICAgICAgICAgICAgICAgIC8vIE9yIHBlcmhhcHMgaXTigJlzIGFuIGFubnVsYXIgc2VjdG9yIGNvbGxhcHNlZCBkdWUgdG8gcGFkZGluZz9cbiAgICAgICAgICAgICAgICBpZiAoIShyMCA+IGVwc2lsb24pIHx8ICEoZGEwID4gZXBzaWxvbikpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHgxMCwgeTEwKTtcbiAgICAgICAgICAgICAgICAvLyBEb2VzIHRoZSBzZWN0b3LigJlzIGlubmVyIHJpbmcgKG9yIHBvaW50KSBoYXZlIHJvdW5kZWQgY29ybmVycz9cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyYzAgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHQwID0gY29ybmVyVGFuZ2VudHMoeDEwLCB5MTAsIHgxMSwgeTExLCByMCwgLXJjMCwgY3cpO1xuICAgICAgICAgICAgICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgwMSwgeTAxLCB4MDAsIHkwMCwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGF2ZSB0aGUgY29ybmVycyBtZXJnZWQ/XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYzAgPCByYylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMwLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBkcmF3IHRoZSB0d28gY29ybmVycyBhbmQgdGhlIHJpbmcuXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzAsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDAueTExLCB0MC54MTEpLCAhY3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjAsIGF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIGF0YW4yKHQxLmN5ICsgdDEueTExLCB0MS5jeCArIHQxLngxMSksIGN3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMwLCBhdGFuMih0MS55MTEsIHQxLngxMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPciBpcyB0aGUgaW5uZXIgcmluZyBqdXN0IGEgY2lyY3VsYXIgYXJjP1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExMCwgYTAwLCBjdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBhcmMuY2VudHJvaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgciA9ICgraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIsIGEgPSAoK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIgLSBwaSAvIDI7XG4gICAgICAgICAgICByZXR1cm4gW2NvcyhhKSAqIHIsIHNpbihhKSAqIHJdO1xuICAgICAgICB9O1xuICAgICAgICBhcmMuaW5uZXJSYWRpdXMgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW5uZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGlubmVyUmFkaXVzO1xuICAgICAgICB9O1xuICAgICAgICBhcmMub3V0ZXJSYWRpdXMgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAob3V0ZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IG91dGVyUmFkaXVzO1xuICAgICAgICB9O1xuICAgICAgICBhcmMuY29ybmVyUmFkaXVzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvcm5lclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogY29ybmVyUmFkaXVzO1xuICAgICAgICB9O1xuICAgICAgICBhcmMucGFkUmFkaXVzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZFJhZGl1cyA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZFJhZGl1cztcbiAgICAgICAgfTtcbiAgICAgICAgYXJjLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogc3RhcnRBbmdsZTtcbiAgICAgICAgfTtcbiAgICAgICAgYXJjLmVuZEFuZ2xlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBlbmRBbmdsZTtcbiAgICAgICAgfTtcbiAgICAgICAgYXJjLnBhZEFuZ2xlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBwYWRBbmdsZTtcbiAgICAgICAgfTtcbiAgICAgICAgYXJjLmNvbnRleHQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXyksIGFyYykgOiBjb250ZXh0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXJjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBMaW5lYXIoY29udGV4dCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgTGluZWFyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgYXJlYVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2ludCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSlcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHggPSAreCwgeSA9ICt5O1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIHByb2NlZWRcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGN1cnZlTGluZWFyKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lYXIoY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHgocCkge1xuICAgICAgICByZXR1cm4gcFswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24geShwKSB7XG4gICAgICAgIHJldHVybiBwWzFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lKCkge1xuICAgICAgICB2YXIgeCQxID0geCwgeSQxID0geSwgZGVmaW5lZCA9IGNvbnN0YW50KHRydWUpLCBjb250ZXh0ID0gbnVsbCwgY3VydmUgPSBjdXJ2ZUxpbmVhciwgb3V0cHV0ID0gbnVsbDtcbiAgICAgICAgZnVuY3Rpb24gbGluZShkYXRhKSB7XG4gICAgICAgICAgICB2YXIgaSwgbiA9IGRhdGEubGVuZ3RoLCBkLCBkZWZpbmVkMCA9IGZhbHNlLCBidWZmZXI7XG4gICAgICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IGQzUGF0aC5wYXRoKCkpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMClcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRlZmluZWQwKVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucG9pbnQoK3gkMShkLCBpLCBkYXRhKSwgK3kkMShkLCBpLCBkYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGluZS54ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHgkMTtcbiAgICAgICAgfTtcbiAgICAgICAgbGluZS55ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHkkMTtcbiAgICAgICAgfTtcbiAgICAgICAgbGluZS5kZWZpbmVkID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlZmluZWQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGxpbmUpIDogZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgbGluZS5jdXJ2ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjdXJ2ZSA9IF8sIGNvbnRleHQgIT0gbnVsbCAmJiAob3V0cHV0ID0gY3VydmUoY29udGV4dCkpLCBsaW5lKSA6IGN1cnZlO1xuICAgICAgICB9O1xuICAgICAgICBsaW5lLmNvbnRleHQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoXyA9PSBudWxsID8gY29udGV4dCA9IG91dHB1dCA9IG51bGwgOiBvdXRwdXQgPSBjdXJ2ZShjb250ZXh0ID0gXyksIGxpbmUpIDogY29udGV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFyZWEoKSB7XG4gICAgICAgIHZhciB4MCA9IHgsIHgxID0gbnVsbCwgeTAgPSBjb25zdGFudCgwKSwgeTEgPSB5LCBkZWZpbmVkID0gY29uc3RhbnQodHJ1ZSksIGNvbnRleHQgPSBudWxsLCBjdXJ2ZSA9IGN1cnZlTGluZWFyLCBvdXRwdXQgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBhcmVhKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBpLCBqLCBrLCBuID0gZGF0YS5sZW5ndGgsIGQsIGRlZmluZWQwID0gZmFsc2UsIGJ1ZmZlciwgeDB6ID0gbmV3IEFycmF5KG4pLCB5MHogPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IGQzUGF0aC5wYXRoKCkpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShpIDwgbiAmJiBkZWZpbmVkKGQgPSBkYXRhW2ldLCBpLCBkYXRhKSkgPT09IGRlZmluZWQwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkMCA9ICFkZWZpbmVkMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYXJlYVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gaSAtIDE7IGsgPj0gajsgLS1rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnBvaW50KHgweltrXSwgeTB6W2tdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuYXJlYUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkMCkge1xuICAgICAgICAgICAgICAgICAgICB4MHpbaV0gPSAreDAoZCwgaSwgZGF0YSksIHkweltpXSA9ICt5MChkLCBpLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnBvaW50KHgxID8gK3gxKGQsIGksIGRhdGEpIDogeDB6W2ldLCB5MSA/ICt5MShkLCBpLCBkYXRhKSA6IHkweltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFyZWFsaW5lKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmUoKS5kZWZpbmVkKGRlZmluZWQpLmN1cnZlKGN1cnZlKS5jb250ZXh0KGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGFyZWEueCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB4MSA9IG51bGwsIGFyZWEpIDogeDA7XG4gICAgICAgIH07XG4gICAgICAgIGFyZWEueDAgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MDtcbiAgICAgICAgfTtcbiAgICAgICAgYXJlYS54MSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MTtcbiAgICAgICAgfTtcbiAgICAgICAgYXJlYS55ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHkxID0gbnVsbCwgYXJlYSkgOiB5MDtcbiAgICAgICAgfTtcbiAgICAgICAgYXJlYS55MCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5MCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkwO1xuICAgICAgICB9O1xuICAgICAgICBhcmVhLnkxID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkxO1xuICAgICAgICB9O1xuICAgICAgICBhcmVhLmxpbmVYMCA9XG4gICAgICAgICAgICBhcmVhLmxpbmVZMCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgwKS55KHkwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGFyZWEubGluZVkxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MCkueSh5MSk7XG4gICAgICAgIH07XG4gICAgICAgIGFyZWEubGluZVgxID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MSkueSh5MCk7XG4gICAgICAgIH07XG4gICAgICAgIGFyZWEuZGVmaW5lZCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWZpbmVkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCBhcmVhKSA6IGRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIGFyZWEuY3VydmUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY3VydmUgPSBfLCBjb250ZXh0ICE9IG51bGwgJiYgKG91dHB1dCA9IGN1cnZlKGNvbnRleHQpKSwgYXJlYSkgOiBjdXJ2ZTtcbiAgICAgICAgfTtcbiAgICAgICAgYXJlYS5jb250ZXh0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBhcmVhKSA6IGNvbnRleHQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhcmVhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpZGVudGl0eShkKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwaWUoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGlkZW50aXR5LCBzb3J0VmFsdWVzID0gZGVzY2VuZGluZywgc29ydCA9IG51bGwsIHN0YXJ0QW5nbGUgPSBjb25zdGFudCgwKSwgZW5kQW5nbGUgPSBjb25zdGFudCh0YXUpLCBwYWRBbmdsZSA9IGNvbnN0YW50KDApO1xuICAgICAgICBmdW5jdGlvbiBwaWUoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGksIG4gPSBkYXRhLmxlbmd0aCwgaiwgaywgc3VtID0gMCwgaW5kZXggPSBuZXcgQXJyYXkobiksIGFyY3MgPSBuZXcgQXJyYXkobiksIGEwID0gK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgZGEgPSBNYXRoLm1pbih0YXUsIE1hdGgubWF4KC10YXUsIGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBhMCkpLCBhMSwgcCA9IE1hdGgubWluKE1hdGguYWJzKGRhKSAvIG4sIHBhZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLCBwYSA9IHAgKiAoZGEgPCAwID8gLTEgOiAxKSwgdjtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHYgPSBhcmNzW2luZGV4W2ldID0gaV0gPSArdmFsdWUoZGF0YVtpXSwgaSwgZGF0YSkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPcHRpb25hbGx5IHNvcnQgdGhlIGFyY3MgYnkgcHJldmlvdXNseS1jb21wdXRlZCB2YWx1ZXMgb3IgYnkgZGF0YS5cbiAgICAgICAgICAgIGlmIChzb3J0VmFsdWVzICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaW5kZXguc29ydChmdW5jdGlvbiAoaSwgaikgeyByZXR1cm4gc29ydFZhbHVlcyhhcmNzW2ldLCBhcmNzW2pdKTsgfSk7XG4gICAgICAgICAgICBlbHNlIGlmIChzb3J0ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaW5kZXguc29ydChmdW5jdGlvbiAoaSwgaikgeyByZXR1cm4gc29ydChkYXRhW2ldLCBkYXRhW2pdKTsgfSk7XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBhcmNzISBUaGV5IGFyZSBzdG9yZWQgaW4gdGhlIG9yaWdpbmFsIGRhdGEncyBvcmRlci5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGsgPSBzdW0gPyAoZGEgLSBuICogcGEpIC8gc3VtIDogMDsgaSA8IG47ICsraSwgYTAgPSBhMSkge1xuICAgICAgICAgICAgICAgIGogPSBpbmRleFtpXSwgdiA9IGFyY3Nbal0sIGExID0gYTAgKyAodiA+IDAgPyB2ICogayA6IDApICsgcGEsIGFyY3Nbal0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFbal0sXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogYTAsXG4gICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlOiBhMSxcbiAgICAgICAgICAgICAgICAgICAgcGFkQW5nbGU6IHBcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyY3M7XG4gICAgICAgIH1cbiAgICAgICAgcGllLnZhbHVlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcGllLnNvcnRWYWx1ZXMgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydFZhbHVlcyA9IF8sIHNvcnQgPSBudWxsLCBwaWUpIDogc29ydFZhbHVlcztcbiAgICAgICAgfTtcbiAgICAgICAgcGllLnNvcnQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydCA9IF8sIHNvcnRWYWx1ZXMgPSBudWxsLCBwaWUpIDogc29ydDtcbiAgICAgICAgfTtcbiAgICAgICAgcGllLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogc3RhcnRBbmdsZTtcbiAgICAgICAgfTtcbiAgICAgICAgcGllLmVuZEFuZ2xlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBlbmRBbmdsZTtcbiAgICAgICAgfTtcbiAgICAgICAgcGllLnBhZEFuZ2xlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBwYWRBbmdsZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBpZTtcbiAgICB9XG4gICAgdmFyIGN1cnZlUmFkaWFsTGluZWFyID0gY3VydmVSYWRpYWwoY3VydmVMaW5lYXIpO1xuICAgIGZ1bmN0aW9uIFJhZGlhbChjdXJ2ZSkge1xuICAgICAgICB0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xuICAgIH1cbiAgICBSYWRpYWwucHJvdG90eXBlID0ge1xuICAgICAgICBhcmVhU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlLmFyZWFTdGFydCgpO1xuICAgICAgICB9LFxuICAgICAgICBhcmVhRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZS5hcmVhRW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY3VydmUubGluZVN0YXJ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnZlLmxpbmVFbmQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uIChhLCByKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJ2ZS5wb2ludChyICogTWF0aC5zaW4oYSksIHIgKiAtTWF0aC5jb3MoYSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjdXJ2ZVJhZGlhbChjdXJ2ZSkge1xuICAgICAgICBmdW5jdGlvbiByYWRpYWwoY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYWRpYWwoY3VydmUoY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIHJhZGlhbC5fY3VydmUgPSBjdXJ2ZTtcbiAgICAgICAgcmV0dXJuIHJhZGlhbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZVJhZGlhbChsKSB7XG4gICAgICAgIHZhciBjID0gbC5jdXJ2ZTtcbiAgICAgICAgbC5hbmdsZSA9IGwueCwgZGVsZXRlIGwueDtcbiAgICAgICAgbC5yYWRpdXMgPSBsLnksIGRlbGV0ZSBsLnk7XG4gICAgICAgIGwuY3VydmUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjKGN1cnZlUmFkaWFsKF8pKSA6IGMoKS5fY3VydmU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lUmFkaWFsJDEoKSB7XG4gICAgICAgIHJldHVybiBsaW5lUmFkaWFsKGxpbmUoKS5jdXJ2ZShjdXJ2ZVJhZGlhbExpbmVhcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcmVhUmFkaWFsKCkge1xuICAgICAgICB2YXIgYSA9IGFyZWEoKS5jdXJ2ZShjdXJ2ZVJhZGlhbExpbmVhciksIGMgPSBhLmN1cnZlLCB4MCA9IGEubGluZVgwLCB4MSA9IGEubGluZVgxLCB5MCA9IGEubGluZVkwLCB5MSA9IGEubGluZVkxO1xuICAgICAgICBhLmFuZ2xlID0gYS54LCBkZWxldGUgYS54O1xuICAgICAgICBhLnN0YXJ0QW5nbGUgPSBhLngwLCBkZWxldGUgYS54MDtcbiAgICAgICAgYS5lbmRBbmdsZSA9IGEueDEsIGRlbGV0ZSBhLngxO1xuICAgICAgICBhLnJhZGl1cyA9IGEueSwgZGVsZXRlIGEueTtcbiAgICAgICAgYS5pbm5lclJhZGl1cyA9IGEueTAsIGRlbGV0ZSBhLnkwO1xuICAgICAgICBhLm91dGVyUmFkaXVzID0gYS55MSwgZGVsZXRlIGEueTE7XG4gICAgICAgIGEubGluZVN0YXJ0QW5nbGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5lUmFkaWFsKHgwKCkpOyB9LCBkZWxldGUgYS5saW5lWDA7XG4gICAgICAgIGEubGluZUVuZEFuZ2xlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbGluZVJhZGlhbCh4MSgpKTsgfSwgZGVsZXRlIGEubGluZVgxO1xuICAgICAgICBhLmxpbmVJbm5lclJhZGl1cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmVSYWRpYWwoeTAoKSk7IH0sIGRlbGV0ZSBhLmxpbmVZMDtcbiAgICAgICAgYS5saW5lT3V0ZXJSYWRpdXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBsaW5lUmFkaWFsKHkxKCkpOyB9LCBkZWxldGUgYS5saW5lWTE7XG4gICAgICAgIGEuY3VydmUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBjKGN1cnZlUmFkaWFsKF8pKSA6IGMoKS5fY3VydmU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludFJhZGlhbCh4LCB5KSB7XG4gICAgICAgIHJldHVybiBbKHkgPSAreSkgKiBNYXRoLmNvcyh4IC09IE1hdGguUEkgLyAyKSwgeSAqIE1hdGguc2luKHgpXTtcbiAgICB9XG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgIGZ1bmN0aW9uIGxpbmtTb3VyY2UoZCkge1xuICAgICAgICByZXR1cm4gZC5zb3VyY2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmtUYXJnZXQoZCkge1xuICAgICAgICByZXR1cm4gZC50YXJnZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmsoY3VydmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGxpbmtTb3VyY2UsIHRhcmdldCA9IGxpbmtUYXJnZXQsIHgkMSA9IHgsIHkkMSA9IHksIGNvbnRleHQgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBsaW5rKCkge1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciwgYXJndiA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSwgcyA9IHNvdXJjZS5hcHBseSh0aGlzLCBhcmd2KSwgdCA9IHRhcmdldC5hcHBseSh0aGlzLCBhcmd2KTtcbiAgICAgICAgICAgIGlmICghY29udGV4dClcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gYnVmZmVyID0gZDNQYXRoLnBhdGgoKTtcbiAgICAgICAgICAgIGN1cnZlKGNvbnRleHQsICt4JDEuYXBwbHkodGhpcywgKGFyZ3ZbMF0gPSBzLCBhcmd2KSksICt5JDEuYXBwbHkodGhpcywgYXJndiksICt4JDEuYXBwbHkodGhpcywgKGFyZ3ZbMF0gPSB0LCBhcmd2KSksICt5JDEuYXBwbHkodGhpcywgYXJndikpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsaW5rLnNvdXJjZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3VyY2UgPSBfLCBsaW5rKSA6IHNvdXJjZTtcbiAgICAgICAgfTtcbiAgICAgICAgbGluay50YXJnZXQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGFyZ2V0ID0gXywgbGluaykgOiB0YXJnZXQ7XG4gICAgICAgIH07XG4gICAgICAgIGxpbmsueCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4JDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluaykgOiB4JDE7XG4gICAgICAgIH07XG4gICAgICAgIGxpbmsueSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5JDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgbGluaykgOiB5JDE7XG4gICAgICAgIH07XG4gICAgICAgIGxpbmsuY29udGV4dCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfKSwgbGluaykgOiBjb250ZXh0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbGluaztcbiAgICB9XG4gICAgZnVuY3Rpb24gY3VydmVIb3Jpem9udGFsKGNvbnRleHQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCA9ICh4MCArIHgxKSAvIDIsIHkwLCB4MCwgeTEsIHgxLCB5MSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN1cnZlVmVydGljYWwoY29udGV4dCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgwLCB5MCA9ICh5MCArIHkxKSAvIDIsIHgxLCB5MCwgeDEsIHkxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3VydmVSYWRpYWwkMShjb250ZXh0LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgICB2YXIgcDAgPSBwb2ludFJhZGlhbCh4MCwgeTApLCBwMSA9IHBvaW50UmFkaWFsKHgwLCB5MCA9ICh5MCArIHkxKSAvIDIpLCBwMiA9IHBvaW50UmFkaWFsKHgxLCB5MCksIHAzID0gcG9pbnRSYWRpYWwoeDEsIHkxKTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8ocDBbMF0sIHAwWzFdKTtcbiAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHAxWzBdLCBwMVsxXSwgcDJbMF0sIHAyWzFdLCBwM1swXSwgcDNbMV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5rSG9yaXpvbnRhbCgpIHtcbiAgICAgICAgcmV0dXJuIGxpbmsoY3VydmVIb3Jpem9udGFsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGlua1ZlcnRpY2FsKCkge1xuICAgICAgICByZXR1cm4gbGluayhjdXJ2ZVZlcnRpY2FsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGlua1JhZGlhbCgpIHtcbiAgICAgICAgdmFyIGwgPSBsaW5rKGN1cnZlUmFkaWFsJDEpO1xuICAgICAgICBsLmFuZ2xlID0gbC54LCBkZWxldGUgbC54O1xuICAgICAgICBsLnJhZGl1cyA9IGwueSwgZGVsZXRlIGwueTtcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgfVxuICAgIHZhciBjaXJjbGUgPSB7XG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICAgICAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gcGkpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8ociwgMCk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByLCAwLCB0YXUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY3Jvc3MgPSB7XG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICAgICAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oLTMgKiByLCAtcik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygtciwgLXIpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oLXIsIC0zICogcik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhyLCAtMyAqIHIpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ociwgLXIpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oMyAqIHIsIC1yKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKDMgKiByLCByKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHIsIHIpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ociwgMyAqIHIpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oLXIsIDMgKiByKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKC1yLCByKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKC0zICogciwgcik7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgdGFuMzAgPSBNYXRoLnNxcnQoMSAvIDMpLCB0YW4zMF8yID0gdGFuMzAgKiAyO1xuICAgIHZhciBkaWFtb25kID0ge1xuICAgICAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgICAgICAgdmFyIHkgPSBNYXRoLnNxcnQoc2l6ZSAvIHRhbjMwXzIpLCB4ID0geSAqIHRhbjMwO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgLXkpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeCwgMCk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbygwLCB5KTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKC14LCAwKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBrYSA9IDAuODkwODEzMDkxNTI5Mjg1MjI4MTAsIGtyID0gTWF0aC5zaW4ocGkgLyAxMCkgLyBNYXRoLnNpbig3ICogcGkgLyAxMCksIGt4ID0gTWF0aC5zaW4odGF1IC8gMTApICoga3IsIGt5ID0gLU1hdGguY29zKHRhdSAvIDEwKSAqIGtyO1xuICAgIHZhciBzdGFyID0ge1xuICAgICAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAqIGthKSwgeCA9IGt4ICogciwgeSA9IGt5ICogcjtcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIC1yKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHRhdSAqIGkgLyA1LCBjID0gTWF0aC5jb3MoYSksIHMgPSBNYXRoLnNpbihhKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhzICogciwgLWMgKiByKTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyhjICogeCAtIHMgKiB5LCBzICogeCArIGMgKiB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzcXVhcmUgPSB7XG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICAgICAgICB2YXIgdyA9IE1hdGguc3FydChzaXplKSwgeCA9IC13IC8gMjtcbiAgICAgICAgICAgIGNvbnRleHQucmVjdCh4LCB4LCB3LCB3KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNxcnQzID0gTWF0aC5zcXJ0KDMpO1xuICAgIHZhciB0cmlhbmdsZSA9IHtcbiAgICAgICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgICAgICAgIHZhciB5ID0gLU1hdGguc3FydChzaXplIC8gKHNxcnQzICogMykpO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgeSAqIDIpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oLXNxcnQzICogeSwgLXkpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oc3FydDMgKiB5LCAteSk7XG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgYyA9IC0wLjUsIHMgPSBNYXRoLnNxcnQoMykgLyAyLCBrID0gMSAvIE1hdGguc3FydCgxMiksIGEgPSAoayAvIDIgKyAxKSAqIDM7XG4gICAgdmFyIHd5ZSA9IHtcbiAgICAgICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgICAgICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgLyBhKSwgeDAgPSByIC8gMiwgeTAgPSByICogaywgeDEgPSB4MCwgeTEgPSByICogayArIHIsIHgyID0gLXgxLCB5MiA9IHkxO1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHgxLCB5MSk7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYyAqIHgwIC0gcyAqIHkwLCBzICogeDAgKyBjICogeTApO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYyAqIHgxIC0gcyAqIHkxLCBzICogeDEgKyBjICogeTEpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYyAqIHgyIC0gcyAqIHkyLCBzICogeDIgKyBjICogeTIpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYyAqIHgwICsgcyAqIHkwLCBjICogeTAgLSBzICogeDApO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYyAqIHgxICsgcyAqIHkxLCBjICogeTEgLSBzICogeDEpO1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oYyAqIHgyICsgcyAqIHkyLCBjICogeTIgLSBzICogeDIpO1xuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN5bWJvbHMgPSBbXG4gICAgICAgIGNpcmNsZSxcbiAgICAgICAgY3Jvc3MsXG4gICAgICAgIGRpYW1vbmQsXG4gICAgICAgIHNxdWFyZSxcbiAgICAgICAgc3RhcixcbiAgICAgICAgdHJpYW5nbGUsXG4gICAgICAgIHd5ZVxuICAgIF07XG4gICAgZnVuY3Rpb24gc3ltYm9sKCkge1xuICAgICAgICB2YXIgdHlwZSA9IGNvbnN0YW50KGNpcmNsZSksIHNpemUgPSBjb25zdGFudCg2NCksIGNvbnRleHQgPSBudWxsO1xuICAgICAgICBmdW5jdGlvbiBzeW1ib2woKSB7XG4gICAgICAgICAgICB2YXIgYnVmZmVyO1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0KVxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBidWZmZXIgPSBkM1BhdGgucGF0aCgpO1xuICAgICAgICAgICAgdHlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmRyYXcoY29udGV4dCwgK3NpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN5bWJvbC50eXBlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHR5cGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBzeW1ib2wpIDogdHlwZTtcbiAgICAgICAgfTtcbiAgICAgICAgc3ltYm9sLnNpemUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2l6ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBzeW1ib2wpIDogc2l6ZTtcbiAgICAgICAgfTtcbiAgICAgICAgc3ltYm9sLmNvbnRleHQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfLCBzeW1ib2wpIDogY29udGV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN5bWJvbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCgpIHsgfVxuICAgIGZ1bmN0aW9uIHBvaW50KHRoYXQsIHgsIHkpIHtcbiAgICAgICAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKCgyICogdGhhdC5feDAgKyB0aGF0Ll94MSkgLyAzLCAoMiAqIHRoYXQuX3kwICsgdGhhdC5feTEpIC8gMywgKHRoYXQuX3gwICsgMiAqIHRoYXQuX3gxKSAvIDMsICh0aGF0Ll95MCArIDIgKiB0aGF0Ll95MSkgLyAzLCAodGhhdC5feDAgKyA0ICogdGhhdC5feDEgKyB4KSAvIDYsICh0aGF0Ll95MCArIDQgKiB0aGF0Ll95MSArIHkpIC8gNik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJhc2lzKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIEJhc2lzLnByb3RvdHlwZSA9IHtcbiAgICAgICAgYXJlYVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICAgICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOO1xuICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiBwb2ludCh0aGlzLCB0aGlzLl94MSwgdGhpcy5feTEpOyAvLyBwcm9jZWVkXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSlcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHggPSAreCwgeSA9ICt5O1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbygoNSAqIHRoaXMuX3gwICsgdGhpcy5feDEpIC8gNiwgKDUgKiB0aGlzLl95MCArIHRoaXMuX3kxKSAvIDYpOyAvLyBwcm9jZWVkXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQodGhpcywgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgICAgICAgICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBiYXNpcyhjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzaXMoY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJhc2lzQ2xvc2VkKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIEJhc2lzQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgICAgICAgYXJlYVN0YXJ0OiBub29wLFxuICAgICAgICBhcmVhRW5kOiBub29wLFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9IHRoaXMuX3gzID0gdGhpcy5feDQgPVxuICAgICAgICAgICAgICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSBOYU47XG4gICAgICAgICAgICB0aGlzLl9wb2ludCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbygodGhpcy5feDIgKyAyICogdGhpcy5feDMpIC8gMywgKHRoaXMuX3kyICsgMiAqIHRoaXMuX3kzKSAvIDMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbygodGhpcy5feDMgKyAyICogdGhpcy5feDIpIC8gMywgKHRoaXMuX3kzICsgMiAqIHRoaXMuX3kyKSAvIDMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB4ID0gK3gsIHkgPSAreTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feDIgPSB4LCB0aGlzLl95MiA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94MyA9IHgsIHRoaXMuX3kzID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbygodGhpcy5feDAgKyA0ICogdGhpcy5feDEgKyB4KSAvIDYsICh0aGlzLl95MCArIDQgKiB0aGlzLl95MSArIHkpIC8gNik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHBvaW50KHRoaXMsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICAgICAgICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gYmFzaXNDbG9zZWQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2lzQ2xvc2VkKGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBCYXNpc09wZW4oY29udGV4dCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgQmFzaXNPcGVuLnByb3RvdHlwZSA9IHtcbiAgICAgICAgYXJlYVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxID1cbiAgICAgICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gTmFOO1xuICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB4ID0gK3gsIHkgPSAreTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeDAgPSAodGhpcy5feDAgKyA0ICogdGhpcy5feDEgKyB4KSAvIDYsIHkwID0gKHRoaXMuX3kwICsgNCAqIHRoaXMuX3kxICsgeSkgLyA2O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeDAsIHkwKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQodGhpcywgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgICAgICAgICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBiYXNpc09wZW4oY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2lzT3Blbihjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQnVuZGxlKGNvbnRleHQsIGJldGEpIHtcbiAgICAgICAgdGhpcy5fYmFzaXMgPSBuZXcgQmFzaXMoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX2JldGEgPSBiZXRhO1xuICAgIH1cbiAgICBCdW5kbGUucHJvdG90eXBlID0ge1xuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3kgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Jhc2lzLmxpbmVTdGFydCgpO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCBqID0geC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHgwID0geFswXSwgeTAgPSB5WzBdLCBkeCA9IHhbal0gLSB4MCwgZHkgPSB5W2pdIC0geTAsIGkgPSAtMSwgdDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDw9IGopIHtcbiAgICAgICAgICAgICAgICAgICAgdCA9IGkgLyBqO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iYXNpcy5wb2ludCh0aGlzLl9iZXRhICogeFtpXSArICgxIC0gdGhpcy5fYmV0YSkgKiAoeDAgKyB0ICogZHgpLCB0aGlzLl9iZXRhICogeVtpXSArICgxIC0gdGhpcy5fYmV0YSkgKiAoeTAgKyB0ICogZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl94ID0gdGhpcy5feSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9iYXNpcy5saW5lRW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgdGhpcy5feC5wdXNoKCt4KTtcbiAgICAgICAgICAgIHRoaXMuX3kucHVzaCgreSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBidW5kbGUgPSAoZnVuY3Rpb24gY3VzdG9tKGJldGEpIHtcbiAgICAgICAgZnVuY3Rpb24gYnVuZGxlKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBiZXRhID09PSAxID8gbmV3IEJhc2lzKGNvbnRleHQpIDogbmV3IEJ1bmRsZShjb250ZXh0LCBiZXRhKTtcbiAgICAgICAgfVxuICAgICAgICBidW5kbGUuYmV0YSA9IGZ1bmN0aW9uIChiZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tKCtiZXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGJ1bmRsZTtcbiAgICB9KSgwLjg1KTtcbiAgICBmdW5jdGlvbiBwb2ludCQxKHRoYXQsIHgsIHkpIHtcbiAgICAgICAgdGhhdC5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHRoYXQuX3gxICsgdGhhdC5fayAqICh0aGF0Ll94MiAtIHRoYXQuX3gwKSwgdGhhdC5feTEgKyB0aGF0Ll9rICogKHRoYXQuX3kyIC0gdGhhdC5feTApLCB0aGF0Ll94MiArIHRoYXQuX2sgKiAodGhhdC5feDEgLSB4KSwgdGhhdC5feTIgKyB0aGF0Ll9rICogKHRoYXQuX3kxIC0geSksIHRoYXQuX3gyLCB0aGF0Ll95Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENhcmRpbmFsKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbiAgICB9XG4gICAgQ2FyZGluYWwucHJvdG90eXBlID0ge1xuICAgICAgICBhcmVhU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBhcmVhRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gTmFOO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgICAgICAgICAgICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHBvaW50JDEodGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB4ID0gK3gsIHkgPSAreTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94MSA9IHgsIHRoaXMuX3kxID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IC8vIHByb2NlZWRcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwb2ludCQxKHRoaXMsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICAgICAgICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNhcmRpbmFsID0gKGZ1bmN0aW9uIGN1c3RvbSh0ZW5zaW9uKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNhcmRpbmFsKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FyZGluYWwoY29udGV4dCwgdGVuc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uICh0ZW5zaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhcmRpbmFsO1xuICAgIH0pKDApO1xuICAgIGZ1bmN0aW9uIENhcmRpbmFsQ2xvc2VkKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbiAgICB9XG4gICAgQ2FyZGluYWxDbG9zZWQucHJvdG90eXBlID0ge1xuICAgICAgICBhcmVhU3RhcnQ6IG5vb3AsXG4gICAgICAgIGFyZWFFbmQ6IG5vb3AsXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9IHRoaXMuX3g1ID1cbiAgICAgICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gdGhpcy5feTUgPSBOYU47XG4gICAgICAgICAgICB0aGlzLl9wb2ludCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB4ID0gK3gsIHkgPSAreTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feDMgPSB4LCB0aGlzLl95MyA9IHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94NSA9IHgsIHRoaXMuX3k1ID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQkMSh0aGlzLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjYXJkaW5hbENsb3NlZCA9IChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xuICAgICAgICBmdW5jdGlvbiBjYXJkaW5hbChjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENhcmRpbmFsQ2xvc2VkKGNvbnRleHQsIHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbiAodGVuc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYXJkaW5hbDtcbiAgICB9KSgwKTtcbiAgICBmdW5jdGlvbiBDYXJkaW5hbE9wZW4oY29udGV4dCwgdGVuc2lvbikge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fayA9ICgxIC0gdGVuc2lvbikgLyA2O1xuICAgIH1cbiAgICBDYXJkaW5hbE9wZW4ucHJvdG90eXBlID0ge1xuICAgICAgICBhcmVhU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBhcmVhRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gTmFOO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgICAgICAgICAgICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB4ID0gK3gsIHkgPSAreTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQkMSh0aGlzLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjYXJkaW5hbE9wZW4gPSAoZnVuY3Rpb24gY3VzdG9tKHRlbnNpb24pIHtcbiAgICAgICAgZnVuY3Rpb24gY2FyZGluYWwoY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYXJkaW5hbE9wZW4oY29udGV4dCwgdGVuc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uICh0ZW5zaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhcmRpbmFsO1xuICAgIH0pKDApO1xuICAgIGZ1bmN0aW9uIHBvaW50JDIodGhhdCwgeCwgeSkge1xuICAgICAgICB2YXIgeDEgPSB0aGF0Ll94MSwgeTEgPSB0aGF0Ll95MSwgeDIgPSB0aGF0Ll94MiwgeTIgPSB0aGF0Ll95MjtcbiAgICAgICAgaWYgKHRoYXQuX2wwMV9hID4gZXBzaWxvbikge1xuICAgICAgICAgICAgdmFyIGEgPSAyICogdGhhdC5fbDAxXzJhICsgMyAqIHRoYXQuX2wwMV9hICogdGhhdC5fbDEyX2EgKyB0aGF0Ll9sMTJfMmEsIG4gPSAzICogdGhhdC5fbDAxX2EgKiAodGhhdC5fbDAxX2EgKyB0aGF0Ll9sMTJfYSk7XG4gICAgICAgICAgICB4MSA9ICh4MSAqIGEgLSB0aGF0Ll94MCAqIHRoYXQuX2wxMl8yYSArIHRoYXQuX3gyICogdGhhdC5fbDAxXzJhKSAvIG47XG4gICAgICAgICAgICB5MSA9ICh5MSAqIGEgLSB0aGF0Ll95MCAqIHRoYXQuX2wxMl8yYSArIHRoYXQuX3kyICogdGhhdC5fbDAxXzJhKSAvIG47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoYXQuX2wyM19hID4gZXBzaWxvbikge1xuICAgICAgICAgICAgdmFyIGIgPSAyICogdGhhdC5fbDIzXzJhICsgMyAqIHRoYXQuX2wyM19hICogdGhhdC5fbDEyX2EgKyB0aGF0Ll9sMTJfMmEsIG0gPSAzICogdGhhdC5fbDIzX2EgKiAodGhhdC5fbDIzX2EgKyB0aGF0Ll9sMTJfYSk7XG4gICAgICAgICAgICB4MiA9ICh4MiAqIGIgKyB0aGF0Ll94MSAqIHRoYXQuX2wyM18yYSAtIHggKiB0aGF0Ll9sMTJfMmEpIC8gbTtcbiAgICAgICAgICAgIHkyID0gKHkyICogYiArIHRoYXQuX3kxICogdGhhdC5fbDIzXzJhIC0geSAqIHRoYXQuX2wxMl8yYSkgLyBtO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgdGhhdC5feDIsIHRoYXQuX3kyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ2F0bXVsbFJvbShjb250ZXh0LCBhbHBoYSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbiAgICB9XG4gICAgQ2F0bXVsbFJvbS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGFyZWFTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGFyZWFFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICAgICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgICAgICAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2EgPVxuICAgICAgICAgICAgICAgIHRoaXMuX2wwMV8yYSA9IHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LCB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyAvLyBwcm9jZWVkXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQkMih0aGlzLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgICAgICAgICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjYXRtdWxsUm9tID0gKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuICAgICAgICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbChjb250ZXh0LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRtdWxsUm9tLmFscGhhID0gZnVuY3Rpb24gKGFscGhhKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYXRtdWxsUm9tO1xuICAgIH0pKDAuNSk7XG4gICAgZnVuY3Rpb24gQ2F0bXVsbFJvbUNsb3NlZChjb250ZXh0LCBhbHBoYSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbiAgICB9XG4gICAgQ2F0bXVsbFJvbUNsb3NlZC5wcm90b3R5cGUgPSB7XG4gICAgICAgIGFyZWFTdGFydDogbm9vcCxcbiAgICAgICAgYXJlYUVuZDogbm9vcCxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxID0gdGhpcy5feDIgPSB0aGlzLl94MyA9IHRoaXMuX3g0ID0gdGhpcy5feDUgPVxuICAgICAgICAgICAgICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSB0aGlzLl95MiA9IHRoaXMuX3kzID0gdGhpcy5feTQgPSB0aGlzLl95NSA9IE5hTjtcbiAgICAgICAgICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgICAgICAgICAgICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnQodGhpcy5feDQsIHRoaXMuX3k0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NSwgdGhpcy5feTUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgeDIzID0gdGhpcy5feDIgLSB4LCB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl94MyA9IHgsIHRoaXMuX3kzID0geTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3g0ID0geCwgdGhpcy5feTQgPSB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3g1ID0geCwgdGhpcy5feTUgPSB5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwb2ludCQyKHRoaXMsIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgICAgICAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEsIHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYTtcbiAgICAgICAgICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0gdGhpcy5feDIsIHRoaXMuX3gyID0geDtcbiAgICAgICAgICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGNhdG11bGxSb21DbG9zZWQgPSAoZnVuY3Rpb24gY3VzdG9tKGFscGhhKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGFscGhhID8gbmV3IENhdG11bGxSb21DbG9zZWQoY29udGV4dCwgYWxwaGEpIDogbmV3IENhcmRpbmFsQ2xvc2VkKGNvbnRleHQsIDApO1xuICAgICAgICB9XG4gICAgICAgIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbiAoYWxwaGEpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhdG11bGxSb207XG4gICAgfSkoMC41KTtcbiAgICBmdW5jdGlvbiBDYXRtdWxsUm9tT3Blbihjb250ZXh0LCBhbHBoYSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbiAgICB9XG4gICAgQ2F0bXVsbFJvbU9wZW4ucHJvdG90eXBlID0ge1xuICAgICAgICBhcmVhU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBhcmVhRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gTmFOO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgICAgICAgICAgICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgICAgICAgICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICAgICAgICAgICAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSlcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHggPSAreCwgeSA9ICt5O1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCwgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2wyM19hID0gTWF0aC5zcXJ0KHRoaXMuX2wyM18yYSA9IE1hdGgucG93KHgyMyAqIHgyMyArIHkyMyAqIHkyMywgdGhpcy5fYWxwaGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogdGhpcy5fcG9pbnQgPSA0OyAvLyBwcm9jZWVkXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQkMih0aGlzLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sMDFfYSA9IHRoaXMuX2wxMl9hLCB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hO1xuICAgICAgICAgICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHRoaXMuX3kyLCB0aGlzLl95MiA9IHk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjYXRtdWxsUm9tT3BlbiA9IChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcbiAgICAgICAgZnVuY3Rpb24gY2F0bXVsbFJvbShjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbU9wZW4oY29udGV4dCwgYWxwaGEpIDogbmV3IENhcmRpbmFsT3Blbihjb250ZXh0LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRtdWxsUm9tLmFscGhhID0gZnVuY3Rpb24gKGFscGhhKSB7XG4gICAgICAgICAgICByZXR1cm4gY3VzdG9tKCthbHBoYSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYXRtdWxsUm9tO1xuICAgIH0pKDAuNSk7XG4gICAgZnVuY3Rpb24gTGluZWFyQ2xvc2VkKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIExpbmVhckNsb3NlZC5wcm90b3R5cGUgPSB7XG4gICAgICAgIGFyZWFTdGFydDogbm9vcCxcbiAgICAgICAgYXJlYUVuZDogbm9vcCxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2ludCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wb2ludClcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHggPSAreCwgeSA9ICt5O1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BvaW50KVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMSwgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxpbmVhckNsb3NlZChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZWFyQ2xvc2VkKGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgICAgcmV0dXJuIHggPCAwID8gLTEgOiAxO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHNsb3BlcyBvZiB0aGUgdGFuZ2VudHMgKEhlcm1pdGUtdHlwZSBpbnRlcnBvbGF0aW9uKSBiYXNlZCBvblxuICAgIC8vIHRoZSBmb2xsb3dpbmcgcGFwZXI6IFN0ZWZmZW4sIE0uIDE5OTAuIEEgU2ltcGxlIE1ldGhvZCBmb3IgTW9ub3RvbmljXG4gICAgLy8gSW50ZXJwb2xhdGlvbiBpbiBPbmUgRGltZW5zaW9uLiBBc3Ryb25vbXkgYW5kIEFzdHJvcGh5c2ljcywgVm9sLiAyMzksIE5PLlxuICAgIC8vIE5PVihJSSksIFAuIDQ0MywgMTk5MC5cbiAgICBmdW5jdGlvbiBzbG9wZTModGhhdCwgeDIsIHkyKSB7XG4gICAgICAgIHZhciBoMCA9IHRoYXQuX3gxIC0gdGhhdC5feDAsIGgxID0geDIgLSB0aGF0Ll94MSwgczAgPSAodGhhdC5feTEgLSB0aGF0Ll95MCkgLyAoaDAgfHwgaDEgPCAwICYmIC0wKSwgczEgPSAoeTIgLSB0aGF0Ll95MSkgLyAoaDEgfHwgaDAgPCAwICYmIC0wKSwgcCA9IChzMCAqIGgxICsgczEgKiBoMCkgLyAoaDAgKyBoMSk7XG4gICAgICAgIHJldHVybiAoc2lnbihzMCkgKyBzaWduKHMxKSkgKiBNYXRoLm1pbihNYXRoLmFicyhzMCksIE1hdGguYWJzKHMxKSwgMC41ICogTWF0aC5hYnMocCkpIHx8IDA7XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZSBhIG9uZS1zaWRlZCBzbG9wZS5cbiAgICBmdW5jdGlvbiBzbG9wZTIodGhhdCwgdCkge1xuICAgICAgICB2YXIgaCA9IHRoYXQuX3gxIC0gdGhhdC5feDA7XG4gICAgICAgIHJldHVybiBoID8gKDMgKiAodGhhdC5feTEgLSB0aGF0Ll95MCkgLyBoIC0gdCkgLyAyIDogdDtcbiAgICB9XG4gICAgLy8gQWNjb3JkaW5nIHRvIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0N1YmljX0hlcm1pdGVfc3BsaW5lI1JlcHJlc2VudGF0aW9uc1xuICAgIC8vIFwieW91IGNhbiBleHByZXNzIGN1YmljIEhlcm1pdGUgaW50ZXJwb2xhdGlvbiBpbiB0ZXJtcyBvZiBjdWJpYyBCw6l6aWVyIGN1cnZlc1xuICAgIC8vIHdpdGggcmVzcGVjdCB0byB0aGUgZm91ciB2YWx1ZXMgcDAsIHAwICsgbTAgLyAzLCBwMSAtIG0xIC8gMywgcDFcIi5cbiAgICBmdW5jdGlvbiBwb2ludCQzKHRoYXQsIHQwLCB0MSkge1xuICAgICAgICB2YXIgeDAgPSB0aGF0Ll94MCwgeTAgPSB0aGF0Ll95MCwgeDEgPSB0aGF0Ll94MSwgeTEgPSB0aGF0Ll95MSwgZHggPSAoeDEgLSB4MCkgLyAzO1xuICAgICAgICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDAgKyBkeCwgeTAgKyBkeCAqIHQwLCB4MSAtIGR4LCB5MSAtIGR4ICogdDEsIHgxLCB5MSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1vbm90b25lWChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBNb25vdG9uZVgucHJvdG90eXBlID0ge1xuICAgICAgICBhcmVhU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBhcmVhRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gTmFOO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPVxuICAgICAgICAgICAgICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90MCA9IE5hTjtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDEsIHRoaXMuX3kxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBwb2ludCQzKHRoaXMsIHRoaXMuX3QwLCBzbG9wZTIodGhpcywgdGhpcy5fdDApKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgdDEgPSBOYU47XG4gICAgICAgICAgICB4ID0gK3gsIHkgPSAreTtcbiAgICAgICAgICAgIGlmICh4ID09PSB0aGlzLl94MSAmJiB5ID09PSB0aGlzLl95MSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIElnbm9yZSBjb2luY2lkZW50IHBvaW50cy5cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BvaW50ID0gMztcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQkMyh0aGlzLCBzbG9wZTIodGhpcywgdDEgPSBzbG9wZTModGhpcywgeCwgeSkpLCB0MSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHBvaW50JDModGhpcywgdGhpcy5fdDAsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHg7XG4gICAgICAgICAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gICAgICAgICAgICB0aGlzLl90MCA9IHQxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBNb25vdG9uZVkoY29udGV4dCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gbmV3IFJlZmxlY3RDb250ZXh0KGNvbnRleHQpO1xuICAgIH1cbiAgICAoTW9ub3RvbmVZLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9ub3RvbmVYLnByb3RvdHlwZSkpLnBvaW50ID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgTW9ub3RvbmVYLnByb3RvdHlwZS5wb2ludC5jYWxsKHRoaXMsIHksIHgpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gUmVmbGVjdENvbnRleHQoY29udGV4dCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgUmVmbGVjdENvbnRleHQucHJvdG90eXBlID0ge1xuICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7IHRoaXMuX2NvbnRleHQubW92ZVRvKHksIHgpOyB9LFxuICAgICAgICBjbG9zZVBhdGg6IGZ1bmN0aW9uICgpIHsgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTsgfSxcbiAgICAgICAgbGluZVRvOiBmdW5jdGlvbiAoeCwgeSkgeyB0aGlzLl9jb250ZXh0LmxpbmVUbyh5LCB4KTsgfSxcbiAgICAgICAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7IHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh5MSwgeDEsIHkyLCB4MiwgeSwgeCk7IH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIG1vbm90b25lWChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9ub3RvbmVYKGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb25vdG9uZVkoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbm90b25lWShjb250ZXh0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTmF0dXJhbChjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBOYXR1cmFsLnByb3RvdHlwZSA9IHtcbiAgICAgICAgYXJlYVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gMDtcbiAgICAgICAgfSxcbiAgICAgICAgYXJlYUVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl94ID0gW107XG4gICAgICAgICAgICB0aGlzLl95ID0gW107XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5feCwgeSA9IHRoaXMuX3ksIG4gPSB4Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHhbMF0sIHlbMF0pIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeFswXSwgeVswXSk7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeFsxXSwgeVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHggPSBjb250cm9sUG9pbnRzKHgpLCBweSA9IGNvbnRyb2xQb2ludHMoeSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkwID0gMCwgaTEgPSAxOyBpMSA8IG47ICsraTAsICsraTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhweFswXVtpMF0sIHB5WzBdW2kwXSwgcHhbMV1baTBdLCBweVsxXVtpMF0sIHhbaTFdLCB5W2kxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiBuID09PSAxKSlcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICAgICAgICAgICAgdGhpcy5feCA9IHRoaXMuX3kgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgIHRoaXMuX3gucHVzaCgreCk7XG4gICAgICAgICAgICB0aGlzLl95LnB1c2goK3kpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBTZWUgaHR0cHM6Ly93d3cucGFydGljbGVpbmNlbGwuY29tLzIwMTIvYmV6aWVyLXNwbGluZXMvIGZvciBkZXJpdmF0aW9uLlxuICAgIGZ1bmN0aW9uIGNvbnRyb2xQb2ludHMoeCkge1xuICAgICAgICB2YXIgaSwgbiA9IHgubGVuZ3RoIC0gMSwgbSwgYSA9IG5ldyBBcnJheShuKSwgYiA9IG5ldyBBcnJheShuKSwgciA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgYVswXSA9IDAsIGJbMF0gPSAyLCByWzBdID0geFswXSArIDIgKiB4WzFdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbiAtIDE7ICsraSlcbiAgICAgICAgICAgIGFbaV0gPSAxLCBiW2ldID0gNCwgcltpXSA9IDQgKiB4W2ldICsgMiAqIHhbaSArIDFdO1xuICAgICAgICBhW24gLSAxXSA9IDIsIGJbbiAtIDFdID0gNywgcltuIC0gMV0gPSA4ICogeFtuIC0gMV0gKyB4W25dO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKVxuICAgICAgICAgICAgbSA9IGFbaV0gLyBiW2kgLSAxXSwgYltpXSAtPSBtLCByW2ldIC09IG0gKiByW2kgLSAxXTtcbiAgICAgICAgYVtuIC0gMV0gPSByW24gLSAxXSAvIGJbbiAtIDFdO1xuICAgICAgICBmb3IgKGkgPSBuIC0gMjsgaSA+PSAwOyAtLWkpXG4gICAgICAgICAgICBhW2ldID0gKHJbaV0gLSBhW2kgKyAxXSkgLyBiW2ldO1xuICAgICAgICBiW24gLSAxXSA9ICh4W25dICsgYVtuIC0gMV0pIC8gMjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyArK2kpXG4gICAgICAgICAgICBiW2ldID0gMiAqIHhbaSArIDFdIC0gYVtpICsgMV07XG4gICAgICAgIHJldHVybiBbYSwgYl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5hdHVyYWwoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IE5hdHVyYWwoY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFN0ZXAoY29udGV4dCwgdCkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fdCA9IHQ7XG4gICAgfVxuICAgIFN0ZXAucHJvdG90eXBlID0ge1xuICAgICAgICBhcmVhU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmUgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBhcmVhRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lID0gTmFOO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gTmFOO1xuICAgICAgICAgICAgdGhpcy5fcG9pbnQgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBsaW5lRW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoMCA8IHRoaXMuX3QgJiYgdGhpcy5fdCA8IDEgJiYgdGhpcy5fcG9pbnQgPT09IDIpXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgdGhpcy5feSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMSkpXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9saW5lID49IDApXG4gICAgICAgICAgICAgICAgdGhpcy5fdCA9IDEgLSB0aGlzLl90LCB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICAgICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb2ludCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgLy8gcHJvY2VlZFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3QgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4MSA9IHRoaXMuX3ggKiAoMSAtIHRoaXMuX3QpICsgeCAqIHRoaXMuX3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MSwgdGhpcy5feSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MSwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5feCA9IHgsIHRoaXMuX3kgPSB5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBzdGVwKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGVwKGNvbnRleHQsIDAuNSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXBCZWZvcmUoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXBBZnRlcihjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9uZShzZXJpZXMsIG9yZGVyKSB7XG4gICAgICAgIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAxKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGosIHMwLCBzMSA9IHNlcmllc1tvcmRlclswXV0sIG4sIG0gPSBzMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIHMwID0gczEsIHMxID0gc2VyaWVzW29yZGVyW2ldXTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgICAgICBzMVtqXVsxXSArPSBzMVtqXVswXSA9IGlzTmFOKHMwW2pdWzFdKSA/IHMwW2pdWzBdIDogczBbal1bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbm9uZSQxKHNlcmllcykge1xuICAgICAgICB2YXIgbiA9IHNlcmllcy5sZW5ndGgsIG8gPSBuZXcgQXJyYXkobik7XG4gICAgICAgIHdoaWxlICgtLW4gPj0gMClcbiAgICAgICAgICAgIG9bbl0gPSBuO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhY2tWYWx1ZShkLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGRba2V5XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhY2soKSB7XG4gICAgICAgIHZhciBrZXlzID0gY29uc3RhbnQoW10pLCBvcmRlciA9IG5vbmUkMSwgb2Zmc2V0ID0gbm9uZSwgdmFsdWUgPSBzdGFja1ZhbHVlO1xuICAgICAgICBmdW5jdGlvbiBzdGFjayhkYXRhKSB7XG4gICAgICAgICAgICB2YXIga3ogPSBrZXlzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGksIG0gPSBkYXRhLmxlbmd0aCwgbiA9IGt6Lmxlbmd0aCwgc3ogPSBuZXcgQXJyYXkobiksIG96O1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtpID0ga3pbaV0sIHNpID0gc3pbaV0gPSBuZXcgQXJyYXkobSksIGogPSAwLCBzaWo7IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgc2lbal0gPSBzaWogPSBbMCwgK3ZhbHVlKGRhdGFbal0sIGtpLCBqLCBkYXRhKV07XG4gICAgICAgICAgICAgICAgICAgIHNpai5kYXRhID0gZGF0YVtqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2kua2V5ID0ga2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBveiA9IG9yZGVyKHN6KTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHN6W296W2ldXS5pbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQoc3osIG96KTtcbiAgICAgICAgICAgIHJldHVybiBzejtcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5rZXlzID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGtleXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpLCBzdGFjaykgOiBrZXlzO1xuICAgICAgICB9O1xuICAgICAgICBzdGFjay52YWx1ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2YWx1ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBzdGFjaykgOiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgc3RhY2sub3JkZXIgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAob3JkZXIgPSBfID09IG51bGwgPyBub25lJDEgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpLCBzdGFjaykgOiBvcmRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgc3RhY2sub2Zmc2V0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9mZnNldCA9IF8gPT0gbnVsbCA/IG5vbmUgOiBfLCBzdGFjaykgOiBvZmZzZXQ7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdGFjaztcbiAgICB9XG4gICAgZnVuY3Rpb24gZXhwYW5kKHNlcmllcywgb3JkZXIpIHtcbiAgICAgICAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBpLCBuLCBqID0gMCwgbSA9IHNlcmllc1swXS5sZW5ndGgsIHk7IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgIGZvciAoeSA9IGkgPSAwOyBpIDwgbjsgKytpKVxuICAgICAgICAgICAgICAgIHkgKz0gc2VyaWVzW2ldW2pdWzFdIHx8IDA7XG4gICAgICAgICAgICBpZiAoeSlcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKVxuICAgICAgICAgICAgICAgICAgICBzZXJpZXNbaV1bal1bMV0gLz0geTtcbiAgICAgICAgfVxuICAgICAgICBub25lKHNlcmllcywgb3JkZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkaXZlcmdpbmcoc2VyaWVzLCBvcmRlcikge1xuICAgICAgICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAodmFyIGksIGogPSAwLCBkLCBkeSwgeXAsIHluLCBuLCBtID0gc2VyaWVzW29yZGVyWzBdXS5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgIGZvciAoeXAgPSB5biA9IDAsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKChkeSA9IChkID0gc2VyaWVzW29yZGVyW2ldXVtqXSlbMV0gLSBkWzBdKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZFswXSA9IHlwLCBkWzFdID0geXAgKz0gZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR5IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBkWzFdID0geW4sIGRbMF0gPSB5biArPSBkeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRbMF0gPSAwLCBkWzFdID0gZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpbGhvdWV0dGUoc2VyaWVzLCBvcmRlcikge1xuICAgICAgICBpZiAoISgobiA9IHNlcmllcy5sZW5ndGgpID4gMCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBzMCA9IHNlcmllc1tvcmRlclswXV0sIG4sIG0gPSBzMC5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCB5ID0gMDsgaSA8IG47ICsraSlcbiAgICAgICAgICAgICAgICB5ICs9IHNlcmllc1tpXVtqXVsxXSB8fCAwO1xuICAgICAgICAgICAgczBbal1bMV0gKz0gczBbal1bMF0gPSAteSAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgbm9uZShzZXJpZXMsIG9yZGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2lnZ2xlKHNlcmllcywgb3JkZXIpIHtcbiAgICAgICAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApIHx8ICEoKG0gPSAoczAgPSBzZXJpZXNbb3JkZXJbMF1dKS5sZW5ndGgpID4gMCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAodmFyIHkgPSAwLCBqID0gMSwgczAsIG0sIG47IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBzMSA9IDAsIHMyID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBzaSA9IHNlcmllc1tvcmRlcltpXV0sIHNpajAgPSBzaVtqXVsxXSB8fCAwLCBzaWoxID0gc2lbaiAtIDFdWzFdIHx8IDAsIHMzID0gKHNpajAgLSBzaWoxKSAvIDI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBpOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNrID0gc2VyaWVzW29yZGVyW2tdXSwgc2tqMCA9IHNrW2pdWzFdIHx8IDAsIHNrajEgPSBza1tqIC0gMV1bMV0gfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgczMgKz0gc2tqMCAtIHNrajE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHMxICs9IHNpajAsIHMyICs9IHMzICogc2lqMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMwW2ogLSAxXVsxXSArPSBzMFtqIC0gMV1bMF0gPSB5O1xuICAgICAgICAgICAgaWYgKHMxKVxuICAgICAgICAgICAgICAgIHkgLT0gczIgLyBzMTtcbiAgICAgICAgfVxuICAgICAgICBzMFtqIC0gMV1bMV0gKz0gczBbaiAtIDFdWzBdID0geTtcbiAgICAgICAgbm9uZShzZXJpZXMsIG9yZGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwZWFyYW5jZShzZXJpZXMpIHtcbiAgICAgICAgdmFyIHBlYWtzID0gc2VyaWVzLm1hcChwZWFrKTtcbiAgICAgICAgcmV0dXJuIG5vbmUkMShzZXJpZXMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHBlYWtzW2FdIC0gcGVha3NbYl07IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZWFrKHNlcmllcykge1xuICAgICAgICB2YXIgaSA9IC0xLCBqID0gMCwgbiA9IHNlcmllcy5sZW5ndGgsIHZpLCB2aiA9IC1JbmZpbml0eTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pXG4gICAgICAgICAgICBpZiAoKHZpID0gK3Nlcmllc1tpXVsxXSkgPiB2ailcbiAgICAgICAgICAgICAgICB2aiA9IHZpLCBqID0gaTtcbiAgICAgICAgcmV0dXJuIGo7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzY2VuZGluZyhzZXJpZXMpIHtcbiAgICAgICAgdmFyIHN1bXMgPSBzZXJpZXMubWFwKHN1bSk7XG4gICAgICAgIHJldHVybiBub25lJDEoc2VyaWVzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBzdW1zW2FdIC0gc3Vtc1tiXTsgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN1bShzZXJpZXMpIHtcbiAgICAgICAgdmFyIHMgPSAwLCBpID0gLTEsIG4gPSBzZXJpZXMubGVuZ3RoLCB2O1xuICAgICAgICB3aGlsZSAoKytpIDwgbilcbiAgICAgICAgICAgIGlmICh2ID0gK3Nlcmllc1tpXVsxXSlcbiAgICAgICAgICAgICAgICBzICs9IHY7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXNjZW5kaW5nJDEoc2VyaWVzKSB7XG4gICAgICAgIHJldHVybiBhc2NlbmRpbmcoc2VyaWVzKS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluc2lkZU91dChzZXJpZXMpIHtcbiAgICAgICAgdmFyIG4gPSBzZXJpZXMubGVuZ3RoLCBpLCBqLCBzdW1zID0gc2VyaWVzLm1hcChzdW0pLCBvcmRlciA9IGFwcGVhcmFuY2Uoc2VyaWVzKSwgdG9wID0gMCwgYm90dG9tID0gMCwgdG9wcyA9IFtdLCBib3R0b21zID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGogPSBvcmRlcltpXTtcbiAgICAgICAgICAgIGlmICh0b3AgPCBib3R0b20pIHtcbiAgICAgICAgICAgICAgICB0b3AgKz0gc3Vtc1tqXTtcbiAgICAgICAgICAgICAgICB0b3BzLnB1c2goaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBib3R0b20gKz0gc3Vtc1tqXTtcbiAgICAgICAgICAgICAgICBib3R0b21zLnB1c2goaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdHRvbXMucmV2ZXJzZSgpLmNvbmNhdCh0b3BzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV2ZXJzZShzZXJpZXMpIHtcbiAgICAgICAgcmV0dXJuIG5vbmUkMShzZXJpZXMpLnJldmVyc2UoKTtcbiAgICB9XG4gICAgZXhwb3J0cy5hcmMgPSBhcmM7XG4gICAgZXhwb3J0cy5hcmVhID0gYXJlYTtcbiAgICBleHBvcnRzLmFyZWFSYWRpYWwgPSBhcmVhUmFkaWFsO1xuICAgIGV4cG9ydHMuY3VydmVCYXNpcyA9IGJhc2lzO1xuICAgIGV4cG9ydHMuY3VydmVCYXNpc0Nsb3NlZCA9IGJhc2lzQ2xvc2VkO1xuICAgIGV4cG9ydHMuY3VydmVCYXNpc09wZW4gPSBiYXNpc09wZW47XG4gICAgZXhwb3J0cy5jdXJ2ZUJ1bmRsZSA9IGJ1bmRsZTtcbiAgICBleHBvcnRzLmN1cnZlQ2FyZGluYWwgPSBjYXJkaW5hbDtcbiAgICBleHBvcnRzLmN1cnZlQ2FyZGluYWxDbG9zZWQgPSBjYXJkaW5hbENsb3NlZDtcbiAgICBleHBvcnRzLmN1cnZlQ2FyZGluYWxPcGVuID0gY2FyZGluYWxPcGVuO1xuICAgIGV4cG9ydHMuY3VydmVDYXRtdWxsUm9tID0gY2F0bXVsbFJvbTtcbiAgICBleHBvcnRzLmN1cnZlQ2F0bXVsbFJvbUNsb3NlZCA9IGNhdG11bGxSb21DbG9zZWQ7XG4gICAgZXhwb3J0cy5jdXJ2ZUNhdG11bGxSb21PcGVuID0gY2F0bXVsbFJvbU9wZW47XG4gICAgZXhwb3J0cy5jdXJ2ZUxpbmVhciA9IGN1cnZlTGluZWFyO1xuICAgIGV4cG9ydHMuY3VydmVMaW5lYXJDbG9zZWQgPSBsaW5lYXJDbG9zZWQ7XG4gICAgZXhwb3J0cy5jdXJ2ZU1vbm90b25lWCA9IG1vbm90b25lWDtcbiAgICBleHBvcnRzLmN1cnZlTW9ub3RvbmVZID0gbW9ub3RvbmVZO1xuICAgIGV4cG9ydHMuY3VydmVOYXR1cmFsID0gbmF0dXJhbDtcbiAgICBleHBvcnRzLmN1cnZlU3RlcCA9IHN0ZXA7XG4gICAgZXhwb3J0cy5jdXJ2ZVN0ZXBBZnRlciA9IHN0ZXBBZnRlcjtcbiAgICBleHBvcnRzLmN1cnZlU3RlcEJlZm9yZSA9IHN0ZXBCZWZvcmU7XG4gICAgZXhwb3J0cy5saW5lID0gbGluZTtcbiAgICBleHBvcnRzLmxpbmVSYWRpYWwgPSBsaW5lUmFkaWFsJDE7XG4gICAgZXhwb3J0cy5saW5rSG9yaXpvbnRhbCA9IGxpbmtIb3Jpem9udGFsO1xuICAgIGV4cG9ydHMubGlua1JhZGlhbCA9IGxpbmtSYWRpYWw7XG4gICAgZXhwb3J0cy5saW5rVmVydGljYWwgPSBsaW5rVmVydGljYWw7XG4gICAgZXhwb3J0cy5waWUgPSBwaWU7XG4gICAgZXhwb3J0cy5wb2ludFJhZGlhbCA9IHBvaW50UmFkaWFsO1xuICAgIGV4cG9ydHMucmFkaWFsQXJlYSA9IGFyZWFSYWRpYWw7XG4gICAgZXhwb3J0cy5yYWRpYWxMaW5lID0gbGluZVJhZGlhbCQxO1xuICAgIGV4cG9ydHMuc3RhY2sgPSBzdGFjaztcbiAgICBleHBvcnRzLnN0YWNrT2Zmc2V0RGl2ZXJnaW5nID0gZGl2ZXJnaW5nO1xuICAgIGV4cG9ydHMuc3RhY2tPZmZzZXRFeHBhbmQgPSBleHBhbmQ7XG4gICAgZXhwb3J0cy5zdGFja09mZnNldE5vbmUgPSBub25lO1xuICAgIGV4cG9ydHMuc3RhY2tPZmZzZXRTaWxob3VldHRlID0gc2lsaG91ZXR0ZTtcbiAgICBleHBvcnRzLnN0YWNrT2Zmc2V0V2lnZ2xlID0gd2lnZ2xlO1xuICAgIGV4cG9ydHMuc3RhY2tPcmRlckFwcGVhcmFuY2UgPSBhcHBlYXJhbmNlO1xuICAgIGV4cG9ydHMuc3RhY2tPcmRlckFzY2VuZGluZyA9IGFzY2VuZGluZztcbiAgICBleHBvcnRzLnN0YWNrT3JkZXJEZXNjZW5kaW5nID0gZGVzY2VuZGluZyQxO1xuICAgIGV4cG9ydHMuc3RhY2tPcmRlckluc2lkZU91dCA9IGluc2lkZU91dDtcbiAgICBleHBvcnRzLnN0YWNrT3JkZXJOb25lID0gbm9uZSQxO1xuICAgIGV4cG9ydHMuc3RhY2tPcmRlclJldmVyc2UgPSByZXZlcnNlO1xuICAgIGV4cG9ydHMuc3ltYm9sID0gc3ltYm9sO1xuICAgIGV4cG9ydHMuc3ltYm9sQ2lyY2xlID0gY2lyY2xlO1xuICAgIGV4cG9ydHMuc3ltYm9sQ3Jvc3MgPSBjcm9zcztcbiAgICBleHBvcnRzLnN5bWJvbERpYW1vbmQgPSBkaWFtb25kO1xuICAgIGV4cG9ydHMuc3ltYm9sU3F1YXJlID0gc3F1YXJlO1xuICAgIGV4cG9ydHMuc3ltYm9sU3RhciA9IHN0YXI7XG4gICAgZXhwb3J0cy5zeW1ib2xUcmlhbmdsZSA9IHRyaWFuZ2xlO1xuICAgIGV4cG9ydHMuc3ltYm9sV3llID0gd3llO1xuICAgIGV4cG9ydHMuc3ltYm9scyA9IHN5bWJvbHM7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtdm9yb25vaUAxLjEuNEBkMy12b3Jvbm9pL2Rpc3QvZDMtdm9yb25vaS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZDMtdm9yb25vaUAxLjEuNEBkMy12b3Jvbm9pL2Rpc3QvZDMtdm9yb25vaS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBodHRwczovL2QzanMub3JnL2QzLXZvcm9ub2kvIHYxLjEuNCBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2tcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgIHRydWUgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHgoZCkge1xuICAgICAgICByZXR1cm4gZFswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24geShkKSB7XG4gICAgICAgIHJldHVybiBkWzFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWRCbGFja1RyZWUoKSB7XG4gICAgICAgIHRoaXMuXyA9IG51bGw7IC8vIHJvb3Qgbm9kZVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWRCbGFja05vZGUobm9kZSkge1xuICAgICAgICBub2RlLlUgPSAvLyBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgbm9kZS5DID0gLy8gY29sb3IgLSB0cnVlIGZvciByZWQsIGZhbHNlIGZvciBibGFja1xuICAgICAgICAgICAgICAgIG5vZGUuTCA9IC8vIGxlZnQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBub2RlLlIgPSAvLyByaWdodCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLlAgPSAvLyBwcmV2aW91cyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5OID0gbnVsbDsgLy8gbmV4dCBub2RlXG4gICAgfVxuICAgIFJlZEJsYWNrVHJlZS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBSZWRCbGFja1RyZWUsXG4gICAgICAgIGluc2VydDogZnVuY3Rpb24gKGFmdGVyLCBub2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50LCBncmFuZHBhLCB1bmNsZTtcbiAgICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgICAgIG5vZGUuUCA9IGFmdGVyO1xuICAgICAgICAgICAgICAgIG5vZGUuTiA9IGFmdGVyLk47XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyLk4pXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyLk4uUCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgYWZ0ZXIuTiA9IG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyLlIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5SO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYWZ0ZXIuTClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyID0gYWZ0ZXIuTDtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXIuTCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZnRlci5SID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gYWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl8pIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IFJlZEJsYWNrRmlyc3QodGhpcy5fKTtcbiAgICAgICAgICAgICAgICBub2RlLlAgPSBudWxsO1xuICAgICAgICAgICAgICAgIG5vZGUuTiA9IGFmdGVyO1xuICAgICAgICAgICAgICAgIGFmdGVyLlAgPSBhZnRlci5MID0gbm9kZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBhZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUuUCA9IG5vZGUuTiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fID0gbm9kZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5MID0gbm9kZS5SID0gbnVsbDtcbiAgICAgICAgICAgIG5vZGUuVSA9IHBhcmVudDtcbiAgICAgICAgICAgIG5vZGUuQyA9IHRydWU7XG4gICAgICAgICAgICBhZnRlciA9IG5vZGU7XG4gICAgICAgICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5DKSB7XG4gICAgICAgICAgICAgICAgZ3JhbmRwYSA9IHBhcmVudC5VO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IGdyYW5kcGEuTCkge1xuICAgICAgICAgICAgICAgICAgICB1bmNsZSA9IGdyYW5kcGEuUjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuY2xlICYmIHVuY2xlLkMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5DID0gdW5jbGUuQyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyID0gZ3JhbmRwYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZnRlciA9PT0gcGFyZW50LlIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBhZnRlci5VO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LkMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIGdyYW5kcGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1bmNsZSA9IGdyYW5kcGEuTDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuY2xlICYmIHVuY2xlLkMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5DID0gdW5jbGUuQyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyID0gZ3JhbmRwYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZnRlciA9PT0gcGFyZW50LkwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5DID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIGdyYW5kcGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl8uQyA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5OKVxuICAgICAgICAgICAgICAgIG5vZGUuTi5QID0gbm9kZS5QO1xuICAgICAgICAgICAgaWYgKG5vZGUuUClcbiAgICAgICAgICAgICAgICBub2RlLlAuTiA9IG5vZGUuTjtcbiAgICAgICAgICAgIG5vZGUuTiA9IG5vZGUuUCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5VLCBzaWJsaW5nLCBsZWZ0ID0gbm9kZS5MLCByaWdodCA9IG5vZGUuUiwgbmV4dCwgcmVkO1xuICAgICAgICAgICAgaWYgKCFsZWZ0KVxuICAgICAgICAgICAgICAgIG5leHQgPSByaWdodDtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFyaWdodClcbiAgICAgICAgICAgICAgICBuZXh0ID0gbGVmdDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBuZXh0ID0gUmVkQmxhY2tGaXJzdChyaWdodCk7XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5MID09PSBub2RlKVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuTCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuUiA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl8gPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnQgJiYgcmlnaHQpIHtcbiAgICAgICAgICAgICAgICByZWQgPSBuZXh0LkM7XG4gICAgICAgICAgICAgICAgbmV4dC5DID0gbm9kZS5DO1xuICAgICAgICAgICAgICAgIG5leHQuTCA9IGxlZnQ7XG4gICAgICAgICAgICAgICAgbGVmdC5VID0gbmV4dDtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gcmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gbmV4dC5VO1xuICAgICAgICAgICAgICAgICAgICBuZXh0LlUgPSBub2RlLlU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0LlI7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5MID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5SID0gcmlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0LlUgPSBuZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dC5VID0gcGFyZW50O1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbmV4dC5SO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZCA9IG5vZGUuQztcbiAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlKVxuICAgICAgICAgICAgICAgIG5vZGUuVSA9IHBhcmVudDtcbiAgICAgICAgICAgIGlmIChyZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5DKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5DID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzLl8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09PSBwYXJlbnQuTCkge1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWJsaW5nLkMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuQyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LkMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChzaWJsaW5nLkwgJiYgc2libGluZy5MLkMpXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAoc2libGluZy5SICYmIHNpYmxpbmcuUi5DKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaWJsaW5nLlIgfHwgIXNpYmxpbmcuUi5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZy5MLkMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgc2libGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc2libGluZy5DID0gcGFyZW50LkM7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuQyA9IHNpYmxpbmcuUi5DID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLl87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2libGluZy5DKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLkMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5DID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKHNpYmxpbmcuTCAmJiBzaWJsaW5nLkwuQylcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IChzaWJsaW5nLlIgJiYgc2libGluZy5SLkMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpYmxpbmcuTCB8fCAhc2libGluZy5MLkMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLlIuQyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNpYmxpbmcuQyA9IHBhcmVudC5DO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LkMgPSBzaWJsaW5nLkwuQyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuXztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpYmxpbmcuQyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuVTtcbiAgICAgICAgICAgIH0gd2hpbGUgKCFub2RlLkMpO1xuICAgICAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgICAgICAgICAgbm9kZS5DID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIFJlZEJsYWNrUm90YXRlTGVmdCh0cmVlLCBub2RlKSB7XG4gICAgICAgIHZhciBwID0gbm9kZSwgcSA9IG5vZGUuUiwgcGFyZW50ID0gcC5VO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50LkwgPT09IHApXG4gICAgICAgICAgICAgICAgcGFyZW50LkwgPSBxO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHBhcmVudC5SID0gcTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyZWUuXyA9IHE7XG4gICAgICAgIH1cbiAgICAgICAgcS5VID0gcGFyZW50O1xuICAgICAgICBwLlUgPSBxO1xuICAgICAgICBwLlIgPSBxLkw7XG4gICAgICAgIGlmIChwLlIpXG4gICAgICAgICAgICBwLlIuVSA9IHA7XG4gICAgICAgIHEuTCA9IHA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlZEJsYWNrUm90YXRlUmlnaHQodHJlZSwgbm9kZSkge1xuICAgICAgICB2YXIgcCA9IG5vZGUsIHEgPSBub2RlLkwsIHBhcmVudCA9IHAuVTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC5MID09PSBwKVxuICAgICAgICAgICAgICAgIHBhcmVudC5MID0gcTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJlbnQuUiA9IHE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cmVlLl8gPSBxO1xuICAgICAgICB9XG4gICAgICAgIHEuVSA9IHBhcmVudDtcbiAgICAgICAgcC5VID0gcTtcbiAgICAgICAgcC5MID0gcS5SO1xuICAgICAgICBpZiAocC5MKVxuICAgICAgICAgICAgcC5MLlUgPSBwO1xuICAgICAgICBxLlIgPSBwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWRCbGFja0ZpcnN0KG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKG5vZGUuTClcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLkw7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVFZGdlKGxlZnQsIHJpZ2h0LCB2MCwgdjEpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBbbnVsbCwgbnVsbF0sIGluZGV4ID0gZWRnZXMucHVzaChlZGdlKSAtIDE7XG4gICAgICAgIGVkZ2UubGVmdCA9IGxlZnQ7XG4gICAgICAgIGVkZ2UucmlnaHQgPSByaWdodDtcbiAgICAgICAgaWYgKHYwKVxuICAgICAgICAgICAgc2V0RWRnZUVuZChlZGdlLCBsZWZ0LCByaWdodCwgdjApO1xuICAgICAgICBpZiAodjEpXG4gICAgICAgICAgICBzZXRFZGdlRW5kKGVkZ2UsIHJpZ2h0LCBsZWZ0LCB2MSk7XG4gICAgICAgIGNlbGxzW2xlZnQuaW5kZXhdLmhhbGZlZGdlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgY2VsbHNbcmlnaHQuaW5kZXhdLmhhbGZlZGdlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGVkZ2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUJvcmRlckVkZ2UobGVmdCwgdjAsIHYxKSB7XG4gICAgICAgIHZhciBlZGdlID0gW3YwLCB2MV07XG4gICAgICAgIGVkZ2UubGVmdCA9IGxlZnQ7XG4gICAgICAgIHJldHVybiBlZGdlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRFZGdlRW5kKGVkZ2UsIGxlZnQsIHJpZ2h0LCB2ZXJ0ZXgpIHtcbiAgICAgICAgaWYgKCFlZGdlWzBdICYmICFlZGdlWzFdKSB7XG4gICAgICAgICAgICBlZGdlWzBdID0gdmVydGV4O1xuICAgICAgICAgICAgZWRnZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgIGVkZ2UucmlnaHQgPSByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlZGdlLmxlZnQgPT09IHJpZ2h0KSB7XG4gICAgICAgICAgICBlZGdlWzFdID0gdmVydGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWRnZVswXSA9IHZlcnRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBMaWFuZ+KAk0JhcnNreSBsaW5lIGNsaXBwaW5nLlxuICAgIGZ1bmN0aW9uIGNsaXBFZGdlKGVkZ2UsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICAgIHZhciBhID0gZWRnZVswXSwgYiA9IGVkZ2VbMV0sIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgdDAgPSAwLCB0MSA9IDEsIGR4ID0gYnggLSBheCwgZHkgPSBieSAtIGF5LCByO1xuICAgICAgICByID0geDAgLSBheDtcbiAgICAgICAgaWYgKCFkeCAmJiByID4gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgciAvPSBkeDtcbiAgICAgICAgaWYgKGR4IDwgMCkge1xuICAgICAgICAgICAgaWYgKHIgPCB0MClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA8IHQxKVxuICAgICAgICAgICAgICAgIHQxID0gcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeCA+IDApIHtcbiAgICAgICAgICAgIGlmIChyID4gdDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPiB0MClcbiAgICAgICAgICAgICAgICB0MCA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgciA9IHgxIC0gYXg7XG4gICAgICAgIGlmICghZHggJiYgciA8IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHIgLz0gZHg7XG4gICAgICAgIGlmIChkeCA8IDApIHtcbiAgICAgICAgICAgIGlmIChyID4gdDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPiB0MClcbiAgICAgICAgICAgICAgICB0MCA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgICAgICAgICBpZiAociA8IHQwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyIDwgdDEpXG4gICAgICAgICAgICAgICAgdDEgPSByO1xuICAgICAgICB9XG4gICAgICAgIHIgPSB5MCAtIGF5O1xuICAgICAgICBpZiAoIWR5ICYmIHIgPiAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByIC89IGR5O1xuICAgICAgICBpZiAoZHkgPCAwKSB7XG4gICAgICAgICAgICBpZiAociA8IHQwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChyIDwgdDEpXG4gICAgICAgICAgICAgICAgdDEgPSByO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR5ID4gMCkge1xuICAgICAgICAgICAgaWYgKHIgPiB0MSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA+IHQwKVxuICAgICAgICAgICAgICAgIHQwID0gcjtcbiAgICAgICAgfVxuICAgICAgICByID0geTEgLSBheTtcbiAgICAgICAgaWYgKCFkeSAmJiByIDwgMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgciAvPSBkeTtcbiAgICAgICAgaWYgKGR5IDwgMCkge1xuICAgICAgICAgICAgaWYgKHIgPiB0MSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAociA+IHQwKVxuICAgICAgICAgICAgICAgIHQwID0gcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkeSA+IDApIHtcbiAgICAgICAgICAgIGlmIChyIDwgdDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHIgPCB0MSlcbiAgICAgICAgICAgICAgICB0MSA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodDAgPiAwKSAmJiAhKHQxIDwgMSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gVE9ETyBCZXR0ZXIgY2hlY2s/XG4gICAgICAgIGlmICh0MCA+IDApXG4gICAgICAgICAgICBlZGdlWzBdID0gW2F4ICsgdDAgKiBkeCwgYXkgKyB0MCAqIGR5XTtcbiAgICAgICAgaWYgKHQxIDwgMSlcbiAgICAgICAgICAgIGVkZ2VbMV0gPSBbYXggKyB0MSAqIGR4LCBheSArIHQxICogZHldO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29ubmVjdEVkZ2UoZWRnZSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgdmFyIHYxID0gZWRnZVsxXTtcbiAgICAgICAgaWYgKHYxKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciB2MCA9IGVkZ2VbMF0sIGxlZnQgPSBlZGdlLmxlZnQsIHJpZ2h0ID0gZWRnZS5yaWdodCwgbHggPSBsZWZ0WzBdLCBseSA9IGxlZnRbMV0sIHJ4ID0gcmlnaHRbMF0sIHJ5ID0gcmlnaHRbMV0sIGZ4ID0gKGx4ICsgcngpIC8gMiwgZnkgPSAobHkgKyByeSkgLyAyLCBmbSwgZmI7XG4gICAgICAgIGlmIChyeSA9PT0gbHkpIHtcbiAgICAgICAgICAgIGlmIChmeCA8IHgwIHx8IGZ4ID49IHgxKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChseCA+IHJ4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2MClcbiAgICAgICAgICAgICAgICAgICAgdjAgPSBbZngsIHkwXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2MFsxXSA+PSB5MSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHYxID0gW2Z4LCB5MV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXYwKVxuICAgICAgICAgICAgICAgICAgICB2MCA9IFtmeCwgeTFdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYwWzFdIDwgeTApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2MSA9IFtmeCwgeTBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm0gPSAobHggLSByeCkgLyAocnkgLSBseSk7XG4gICAgICAgICAgICBmYiA9IGZ5IC0gZm0gKiBmeDtcbiAgICAgICAgICAgIGlmIChmbSA8IC0xIHx8IGZtID4gMSkge1xuICAgICAgICAgICAgICAgIGlmIChseCA+IHJ4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdjApXG4gICAgICAgICAgICAgICAgICAgICAgICB2MCA9IFsoeTAgLSBmYikgLyBmbSwgeTBdO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2MFsxXSA+PSB5MSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgdjEgPSBbKHkxIC0gZmIpIC8gZm0sIHkxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdjApXG4gICAgICAgICAgICAgICAgICAgICAgICB2MCA9IFsoeTEgLSBmYikgLyBmbSwgeTFdO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2MFsxXSA8IHkwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2MSA9IFsoeTAgLSBmYikgLyBmbSwgeTBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChseSA8IHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdjApXG4gICAgICAgICAgICAgICAgICAgICAgICB2MCA9IFt4MCwgZm0gKiB4MCArIGZiXTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodjBbMF0gPj0geDEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHYxID0gW3gxLCBmbSAqIHgxICsgZmJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2MClcbiAgICAgICAgICAgICAgICAgICAgICAgIHYwID0gW3gxLCBmbSAqIHgxICsgZmJdO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2MFswXSA8IHgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2MSA9IFt4MCwgZm0gKiB4MCArIGZiXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWRnZVswXSA9IHYwO1xuICAgICAgICBlZGdlWzFdID0gdjE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGlwRWRnZXMoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgdmFyIGkgPSBlZGdlcy5sZW5ndGgsIGVkZ2U7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmICghY29ubmVjdEVkZ2UoZWRnZSA9IGVkZ2VzW2ldLCB4MCwgeTAsIHgxLCB5MSlcbiAgICAgICAgICAgICAgICB8fCAhY2xpcEVkZ2UoZWRnZSwgeDAsIHkwLCB4MSwgeTEpXG4gICAgICAgICAgICAgICAgfHwgIShNYXRoLmFicyhlZGdlWzBdWzBdIC0gZWRnZVsxXVswXSkgPiBlcHNpbG9uXG4gICAgICAgICAgICAgICAgICAgIHx8IE1hdGguYWJzKGVkZ2VbMF1bMV0gLSBlZGdlWzFdWzFdKSA+IGVwc2lsb24pKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVkZ2VzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNlbGwoc2l0ZSkge1xuICAgICAgICByZXR1cm4gY2VsbHNbc2l0ZS5pbmRleF0gPSB7XG4gICAgICAgICAgICBzaXRlOiBzaXRlLFxuICAgICAgICAgICAgaGFsZmVkZ2VzOiBbXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZWxsSGFsZmVkZ2VBbmdsZShjZWxsLCBlZGdlKSB7XG4gICAgICAgIHZhciBzaXRlID0gY2VsbC5zaXRlLCB2YSA9IGVkZ2UubGVmdCwgdmIgPSBlZGdlLnJpZ2h0O1xuICAgICAgICBpZiAoc2l0ZSA9PT0gdmIpXG4gICAgICAgICAgICB2YiA9IHZhLCB2YSA9IHNpdGU7XG4gICAgICAgIGlmICh2YilcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHZiWzFdIC0gdmFbMV0sIHZiWzBdIC0gdmFbMF0pO1xuICAgICAgICBpZiAoc2l0ZSA9PT0gdmEpXG4gICAgICAgICAgICB2YSA9IGVkZ2VbMV0sIHZiID0gZWRnZVswXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmEgPSBlZGdlWzBdLCB2YiA9IGVkZ2VbMV07XG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHZhWzBdIC0gdmJbMF0sIHZiWzFdIC0gdmFbMV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZWxsSGFsZmVkZ2VTdGFydChjZWxsLCBlZGdlKSB7XG4gICAgICAgIHJldHVybiBlZGdlWysoZWRnZS5sZWZ0ICE9PSBjZWxsLnNpdGUpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VsbEhhbGZlZGdlRW5kKGNlbGwsIGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VbKyhlZGdlLmxlZnQgPT09IGNlbGwuc2l0ZSldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzb3J0Q2VsbEhhbGZlZGdlcygpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjZWxscy5sZW5ndGgsIGNlbGwsIGhhbGZlZGdlcywgaiwgbTsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgaWYgKChjZWxsID0gY2VsbHNbaV0pICYmIChtID0gKGhhbGZlZGdlcyA9IGNlbGwuaGFsZmVkZ2VzKS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbmV3IEFycmF5KG0pLCBhcnJheSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKVxuICAgICAgICAgICAgICAgICAgICBpbmRleFtqXSA9IGosIGFycmF5W2pdID0gY2VsbEhhbGZlZGdlQW5nbGUoY2VsbCwgZWRnZXNbaGFsZmVkZ2VzW2pdXSk7XG4gICAgICAgICAgICAgICAgaW5kZXguc29ydChmdW5jdGlvbiAoaSwgaikgeyByZXR1cm4gYXJyYXlbal0gLSBhcnJheVtpXTsgfSk7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsrailcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlbal0gPSBoYWxmZWRnZXNbaW5kZXhbal1dO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opXG4gICAgICAgICAgICAgICAgICAgIGhhbGZlZGdlc1tqXSA9IGFycmF5W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsaXBDZWxscyh4MCwgeTAsIHgxLCB5MSkge1xuICAgICAgICB2YXIgbkNlbGxzID0gY2VsbHMubGVuZ3RoLCBpQ2VsbCwgY2VsbCwgc2l0ZSwgaUhhbGZlZGdlLCBoYWxmZWRnZXMsIG5IYWxmZWRnZXMsIHN0YXJ0LCBzdGFydFgsIHN0YXJ0WSwgZW5kLCBlbmRYLCBlbmRZLCBjb3ZlciA9IHRydWU7XG4gICAgICAgIGZvciAoaUNlbGwgPSAwOyBpQ2VsbCA8IG5DZWxsczsgKytpQ2VsbCkge1xuICAgICAgICAgICAgaWYgKGNlbGwgPSBjZWxsc1tpQ2VsbF0pIHtcbiAgICAgICAgICAgICAgICBzaXRlID0gY2VsbC5zaXRlO1xuICAgICAgICAgICAgICAgIGhhbGZlZGdlcyA9IGNlbGwuaGFsZmVkZ2VzO1xuICAgICAgICAgICAgICAgIGlIYWxmZWRnZSA9IGhhbGZlZGdlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBkYW5nbGluZyBjbGlwcGVkIGVkZ2VzLlxuICAgICAgICAgICAgICAgIHdoaWxlIChpSGFsZmVkZ2UtLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVkZ2VzW2hhbGZlZGdlc1tpSGFsZmVkZ2VdXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFsZmVkZ2VzLnNwbGljZShpSGFsZmVkZ2UsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEluc2VydCBhbnkgYm9yZGVyIGVkZ2VzIGFzIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgICAgICBpSGFsZmVkZ2UgPSAwLCBuSGFsZmVkZ2VzID0gaGFsZmVkZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaUhhbGZlZGdlIDwgbkhhbGZlZGdlcykge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBjZWxsSGFsZmVkZ2VFbmQoY2VsbCwgZWRnZXNbaGFsZmVkZ2VzW2lIYWxmZWRnZV1dKSwgZW5kWCA9IGVuZFswXSwgZW5kWSA9IGVuZFsxXTtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBjZWxsSGFsZmVkZ2VTdGFydChjZWxsLCBlZGdlc1toYWxmZWRnZXNbKytpSGFsZmVkZ2UgJSBuSGFsZmVkZ2VzXV0pLCBzdGFydFggPSBzdGFydFswXSwgc3RhcnRZID0gc3RhcnRbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhlbmRYIC0gc3RhcnRYKSA+IGVwc2lsb24gfHwgTWF0aC5hYnMoZW5kWSAtIHN0YXJ0WSkgPiBlcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYWxmZWRnZXMuc3BsaWNlKGlIYWxmZWRnZSwgMCwgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUsIGVuZCwgTWF0aC5hYnMoZW5kWCAtIHgwKSA8IGVwc2lsb24gJiYgeTEgLSBlbmRZID4gZXBzaWxvbiA/IFt4MCwgTWF0aC5hYnMoc3RhcnRYIC0geDApIDwgZXBzaWxvbiA/IHN0YXJ0WSA6IHkxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5hYnMoZW5kWSAtIHkxKSA8IGVwc2lsb24gJiYgeDEgLSBlbmRYID4gZXBzaWxvbiA/IFtNYXRoLmFicyhzdGFydFkgLSB5MSkgPCBlcHNpbG9uID8gc3RhcnRYIDogeDEsIHkxXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGguYWJzKGVuZFggLSB4MSkgPCBlcHNpbG9uICYmIGVuZFkgLSB5MCA+IGVwc2lsb24gPyBbeDEsIE1hdGguYWJzKHN0YXJ0WCAtIHgxKSA8IGVwc2lsb24gPyBzdGFydFkgOiB5MF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5hYnMoZW5kWSAtIHkwKSA8IGVwc2lsb24gJiYgZW5kWCAtIHgwID4gZXBzaWxvbiA/IFtNYXRoLmFicyhzdGFydFkgLSB5MCkgPCBlcHNpbG9uID8gc3RhcnRYIDogeDAsIHkwXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCkpIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICArK25IYWxmZWRnZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5IYWxmZWRnZXMpXG4gICAgICAgICAgICAgICAgICAgIGNvdmVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUgd2VyZW7igJl0IGFueSBlZGdlcywgaGF2ZSB0aGUgY2xvc2VzdCBzaXRlIGNvdmVyIHRoZSBleHRlbnQuXG4gICAgICAgIC8vIEl0IGRvZXNu4oCZdCBtYXR0ZXIgd2hpY2ggY29ybmVyIG9mIHRoZSBleHRlbnQgd2UgbWVhc3VyZSFcbiAgICAgICAgaWYgKGNvdmVyKSB7XG4gICAgICAgICAgICB2YXIgZHgsIGR5LCBkMiwgZGMgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAoaUNlbGwgPSAwLCBjb3ZlciA9IG51bGw7IGlDZWxsIDwgbkNlbGxzOyArK2lDZWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGwgPSBjZWxsc1tpQ2VsbF0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2l0ZSA9IGNlbGwuc2l0ZTtcbiAgICAgICAgICAgICAgICAgICAgZHggPSBzaXRlWzBdIC0geDA7XG4gICAgICAgICAgICAgICAgICAgIGR5ID0gc2l0ZVsxXSAtIHkwO1xuICAgICAgICAgICAgICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZDIgPCBkYylcbiAgICAgICAgICAgICAgICAgICAgICAgIGRjID0gZDIsIGNvdmVyID0gY2VsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY292ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdjAwID0gW3gwLCB5MF0sIHYwMSA9IFt4MCwgeTFdLCB2MTEgPSBbeDEsIHkxXSwgdjEwID0gW3gxLCB5MF07XG4gICAgICAgICAgICAgICAgY292ZXIuaGFsZmVkZ2VzLnB1c2goZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUgPSBjb3Zlci5zaXRlLCB2MDAsIHYwMSkpIC0gMSwgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUsIHYwMSwgdjExKSkgLSAxLCBlZGdlcy5wdXNoKGNyZWF0ZUJvcmRlckVkZ2Uoc2l0ZSwgdjExLCB2MTApKSAtIDEsIGVkZ2VzLnB1c2goY3JlYXRlQm9yZGVyRWRnZShzaXRlLCB2MTAsIHYwMCkpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGFzdGx5IGRlbGV0ZSBhbnkgY2VsbHMgd2l0aCBubyBlZGdlczsgdGhlc2Ugd2VyZSBlbnRpcmVseSBjbGlwcGVkLlxuICAgICAgICBmb3IgKGlDZWxsID0gMDsgaUNlbGwgPCBuQ2VsbHM7ICsraUNlbGwpIHtcbiAgICAgICAgICAgIGlmIChjZWxsID0gY2VsbHNbaUNlbGxdKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjZWxsLmhhbGZlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNlbGxzW2lDZWxsXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNpcmNsZVBvb2wgPSBbXTtcbiAgICB2YXIgZmlyc3RDaXJjbGU7XG4gICAgZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgICAgICBSZWRCbGFja05vZGUodGhpcyk7XG4gICAgICAgIHRoaXMueCA9XG4gICAgICAgICAgICB0aGlzLnkgPVxuICAgICAgICAgICAgICAgIHRoaXMuYXJjID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3kgPSBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRhY2hDaXJjbGUoYXJjKSB7XG4gICAgICAgIHZhciBsQXJjID0gYXJjLlAsIHJBcmMgPSBhcmMuTjtcbiAgICAgICAgaWYgKCFsQXJjIHx8ICFyQXJjKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbFNpdGUgPSBsQXJjLnNpdGUsIGNTaXRlID0gYXJjLnNpdGUsIHJTaXRlID0gckFyYy5zaXRlO1xuICAgICAgICBpZiAobFNpdGUgPT09IHJTaXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgYnggPSBjU2l0ZVswXSwgYnkgPSBjU2l0ZVsxXSwgYXggPSBsU2l0ZVswXSAtIGJ4LCBheSA9IGxTaXRlWzFdIC0gYnksIGN4ID0gclNpdGVbMF0gLSBieCwgY3kgPSByU2l0ZVsxXSAtIGJ5O1xuICAgICAgICB2YXIgZCA9IDIgKiAoYXggKiBjeSAtIGF5ICogY3gpO1xuICAgICAgICBpZiAoZCA+PSAtZXBzaWxvbjIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBoYSA9IGF4ICogYXggKyBheSAqIGF5LCBoYyA9IGN4ICogY3ggKyBjeSAqIGN5LCB4ID0gKGN5ICogaGEgLSBheSAqIGhjKSAvIGQsIHkgPSAoYXggKiBoYyAtIGN4ICogaGEpIC8gZDtcbiAgICAgICAgdmFyIGNpcmNsZSA9IGNpcmNsZVBvb2wucG9wKCkgfHwgbmV3IENpcmNsZTtcbiAgICAgICAgY2lyY2xlLmFyYyA9IGFyYztcbiAgICAgICAgY2lyY2xlLnNpdGUgPSBjU2l0ZTtcbiAgICAgICAgY2lyY2xlLnggPSB4ICsgYng7XG4gICAgICAgIGNpcmNsZS55ID0gKGNpcmNsZS5jeSA9IHkgKyBieSkgKyBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7IC8vIHkgYm90dG9tXG4gICAgICAgIGFyYy5jaXJjbGUgPSBjaXJjbGU7XG4gICAgICAgIHZhciBiZWZvcmUgPSBudWxsLCBub2RlID0gY2lyY2xlcy5fO1xuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgaWYgKGNpcmNsZS55IDwgbm9kZS55IHx8IChjaXJjbGUueSA9PT0gbm9kZS55ICYmIGNpcmNsZS54IDw9IG5vZGUueCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5MKVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5MO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgPSBub2RlLlA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLlIpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLlI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaXJjbGVzLmluc2VydChiZWZvcmUsIGNpcmNsZSk7XG4gICAgICAgIGlmICghYmVmb3JlKVxuICAgICAgICAgICAgZmlyc3RDaXJjbGUgPSBjaXJjbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRldGFjaENpcmNsZShhcmMpIHtcbiAgICAgICAgdmFyIGNpcmNsZSA9IGFyYy5jaXJjbGU7XG4gICAgICAgIGlmIChjaXJjbGUpIHtcbiAgICAgICAgICAgIGlmICghY2lyY2xlLlApXG4gICAgICAgICAgICAgICAgZmlyc3RDaXJjbGUgPSBjaXJjbGUuTjtcbiAgICAgICAgICAgIGNpcmNsZXMucmVtb3ZlKGNpcmNsZSk7XG4gICAgICAgICAgICBjaXJjbGVQb29sLnB1c2goY2lyY2xlKTtcbiAgICAgICAgICAgIFJlZEJsYWNrTm9kZShjaXJjbGUpO1xuICAgICAgICAgICAgYXJjLmNpcmNsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGJlYWNoUG9vbCA9IFtdO1xuICAgIGZ1bmN0aW9uIEJlYWNoKCkge1xuICAgICAgICBSZWRCbGFja05vZGUodGhpcyk7XG4gICAgICAgIHRoaXMuZWRnZSA9XG4gICAgICAgICAgICB0aGlzLnNpdGUgPVxuICAgICAgICAgICAgICAgIHRoaXMuY2lyY2xlID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlQmVhY2goc2l0ZSkge1xuICAgICAgICB2YXIgYmVhY2ggPSBiZWFjaFBvb2wucG9wKCkgfHwgbmV3IEJlYWNoO1xuICAgICAgICBiZWFjaC5zaXRlID0gc2l0ZTtcbiAgICAgICAgcmV0dXJuIGJlYWNoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXRhY2hCZWFjaChiZWFjaCkge1xuICAgICAgICBkZXRhY2hDaXJjbGUoYmVhY2gpO1xuICAgICAgICBiZWFjaGVzLnJlbW92ZShiZWFjaCk7XG4gICAgICAgIGJlYWNoUG9vbC5wdXNoKGJlYWNoKTtcbiAgICAgICAgUmVkQmxhY2tOb2RlKGJlYWNoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQmVhY2goYmVhY2gpIHtcbiAgICAgICAgdmFyIGNpcmNsZSA9IGJlYWNoLmNpcmNsZSwgeCA9IGNpcmNsZS54LCB5ID0gY2lyY2xlLmN5LCB2ZXJ0ZXggPSBbeCwgeV0sIHByZXZpb3VzID0gYmVhY2guUCwgbmV4dCA9IGJlYWNoLk4sIGRpc2FwcGVhcmluZyA9IFtiZWFjaF07XG4gICAgICAgIGRldGFjaEJlYWNoKGJlYWNoKTtcbiAgICAgICAgdmFyIGxBcmMgPSBwcmV2aW91cztcbiAgICAgICAgd2hpbGUgKGxBcmMuY2lyY2xlXG4gICAgICAgICAgICAmJiBNYXRoLmFicyh4IC0gbEFyYy5jaXJjbGUueCkgPCBlcHNpbG9uXG4gICAgICAgICAgICAmJiBNYXRoLmFicyh5IC0gbEFyYy5jaXJjbGUuY3kpIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgcHJldmlvdXMgPSBsQXJjLlA7XG4gICAgICAgICAgICBkaXNhcHBlYXJpbmcudW5zaGlmdChsQXJjKTtcbiAgICAgICAgICAgIGRldGFjaEJlYWNoKGxBcmMpO1xuICAgICAgICAgICAgbEFyYyA9IHByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIGRpc2FwcGVhcmluZy51bnNoaWZ0KGxBcmMpO1xuICAgICAgICBkZXRhY2hDaXJjbGUobEFyYyk7XG4gICAgICAgIHZhciByQXJjID0gbmV4dDtcbiAgICAgICAgd2hpbGUgKHJBcmMuY2lyY2xlXG4gICAgICAgICAgICAmJiBNYXRoLmFicyh4IC0gckFyYy5jaXJjbGUueCkgPCBlcHNpbG9uXG4gICAgICAgICAgICAmJiBNYXRoLmFicyh5IC0gckFyYy5jaXJjbGUuY3kpIDwgZXBzaWxvbikge1xuICAgICAgICAgICAgbmV4dCA9IHJBcmMuTjtcbiAgICAgICAgICAgIGRpc2FwcGVhcmluZy5wdXNoKHJBcmMpO1xuICAgICAgICAgICAgZGV0YWNoQmVhY2gockFyYyk7XG4gICAgICAgICAgICByQXJjID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBkaXNhcHBlYXJpbmcucHVzaChyQXJjKTtcbiAgICAgICAgZGV0YWNoQ2lyY2xlKHJBcmMpO1xuICAgICAgICB2YXIgbkFyY3MgPSBkaXNhcHBlYXJpbmcubGVuZ3RoLCBpQXJjO1xuICAgICAgICBmb3IgKGlBcmMgPSAxOyBpQXJjIDwgbkFyY3M7ICsraUFyYykge1xuICAgICAgICAgICAgckFyYyA9IGRpc2FwcGVhcmluZ1tpQXJjXTtcbiAgICAgICAgICAgIGxBcmMgPSBkaXNhcHBlYXJpbmdbaUFyYyAtIDFdO1xuICAgICAgICAgICAgc2V0RWRnZUVuZChyQXJjLmVkZ2UsIGxBcmMuc2l0ZSwgckFyYy5zaXRlLCB2ZXJ0ZXgpO1xuICAgICAgICB9XG4gICAgICAgIGxBcmMgPSBkaXNhcHBlYXJpbmdbMF07XG4gICAgICAgIHJBcmMgPSBkaXNhcHBlYXJpbmdbbkFyY3MgLSAxXTtcbiAgICAgICAgckFyYy5lZGdlID0gY3JlYXRlRWRnZShsQXJjLnNpdGUsIHJBcmMuc2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgICAgICAgYXR0YWNoQ2lyY2xlKGxBcmMpO1xuICAgICAgICBhdHRhY2hDaXJjbGUockFyYyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZEJlYWNoKHNpdGUpIHtcbiAgICAgICAgdmFyIHggPSBzaXRlWzBdLCBkaXJlY3RyaXggPSBzaXRlWzFdLCBsQXJjLCByQXJjLCBkeGwsIGR4ciwgbm9kZSA9IGJlYWNoZXMuXztcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGR4bCA9IGxlZnRCcmVha1BvaW50KG5vZGUsIGRpcmVjdHJpeCkgLSB4O1xuICAgICAgICAgICAgaWYgKGR4bCA+IGVwc2lsb24pXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuTDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGR4ciA9IHggLSByaWdodEJyZWFrUG9pbnQobm9kZSwgZGlyZWN0cml4KTtcbiAgICAgICAgICAgICAgICBpZiAoZHhyID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbEFyYyA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5SO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR4bCA+IC1lcHNpbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsQXJjID0gbm9kZS5QO1xuICAgICAgICAgICAgICAgICAgICAgICAgckFyYyA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZHhyID4gLWVwc2lsb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxBcmMgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgckFyYyA9IG5vZGUuTjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxBcmMgPSByQXJjID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlQ2VsbChzaXRlKTtcbiAgICAgICAgdmFyIG5ld0FyYyA9IGNyZWF0ZUJlYWNoKHNpdGUpO1xuICAgICAgICBiZWFjaGVzLmluc2VydChsQXJjLCBuZXdBcmMpO1xuICAgICAgICBpZiAoIWxBcmMgJiYgIXJBcmMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChsQXJjID09PSByQXJjKSB7XG4gICAgICAgICAgICBkZXRhY2hDaXJjbGUobEFyYyk7XG4gICAgICAgICAgICByQXJjID0gY3JlYXRlQmVhY2gobEFyYy5zaXRlKTtcbiAgICAgICAgICAgIGJlYWNoZXMuaW5zZXJ0KG5ld0FyYywgckFyYyk7XG4gICAgICAgICAgICBuZXdBcmMuZWRnZSA9IHJBcmMuZWRnZSA9IGNyZWF0ZUVkZ2UobEFyYy5zaXRlLCBuZXdBcmMuc2l0ZSk7XG4gICAgICAgICAgICBhdHRhY2hDaXJjbGUobEFyYyk7XG4gICAgICAgICAgICBhdHRhY2hDaXJjbGUockFyYyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyQXJjKSB7IC8vICYmIGxBcmNcbiAgICAgICAgICAgIG5ld0FyYy5lZGdlID0gY3JlYXRlRWRnZShsQXJjLnNpdGUsIG5ld0FyYy5zaXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIGxBcmMgIT09IHJBcmNcbiAgICAgICAgZGV0YWNoQ2lyY2xlKGxBcmMpO1xuICAgICAgICBkZXRhY2hDaXJjbGUockFyYyk7XG4gICAgICAgIHZhciBsU2l0ZSA9IGxBcmMuc2l0ZSwgYXggPSBsU2l0ZVswXSwgYXkgPSBsU2l0ZVsxXSwgYnggPSBzaXRlWzBdIC0gYXgsIGJ5ID0gc2l0ZVsxXSAtIGF5LCByU2l0ZSA9IHJBcmMuc2l0ZSwgY3ggPSByU2l0ZVswXSAtIGF4LCBjeSA9IHJTaXRlWzFdIC0gYXksIGQgPSAyICogKGJ4ICogY3kgLSBieSAqIGN4KSwgaGIgPSBieCAqIGJ4ICsgYnkgKiBieSwgaGMgPSBjeCAqIGN4ICsgY3kgKiBjeSwgdmVydGV4ID0gWyhjeSAqIGhiIC0gYnkgKiBoYykgLyBkICsgYXgsIChieCAqIGhjIC0gY3ggKiBoYikgLyBkICsgYXldO1xuICAgICAgICBzZXRFZGdlRW5kKHJBcmMuZWRnZSwgbFNpdGUsIHJTaXRlLCB2ZXJ0ZXgpO1xuICAgICAgICBuZXdBcmMuZWRnZSA9IGNyZWF0ZUVkZ2UobFNpdGUsIHNpdGUsIG51bGwsIHZlcnRleCk7XG4gICAgICAgIHJBcmMuZWRnZSA9IGNyZWF0ZUVkZ2Uoc2l0ZSwgclNpdGUsIG51bGwsIHZlcnRleCk7XG4gICAgICAgIGF0dGFjaENpcmNsZShsQXJjKTtcbiAgICAgICAgYXR0YWNoQ2lyY2xlKHJBcmMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsZWZ0QnJlYWtQb2ludChhcmMsIGRpcmVjdHJpeCkge1xuICAgICAgICB2YXIgc2l0ZSA9IGFyYy5zaXRlLCByZm9jeCA9IHNpdGVbMF0sIHJmb2N5ID0gc2l0ZVsxXSwgcGJ5MiA9IHJmb2N5IC0gZGlyZWN0cml4O1xuICAgICAgICBpZiAoIXBieTIpXG4gICAgICAgICAgICByZXR1cm4gcmZvY3g7XG4gICAgICAgIHZhciBsQXJjID0gYXJjLlA7XG4gICAgICAgIGlmICghbEFyYylcbiAgICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICAgIHNpdGUgPSBsQXJjLnNpdGU7XG4gICAgICAgIHZhciBsZm9jeCA9IHNpdGVbMF0sIGxmb2N5ID0gc2l0ZVsxXSwgcGxieTIgPSBsZm9jeSAtIGRpcmVjdHJpeDtcbiAgICAgICAgaWYgKCFwbGJ5MilcbiAgICAgICAgICAgIHJldHVybiBsZm9jeDtcbiAgICAgICAgdmFyIGhsID0gbGZvY3ggLSByZm9jeCwgYWJ5MiA9IDEgLyBwYnkyIC0gMSAvIHBsYnkyLCBiID0gaGwgLyBwbGJ5MjtcbiAgICAgICAgaWYgKGFieTIpXG4gICAgICAgICAgICByZXR1cm4gKC1iICsgTWF0aC5zcXJ0KGIgKiBiIC0gMiAqIGFieTIgKiAoaGwgKiBobCAvICgtMiAqIHBsYnkyKSAtIGxmb2N5ICsgcGxieTIgLyAyICsgcmZvY3kgLSBwYnkyIC8gMikpKSAvIGFieTIgKyByZm9jeDtcbiAgICAgICAgcmV0dXJuIChyZm9jeCArIGxmb2N4KSAvIDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJpZ2h0QnJlYWtQb2ludChhcmMsIGRpcmVjdHJpeCkge1xuICAgICAgICB2YXIgckFyYyA9IGFyYy5OO1xuICAgICAgICBpZiAockFyYylcbiAgICAgICAgICAgIHJldHVybiBsZWZ0QnJlYWtQb2ludChyQXJjLCBkaXJlY3RyaXgpO1xuICAgICAgICB2YXIgc2l0ZSA9IGFyYy5zaXRlO1xuICAgICAgICByZXR1cm4gc2l0ZVsxXSA9PT0gZGlyZWN0cml4ID8gc2l0ZVswXSA6IEluZmluaXR5O1xuICAgIH1cbiAgICB2YXIgZXBzaWxvbiA9IDFlLTY7XG4gICAgdmFyIGVwc2lsb24yID0gMWUtMTI7XG4gICAgdmFyIGJlYWNoZXM7XG4gICAgdmFyIGNlbGxzO1xuICAgIHZhciBjaXJjbGVzO1xuICAgIHZhciBlZGdlcztcbiAgICBmdW5jdGlvbiB0cmlhbmdsZUFyZWEoYSwgYiwgYykge1xuICAgICAgICByZXR1cm4gKGFbMF0gLSBjWzBdKSAqIChiWzFdIC0gYVsxXSkgLSAoYVswXSAtIGJbMF0pICogKGNbMV0gLSBhWzFdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGV4aWNvZ3JhcGhpYyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBiWzFdIC0gYVsxXVxuICAgICAgICAgICAgfHwgYlswXSAtIGFbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIERpYWdyYW0oc2l0ZXMsIGV4dGVudCkge1xuICAgICAgICB2YXIgc2l0ZSA9IHNpdGVzLnNvcnQobGV4aWNvZ3JhcGhpYykucG9wKCksIHgsIHksIGNpcmNsZTtcbiAgICAgICAgZWRnZXMgPSBbXTtcbiAgICAgICAgY2VsbHMgPSBuZXcgQXJyYXkoc2l0ZXMubGVuZ3RoKTtcbiAgICAgICAgYmVhY2hlcyA9IG5ldyBSZWRCbGFja1RyZWU7XG4gICAgICAgIGNpcmNsZXMgPSBuZXcgUmVkQmxhY2tUcmVlO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY2lyY2xlID0gZmlyc3RDaXJjbGU7XG4gICAgICAgICAgICBpZiAoc2l0ZSAmJiAoIWNpcmNsZSB8fCBzaXRlWzFdIDwgY2lyY2xlLnkgfHwgKHNpdGVbMV0gPT09IGNpcmNsZS55ICYmIHNpdGVbMF0gPCBjaXJjbGUueCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNpdGVbMF0gIT09IHggfHwgc2l0ZVsxXSAhPT0geSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRCZWFjaChzaXRlKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHNpdGVbMF0sIHkgPSBzaXRlWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaXRlID0gc2l0ZXMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaXJjbGUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVCZWFjaChjaXJjbGUuYXJjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNvcnRDZWxsSGFsZmVkZ2VzKCk7XG4gICAgICAgIGlmIChleHRlbnQpIHtcbiAgICAgICAgICAgIHZhciB4MCA9ICtleHRlbnRbMF1bMF0sIHkwID0gK2V4dGVudFswXVsxXSwgeDEgPSArZXh0ZW50WzFdWzBdLCB5MSA9ICtleHRlbnRbMV1bMV07XG4gICAgICAgICAgICBjbGlwRWRnZXMoeDAsIHkwLCB4MSwgeTEpO1xuICAgICAgICAgICAgY2xpcENlbGxzKHgwLCB5MCwgeDEsIHkxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkZ2VzID0gZWRnZXM7XG4gICAgICAgIHRoaXMuY2VsbHMgPSBjZWxscztcbiAgICAgICAgYmVhY2hlcyA9XG4gICAgICAgICAgICBjaXJjbGVzID1cbiAgICAgICAgICAgICAgICBlZGdlcyA9XG4gICAgICAgICAgICAgICAgICAgIGNlbGxzID0gbnVsbDtcbiAgICB9XG4gICAgRGlhZ3JhbS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiBEaWFncmFtLFxuICAgICAgICBwb2x5Z29uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICAgICAgICAgIHZhciBwb2x5Z29uID0gY2VsbC5oYWxmZWRnZXMubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBjZWxsSGFsZmVkZ2VTdGFydChjZWxsLCBlZGdlc1tpXSk7IH0pO1xuICAgICAgICAgICAgICAgIHBvbHlnb24uZGF0YSA9IGNlbGwuc2l0ZS5kYXRhO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWFuZ2xlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRyaWFuZ2xlcyA9IFtdLCBlZGdlcyA9IHRoaXMuZWRnZXM7XG4gICAgICAgICAgICB0aGlzLmNlbGxzLmZvckVhY2goZnVuY3Rpb24gKGNlbGwsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShtID0gKGhhbGZlZGdlcyA9IGNlbGwuaGFsZmVkZ2VzKS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIHNpdGUgPSBjZWxsLnNpdGUsIGhhbGZlZGdlcywgaiA9IC0xLCBtLCBzMCwgZTEgPSBlZGdlc1toYWxmZWRnZXNbbSAtIDFdXSwgczEgPSBlMS5sZWZ0ID09PSBzaXRlID8gZTEucmlnaHQgOiBlMS5sZWZ0O1xuICAgICAgICAgICAgICAgIHdoaWxlICgrK2ogPCBtKSB7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICAgIGUxID0gZWRnZXNbaGFsZmVkZ2VzW2pdXTtcbiAgICAgICAgICAgICAgICAgICAgczEgPSBlMS5sZWZ0ID09PSBzaXRlID8gZTEucmlnaHQgOiBlMS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoczAgJiYgczEgJiYgaSA8IHMwLmluZGV4ICYmIGkgPCBzMS5pbmRleCAmJiB0cmlhbmdsZUFyZWEoc2l0ZSwgczAsIHMxKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKFtzaXRlLmRhdGEsIHMwLmRhdGEsIHMxLmRhdGFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRyaWFuZ2xlcztcbiAgICAgICAgfSxcbiAgICAgICAgbGlua3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkZ2VzLmZpbHRlcihmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlLnJpZ2h0O1xuICAgICAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBlZGdlLmxlZnQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBlZGdlLnJpZ2h0LmRhdGFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmQ6IGZ1bmN0aW9uICh4LCB5LCByYWRpdXMpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcywgaTAsIGkxID0gdGhhdC5fZm91bmQgfHwgMCwgbiA9IHRoYXQuY2VsbHMubGVuZ3RoLCBjZWxsO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBwcmV2aW91c2x5LWZvdW5kIGNlbGwsIG9yIHN0YXJ0IHdpdGggYW4gYXJiaXRyYXJ5IG9uZS5cbiAgICAgICAgICAgIHdoaWxlICghKGNlbGwgPSB0aGF0LmNlbGxzW2kxXSkpXG4gICAgICAgICAgICAgICAgaWYgKCsraTEgPj0gbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB2YXIgZHggPSB4IC0gY2VsbC5zaXRlWzBdLCBkeSA9IHkgLSBjZWxsLnNpdGVbMV0sIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgICAgICAvLyBUcmF2ZXJzZSB0aGUgaGFsZi1lZGdlcyB0byBmaW5kIGEgY2xvc2VyIGNlbGwsIGlmIGFueS5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjZWxsID0gdGhhdC5jZWxsc1tpMCA9IGkxXSwgaTEgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNlbGwuaGFsZmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSB0aGF0LmVkZ2VzW2VdLCB2ID0gZWRnZS5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHYgPT09IGNlbGwuc2l0ZSB8fCAhdikgJiYgISh2ID0gZWRnZS5yaWdodCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHZhciB2eCA9IHggLSB2WzBdLCB2eSA9IHkgLSB2WzFdLCB2MiA9IHZ4ICogdnggKyB2eSAqIHZ5O1xuICAgICAgICAgICAgICAgICAgICBpZiAodjIgPCBkMilcbiAgICAgICAgICAgICAgICAgICAgICAgIGQyID0gdjIsIGkxID0gdi5pbmRleDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGkxICE9PSBudWxsKTtcbiAgICAgICAgICAgIHRoYXQuX2ZvdW5kID0gaTA7XG4gICAgICAgICAgICByZXR1cm4gcmFkaXVzID09IG51bGwgfHwgZDIgPD0gcmFkaXVzICogcmFkaXVzID8gY2VsbC5zaXRlIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gdm9yb25vaSgpIHtcbiAgICAgICAgdmFyIHgkJDEgPSB4LCB5JCQxID0geSwgZXh0ZW50ID0gbnVsbDtcbiAgICAgICAgZnVuY3Rpb24gdm9yb25vaShkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERpYWdyYW0oZGF0YS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IFtNYXRoLnJvdW5kKHgkJDEoZCwgaSwgZGF0YSkgLyBlcHNpbG9uKSAqIGVwc2lsb24sIE1hdGgucm91bmQoeSQkMShkLCBpLCBkYXRhKSAvIGVwc2lsb24pICogZXBzaWxvbl07XG4gICAgICAgICAgICAgICAgcy5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgcy5kYXRhID0gZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgICAgIH0pLCBleHRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHZvcm9ub2kucG9seWdvbnMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHZvcm9ub2koZGF0YSkucG9seWdvbnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdm9yb25vaS5saW5rcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9yb25vaShkYXRhKS5saW5rcygpO1xuICAgICAgICB9O1xuICAgICAgICB2b3Jvbm9pLnRyaWFuZ2xlcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9yb25vaShkYXRhKS50cmlhbmdsZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdm9yb25vaS54ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgkJDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgdm9yb25vaSkgOiB4JCQxO1xuICAgICAgICB9O1xuICAgICAgICB2b3Jvbm9pLnkgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSQkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB2b3Jvbm9pKSA6IHkkJDE7XG4gICAgICAgIH07XG4gICAgICAgIHZvcm9ub2kuZXh0ZW50ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IF8gPT0gbnVsbCA/IG51bGwgOiBbWytfWzBdWzBdLCArX1swXVsxXV0sIFsrX1sxXVswXSwgK19bMV1bMV1dXSwgdm9yb25vaSkgOiBleHRlbnQgJiYgW1tleHRlbnRbMF1bMF0sIGV4dGVudFswXVsxXV0sIFtleHRlbnRbMV1bMF0sIGV4dGVudFsxXVsxXV1dO1xuICAgICAgICB9O1xuICAgICAgICB2b3Jvbm9pLnNpemUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZXh0ZW50ID0gXyA9PSBudWxsID8gbnVsbCA6IFtbMCwgMF0sIFsrX1swXSwgK19bMV1dXSwgdm9yb25vaSkgOiBleHRlbnQgJiYgW2V4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSwgZXh0ZW50WzFdWzFdIC0gZXh0ZW50WzBdWzFdXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHZvcm9ub2k7XG4gICAgfVxuICAgIGV4cG9ydHMudm9yb25vaSA9IHZvcm9ub2k7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn0pKSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qXG5Db3B5cmlnaHQgKGMpIDIwMTItMjAxNCBDaHJpcyBQZXR0aXR0XG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cbiovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBncmFwaGxpYjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIvZ3JhcGhsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2dyYXBobGliLmpzXCIpLFxuXG4gIGxheW91dDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIvbGF5b3V0ICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sYXlvdXQuanNcIiksXG4gIGRlYnVnOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpYi9kZWJ1ZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZGVidWcuanNcIiksXG4gIHV0aWw6IHtcbiAgICB0aW1lOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpYi91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi91dGlsLmpzXCIpLnRpbWUsXG4gICAgbm90aW1lOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpYi91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi91dGlsLmpzXCIpLm5vdGltZVxuICB9LFxuICB2ZXJzaW9uOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpYi92ZXJzaW9uICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi92ZXJzaW9uLmpzXCIpXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvYWN5Y2xpYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9hY3ljbGljLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG52YXIgZ3JlZWR5RkFTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ncmVlZHktZmFzICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9ncmVlZHktZmFzLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcnVuOiBydW4sXG4gIHVuZG86IHVuZG9cbn07XG5cbmZ1bmN0aW9uIHJ1bihnKSB7XG4gIHZhciBmYXMgPSAoZy5ncmFwaCgpLmFjeWNsaWNlciA9PT0gXCJncmVlZHlcIlxuICAgID8gZ3JlZWR5RkFTKGcsIHdlaWdodEZuKGcpKVxuICAgIDogZGZzRkFTKGcpKTtcbiAgXy5mb3JFYWNoKGZhcywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBsYWJlbCA9IGcuZWRnZShlKTtcbiAgICBnLnJlbW92ZUVkZ2UoZSk7XG4gICAgbGFiZWwuZm9yd2FyZE5hbWUgPSBlLm5hbWU7XG4gICAgbGFiZWwucmV2ZXJzZWQgPSB0cnVlO1xuICAgIGcuc2V0RWRnZShlLncsIGUudiwgbGFiZWwsIF8udW5pcXVlSWQoXCJyZXZcIikpO1xuICB9KTtcblxuICBmdW5jdGlvbiB3ZWlnaHRGbihnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiBnLmVkZ2UoZSkud2VpZ2h0O1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZGZzRkFTKGcpIHtcbiAgdmFyIGZhcyA9IFtdO1xuICB2YXIgc3RhY2sgPSB7fTtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIGlmIChfLmhhcyh2aXNpdGVkLCB2KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICBzdGFja1t2XSA9IHRydWU7XG4gICAgXy5mb3JFYWNoKGcub3V0RWRnZXModiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChfLmhhcyhzdGFjaywgZS53KSkge1xuICAgICAgICBmYXMucHVzaChlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRmcyhlLncpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlbGV0ZSBzdGFja1t2XTtcbiAgfVxuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGRmcyk7XG4gIHJldHVybiBmYXM7XG59XG5cbmZ1bmN0aW9uIHVuZG8oZykge1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGxhYmVsID0gZy5lZGdlKGUpO1xuICAgIGlmIChsYWJlbC5yZXZlcnNlZCkge1xuICAgICAgZy5yZW1vdmVFZGdlKGUpO1xuXG4gICAgICB2YXIgZm9yd2FyZE5hbWUgPSBsYWJlbC5mb3J3YXJkTmFtZTtcbiAgICAgIGRlbGV0ZSBsYWJlbC5yZXZlcnNlZDtcbiAgICAgIGRlbGV0ZSBsYWJlbC5mb3J3YXJkTmFtZTtcbiAgICAgIGcuc2V0RWRnZShlLncsIGUudiwgbGFiZWwsIGZvcndhcmROYW1lKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvYWRkLWJvcmRlci1zZWdtZW50cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9hZGQtYm9yZGVyLXNlZ21lbnRzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvdXRpbC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRCb3JkZXJTZWdtZW50cztcblxuZnVuY3Rpb24gYWRkQm9yZGVyU2VnbWVudHMoZykge1xuICBmdW5jdGlvbiBkZnModikge1xuICAgIHZhciBjaGlsZHJlbiA9IGcuY2hpbGRyZW4odik7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgXy5mb3JFYWNoKGNoaWxkcmVuLCBkZnMpO1xuICAgIH1cblxuICAgIGlmIChfLmhhcyhub2RlLCBcIm1pblJhbmtcIikpIHtcbiAgICAgIG5vZGUuYm9yZGVyTGVmdCA9IFtdO1xuICAgICAgbm9kZS5ib3JkZXJSaWdodCA9IFtdO1xuICAgICAgZm9yICh2YXIgcmFuayA9IG5vZGUubWluUmFuaywgbWF4UmFuayA9IG5vZGUubWF4UmFuayArIDE7XG4gICAgICAgIHJhbmsgPCBtYXhSYW5rO1xuICAgICAgICArK3JhbmspIHtcbiAgICAgICAgYWRkQm9yZGVyTm9kZShnLCBcImJvcmRlckxlZnRcIiwgXCJfYmxcIiwgdiwgbm9kZSwgcmFuayk7XG4gICAgICAgIGFkZEJvcmRlck5vZGUoZywgXCJib3JkZXJSaWdodFwiLCBcIl9iclwiLCB2LCBub2RlLCByYW5rKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfLmZvckVhY2goZy5jaGlsZHJlbigpLCBkZnMpO1xufVxuXG5mdW5jdGlvbiBhZGRCb3JkZXJOb2RlKGcsIHByb3AsIHByZWZpeCwgc2csIHNnTm9kZSwgcmFuaykge1xuICB2YXIgbGFiZWwgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAsIHJhbms6IHJhbmssIGJvcmRlclR5cGU6IHByb3AgfTtcbiAgdmFyIHByZXYgPSBzZ05vZGVbcHJvcF1bcmFuayAtIDFdO1xuICB2YXIgY3VyciA9IHV0aWwuYWRkRHVtbXlOb2RlKGcsIFwiYm9yZGVyXCIsIGxhYmVsLCBwcmVmaXgpO1xuICBzZ05vZGVbcHJvcF1bcmFua10gPSBjdXJyO1xuICBnLnNldFBhcmVudChjdXJyLCBzZyk7XG4gIGlmIChwcmV2KSB7XG4gICAgZy5zZXRFZGdlKHByZXYsIGN1cnIsIHsgd2VpZ2h0OiAxIH0pO1xuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9jb29yZGluYXRlLXN5c3RlbS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvY29vcmRpbmF0ZS1zeXN0ZW0uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGp1c3Q6IGFkanVzdCxcbiAgdW5kbzogdW5kb1xufTtcblxuZnVuY3Rpb24gYWRqdXN0KGcpIHtcbiAgdmFyIHJhbmtEaXIgPSBnLmdyYXBoKCkucmFua2Rpci50b0xvd2VyQ2FzZSgpO1xuICBpZiAocmFua0RpciA9PT0gXCJsclwiIHx8IHJhbmtEaXIgPT09IFwicmxcIikge1xuICAgIHN3YXBXaWR0aEhlaWdodChnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmRvKGcpIHtcbiAgdmFyIHJhbmtEaXIgPSBnLmdyYXBoKCkucmFua2Rpci50b0xvd2VyQ2FzZSgpO1xuICBpZiAocmFua0RpciA9PT0gXCJidFwiIHx8IHJhbmtEaXIgPT09IFwicmxcIikge1xuICAgIHJldmVyc2VZKGcpO1xuICB9XG5cbiAgaWYgKHJhbmtEaXIgPT09IFwibHJcIiB8fCByYW5rRGlyID09PSBcInJsXCIpIHtcbiAgICBzd2FwWFkoZyk7XG4gICAgc3dhcFdpZHRoSGVpZ2h0KGcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN3YXBXaWR0aEhlaWdodChnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgc3dhcFdpZHRoSGVpZ2h0T25lKGcubm9kZSh2KSk7IH0pO1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7IHN3YXBXaWR0aEhlaWdodE9uZShnLmVkZ2UoZSkpOyB9KTtcbn1cblxuZnVuY3Rpb24gc3dhcFdpZHRoSGVpZ2h0T25lKGF0dHJzKSB7XG4gIHZhciB3ID0gYXR0cnMud2lkdGg7XG4gIGF0dHJzLndpZHRoID0gYXR0cnMuaGVpZ2h0O1xuICBhdHRycy5oZWlnaHQgPSB3O1xufVxuXG5mdW5jdGlvbiByZXZlcnNlWShnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgcmV2ZXJzZVlPbmUoZy5ub2RlKHYpKTsgfSk7XG5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIF8uZm9yRWFjaChlZGdlLnBvaW50cywgcmV2ZXJzZVlPbmUpO1xuICAgIGlmIChfLmhhcyhlZGdlLCBcInlcIikpIHtcbiAgICAgIHJldmVyc2VZT25lKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJldmVyc2VZT25lKGF0dHJzKSB7XG4gIGF0dHJzLnkgPSAtYXR0cnMueTtcbn1cblxuZnVuY3Rpb24gc3dhcFhZKGcpIHtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikgeyBzd2FwWFlPbmUoZy5ub2RlKHYpKTsgfSk7XG5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIF8uZm9yRWFjaChlZGdlLnBvaW50cywgc3dhcFhZT25lKTtcbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ4XCIpKSB7XG4gICAgICBzd2FwWFlPbmUoZWRnZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc3dhcFhZT25lKGF0dHJzKSB7XG4gIHZhciB4ID0gYXR0cnMueDtcbiAgYXR0cnMueCA9IGF0dHJzLnk7XG4gIGF0dHJzLnkgPSB4O1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZGF0YS9saXN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZGF0YS9saXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qXG4gKiBTaW1wbGUgZG91Ymx5IGxpbmtlZCBsaXN0IGltcGxlbWVudGF0aW9uIGRlcml2ZWQgZnJvbSBDb3JtZW4sIGV0IGFsLixcbiAqIFwiSW50cm9kdWN0aW9uIHRvIEFsZ29yaXRobXNcIi5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3Q7XG5cbmZ1bmN0aW9uIExpc3QoKSB7XG4gIHZhciBzZW50aW5lbCA9IHt9O1xuICBzZW50aW5lbC5fbmV4dCA9IHNlbnRpbmVsLl9wcmV2ID0gc2VudGluZWw7XG4gIHRoaXMuX3NlbnRpbmVsID0gc2VudGluZWw7XG59XG5cbkxpc3QucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbnRpbmVsID0gdGhpcy5fc2VudGluZWw7XG4gIHZhciBlbnRyeSA9IHNlbnRpbmVsLl9wcmV2O1xuICBpZiAoZW50cnkgIT09IHNlbnRpbmVsKSB7XG4gICAgdW5saW5rKGVudHJ5KTtcbiAgICByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbkxpc3QucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbihlbnRyeSkge1xuICB2YXIgc2VudGluZWwgPSB0aGlzLl9zZW50aW5lbDtcbiAgaWYgKGVudHJ5Ll9wcmV2ICYmIGVudHJ5Ll9uZXh0KSB7XG4gICAgdW5saW5rKGVudHJ5KTtcbiAgfVxuICBlbnRyeS5fbmV4dCA9IHNlbnRpbmVsLl9uZXh0O1xuICBzZW50aW5lbC5fbmV4dC5fcHJldiA9IGVudHJ5O1xuICBzZW50aW5lbC5fbmV4dCA9IGVudHJ5O1xuICBlbnRyeS5fcHJldiA9IHNlbnRpbmVsO1xufTtcblxuTGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0cnMgPSBbXTtcbiAgdmFyIHNlbnRpbmVsID0gdGhpcy5fc2VudGluZWw7XG4gIHZhciBjdXJyID0gc2VudGluZWwuX3ByZXY7XG4gIHdoaWxlIChjdXJyICE9PSBzZW50aW5lbCkge1xuICAgIHN0cnMucHVzaChKU09OLnN0cmluZ2lmeShjdXJyLCBmaWx0ZXJPdXRMaW5rcykpO1xuICAgIGN1cnIgPSBjdXJyLl9wcmV2O1xuICB9XG4gIHJldHVybiBcIltcIiArIHN0cnMuam9pbihcIiwgXCIpICsgXCJdXCI7XG59O1xuXG5mdW5jdGlvbiB1bmxpbmsoZW50cnkpIHtcbiAgZW50cnkuX3ByZXYuX25leHQgPSBlbnRyeS5fbmV4dDtcbiAgZW50cnkuX25leHQuX3ByZXYgPSBlbnRyeS5fcHJldjtcbiAgZGVsZXRlIGVudHJ5Ll9uZXh0O1xuICBkZWxldGUgZW50cnkuX3ByZXY7XG59XG5cbmZ1bmN0aW9uIGZpbHRlck91dExpbmtzKGssIHYpIHtcbiAgaWYgKGsgIT09IFwiX25leHRcIiAmJiBrICE9PSBcIl9wcmV2XCIpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZGVidWcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2RlYnVnLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3V0aWwuanNcIik7XG52YXIgR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dyYXBobGliICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9ncmFwaGxpYi5qc1wiKS5HcmFwaDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlYnVnT3JkZXJpbmc6IGRlYnVnT3JkZXJpbmdcbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBkZWJ1Z09yZGVyaW5nKGcpIHtcbiAgdmFyIGxheWVyTWF0cml4ID0gdXRpbC5idWlsZExheWVyTWF0cml4KGcpO1xuXG4gIHZhciBoID0gbmV3IEdyYXBoKHsgY29tcG91bmQ6IHRydWUsIG11bHRpZ3JhcGg6IHRydWUgfSkuc2V0R3JhcGgoe30pO1xuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBoLnNldE5vZGUodiwgeyBsYWJlbDogdiB9KTtcbiAgICBoLnNldFBhcmVudCh2LCBcImxheWVyXCIgKyBnLm5vZGUodikucmFuayk7XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICBoLnNldEVkZ2UoZS52LCBlLncsIHt9LCBlLm5hbWUpO1xuICB9KTtcblxuICBfLmZvckVhY2gobGF5ZXJNYXRyaXgsIGZ1bmN0aW9uKGxheWVyLCBpKSB7XG4gICAgdmFyIGxheWVyViA9IFwibGF5ZXJcIiArIGk7XG4gICAgaC5zZXROb2RlKGxheWVyViwgeyByYW5rOiBcInNhbWVcIiB9KTtcbiAgICBfLnJlZHVjZShsYXllciwgZnVuY3Rpb24odSwgdikge1xuICAgICAgaC5zZXRFZGdlKHUsIHYsIHsgc3R5bGU6IFwiaW52aXNcIiB9KTtcbiAgICAgIHJldHVybiB2O1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gaDtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2dyYXBobGliLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9ncmFwaGxpYi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGdsb2JhbCB3aW5kb3cgKi9cblxudmFyIGdyYXBobGliO1xuXG5pZiAodHJ1ZSkge1xuICB0cnkge1xuICAgIGdyYXBobGliID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZ3JhcGhsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvaW5kZXguanNcIik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gIH1cbn1cblxuaWYgKCFncmFwaGxpYikge1xuICBncmFwaGxpYiA9IHdpbmRvdy5ncmFwaGxpYjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBncmFwaGxpYjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2dyZWVkeS1mYXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZ3JlZWR5LWZhcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xudmFyIEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9ncmFwaGxpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZ3JhcGhsaWIuanNcIikuR3JhcGg7XG52YXIgTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGF0YS9saXN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9kYXRhL2xpc3QuanNcIik7XG5cbi8qXG4gKiBBIGdyZWVkeSBoZXVyaXN0aWMgZm9yIGZpbmRpbmcgYSBmZWVkYmFjayBhcmMgc2V0IGZvciBhIGdyYXBoLiBBIGZlZWRiYWNrXG4gKiBhcmMgc2V0IGlzIGEgc2V0IG9mIGVkZ2VzIHRoYXQgY2FuIGJlIHJlbW92ZWQgdG8gbWFrZSBhIGdyYXBoIGFjeWNsaWMuXG4gKiBUaGUgYWxnb3JpdGhtIGNvbWVzIGZyb206IFAuIEVhZGVzLCBYLiBMaW4sIGFuZCBXLiBGLiBTbXl0aCwgXCJBIGZhc3QgYW5kXG4gKiBlZmZlY3RpdmUgaGV1cmlzdGljIGZvciB0aGUgZmVlZGJhY2sgYXJjIHNldCBwcm9ibGVtLlwiIFRoaXMgaW1wbGVtZW50YXRpb25cbiAqIGFkanVzdHMgdGhhdCBmcm9tIHRoZSBwYXBlciB0byBhbGxvdyBmb3Igd2VpZ2h0ZWQgZWRnZXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZ3JlZWR5RkFTO1xuXG52YXIgREVGQVVMVF9XRUlHSFRfRk4gPSBfLmNvbnN0YW50KDEpO1xuXG5mdW5jdGlvbiBncmVlZHlGQVMoZywgd2VpZ2h0Rm4pIHtcbiAgaWYgKGcubm9kZUNvdW50KCkgPD0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgc3RhdGUgPSBidWlsZFN0YXRlKGcsIHdlaWdodEZuIHx8IERFRkFVTFRfV0VJR0hUX0ZOKTtcbiAgdmFyIHJlc3VsdHMgPSBkb0dyZWVkeUZBUyhzdGF0ZS5ncmFwaCwgc3RhdGUuYnVja2V0cywgc3RhdGUuemVyb0lkeCk7XG5cbiAgLy8gRXhwYW5kIG11bHRpLWVkZ2VzXG4gIHJldHVybiBfLmZsYXR0ZW4oXy5tYXAocmVzdWx0cywgZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBnLm91dEVkZ2VzKGUudiwgZS53KTtcbiAgfSksIHRydWUpO1xufVxuXG5mdW5jdGlvbiBkb0dyZWVkeUZBUyhnLCBidWNrZXRzLCB6ZXJvSWR4KSB7XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciBzb3VyY2VzID0gYnVja2V0c1tidWNrZXRzLmxlbmd0aCAtIDFdO1xuICB2YXIgc2lua3MgPSBidWNrZXRzWzBdO1xuXG4gIHZhciBlbnRyeTtcbiAgd2hpbGUgKGcubm9kZUNvdW50KCkpIHtcbiAgICB3aGlsZSAoKGVudHJ5ID0gc2lua3MuZGVxdWV1ZSgpKSkgICB7IHJlbW92ZU5vZGUoZywgYnVja2V0cywgemVyb0lkeCwgZW50cnkpOyB9XG4gICAgd2hpbGUgKChlbnRyeSA9IHNvdXJjZXMuZGVxdWV1ZSgpKSkgeyByZW1vdmVOb2RlKGcsIGJ1Y2tldHMsIHplcm9JZHgsIGVudHJ5KTsgfVxuICAgIGlmIChnLm5vZGVDb3VudCgpKSB7XG4gICAgICBmb3IgKHZhciBpID0gYnVja2V0cy5sZW5ndGggLSAyOyBpID4gMDsgLS1pKSB7XG4gICAgICAgIGVudHJ5ID0gYnVja2V0c1tpXS5kZXF1ZXVlKCk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChyZW1vdmVOb2RlKGcsIGJ1Y2tldHMsIHplcm9JZHgsIGVudHJ5LCB0cnVlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShnLCBidWNrZXRzLCB6ZXJvSWR4LCBlbnRyeSwgY29sbGVjdFByZWRlY2Vzc29ycykge1xuICB2YXIgcmVzdWx0cyA9IGNvbGxlY3RQcmVkZWNlc3NvcnMgPyBbXSA6IHVuZGVmaW5lZDtcblxuICBfLmZvckVhY2goZy5pbkVkZ2VzKGVudHJ5LnYpLCBmdW5jdGlvbihlZGdlKSB7XG4gICAgdmFyIHdlaWdodCA9IGcuZWRnZShlZGdlKTtcbiAgICB2YXIgdUVudHJ5ID0gZy5ub2RlKGVkZ2Uudik7XG5cbiAgICBpZiAoY29sbGVjdFByZWRlY2Vzc29ycykge1xuICAgICAgcmVzdWx0cy5wdXNoKHsgdjogZWRnZS52LCB3OiBlZGdlLncgfSk7XG4gICAgfVxuXG4gICAgdUVudHJ5Lm91dCAtPSB3ZWlnaHQ7XG4gICAgYXNzaWduQnVja2V0KGJ1Y2tldHMsIHplcm9JZHgsIHVFbnRyeSk7XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChnLm91dEVkZ2VzKGVudHJ5LnYpLCBmdW5jdGlvbihlZGdlKSB7XG4gICAgdmFyIHdlaWdodCA9IGcuZWRnZShlZGdlKTtcbiAgICB2YXIgdyA9IGVkZ2UudztcbiAgICB2YXIgd0VudHJ5ID0gZy5ub2RlKHcpO1xuICAgIHdFbnRyeVtcImluXCJdIC09IHdlaWdodDtcbiAgICBhc3NpZ25CdWNrZXQoYnVja2V0cywgemVyb0lkeCwgd0VudHJ5KTtcbiAgfSk7XG5cbiAgZy5yZW1vdmVOb2RlKGVudHJ5LnYpO1xuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBidWlsZFN0YXRlKGcsIHdlaWdodEZuKSB7XG4gIHZhciBmYXNHcmFwaCA9IG5ldyBHcmFwaCgpO1xuICB2YXIgbWF4SW4gPSAwO1xuICB2YXIgbWF4T3V0ID0gMDtcblxuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgZmFzR3JhcGguc2V0Tm9kZSh2LCB7IHY6IHYsIFwiaW5cIjogMCwgb3V0OiAwIH0pO1xuICB9KTtcblxuICAvLyBBZ2dyZWdhdGUgd2VpZ2h0cyBvbiBub2RlcywgYnV0IGFsc28gc3VtIHRoZSB3ZWlnaHRzIGFjcm9zcyBtdWx0aS1lZGdlc1xuICAvLyBpbnRvIGEgc2luZ2xlIGVkZ2UgZm9yIHRoZSBmYXNHcmFwaC5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBwcmV2V2VpZ2h0ID0gZmFzR3JhcGguZWRnZShlLnYsIGUudykgfHwgMDtcbiAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4oZSk7XG4gICAgdmFyIGVkZ2VXZWlnaHQgPSBwcmV2V2VpZ2h0ICsgd2VpZ2h0O1xuICAgIGZhc0dyYXBoLnNldEVkZ2UoZS52LCBlLncsIGVkZ2VXZWlnaHQpO1xuICAgIG1heE91dCA9IE1hdGgubWF4KG1heE91dCwgZmFzR3JhcGgubm9kZShlLnYpLm91dCArPSB3ZWlnaHQpO1xuICAgIG1heEluICA9IE1hdGgubWF4KG1heEluLCAgZmFzR3JhcGgubm9kZShlLncpW1wiaW5cIl0gICs9IHdlaWdodCk7XG4gIH0pO1xuXG4gIHZhciBidWNrZXRzID0gXy5yYW5nZShtYXhPdXQgKyBtYXhJbiArIDMpLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBMaXN0KCk7IH0pO1xuICB2YXIgemVyb0lkeCA9IG1heEluICsgMTtcblxuICBfLmZvckVhY2goZmFzR3JhcGgubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGFzc2lnbkJ1Y2tldChidWNrZXRzLCB6ZXJvSWR4LCBmYXNHcmFwaC5ub2RlKHYpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgZ3JhcGg6IGZhc0dyYXBoLCBidWNrZXRzOiBidWNrZXRzLCB6ZXJvSWR4OiB6ZXJvSWR4IH07XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkJ1Y2tldChidWNrZXRzLCB6ZXJvSWR4LCBlbnRyeSkge1xuICBpZiAoIWVudHJ5Lm91dCkge1xuICAgIGJ1Y2tldHNbMF0uZW5xdWV1ZShlbnRyeSk7XG4gIH0gZWxzZSBpZiAoIWVudHJ5W1wiaW5cIl0pIHtcbiAgICBidWNrZXRzW2J1Y2tldHMubGVuZ3RoIC0gMV0uZW5xdWV1ZShlbnRyeSk7XG4gIH0gZWxzZSB7XG4gICAgYnVja2V0c1tlbnRyeS5vdXQgLSBlbnRyeVtcImluXCJdICsgemVyb0lkeF0uZW5xdWV1ZShlbnRyeSk7XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2xheW91dC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2xheW91dC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG52YXIgYWN5Y2xpYyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWN5Y2xpYyAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvYWN5Y2xpYy5qc1wiKTtcbnZhciBub3JtYWxpemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL25vcm1hbGl6ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbm9ybWFsaXplLmpzXCIpO1xudmFyIHJhbmsgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JhbmsgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3JhbmsvaW5kZXguanNcIik7XG52YXIgbm9ybWFsaXplUmFua3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3V0aWwuanNcIikubm9ybWFsaXplUmFua3M7XG52YXIgcGFyZW50RHVtbXlDaGFpbnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BhcmVudC1kdW1teS1jaGFpbnMgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3BhcmVudC1kdW1teS1jaGFpbnMuanNcIik7XG52YXIgcmVtb3ZlRW1wdHlSYW5rcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvdXRpbC5qc1wiKS5yZW1vdmVFbXB0eVJhbmtzO1xudmFyIG5lc3RpbmdHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbmVzdGluZy1ncmFwaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbmVzdGluZy1ncmFwaC5qc1wiKTtcbnZhciBhZGRCb3JkZXJTZWdtZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYWRkLWJvcmRlci1zZWdtZW50cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvYWRkLWJvcmRlci1zZWdtZW50cy5qc1wiKTtcbnZhciBjb29yZGluYXRlU3lzdGVtID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb29yZGluYXRlLXN5c3RlbSAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvY29vcmRpbmF0ZS1zeXN0ZW0uanNcIik7XG52YXIgb3JkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL29yZGVyICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9pbmRleC5qc1wiKTtcbnZhciBwb3NpdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcG9zaXRpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3Bvc2l0aW9uL2luZGV4LmpzXCIpO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3V0aWwuanNcIik7XG52YXIgR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dyYXBobGliICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9ncmFwaGxpYi5qc1wiKS5HcmFwaDtcblxubW9kdWxlLmV4cG9ydHMgPSBsYXlvdXQ7XG5cbmZ1bmN0aW9uIGxheW91dChnLCBvcHRzKSB7XG4gIHZhciB0aW1lID0gb3B0cyAmJiBvcHRzLmRlYnVnVGltaW5nID8gdXRpbC50aW1lIDogdXRpbC5ub3RpbWU7XG4gIHRpbWUoXCJsYXlvdXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxheW91dEdyYXBoID0gXG4gICAgICB0aW1lKFwiICBidWlsZExheW91dEdyYXBoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYnVpbGRMYXlvdXRHcmFwaChnKTsgfSk7XG4gICAgdGltZShcIiAgcnVuTGF5b3V0XCIsICAgICAgICBmdW5jdGlvbigpIHsgcnVuTGF5b3V0KGxheW91dEdyYXBoLCB0aW1lKTsgfSk7XG4gICAgdGltZShcIiAgdXBkYXRlSW5wdXRHcmFwaFwiLCBmdW5jdGlvbigpIHsgdXBkYXRlSW5wdXRHcmFwaChnLCBsYXlvdXRHcmFwaCk7IH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcnVuTGF5b3V0KGcsIHRpbWUpIHtcbiAgdGltZShcIiAgICBtYWtlU3BhY2VGb3JFZGdlTGFiZWxzXCIsIGZ1bmN0aW9uKCkgeyBtYWtlU3BhY2VGb3JFZGdlTGFiZWxzKGcpOyB9KTtcbiAgdGltZShcIiAgICByZW1vdmVTZWxmRWRnZXNcIiwgICAgICAgIGZ1bmN0aW9uKCkgeyByZW1vdmVTZWxmRWRnZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIGFjeWNsaWNcIiwgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IGFjeWNsaWMucnVuKGcpOyB9KTtcbiAgdGltZShcIiAgICBuZXN0aW5nR3JhcGgucnVuXCIsICAgICAgIGZ1bmN0aW9uKCkgeyBuZXN0aW5nR3JhcGgucnVuKGcpOyB9KTtcbiAgdGltZShcIiAgICByYW5rXCIsICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyByYW5rKHV0aWwuYXNOb25Db21wb3VuZEdyYXBoKGcpKTsgfSk7XG4gIHRpbWUoXCIgICAgaW5qZWN0RWRnZUxhYmVsUHJveGllc1wiLCBmdW5jdGlvbigpIHsgaW5qZWN0RWRnZUxhYmVsUHJveGllcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgcmVtb3ZlRW1wdHlSYW5rc1wiLCAgICAgICBmdW5jdGlvbigpIHsgcmVtb3ZlRW1wdHlSYW5rcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgbmVzdGluZ0dyYXBoLmNsZWFudXBcIiwgICBmdW5jdGlvbigpIHsgbmVzdGluZ0dyYXBoLmNsZWFudXAoZyk7IH0pO1xuICB0aW1lKFwiICAgIG5vcm1hbGl6ZVJhbmtzXCIsICAgICAgICAgZnVuY3Rpb24oKSB7IG5vcm1hbGl6ZVJhbmtzKGcpOyB9KTtcbiAgdGltZShcIiAgICBhc3NpZ25SYW5rTWluTWF4XCIsICAgICAgIGZ1bmN0aW9uKCkgeyBhc3NpZ25SYW5rTWluTWF4KGcpOyB9KTtcbiAgdGltZShcIiAgICByZW1vdmVFZGdlTGFiZWxQcm94aWVzXCIsIGZ1bmN0aW9uKCkgeyByZW1vdmVFZGdlTGFiZWxQcm94aWVzKGcpOyB9KTtcbiAgdGltZShcIiAgICBub3JtYWxpemUucnVuXCIsICAgICAgICAgIGZ1bmN0aW9uKCkgeyBub3JtYWxpemUucnVuKGcpOyB9KTtcbiAgdGltZShcIiAgICBwYXJlbnREdW1teUNoYWluc1wiLCAgICAgIGZ1bmN0aW9uKCkgeyBwYXJlbnREdW1teUNoYWlucyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgYWRkQm9yZGVyU2VnbWVudHNcIiwgICAgICBmdW5jdGlvbigpIHsgYWRkQm9yZGVyU2VnbWVudHMoZyk7IH0pO1xuICB0aW1lKFwiICAgIG9yZGVyXCIsICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IG9yZGVyKGcpOyB9KTtcbiAgdGltZShcIiAgICBpbnNlcnRTZWxmRWRnZXNcIiwgICAgICAgIGZ1bmN0aW9uKCkgeyBpbnNlcnRTZWxmRWRnZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIGFkanVzdENvb3JkaW5hdGVTeXN0ZW1cIiwgZnVuY3Rpb24oKSB7IGNvb3JkaW5hdGVTeXN0ZW0uYWRqdXN0KGcpOyB9KTtcbiAgdGltZShcIiAgICBwb3NpdGlvblwiLCAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyBwb3NpdGlvbihnKTsgfSk7XG4gIHRpbWUoXCIgICAgcG9zaXRpb25TZWxmRWRnZXNcIiwgICAgICBmdW5jdGlvbigpIHsgcG9zaXRpb25TZWxmRWRnZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIHJlbW92ZUJvcmRlck5vZGVzXCIsICAgICAgZnVuY3Rpb24oKSB7IHJlbW92ZUJvcmRlck5vZGVzKGcpOyB9KTtcbiAgdGltZShcIiAgICBub3JtYWxpemUudW5kb1wiLCAgICAgICAgIGZ1bmN0aW9uKCkgeyBub3JtYWxpemUudW5kbyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgZml4dXBFZGdlTGFiZWxDb29yZHNcIiwgICBmdW5jdGlvbigpIHsgZml4dXBFZGdlTGFiZWxDb29yZHMoZyk7IH0pO1xuICB0aW1lKFwiICAgIHVuZG9Db29yZGluYXRlU3lzdGVtXCIsICAgZnVuY3Rpb24oKSB7IGNvb3JkaW5hdGVTeXN0ZW0udW5kbyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgdHJhbnNsYXRlR3JhcGhcIiwgICAgICAgICBmdW5jdGlvbigpIHsgdHJhbnNsYXRlR3JhcGgoZyk7IH0pO1xuICB0aW1lKFwiICAgIGFzc2lnbk5vZGVJbnRlcnNlY3RzXCIsICAgZnVuY3Rpb24oKSB7IGFzc2lnbk5vZGVJbnRlcnNlY3RzKGcpOyB9KTtcbiAgdGltZShcIiAgICByZXZlcnNlUG9pbnRzXCIsICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXZlcnNlUG9pbnRzRm9yUmV2ZXJzZWRFZGdlcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgYWN5Y2xpYy51bmRvXCIsICAgICAgICAgICBmdW5jdGlvbigpIHsgYWN5Y2xpYy51bmRvKGcpOyB9KTtcbn1cblxuLypcbiAqIENvcGllcyBmaW5hbCBsYXlvdXQgaW5mb3JtYXRpb24gZnJvbSB0aGUgbGF5b3V0IGdyYXBoIGJhY2sgdG8gdGhlIGlucHV0XG4gKiBncmFwaC4gVGhpcyBwcm9jZXNzIG9ubHkgY29waWVzIHdoaXRlbGlzdGVkIGF0dHJpYnV0ZXMgZnJvbSB0aGUgbGF5b3V0IGdyYXBoXG4gKiB0byB0aGUgaW5wdXQgZ3JhcGgsIHNvIGl0IHNlcnZlcyBhcyBhIGdvb2QgcGxhY2UgdG8gZGV0ZXJtaW5lIHdoYXRcbiAqIGF0dHJpYnV0ZXMgY2FuIGluZmx1ZW5jZSBsYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUlucHV0R3JhcGgoaW5wdXRHcmFwaCwgbGF5b3V0R3JhcGgpIHtcbiAgXy5mb3JFYWNoKGlucHV0R3JhcGgubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBpbnB1dExhYmVsID0gaW5wdXRHcmFwaC5ub2RlKHYpO1xuICAgIHZhciBsYXlvdXRMYWJlbCA9IGxheW91dEdyYXBoLm5vZGUodik7XG5cbiAgICBpZiAoaW5wdXRMYWJlbCkge1xuICAgICAgaW5wdXRMYWJlbC54ID0gbGF5b3V0TGFiZWwueDtcbiAgICAgIGlucHV0TGFiZWwueSA9IGxheW91dExhYmVsLnk7XG5cbiAgICAgIGlmIChsYXlvdXRHcmFwaC5jaGlsZHJlbih2KS5sZW5ndGgpIHtcbiAgICAgICAgaW5wdXRMYWJlbC53aWR0aCA9IGxheW91dExhYmVsLndpZHRoO1xuICAgICAgICBpbnB1dExhYmVsLmhlaWdodCA9IGxheW91dExhYmVsLmhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChpbnB1dEdyYXBoLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgaW5wdXRMYWJlbCA9IGlucHV0R3JhcGguZWRnZShlKTtcbiAgICB2YXIgbGF5b3V0TGFiZWwgPSBsYXlvdXRHcmFwaC5lZGdlKGUpO1xuXG4gICAgaW5wdXRMYWJlbC5wb2ludHMgPSBsYXlvdXRMYWJlbC5wb2ludHM7XG4gICAgaWYgKF8uaGFzKGxheW91dExhYmVsLCBcInhcIikpIHtcbiAgICAgIGlucHV0TGFiZWwueCA9IGxheW91dExhYmVsLng7XG4gICAgICBpbnB1dExhYmVsLnkgPSBsYXlvdXRMYWJlbC55O1xuICAgIH1cbiAgfSk7XG5cbiAgaW5wdXRHcmFwaC5ncmFwaCgpLndpZHRoID0gbGF5b3V0R3JhcGguZ3JhcGgoKS53aWR0aDtcbiAgaW5wdXRHcmFwaC5ncmFwaCgpLmhlaWdodCA9IGxheW91dEdyYXBoLmdyYXBoKCkuaGVpZ2h0O1xufVxuXG52YXIgZ3JhcGhOdW1BdHRycyA9IFtcIm5vZGVzZXBcIiwgXCJlZGdlc2VwXCIsIFwicmFua3NlcFwiLCBcIm1hcmdpbnhcIiwgXCJtYXJnaW55XCJdO1xudmFyIGdyYXBoRGVmYXVsdHMgPSB7IHJhbmtzZXA6IDUwLCBlZGdlc2VwOiAyMCwgbm9kZXNlcDogNTAsIHJhbmtkaXI6IFwidGJcIiB9O1xudmFyIGdyYXBoQXR0cnMgPSBbXCJhY3ljbGljZXJcIiwgXCJyYW5rZXJcIiwgXCJyYW5rZGlyXCIsIFwiYWxpZ25cIl07XG52YXIgbm9kZU51bUF0dHJzID0gW1wid2lkdGhcIiwgXCJoZWlnaHRcIl07XG52YXIgbm9kZURlZmF1bHRzID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG52YXIgZWRnZU51bUF0dHJzID0gW1wibWlubGVuXCIsIFwid2VpZ2h0XCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJsYWJlbG9mZnNldFwiXTtcbnZhciBlZGdlRGVmYXVsdHMgPSB7XG4gIG1pbmxlbjogMSwgd2VpZ2h0OiAxLCB3aWR0aDogMCwgaGVpZ2h0OiAwLFxuICBsYWJlbG9mZnNldDogMTAsIGxhYmVscG9zOiBcInJcIlxufTtcbnZhciBlZGdlQXR0cnMgPSBbXCJsYWJlbHBvc1wiXTtcblxuLypcbiAqIENvbnN0cnVjdHMgYSBuZXcgZ3JhcGggZnJvbSB0aGUgaW5wdXQgZ3JhcGgsIHdoaWNoIGNhbiBiZSB1c2VkIGZvciBsYXlvdXQuXG4gKiBUaGlzIHByb2Nlc3MgY29waWVzIG9ubHkgd2hpdGVsaXN0ZWQgYXR0cmlidXRlcyBmcm9tIHRoZSBpbnB1dCBncmFwaCB0byB0aGVcbiAqIGxheW91dCBncmFwaC4gVGh1cyB0aGlzIGZ1bmN0aW9uIHNlcnZlcyBhcyBhIGdvb2QgcGxhY2UgdG8gZGV0ZXJtaW5lIHdoYXRcbiAqIGF0dHJpYnV0ZXMgY2FuIGluZmx1ZW5jZSBsYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0R3JhcGgoaW5wdXRHcmFwaCkge1xuICB2YXIgZyA9IG5ldyBHcmFwaCh7IG11bHRpZ3JhcGg6IHRydWUsIGNvbXBvdW5kOiB0cnVlIH0pO1xuICB2YXIgZ3JhcGggPSBjYW5vbmljYWxpemUoaW5wdXRHcmFwaC5ncmFwaCgpKTtcblxuICBnLnNldEdyYXBoKF8ubWVyZ2Uoe30sXG4gICAgZ3JhcGhEZWZhdWx0cyxcbiAgICBzZWxlY3ROdW1iZXJBdHRycyhncmFwaCwgZ3JhcGhOdW1BdHRycyksXG4gICAgXy5waWNrKGdyYXBoLCBncmFwaEF0dHJzKSkpO1xuXG4gIF8uZm9yRWFjaChpbnB1dEdyYXBoLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGNhbm9uaWNhbGl6ZShpbnB1dEdyYXBoLm5vZGUodikpO1xuICAgIGcuc2V0Tm9kZSh2LCBfLmRlZmF1bHRzKHNlbGVjdE51bWJlckF0dHJzKG5vZGUsIG5vZGVOdW1BdHRycyksIG5vZGVEZWZhdWx0cykpO1xuICAgIGcuc2V0UGFyZW50KHYsIGlucHV0R3JhcGgucGFyZW50KHYpKTtcbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGlucHV0R3JhcGguZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gY2Fub25pY2FsaXplKGlucHV0R3JhcGguZWRnZShlKSk7XG4gICAgZy5zZXRFZGdlKGUsIF8ubWVyZ2Uoe30sXG4gICAgICBlZGdlRGVmYXVsdHMsXG4gICAgICBzZWxlY3ROdW1iZXJBdHRycyhlZGdlLCBlZGdlTnVtQXR0cnMpLFxuICAgICAgXy5waWNrKGVkZ2UsIGVkZ2VBdHRycykpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGc7XG59XG5cbi8qXG4gKiBUaGlzIGlkZWEgY29tZXMgZnJvbSB0aGUgR2Fuc25lciBwYXBlcjogdG8gYWNjb3VudCBmb3IgZWRnZSBsYWJlbHMgaW4gb3VyXG4gKiBsYXlvdXQgd2Ugc3BsaXQgZWFjaCByYW5rIGluIGhhbGYgYnkgZG91YmxpbmcgbWlubGVuIGFuZCBoYWx2aW5nIHJhbmtzZXAuXG4gKiBUaGVuIHdlIGNhbiBwbGFjZSBsYWJlbHMgYXQgdGhlc2UgbWlkLXBvaW50cyBiZXR3ZWVuIG5vZGVzLlxuICpcbiAqIFdlIGFsc28gYWRkIHNvbWUgbWluaW1hbCBwYWRkaW5nIHRvIHRoZSB3aWR0aCB0byBwdXNoIHRoZSBsYWJlbCBmb3IgdGhlIGVkZ2VcbiAqIGF3YXkgZnJvbSB0aGUgZWRnZSBpdHNlbGYgYSBiaXQuXG4gKi9cbmZ1bmN0aW9uIG1ha2VTcGFjZUZvckVkZ2VMYWJlbHMoZykge1xuICB2YXIgZ3JhcGggPSBnLmdyYXBoKCk7XG4gIGdyYXBoLnJhbmtzZXAgLz0gMjtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIGVkZ2UubWlubGVuICo9IDI7XG4gICAgaWYgKGVkZ2UubGFiZWxwb3MudG9Mb3dlckNhc2UoKSAhPT0gXCJjXCIpIHtcbiAgICAgIGlmIChncmFwaC5yYW5rZGlyID09PSBcIlRCXCIgfHwgZ3JhcGgucmFua2RpciA9PT0gXCJCVFwiKSB7XG4gICAgICAgIGVkZ2Uud2lkdGggKz0gZWRnZS5sYWJlbG9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2UuaGVpZ2h0ICs9IGVkZ2UubGFiZWxvZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLypcbiAqIENyZWF0ZXMgdGVtcG9yYXJ5IGR1bW15IG5vZGVzIHRoYXQgY2FwdHVyZSB0aGUgcmFuayBpbiB3aGljaCBlYWNoIGVkZ2Unc1xuICogbGFiZWwgaXMgZ29pbmcgdG8sIGlmIGl0IGhhcyBvbmUgb2Ygbm9uLXplcm8gd2lkdGggYW5kIGhlaWdodC4gV2UgZG8gdGhpc1xuICogc28gdGhhdCB3ZSBjYW4gc2FmZWx5IHJlbW92ZSBlbXB0eSByYW5rcyB3aGlsZSBwcmVzZXJ2aW5nIGJhbGFuY2UgZm9yIHRoZVxuICogbGFiZWwncyBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RWRnZUxhYmVsUHJveGllcyhnKSB7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBpZiAoZWRnZS53aWR0aCAmJiBlZGdlLmhlaWdodCkge1xuICAgICAgdmFyIHYgPSBnLm5vZGUoZS52KTtcbiAgICAgIHZhciB3ID0gZy5ub2RlKGUudyk7XG4gICAgICB2YXIgbGFiZWwgPSB7IHJhbms6ICh3LnJhbmsgLSB2LnJhbmspIC8gMiArIHYucmFuaywgZTogZSB9O1xuICAgICAgdXRpbC5hZGREdW1teU5vZGUoZywgXCJlZGdlLXByb3h5XCIsIGxhYmVsLCBcIl9lcFwiKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25SYW5rTWluTWF4KGcpIHtcbiAgdmFyIG1heFJhbmsgPSAwO1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgaWYgKG5vZGUuYm9yZGVyVG9wKSB7XG4gICAgICBub2RlLm1pblJhbmsgPSBnLm5vZGUobm9kZS5ib3JkZXJUb3ApLnJhbms7XG4gICAgICBub2RlLm1heFJhbmsgPSBnLm5vZGUobm9kZS5ib3JkZXJCb3R0b20pLnJhbms7XG4gICAgICBtYXhSYW5rID0gXy5tYXgobWF4UmFuaywgbm9kZS5tYXhSYW5rKTtcbiAgICB9XG4gIH0pO1xuICBnLmdyYXBoKCkubWF4UmFuayA9IG1heFJhbms7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUVkZ2VMYWJlbFByb3hpZXMoZykge1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgaWYgKG5vZGUuZHVtbXkgPT09IFwiZWRnZS1wcm94eVwiKSB7XG4gICAgICBnLmVkZ2Uobm9kZS5lKS5sYWJlbFJhbmsgPSBub2RlLnJhbms7XG4gICAgICBnLnJlbW92ZU5vZGUodik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlR3JhcGgoZykge1xuICB2YXIgbWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgdmFyIG1heFggPSAwO1xuICB2YXIgbWluWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgdmFyIG1heFkgPSAwO1xuICB2YXIgZ3JhcGhMYWJlbCA9IGcuZ3JhcGgoKTtcbiAgdmFyIG1hcmdpblggPSBncmFwaExhYmVsLm1hcmdpbnggfHwgMDtcbiAgdmFyIG1hcmdpblkgPSBncmFwaExhYmVsLm1hcmdpbnkgfHwgMDtcblxuICBmdW5jdGlvbiBnZXRFeHRyZW1lcyhhdHRycykge1xuICAgIHZhciB4ID0gYXR0cnMueDtcbiAgICB2YXIgeSA9IGF0dHJzLnk7XG4gICAgdmFyIHcgPSBhdHRycy53aWR0aDtcbiAgICB2YXIgaCA9IGF0dHJzLmhlaWdodDtcbiAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCAtIHcgLyAyKTtcbiAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCArIHcgLyAyKTtcbiAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSAtIGggLyAyKTtcbiAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSArIGggLyAyKTtcbiAgfVxuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgZ2V0RXh0cmVtZXMoZy5ub2RlKHYpKTsgfSk7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ4XCIpKSB7XG4gICAgICBnZXRFeHRyZW1lcyhlZGdlKTtcbiAgICB9XG4gIH0pO1xuXG4gIG1pblggLT0gbWFyZ2luWDtcbiAgbWluWSAtPSBtYXJnaW5ZO1xuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBub2RlLnggLT0gbWluWDtcbiAgICBub2RlLnkgLT0gbWluWTtcbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIF8uZm9yRWFjaChlZGdlLnBvaW50cywgZnVuY3Rpb24ocCkge1xuICAgICAgcC54IC09IG1pblg7XG4gICAgICBwLnkgLT0gbWluWTtcbiAgICB9KTtcbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ4XCIpKSB7IGVkZ2UueCAtPSBtaW5YOyB9XG4gICAgaWYgKF8uaGFzKGVkZ2UsIFwieVwiKSkgeyBlZGdlLnkgLT0gbWluWTsgfVxuICB9KTtcblxuICBncmFwaExhYmVsLndpZHRoID0gbWF4WCAtIG1pblggKyBtYXJnaW5YO1xuICBncmFwaExhYmVsLmhlaWdodCA9IG1heFkgLSBtaW5ZICsgbWFyZ2luWTtcbn1cblxuZnVuY3Rpb24gYXNzaWduTm9kZUludGVyc2VjdHMoZykge1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgdmFyIG5vZGVWID0gZy5ub2RlKGUudik7XG4gICAgdmFyIG5vZGVXID0gZy5ub2RlKGUudyk7XG4gICAgdmFyIHAxLCBwMjtcbiAgICBpZiAoIWVkZ2UucG9pbnRzKSB7XG4gICAgICBlZGdlLnBvaW50cyA9IFtdO1xuICAgICAgcDEgPSBub2RlVztcbiAgICAgIHAyID0gbm9kZVY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAxID0gZWRnZS5wb2ludHNbMF07XG4gICAgICBwMiA9IGVkZ2UucG9pbnRzW2VkZ2UucG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBlZGdlLnBvaW50cy51bnNoaWZ0KHV0aWwuaW50ZXJzZWN0UmVjdChub2RlViwgcDEpKTtcbiAgICBlZGdlLnBvaW50cy5wdXNoKHV0aWwuaW50ZXJzZWN0UmVjdChub2RlVywgcDIpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpeHVwRWRnZUxhYmVsQ29vcmRzKGcpIHtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIGlmIChfLmhhcyhlZGdlLCBcInhcIikpIHtcbiAgICAgIGlmIChlZGdlLmxhYmVscG9zID09PSBcImxcIiB8fCBlZGdlLmxhYmVscG9zID09PSBcInJcIikge1xuICAgICAgICBlZGdlLndpZHRoIC09IGVkZ2UubGFiZWxvZmZzZXQ7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGVkZ2UubGFiZWxwb3MpIHtcbiAgICAgIGNhc2UgXCJsXCI6IGVkZ2UueCAtPSBlZGdlLndpZHRoIC8gMiArIGVkZ2UubGFiZWxvZmZzZXQ7IGJyZWFrO1xuICAgICAgY2FzZSBcInJcIjogZWRnZS54ICs9IGVkZ2Uud2lkdGggLyAyICsgZWRnZS5sYWJlbG9mZnNldDsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVBvaW50c0ZvclJldmVyc2VkRWRnZXMoZykge1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgaWYgKGVkZ2UucmV2ZXJzZWQpIHtcbiAgICAgIGVkZ2UucG9pbnRzLnJldmVyc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVCb3JkZXJOb2RlcyhnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoZy5jaGlsZHJlbih2KS5sZW5ndGgpIHtcbiAgICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgICAgdmFyIHQgPSBnLm5vZGUobm9kZS5ib3JkZXJUb3ApO1xuICAgICAgdmFyIGIgPSBnLm5vZGUobm9kZS5ib3JkZXJCb3R0b20pO1xuICAgICAgdmFyIGwgPSBnLm5vZGUoXy5sYXN0KG5vZGUuYm9yZGVyTGVmdCkpO1xuICAgICAgdmFyIHIgPSBnLm5vZGUoXy5sYXN0KG5vZGUuYm9yZGVyUmlnaHQpKTtcblxuICAgICAgbm9kZS53aWR0aCA9IE1hdGguYWJzKHIueCAtIGwueCk7XG4gICAgICBub2RlLmhlaWdodCA9IE1hdGguYWJzKGIueSAtIHQueSk7XG4gICAgICBub2RlLnggPSBsLnggKyBub2RlLndpZHRoIC8gMjtcbiAgICAgIG5vZGUueSA9IHQueSArIG5vZGUuaGVpZ2h0IC8gMjtcbiAgICB9XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoZy5ub2RlKHYpLmR1bW15ID09PSBcImJvcmRlclwiKSB7XG4gICAgICBnLnJlbW92ZU5vZGUodik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU2VsZkVkZ2VzKGcpIHtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIGlmIChlLnYgPT09IGUudykge1xuICAgICAgdmFyIG5vZGUgPSBnLm5vZGUoZS52KTtcbiAgICAgIGlmICghbm9kZS5zZWxmRWRnZXMpIHtcbiAgICAgICAgbm9kZS5zZWxmRWRnZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2VsZkVkZ2VzLnB1c2goeyBlOiBlLCBsYWJlbDogZy5lZGdlKGUpIH0pO1xuICAgICAgZy5yZW1vdmVFZGdlKGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydFNlbGZFZGdlcyhnKSB7XG4gIHZhciBsYXllcnMgPSB1dGlsLmJ1aWxkTGF5ZXJNYXRyaXgoZyk7XG4gIF8uZm9yRWFjaChsYXllcnMsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIG9yZGVyU2hpZnQgPSAwO1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odiwgaSkge1xuICAgICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgICBub2RlLm9yZGVyID0gaSArIG9yZGVyU2hpZnQ7XG4gICAgICBfLmZvckVhY2gobm9kZS5zZWxmRWRnZXMsIGZ1bmN0aW9uKHNlbGZFZGdlKSB7XG4gICAgICAgIHV0aWwuYWRkRHVtbXlOb2RlKGcsIFwic2VsZmVkZ2VcIiwge1xuICAgICAgICAgIHdpZHRoOiBzZWxmRWRnZS5sYWJlbC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHNlbGZFZGdlLmxhYmVsLmhlaWdodCxcbiAgICAgICAgICByYW5rOiBub2RlLnJhbmssXG4gICAgICAgICAgb3JkZXI6IGkgKyAoKytvcmRlclNoaWZ0KSxcbiAgICAgICAgICBlOiBzZWxmRWRnZS5lLFxuICAgICAgICAgIGxhYmVsOiBzZWxmRWRnZS5sYWJlbFxuICAgICAgICB9LCBcIl9zZVwiKTtcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIG5vZGUuc2VsZkVkZ2VzO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcG9zaXRpb25TZWxmRWRnZXMoZykge1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgaWYgKG5vZGUuZHVtbXkgPT09IFwic2VsZmVkZ2VcIikge1xuICAgICAgdmFyIHNlbGZOb2RlID0gZy5ub2RlKG5vZGUuZS52KTtcbiAgICAgIHZhciB4ID0gc2VsZk5vZGUueCArIHNlbGZOb2RlLndpZHRoIC8gMjtcbiAgICAgIHZhciB5ID0gc2VsZk5vZGUueTtcbiAgICAgIHZhciBkeCA9IG5vZGUueCAtIHg7XG4gICAgICB2YXIgZHkgPSBzZWxmTm9kZS5oZWlnaHQgLyAyO1xuICAgICAgZy5zZXRFZGdlKG5vZGUuZSwgbm9kZS5sYWJlbCk7XG4gICAgICBnLnJlbW92ZU5vZGUodik7XG4gICAgICBub2RlLmxhYmVsLnBvaW50cyA9IFtcbiAgICAgICAgeyB4OiB4ICsgMiAqIGR4IC8gMywgeTogeSAtIGR5IH0sXG4gICAgICAgIHsgeDogeCArIDUgKiBkeCAvIDYsIHk6IHkgLSBkeSB9LFxuICAgICAgICB7IHg6IHggKyAgICAgZHggICAgLCB5OiB5IH0sXG4gICAgICAgIHsgeDogeCArIDUgKiBkeCAvIDYsIHk6IHkgKyBkeSB9LFxuICAgICAgICB7IHg6IHggKyAyICogZHggLyAzLCB5OiB5ICsgZHkgfVxuICAgICAgXTtcbiAgICAgIG5vZGUubGFiZWwueCA9IG5vZGUueDtcbiAgICAgIG5vZGUubGFiZWwueSA9IG5vZGUueTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZWxlY3ROdW1iZXJBdHRycyhvYmosIGF0dHJzKSB7XG4gIHJldHVybiBfLm1hcFZhbHVlcyhfLnBpY2sob2JqLCBhdHRycyksIE51bWJlcik7XG59XG5cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZShhdHRycykge1xuICB2YXIgbmV3QXR0cnMgPSB7fTtcbiAgXy5mb3JFYWNoKGF0dHJzLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgbmV3QXR0cnNbay50b0xvd2VyQ2FzZSgpXSA9IHY7XG4gIH0pO1xuICByZXR1cm4gbmV3QXR0cnM7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG52YXIgbG9kYXNoO1xuXG5pZiAodHJ1ZSkge1xuICB0cnkge1xuICAgIGxvZGFzaCA9IHtcbiAgICAgIGNsb25lRGVlcDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL2Nsb25lRGVlcCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvY2xvbmVEZWVwLmpzXCIpLFxuICAgICAgY29uc3RhbnQ6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9jb25zdGFudCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvY29uc3RhbnQuanNcIiksXG4gICAgICBkZWZhdWx0czogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL2RlZmF1bHRzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9kZWZhdWx0cy5qc1wiKSxcbiAgICAgIGVhY2g6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9lYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9lYWNoLmpzXCIpLFxuICAgICAgZmlsdGVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvZmlsdGVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9maWx0ZXIuanNcIiksXG4gICAgICBmaW5kOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvZmluZCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZmluZC5qc1wiKSxcbiAgICAgIGZsYXR0ZW46IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9mbGF0dGVuICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9mbGF0dGVuLmpzXCIpLFxuICAgICAgZm9yRWFjaDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL2ZvckVhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2ZvckVhY2guanNcIiksXG4gICAgICBmb3JJbjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL2ZvckluICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9mb3JJbi5qc1wiKSxcbiAgICAgIGhhczogIF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2hhcy5qc1wiKSxcbiAgICAgIGlzVW5kZWZpbmVkOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvaXNVbmRlZmluZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzVW5kZWZpbmVkLmpzXCIpLFxuICAgICAgbGFzdDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL2xhc3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2xhc3QuanNcIiksXG4gICAgICBtYXA6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9tYXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL21hcC5qc1wiKSxcbiAgICAgIG1hcFZhbHVlczogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL21hcFZhbHVlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWFwVmFsdWVzLmpzXCIpLFxuICAgICAgbWF4OiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvbWF4ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9tYXguanNcIiksXG4gICAgICBtZXJnZTogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL21lcmdlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9tZXJnZS5qc1wiKSxcbiAgICAgIG1pbjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL21pbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWluLmpzXCIpLFxuICAgICAgbWluQnk6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9taW5CeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWluQnkuanNcIiksXG4gICAgICBub3c6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9ub3cgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL25vdy5qc1wiKSxcbiAgICAgIHBpY2s6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9waWNrICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9waWNrLmpzXCIpLFxuICAgICAgcmFuZ2U6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9yYW5nZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvcmFuZ2UuanNcIiksXG4gICAgICByZWR1Y2U6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9yZWR1Y2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3JlZHVjZS5qc1wiKSxcbiAgICAgIHNvcnRCeTogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL3NvcnRCeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvc29ydEJ5LmpzXCIpLFxuICAgICAgdW5pcXVlSWQ6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC91bmlxdWVJZCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdW5pcXVlSWQuanNcIiksXG4gICAgICB2YWx1ZXM6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC92YWx1ZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3ZhbHVlcy5qc1wiKSxcbiAgICAgIHppcE9iamVjdDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL3ppcE9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvemlwT2JqZWN0LmpzXCIpLFxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gIH1cbn1cblxuaWYgKCFsb2Rhc2gpIHtcbiAgbG9kYXNoID0gd2luZG93Ll87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbG9kYXNoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbmVzdGluZy1ncmFwaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9uZXN0aW5nLWdyYXBoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvdXRpbC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJ1bjogcnVuLFxuICBjbGVhbnVwOiBjbGVhbnVwXG59O1xuXG4vKlxuICogQSBuZXN0aW5nIGdyYXBoIGNyZWF0ZXMgZHVtbXkgbm9kZXMgZm9yIHRoZSB0b3BzIGFuZCBib3R0b21zIG9mIHN1YmdyYXBocyxcbiAqIGFkZHMgYXBwcm9wcmlhdGUgZWRnZXMgdG8gZW5zdXJlIHRoYXQgYWxsIGNsdXN0ZXIgbm9kZXMgYXJlIHBsYWNlZCBiZXR3ZWVuXG4gKiB0aGVzZSBib3VuZHJpZXMsIGFuZCBlbnN1cmVzIHRoYXQgdGhlIGdyYXBoIGlzIGNvbm5lY3RlZC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB3ZSBlbnN1cmUsIHRocm91Z2ggdGhlIHVzZSBvZiB0aGUgbWlubGVuIHByb3BlcnR5LCB0aGF0IG5vZGVzXG4gKiBhbmQgc3ViZ3JhcGggYm9yZGVyIG5vZGVzIHRvIG5vdCBlbmQgdXAgb24gdGhlIHNhbWUgcmFuay5cbiAqXG4gKiBQcmVjb25kaXRpb25zOlxuICpcbiAqICAgIDEuIElucHV0IGdyYXBoIGlzIGEgREFHXG4gKiAgICAyLiBOb2RlcyBpbiB0aGUgaW5wdXQgZ3JhcGggaGFzIGEgbWlubGVuIGF0dHJpYnV0ZVxuICpcbiAqIFBvc3Rjb25kaXRpb25zOlxuICpcbiAqICAgIDEuIElucHV0IGdyYXBoIGlzIGNvbm5lY3RlZC5cbiAqICAgIDIuIER1bW15IG5vZGVzIGFyZSBhZGRlZCBmb3IgdGhlIHRvcHMgYW5kIGJvdHRvbXMgb2Ygc3ViZ3JhcGhzLlxuICogICAgMy4gVGhlIG1pbmxlbiBhdHRyaWJ1dGUgZm9yIG5vZGVzIGlzIGFkanVzdGVkIHRvIGVuc3VyZSBub2RlcyBkbyBub3RcbiAqICAgICAgIGdldCBwbGFjZWQgb24gdGhlIHNhbWUgcmFuayBhcyBzdWJncmFwaCBib3JkZXIgbm9kZXMuXG4gKlxuICogVGhlIG5lc3RpbmcgZ3JhcGggaWRlYSBjb21lcyBmcm9tIFNhbmRlciwgXCJMYXlvdXQgb2YgQ29tcG91bmQgRGlyZWN0ZWRcbiAqIEdyYXBocy5cIlxuICovXG5mdW5jdGlvbiBydW4oZykge1xuICB2YXIgcm9vdCA9IHV0aWwuYWRkRHVtbXlOb2RlKGcsIFwicm9vdFwiLCB7fSwgXCJfcm9vdFwiKTtcbiAgdmFyIGRlcHRocyA9IHRyZWVEZXB0aHMoZyk7XG4gIHZhciBoZWlnaHQgPSBfLm1heChfLnZhbHVlcyhkZXB0aHMpKSAtIDE7IC8vIE5vdGU6IGRlcHRocyBpcyBhbiBPYmplY3Qgbm90IGFuIGFycmF5XG4gIHZhciBub2RlU2VwID0gMiAqIGhlaWdodCArIDE7XG5cbiAgZy5ncmFwaCgpLm5lc3RpbmdSb290ID0gcm9vdDtcblxuICAvLyBNdWx0aXBseSBtaW5sZW4gYnkgbm9kZVNlcCB0byBhbGlnbiBub2RlcyBvbiBub24tYm9yZGVyIHJhbmtzLlxuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7IGcuZWRnZShlKS5taW5sZW4gKj0gbm9kZVNlcDsgfSk7XG5cbiAgLy8gQ2FsY3VsYXRlIGEgd2VpZ2h0IHRoYXQgaXMgc3VmZmljaWVudCB0byBrZWVwIHN1YmdyYXBocyB2ZXJ0aWNhbGx5IGNvbXBhY3RcbiAgdmFyIHdlaWdodCA9IHN1bVdlaWdodHMoZykgKyAxO1xuXG4gIC8vIENyZWF0ZSBib3JkZXIgbm9kZXMgYW5kIGxpbmsgdGhlbSB1cFxuICBfLmZvckVhY2goZy5jaGlsZHJlbigpLCBmdW5jdGlvbihjaGlsZCkge1xuICAgIGRmcyhnLCByb290LCBub2RlU2VwLCB3ZWlnaHQsIGhlaWdodCwgZGVwdGhzLCBjaGlsZCk7XG4gIH0pO1xuXG4gIC8vIFNhdmUgdGhlIG11bHRpcGxpZXIgZm9yIG5vZGUgbGF5ZXJzIGZvciBsYXRlciByZW1vdmFsIG9mIGVtcHR5IGJvcmRlclxuICAvLyBsYXllcnMuXG4gIGcuZ3JhcGgoKS5ub2RlUmFua0ZhY3RvciA9IG5vZGVTZXA7XG59XG5cbmZ1bmN0aW9uIGRmcyhnLCByb290LCBub2RlU2VwLCB3ZWlnaHQsIGhlaWdodCwgZGVwdGhzLCB2KSB7XG4gIHZhciBjaGlsZHJlbiA9IGcuY2hpbGRyZW4odik7XG4gIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgaWYgKHYgIT09IHJvb3QpIHtcbiAgICAgIGcuc2V0RWRnZShyb290LCB2LCB7IHdlaWdodDogMCwgbWlubGVuOiBub2RlU2VwIH0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdG9wID0gdXRpbC5hZGRCb3JkZXJOb2RlKGcsIFwiX2J0XCIpO1xuICB2YXIgYm90dG9tID0gdXRpbC5hZGRCb3JkZXJOb2RlKGcsIFwiX2JiXCIpO1xuICB2YXIgbGFiZWwgPSBnLm5vZGUodik7XG5cbiAgZy5zZXRQYXJlbnQodG9wLCB2KTtcbiAgbGFiZWwuYm9yZGVyVG9wID0gdG9wO1xuICBnLnNldFBhcmVudChib3R0b20sIHYpO1xuICBsYWJlbC5ib3JkZXJCb3R0b20gPSBib3R0b207XG5cbiAgXy5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgIGRmcyhnLCByb290LCBub2RlU2VwLCB3ZWlnaHQsIGhlaWdodCwgZGVwdGhzLCBjaGlsZCk7XG5cbiAgICB2YXIgY2hpbGROb2RlID0gZy5ub2RlKGNoaWxkKTtcbiAgICB2YXIgY2hpbGRUb3AgPSBjaGlsZE5vZGUuYm9yZGVyVG9wID8gY2hpbGROb2RlLmJvcmRlclRvcCA6IGNoaWxkO1xuICAgIHZhciBjaGlsZEJvdHRvbSA9IGNoaWxkTm9kZS5ib3JkZXJCb3R0b20gPyBjaGlsZE5vZGUuYm9yZGVyQm90dG9tIDogY2hpbGQ7XG4gICAgdmFyIHRoaXNXZWlnaHQgPSBjaGlsZE5vZGUuYm9yZGVyVG9wID8gd2VpZ2h0IDogMiAqIHdlaWdodDtcbiAgICB2YXIgbWlubGVuID0gY2hpbGRUb3AgIT09IGNoaWxkQm90dG9tID8gMSA6IGhlaWdodCAtIGRlcHRoc1t2XSArIDE7XG5cbiAgICBnLnNldEVkZ2UodG9wLCBjaGlsZFRvcCwge1xuICAgICAgd2VpZ2h0OiB0aGlzV2VpZ2h0LFxuICAgICAgbWlubGVuOiBtaW5sZW4sXG4gICAgICBuZXN0aW5nRWRnZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgZy5zZXRFZGdlKGNoaWxkQm90dG9tLCBib3R0b20sIHtcbiAgICAgIHdlaWdodDogdGhpc1dlaWdodCxcbiAgICAgIG1pbmxlbjogbWlubGVuLFxuICAgICAgbmVzdGluZ0VkZ2U6IHRydWVcbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKCFnLnBhcmVudCh2KSkge1xuICAgIGcuc2V0RWRnZShyb290LCB0b3AsIHsgd2VpZ2h0OiAwLCBtaW5sZW46IGhlaWdodCArIGRlcHRoc1t2XSB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmVlRGVwdGhzKGcpIHtcbiAgdmFyIGRlcHRocyA9IHt9O1xuICBmdW5jdGlvbiBkZnModiwgZGVwdGgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBnLmNoaWxkcmVuKHYpO1xuICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIF8uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgZGZzKGNoaWxkLCBkZXB0aCArIDEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGRlcHRoc1t2XSA9IGRlcHRoO1xuICB9XG4gIF8uZm9yRWFjaChnLmNoaWxkcmVuKCksIGZ1bmN0aW9uKHYpIHsgZGZzKHYsIDEpOyB9KTtcbiAgcmV0dXJuIGRlcHRocztcbn1cblxuZnVuY3Rpb24gc3VtV2VpZ2h0cyhnKSB7XG4gIHJldHVybiBfLnJlZHVjZShnLmVkZ2VzKCksIGZ1bmN0aW9uKGFjYywgZSkge1xuICAgIHJldHVybiBhY2MgKyBnLmVkZ2UoZSkud2VpZ2h0O1xuICB9LCAwKTtcbn1cblxuZnVuY3Rpb24gY2xlYW51cChnKSB7XG4gIHZhciBncmFwaExhYmVsID0gZy5ncmFwaCgpO1xuICBnLnJlbW92ZU5vZGUoZ3JhcGhMYWJlbC5uZXN0aW5nUm9vdCk7XG4gIGRlbGV0ZSBncmFwaExhYmVsLm5lc3RpbmdSb290O1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgaWYgKGVkZ2UubmVzdGluZ0VkZ2UpIHtcbiAgICAgIGcucmVtb3ZlRWRnZShlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbm9ybWFsaXplLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbm9ybWFsaXplLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2xvZGFzaC5qc1wiKTtcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi91dGlsLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcnVuOiBydW4sXG4gIHVuZG86IHVuZG9cbn07XG5cbi8qXG4gKiBCcmVha3MgYW55IGxvbmcgZWRnZXMgaW4gdGhlIGdyYXBoIGludG8gc2hvcnQgc2VnbWVudHMgdGhhdCBzcGFuIDEgbGF5ZXJcbiAqIGVhY2guIFRoaXMgb3BlcmF0aW9uIGlzIHVuZG9hYmxlIHdpdGggdGhlIGRlbm9ybWFsaXplIGZ1bmN0aW9uLlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIFRoZSBpbnB1dCBncmFwaCBpcyBhIERBRy5cbiAqICAgIDIuIEVhY2ggbm9kZSBpbiB0aGUgZ3JhcGggaGFzIGEgXCJyYW5rXCIgcHJvcGVydHkuXG4gKlxuICogUG9zdC1jb25kaXRpb246XG4gKlxuICogICAgMS4gQWxsIGVkZ2VzIGluIHRoZSBncmFwaCBoYXZlIGEgbGVuZ3RoIG9mIDEuXG4gKiAgICAyLiBEdW1teSBub2RlcyBhcmUgYWRkZWQgd2hlcmUgZWRnZXMgaGF2ZSBiZWVuIHNwbGl0IGludG8gc2VnbWVudHMuXG4gKiAgICAzLiBUaGUgZ3JhcGggaXMgYXVnbWVudGVkIHdpdGggYSBcImR1bW15Q2hhaW5zXCIgYXR0cmlidXRlIHdoaWNoIGNvbnRhaW5zXG4gKiAgICAgICB0aGUgZmlyc3QgZHVtbXkgaW4gZWFjaCBjaGFpbiBvZiBkdW1teSBub2RlcyBwcm9kdWNlZC5cbiAqL1xuZnVuY3Rpb24gcnVuKGcpIHtcbiAgZy5ncmFwaCgpLmR1bW15Q2hhaW5zID0gW107XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGVkZ2UpIHsgbm9ybWFsaXplRWRnZShnLCBlZGdlKTsgfSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVkZ2UoZywgZSkge1xuICB2YXIgdiA9IGUudjtcbiAgdmFyIHZSYW5rID0gZy5ub2RlKHYpLnJhbms7XG4gIHZhciB3ID0gZS53O1xuICB2YXIgd1JhbmsgPSBnLm5vZGUodykucmFuaztcbiAgdmFyIG5hbWUgPSBlLm5hbWU7XG4gIHZhciBlZGdlTGFiZWwgPSBnLmVkZ2UoZSk7XG4gIHZhciBsYWJlbFJhbmsgPSBlZGdlTGFiZWwubGFiZWxSYW5rO1xuXG4gIGlmICh3UmFuayA9PT0gdlJhbmsgKyAxKSByZXR1cm47XG5cbiAgZy5yZW1vdmVFZGdlKGUpO1xuXG4gIHZhciBkdW1teSwgYXR0cnMsIGk7XG4gIGZvciAoaSA9IDAsICsrdlJhbms7IHZSYW5rIDwgd1Jhbms7ICsraSwgKyt2UmFuaykge1xuICAgIGVkZ2VMYWJlbC5wb2ludHMgPSBbXTtcbiAgICBhdHRycyA9IHtcbiAgICAgIHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG4gICAgICBlZGdlTGFiZWw6IGVkZ2VMYWJlbCwgZWRnZU9iajogZSxcbiAgICAgIHJhbms6IHZSYW5rXG4gICAgfTtcbiAgICBkdW1teSA9IHV0aWwuYWRkRHVtbXlOb2RlKGcsIFwiZWRnZVwiLCBhdHRycywgXCJfZFwiKTtcbiAgICBpZiAodlJhbmsgPT09IGxhYmVsUmFuaykge1xuICAgICAgYXR0cnMud2lkdGggPSBlZGdlTGFiZWwud2lkdGg7XG4gICAgICBhdHRycy5oZWlnaHQgPSBlZGdlTGFiZWwuaGVpZ2h0O1xuICAgICAgYXR0cnMuZHVtbXkgPSBcImVkZ2UtbGFiZWxcIjtcbiAgICAgIGF0dHJzLmxhYmVscG9zID0gZWRnZUxhYmVsLmxhYmVscG9zO1xuICAgIH1cbiAgICBnLnNldEVkZ2UodiwgZHVtbXksIHsgd2VpZ2h0OiBlZGdlTGFiZWwud2VpZ2h0IH0sIG5hbWUpO1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBnLmdyYXBoKCkuZHVtbXlDaGFpbnMucHVzaChkdW1teSk7XG4gICAgfVxuICAgIHYgPSBkdW1teTtcbiAgfVxuXG4gIGcuc2V0RWRnZSh2LCB3LCB7IHdlaWdodDogZWRnZUxhYmVsLndlaWdodCB9LCBuYW1lKTtcbn1cblxuZnVuY3Rpb24gdW5kbyhnKSB7XG4gIF8uZm9yRWFjaChnLmdyYXBoKCkuZHVtbXlDaGFpbnMsIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICB2YXIgb3JpZ0xhYmVsID0gbm9kZS5lZGdlTGFiZWw7XG4gICAgdmFyIHc7XG4gICAgZy5zZXRFZGdlKG5vZGUuZWRnZU9iaiwgb3JpZ0xhYmVsKTtcbiAgICB3aGlsZSAobm9kZS5kdW1teSkge1xuICAgICAgdyA9IGcuc3VjY2Vzc29ycyh2KVswXTtcbiAgICAgIGcucmVtb3ZlTm9kZSh2KTtcbiAgICAgIG9yaWdMYWJlbC5wb2ludHMucHVzaCh7IHg6IG5vZGUueCwgeTogbm9kZS55IH0pO1xuICAgICAgaWYgKG5vZGUuZHVtbXkgPT09IFwiZWRnZS1sYWJlbFwiKSB7XG4gICAgICAgIG9yaWdMYWJlbC54ID0gbm9kZS54O1xuICAgICAgICBvcmlnTGFiZWwueSA9IG5vZGUueTtcbiAgICAgICAgb3JpZ0xhYmVsLndpZHRoID0gbm9kZS53aWR0aDtcbiAgICAgICAgb3JpZ0xhYmVsLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgdiA9IHc7XG4gICAgICBub2RlID0gZy5ub2RlKHYpO1xuICAgIH1cbiAgfSk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9hZGQtc3ViZ3JhcGgtY29uc3RyYWludHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9hZGQtc3ViZ3JhcGgtY29uc3RyYWludHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2xvZGFzaC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRTdWJncmFwaENvbnN0cmFpbnRzO1xuXG5mdW5jdGlvbiBhZGRTdWJncmFwaENvbnN0cmFpbnRzKGcsIGNnLCB2cykge1xuICB2YXIgcHJldiA9IHt9LFxuICAgIHJvb3RQcmV2O1xuXG4gIF8uZm9yRWFjaCh2cywgZnVuY3Rpb24odikge1xuICAgIHZhciBjaGlsZCA9IGcucGFyZW50KHYpLFxuICAgICAgcGFyZW50LFxuICAgICAgcHJldkNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgcGFyZW50ID0gZy5wYXJlbnQoY2hpbGQpO1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwcmV2Q2hpbGQgPSBwcmV2W3BhcmVudF07XG4gICAgICAgIHByZXZbcGFyZW50XSA9IGNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldkNoaWxkID0gcm9vdFByZXY7XG4gICAgICAgIHJvb3RQcmV2ID0gY2hpbGQ7XG4gICAgICB9XG4gICAgICBpZiAocHJldkNoaWxkICYmIHByZXZDaGlsZCAhPT0gY2hpbGQpIHtcbiAgICAgICAgY2cuc2V0RWRnZShwcmV2Q2hpbGQsIGNoaWxkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBwYXJlbnQ7XG4gICAgfVxuICB9KTtcblxuICAvKlxuICBmdW5jdGlvbiBkZnModikge1xuICAgIHZhciBjaGlsZHJlbiA9IHYgPyBnLmNoaWxkcmVuKHYpIDogZy5jaGlsZHJlbigpO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgc3ViZ3JhcGhzID0gW107XG4gICAgICBfLmVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZE1pbiA9IGRmcyhjaGlsZCk7XG4gICAgICAgIGlmIChnLmNoaWxkcmVuKGNoaWxkKS5sZW5ndGgpIHtcbiAgICAgICAgICBzdWJncmFwaHMucHVzaCh7IHY6IGNoaWxkLCBvcmRlcjogY2hpbGRNaW4gfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBjaGlsZE1pbik7XG4gICAgICB9KTtcbiAgICAgIF8ucmVkdWNlKF8uc29ydEJ5KHN1YmdyYXBocywgXCJvcmRlclwiKSwgZnVuY3Rpb24ocHJldiwgY3Vycikge1xuICAgICAgICBjZy5zZXRFZGdlKHByZXYudiwgY3Vyci52KTtcbiAgICAgICAgcmV0dXJuIGN1cnI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIHJldHVybiBnLm5vZGUodikub3JkZXI7XG4gIH1cbiAgZGZzKHVuZGVmaW5lZCk7XG4gICovXG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9iYXJ5Y2VudGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL2JhcnljZW50ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFyeWNlbnRlcjtcblxuZnVuY3Rpb24gYmFyeWNlbnRlcihnLCBtb3ZhYmxlKSB7XG4gIHJldHVybiBfLm1hcChtb3ZhYmxlLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIGluViA9IGcuaW5FZGdlcyh2KTtcbiAgICBpZiAoIWluVi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7IHY6IHYgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdCA9IF8ucmVkdWNlKGluViwgZnVuY3Rpb24oYWNjLCBlKSB7XG4gICAgICAgIHZhciBlZGdlID0gZy5lZGdlKGUpLFxuICAgICAgICAgIG5vZGVVID0gZy5ub2RlKGUudik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VtOiBhY2Muc3VtICsgKGVkZ2Uud2VpZ2h0ICogbm9kZVUub3JkZXIpLFxuICAgICAgICAgIHdlaWdodDogYWNjLndlaWdodCArIGVkZ2Uud2VpZ2h0XG4gICAgICAgIH07XG4gICAgICB9LCB7IHN1bTogMCwgd2VpZ2h0OiAwIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2OiB2LFxuICAgICAgICBiYXJ5Y2VudGVyOiByZXN1bHQuc3VtIC8gcmVzdWx0LndlaWdodCxcbiAgICAgICAgd2VpZ2h0OiByZXN1bHQud2VpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL2J1aWxkLWxheWVyLWdyYXBoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9idWlsZC1sYXllci1ncmFwaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG52YXIgR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ncmFwaGxpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZ3JhcGhsaWIuanNcIikuR3JhcGg7XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRMYXllckdyYXBoO1xuXG4vKlxuICogQ29uc3RydWN0cyBhIGdyYXBoIHRoYXQgY2FuIGJlIHVzZWQgdG8gc29ydCBhIGxheWVyIG9mIG5vZGVzLiBUaGUgZ3JhcGggd2lsbFxuICogY29udGFpbiBhbGwgYmFzZSBhbmQgc3ViZ3JhcGggbm9kZXMgZnJvbSB0aGUgcmVxdWVzdCBsYXllciBpbiB0aGVpciBvcmlnaW5hbFxuICogaGllcmFyY2h5IGFuZCBhbnkgZWRnZXMgdGhhdCBhcmUgaW5jaWRlbnQgb24gdGhlc2Ugbm9kZXMgYW5kIGFyZSBvZiB0aGUgdHlwZVxuICogcmVxdWVzdGVkIGJ5IHRoZSBcInJlbGF0aW9uc2hpcFwiIHBhcmFtZXRlci5cbiAqXG4gKiBOb2RlcyBmcm9tIHRoZSByZXF1ZXN0ZWQgcmFuayB0aGF0IGRvIG5vdCBoYXZlIHBhcmVudHMgYXJlIGFzc2lnbmVkIGEgcm9vdFxuICogbm9kZSBpbiB0aGUgb3V0cHV0IGdyYXBoLCB3aGljaCBpcyBzZXQgaW4gdGhlIHJvb3QgZ3JhcGggYXR0cmlidXRlLiBUaGlzXG4gKiBtYWtlcyBpdCBlYXN5IHRvIHdhbGsgdGhlIGhpZXJhcmNoeSBvZiBtb3ZhYmxlIG5vZGVzIGR1cmluZyBvcmRlcmluZy5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBJbnB1dCBncmFwaCBpcyBhIERBR1xuICogICAgMi4gQmFzZSBub2RlcyBpbiB0aGUgaW5wdXQgZ3JhcGggaGF2ZSBhIHJhbmsgYXR0cmlidXRlXG4gKiAgICAzLiBTdWJncmFwaCBub2RlcyBpbiB0aGUgaW5wdXQgZ3JhcGggaGFzIG1pblJhbmsgYW5kIG1heFJhbmsgYXR0cmlidXRlc1xuICogICAgNC4gRWRnZXMgaGF2ZSBhbiBhc3NpZ25lZCB3ZWlnaHRcbiAqXG4gKiBQb3N0LWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gT3V0cHV0IGdyYXBoIGhhcyBhbGwgbm9kZXMgaW4gdGhlIG1vdmFibGUgcmFuayB3aXRoIHByZXNlcnZlZFxuICogICAgICAgaGllcmFyY2h5LlxuICogICAgMi4gUm9vdCBub2RlcyBpbiB0aGUgbW92YWJsZSBsYXllciBhcmUgbWFkZSBjaGlsZHJlbiBvZiB0aGUgbm9kZVxuICogICAgICAgaW5kaWNhdGVkIGJ5IHRoZSByb290IGF0dHJpYnV0ZSBvZiB0aGUgZ3JhcGguXG4gKiAgICAzLiBOb24tbW92YWJsZSBub2RlcyBpbmNpZGVudCBvbiBtb3ZhYmxlIG5vZGVzLCBzZWxlY3RlZCBieSB0aGVcbiAqICAgICAgIHJlbGF0aW9uc2hpcCBwYXJhbWV0ZXIsIGFyZSBpbmNsdWRlZCBpbiB0aGUgZ3JhcGggKHdpdGhvdXQgaGllcmFyY2h5KS5cbiAqICAgIDQuIEVkZ2VzIGluY2lkZW50IG9uIG1vdmFibGUgbm9kZXMsIHNlbGVjdGVkIGJ5IHRoZSByZWxhdGlvbnNoaXBcbiAqICAgICAgIHBhcmFtZXRlciwgYXJlIGFkZGVkIHRvIHRoZSBvdXRwdXQgZ3JhcGguXG4gKiAgICA1LiBUaGUgd2VpZ2h0cyBmb3IgY29waWVkIGVkZ2VzIGFyZSBhZ2dyZWdhdGVkIGFzIG5lZWQsIHNpbmNlIHRoZSBvdXRwdXRcbiAqICAgICAgIGdyYXBoIGlzIG5vdCBhIG11bHRpLWdyYXBoLlxuICovXG5mdW5jdGlvbiBidWlsZExheWVyR3JhcGgoZywgcmFuaywgcmVsYXRpb25zaGlwKSB7XG4gIHZhciByb290ID0gY3JlYXRlUm9vdE5vZGUoZyksXG4gICAgcmVzdWx0ID0gbmV3IEdyYXBoKHsgY29tcG91bmQ6IHRydWUgfSkuc2V0R3JhcGgoeyByb290OiByb290IH0pXG4gICAgICAuc2V0RGVmYXVsdE5vZGVMYWJlbChmdW5jdGlvbih2KSB7IHJldHVybiBnLm5vZGUodik7IH0pO1xuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KSxcbiAgICAgIHBhcmVudCA9IGcucGFyZW50KHYpO1xuXG4gICAgaWYgKG5vZGUucmFuayA9PT0gcmFuayB8fCBub2RlLm1pblJhbmsgPD0gcmFuayAmJiByYW5rIDw9IG5vZGUubWF4UmFuaykge1xuICAgICAgcmVzdWx0LnNldE5vZGUodik7XG4gICAgICByZXN1bHQuc2V0UGFyZW50KHYsIHBhcmVudCB8fCByb290KTtcblxuICAgICAgLy8gVGhpcyBhc3N1bWVzIHdlIGhhdmUgb25seSBzaG9ydCBlZGdlcyFcbiAgICAgIF8uZm9yRWFjaChnW3JlbGF0aW9uc2hpcF0odiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHUgPSBlLnYgPT09IHYgPyBlLncgOiBlLnYsXG4gICAgICAgICAgZWRnZSA9IHJlc3VsdC5lZGdlKHUsIHYpLFxuICAgICAgICAgIHdlaWdodCA9ICFfLmlzVW5kZWZpbmVkKGVkZ2UpID8gZWRnZS53ZWlnaHQgOiAwO1xuICAgICAgICByZXN1bHQuc2V0RWRnZSh1LCB2LCB7IHdlaWdodDogZy5lZGdlKGUpLndlaWdodCArIHdlaWdodCB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoXy5oYXMobm9kZSwgXCJtaW5SYW5rXCIpKSB7XG4gICAgICAgIHJlc3VsdC5zZXROb2RlKHYsIHtcbiAgICAgICAgICBib3JkZXJMZWZ0OiBub2RlLmJvcmRlckxlZnRbcmFua10sXG4gICAgICAgICAgYm9yZGVyUmlnaHQ6IG5vZGUuYm9yZGVyUmlnaHRbcmFua11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSb290Tm9kZShnKSB7XG4gIHZhciB2O1xuICB3aGlsZSAoZy5oYXNOb2RlKCh2ID0gXy51bmlxdWVJZChcIl9yb290XCIpKSkpO1xuICByZXR1cm4gdjtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL2Nyb3NzLWNvdW50LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9jcm9zcy1jb3VudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gY3Jvc3NDb3VudDtcblxuLypcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGxheWVyaW5nIChhbiBhcnJheSBvZiBsYXllcnMsIGVhY2ggd2l0aCBhbiBhcnJheSBvZlxuICogb3JkZXJlcmQgbm9kZXMpIGFuZCBhIGdyYXBoIGFuZCByZXR1cm5zIGEgd2VpZ2h0ZWQgY3Jvc3NpbmcgY291bnQuXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gSW5wdXQgZ3JhcGggbXVzdCBiZSBzaW1wbGUgKG5vdCBhIG11bHRpZ3JhcGgpLCBkaXJlY3RlZCwgYW5kIGluY2x1ZGVcbiAqICAgICAgIG9ubHkgc2ltcGxlIGVkZ2VzLlxuICogICAgMi4gRWRnZXMgaW4gdGhlIGlucHV0IGdyYXBoIG11c3QgaGF2ZSBhc3NpZ25lZCB3ZWlnaHRzLlxuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBUaGUgZ3JhcGggYW5kIGxheWVyaW5nIG1hdHJpeCBhcmUgbGVmdCB1bmNoYW5nZWQuXG4gKlxuICogVGhpcyBhbGdvcml0aG0gaXMgZGVyaXZlZCBmcm9tIEJhcnRoLCBldCBhbC4sIFwiQmlsYXllciBDcm9zcyBDb3VudGluZy5cIlxuICovXG5mdW5jdGlvbiBjcm9zc0NvdW50KGcsIGxheWVyaW5nKSB7XG4gIHZhciBjYyA9IDA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGF5ZXJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICBjYyArPSB0d29MYXllckNyb3NzQ291bnQoZywgbGF5ZXJpbmdbaS0xXSwgbGF5ZXJpbmdbaV0pO1xuICB9XG4gIHJldHVybiBjYztcbn1cblxuZnVuY3Rpb24gdHdvTGF5ZXJDcm9zc0NvdW50KGcsIG5vcnRoTGF5ZXIsIHNvdXRoTGF5ZXIpIHtcbiAgLy8gU29ydCBhbGwgb2YgdGhlIGVkZ2VzIGJldHdlZW4gdGhlIG5vcnRoIGFuZCBzb3V0aCBsYXllcnMgYnkgdGhlaXIgcG9zaXRpb25cbiAgLy8gaW4gdGhlIG5vcnRoIGxheWVyIGFuZCB0aGVuIHRoZSBzb3V0aC4gTWFwIHRoZXNlIGVkZ2VzIHRvIHRoZSBwb3NpdGlvbiBvZlxuICAvLyB0aGVpciBoZWFkIGluIHRoZSBzb3V0aCBsYXllci5cbiAgdmFyIHNvdXRoUG9zID0gXy56aXBPYmplY3Qoc291dGhMYXllcixcbiAgICBfLm1hcChzb3V0aExheWVyLCBmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gaTsgfSkpO1xuICB2YXIgc291dGhFbnRyaWVzID0gXy5mbGF0dGVuKF8ubWFwKG5vcnRoTGF5ZXIsIGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gXy5zb3J0QnkoXy5tYXAoZy5vdXRFZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIHsgcG9zOiBzb3V0aFBvc1tlLnddLCB3ZWlnaHQ6IGcuZWRnZShlKS53ZWlnaHQgfTtcbiAgICB9KSwgXCJwb3NcIik7XG4gIH0pLCB0cnVlKTtcblxuICAvLyBCdWlsZCB0aGUgYWNjdW11bGF0b3IgdHJlZVxuICB2YXIgZmlyc3RJbmRleCA9IDE7XG4gIHdoaWxlIChmaXJzdEluZGV4IDwgc291dGhMYXllci5sZW5ndGgpIGZpcnN0SW5kZXggPDw9IDE7XG4gIHZhciB0cmVlU2l6ZSA9IDIgKiBmaXJzdEluZGV4IC0gMTtcbiAgZmlyc3RJbmRleCAtPSAxO1xuICB2YXIgdHJlZSA9IF8ubWFwKG5ldyBBcnJheSh0cmVlU2l6ZSksIGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSB3ZWlnaHRlZCBjcm9zc2luZ3NcbiAgdmFyIGNjID0gMDtcbiAgXy5mb3JFYWNoKHNvdXRoRW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgdmFyIGluZGV4ID0gZW50cnkucG9zICsgZmlyc3RJbmRleDtcbiAgICB0cmVlW2luZGV4XSArPSBlbnRyeS53ZWlnaHQ7XG4gICAgdmFyIHdlaWdodFN1bSA9IDA7XG4gICAgd2hpbGUgKGluZGV4ID4gMCkge1xuICAgICAgaWYgKGluZGV4ICUgMikge1xuICAgICAgICB3ZWlnaHRTdW0gKz0gdHJlZVtpbmRleCArIDFdO1xuICAgICAgfVxuICAgICAgaW5kZXggPSAoaW5kZXggLSAxKSA+PiAxO1xuICAgICAgdHJlZVtpbmRleF0gKz0gZW50cnkud2VpZ2h0O1xuICAgIH1cbiAgICBjYyArPSBlbnRyeS53ZWlnaHQgKiB3ZWlnaHRTdW07XG4gIH0pKTtcblxuICByZXR1cm4gY2M7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xudmFyIGluaXRPcmRlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaW5pdC1vcmRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvaW5pdC1vcmRlci5qc1wiKTtcbnZhciBjcm9zc0NvdW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jcm9zcy1jb3VudCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvY3Jvc3MtY291bnQuanNcIik7XG52YXIgc29ydFN1YmdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zb3J0LXN1YmdyYXBoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9zb3J0LXN1YmdyYXBoLmpzXCIpO1xudmFyIGJ1aWxkTGF5ZXJHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYnVpbGQtbGF5ZXItZ3JhcGggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL2J1aWxkLWxheWVyLWdyYXBoLmpzXCIpO1xudmFyIGFkZFN1YmdyYXBoQ29uc3RyYWludHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FkZC1zdWJncmFwaC1jb25zdHJhaW50cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvYWRkLXN1YmdyYXBoLWNvbnN0cmFpbnRzLmpzXCIpO1xudmFyIEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZ3JhcGhsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2dyYXBobGliLmpzXCIpLkdyYXBoO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi91dGlsLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9yZGVyO1xuXG4vKlxuICogQXBwbGllcyBoZXVyaXN0aWNzIHRvIG1pbmltaXplIGVkZ2UgY3Jvc3NpbmdzIGluIHRoZSBncmFwaCBhbmQgc2V0cyB0aGUgYmVzdFxuICogb3JkZXIgc29sdXRpb24gYXMgYW4gb3JkZXIgYXR0cmlidXRlIG9uIGVhY2ggbm9kZS5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBHcmFwaCBtdXN0IGJlIERBR1xuICogICAgMi4gR3JhcGggbm9kZXMgbXVzdCBiZSBvYmplY3RzIHdpdGggYSBcInJhbmtcIiBhdHRyaWJ1dGVcbiAqICAgIDMuIEdyYXBoIGVkZ2VzIG11c3QgaGF2ZSB0aGUgXCJ3ZWlnaHRcIiBhdHRyaWJ1dGVcbiAqXG4gKiBQb3N0LWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gR3JhcGggbm9kZXMgd2lsbCBoYXZlIGFuIFwib3JkZXJcIiBhdHRyaWJ1dGUgYmFzZWQgb24gdGhlIHJlc3VsdHMgb2YgdGhlXG4gKiAgICAgICBhbGdvcml0aG0uXG4gKi9cbmZ1bmN0aW9uIG9yZGVyKGcpIHtcbiAgdmFyIG1heFJhbmsgPSB1dGlsLm1heFJhbmsoZyksXG4gICAgZG93bkxheWVyR3JhcGhzID0gYnVpbGRMYXllckdyYXBocyhnLCBfLnJhbmdlKDEsIG1heFJhbmsgKyAxKSwgXCJpbkVkZ2VzXCIpLFxuICAgIHVwTGF5ZXJHcmFwaHMgPSBidWlsZExheWVyR3JhcGhzKGcsIF8ucmFuZ2UobWF4UmFuayAtIDEsIC0xLCAtMSksIFwib3V0RWRnZXNcIik7XG5cbiAgdmFyIGxheWVyaW5nID0gaW5pdE9yZGVyKGcpO1xuICBhc3NpZ25PcmRlcihnLCBsYXllcmluZyk7XG5cbiAgdmFyIGJlc3RDQyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBiZXN0O1xuXG4gIGZvciAodmFyIGkgPSAwLCBsYXN0QmVzdCA9IDA7IGxhc3RCZXN0IDwgNDsgKytpLCArK2xhc3RCZXN0KSB7XG4gICAgc3dlZXBMYXllckdyYXBocyhpICUgMiA/IGRvd25MYXllckdyYXBocyA6IHVwTGF5ZXJHcmFwaHMsIGkgJSA0ID49IDIpO1xuXG4gICAgbGF5ZXJpbmcgPSB1dGlsLmJ1aWxkTGF5ZXJNYXRyaXgoZyk7XG4gICAgdmFyIGNjID0gY3Jvc3NDb3VudChnLCBsYXllcmluZyk7XG4gICAgaWYgKGNjIDwgYmVzdENDKSB7XG4gICAgICBsYXN0QmVzdCA9IDA7XG4gICAgICBiZXN0ID0gXy5jbG9uZURlZXAobGF5ZXJpbmcpO1xuICAgICAgYmVzdENDID0gY2M7XG4gICAgfVxuICB9XG5cbiAgYXNzaWduT3JkZXIoZywgYmVzdCk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTGF5ZXJHcmFwaHMoZywgcmFua3MsIHJlbGF0aW9uc2hpcCkge1xuICByZXR1cm4gXy5tYXAocmFua3MsIGZ1bmN0aW9uKHJhbmspIHtcbiAgICByZXR1cm4gYnVpbGRMYXllckdyYXBoKGcsIHJhbmssIHJlbGF0aW9uc2hpcCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzd2VlcExheWVyR3JhcGhzKGxheWVyR3JhcGhzLCBiaWFzUmlnaHQpIHtcbiAgdmFyIGNnID0gbmV3IEdyYXBoKCk7XG4gIF8uZm9yRWFjaChsYXllckdyYXBocywgZnVuY3Rpb24obGcpIHtcbiAgICB2YXIgcm9vdCA9IGxnLmdyYXBoKCkucm9vdDtcbiAgICB2YXIgc29ydGVkID0gc29ydFN1YmdyYXBoKGxnLCByb290LCBjZywgYmlhc1JpZ2h0KTtcbiAgICBfLmZvckVhY2goc29ydGVkLnZzLCBmdW5jdGlvbih2LCBpKSB7XG4gICAgICBsZy5ub2RlKHYpLm9yZGVyID0gaTtcbiAgICB9KTtcbiAgICBhZGRTdWJncmFwaENvbnN0cmFpbnRzKGxnLCBjZywgc29ydGVkLnZzKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbk9yZGVyKGcsIGxheWVyaW5nKSB7XG4gIF8uZm9yRWFjaChsYXllcmluZywgZnVuY3Rpb24obGF5ZXIpIHtcbiAgICBfLmZvckVhY2gobGF5ZXIsIGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgIGcubm9kZSh2KS5vcmRlciA9IGk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvaW5pdC1vcmRlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9pbml0LW9yZGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRPcmRlcjtcblxuLypcbiAqIEFzc2lnbnMgYW4gaW5pdGlhbCBvcmRlciB2YWx1ZSBmb3IgZWFjaCBub2RlIGJ5IHBlcmZvcm1pbmcgYSBERlMgc2VhcmNoXG4gKiBzdGFydGluZyBmcm9tIG5vZGVzIGluIHRoZSBmaXJzdCByYW5rLiBOb2RlcyBhcmUgYXNzaWduZWQgYW4gb3JkZXIgaW4gdGhlaXJcbiAqIHJhbmsgYXMgdGhleSBhcmUgZmlyc3QgdmlzaXRlZC5cbiAqXG4gKiBUaGlzIGFwcHJvYWNoIGNvbWVzIGZyb20gR2Fuc25lciwgZXQgYWwuLCBcIkEgVGVjaG5pcXVlIGZvciBEcmF3aW5nIERpcmVjdGVkXG4gKiBHcmFwaHMuXCJcbiAqXG4gKiBSZXR1cm5zIGEgbGF5ZXJpbmcgbWF0cml4IHdpdGggYW4gYXJyYXkgcGVyIGxheWVyIGFuZCBlYWNoIGxheWVyIHNvcnRlZCBieVxuICogdGhlIG9yZGVyIG9mIGl0cyBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gaW5pdE9yZGVyKGcpIHtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgdmFyIHNpbXBsZU5vZGVzID0gXy5maWx0ZXIoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuICFnLmNoaWxkcmVuKHYpLmxlbmd0aDtcbiAgfSk7XG4gIHZhciBtYXhSYW5rID0gXy5tYXgoXy5tYXAoc2ltcGxlTm9kZXMsIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcubm9kZSh2KS5yYW5rOyB9KSk7XG4gIHZhciBsYXllcnMgPSBfLm1hcChfLnJhbmdlKG1heFJhbmsgKyAxKSwgZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfSk7XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICBpZiAoXy5oYXModmlzaXRlZCwgdikpIHJldHVybjtcbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBsYXllcnNbbm9kZS5yYW5rXS5wdXNoKHYpO1xuICAgIF8uZm9yRWFjaChnLnN1Y2Nlc3NvcnModiksIGRmcyk7XG4gIH1cblxuICB2YXIgb3JkZXJlZFZzID0gXy5zb3J0Qnkoc2ltcGxlTm9kZXMsIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcubm9kZSh2KS5yYW5rOyB9KTtcbiAgXy5mb3JFYWNoKG9yZGVyZWRWcywgZGZzKTtcblxuICByZXR1cm4gbGF5ZXJzO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvcmVzb2x2ZS1jb25mbGljdHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL3Jlc29sdmUtY29uZmxpY3RzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2xvZGFzaC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlQ29uZmxpY3RzO1xuXG4vKlxuICogR2l2ZW4gYSBsaXN0IG9mIGVudHJpZXMgb2YgdGhlIGZvcm0ge3YsIGJhcnljZW50ZXIsIHdlaWdodH0gYW5kIGFcbiAqIGNvbnN0cmFpbnQgZ3JhcGggdGhpcyBmdW5jdGlvbiB3aWxsIHJlc29sdmUgYW55IGNvbmZsaWN0cyBiZXR3ZWVuIHRoZVxuICogY29uc3RyYWludCBncmFwaCBhbmQgdGhlIGJhcnljZW50ZXJzIGZvciB0aGUgZW50cmllcy4gSWYgdGhlIGJhcnljZW50ZXJzIGZvclxuICogYW4gZW50cnkgd291bGQgdmlvbGF0ZSBhIGNvbnN0cmFpbnQgaW4gdGhlIGNvbnN0cmFpbnQgZ3JhcGggdGhlbiB3ZSBjb2FsZXNjZVxuICogdGhlIG5vZGVzIGluIHRoZSBjb25mbGljdCBpbnRvIGEgbmV3IG5vZGUgdGhhdCByZXNwZWN0cyB0aGUgY29udHJhaW50IGFuZFxuICogYWdncmVnYXRlcyBiYXJ5Y2VudGVyIGFuZCB3ZWlnaHQgaW5mb3JtYXRpb24uXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB0aGUgZGVzY3JpcHRpb24gaW4gRm9yc3RlciwgXCJBIEZhc3QgYW5kXG4gKiBTaW1wbGUgSHVlcmlzdGljIGZvciBDb25zdHJhaW5lZCBUd28tTGV2ZWwgQ3Jvc3NpbmcgUmVkdWN0aW9uLFwiIHRob3VnaHQgaXRcbiAqIGRpZmZlcnMgaW4gc29tZSBzcGVjaWZpYyBkZXRhaWxzLlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEVhY2ggZW50cnkgaGFzIHRoZSBmb3JtIHt2LCBiYXJ5Y2VudGVyLCB3ZWlnaHR9LCBvciBpZiB0aGUgbm9kZSBoYXNcbiAqICAgICAgIG5vIGJhcnljZW50ZXIsIHRoZW4ge3Z9LlxuICpcbiAqIFJldHVybnM6XG4gKlxuICogICAgQSBuZXcgbGlzdCBvZiBlbnRyaWVzIG9mIHRoZSBmb3JtIHt2cywgaSwgYmFyeWNlbnRlciwgd2VpZ2h0fS4gVGhlIGxpc3RcbiAqICAgIGB2c2AgbWF5IGVpdGhlciBiZSBhIHNpbmdsZXRvbiBvciBpdCBtYXkgYmUgYW4gYWdncmVnYXRpb24gb2Ygbm9kZXNcbiAqICAgIG9yZGVyZWQgc3VjaCB0aGF0IHRoZXkgZG8gbm90IHZpb2xhdGUgY29uc3RyYWludHMgZnJvbSB0aGUgY29uc3RyYWludFxuICogICAgZ3JhcGguIFRoZSBwcm9wZXJ0eSBgaWAgaXMgdGhlIGxvd2VzdCBvcmlnaW5hbCBpbmRleCBvZiBhbnkgb2YgdGhlXG4gKiAgICBlbGVtZW50cyBpbiBgdnNgLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQ29uZmxpY3RzKGVudHJpZXMsIGNnKSB7XG4gIHZhciBtYXBwZWRFbnRyaWVzID0ge307XG4gIF8uZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSwgaSkge1xuICAgIHZhciB0bXAgPSBtYXBwZWRFbnRyaWVzW2VudHJ5LnZdID0ge1xuICAgICAgaW5kZWdyZWU6IDAsXG4gICAgICBcImluXCI6IFtdLFxuICAgICAgb3V0OiBbXSxcbiAgICAgIHZzOiBbZW50cnkudl0sXG4gICAgICBpOiBpXG4gICAgfTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoZW50cnkuYmFyeWNlbnRlcikpIHtcbiAgICAgIHRtcC5iYXJ5Y2VudGVyID0gZW50cnkuYmFyeWNlbnRlcjtcbiAgICAgIHRtcC53ZWlnaHQgPSBlbnRyeS53ZWlnaHQ7XG4gICAgfVxuICB9KTtcblxuICBfLmZvckVhY2goY2cuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbnRyeVYgPSBtYXBwZWRFbnRyaWVzW2Uudl07XG4gICAgdmFyIGVudHJ5VyA9IG1hcHBlZEVudHJpZXNbZS53XTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoZW50cnlWKSAmJiAhXy5pc1VuZGVmaW5lZChlbnRyeVcpKSB7XG4gICAgICBlbnRyeVcuaW5kZWdyZWUrKztcbiAgICAgIGVudHJ5Vi5vdXQucHVzaChtYXBwZWRFbnRyaWVzW2Uud10pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHNvdXJjZVNldCA9IF8uZmlsdGVyKG1hcHBlZEVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgcmV0dXJuICFlbnRyeS5pbmRlZ3JlZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRvUmVzb2x2ZUNvbmZsaWN0cyhzb3VyY2VTZXQpO1xufVxuXG5mdW5jdGlvbiBkb1Jlc29sdmVDb25mbGljdHMoc291cmNlU2V0KSB7XG4gIHZhciBlbnRyaWVzID0gW107XG5cbiAgZnVuY3Rpb24gaGFuZGxlSW4odkVudHJ5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHVFbnRyeSkge1xuICAgICAgaWYgKHVFbnRyeS5tZXJnZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQodUVudHJ5LmJhcnljZW50ZXIpIHx8XG4gICAgICAgICAgXy5pc1VuZGVmaW5lZCh2RW50cnkuYmFyeWNlbnRlcikgfHxcbiAgICAgICAgICB1RW50cnkuYmFyeWNlbnRlciA+PSB2RW50cnkuYmFyeWNlbnRlcikge1xuICAgICAgICBtZXJnZUVudHJpZXModkVudHJ5LCB1RW50cnkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVPdXQodkVudHJ5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHdFbnRyeSkge1xuICAgICAgd0VudHJ5W1wiaW5cIl0ucHVzaCh2RW50cnkpO1xuICAgICAgaWYgKC0td0VudHJ5LmluZGVncmVlID09PSAwKSB7XG4gICAgICAgIHNvdXJjZVNldC5wdXNoKHdFbnRyeSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHdoaWxlIChzb3VyY2VTZXQubGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gc291cmNlU2V0LnBvcCgpO1xuICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgXy5mb3JFYWNoKGVudHJ5W1wiaW5cIl0ucmV2ZXJzZSgpLCBoYW5kbGVJbihlbnRyeSkpO1xuICAgIF8uZm9yRWFjaChlbnRyeS5vdXQsIGhhbmRsZU91dChlbnRyeSkpO1xuICB9XG5cbiAgcmV0dXJuIF8ubWFwKF8uZmlsdGVyKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7IHJldHVybiAhZW50cnkubWVyZ2VkOyB9KSxcbiAgICBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgcmV0dXJuIF8ucGljayhlbnRyeSwgW1widnNcIiwgXCJpXCIsIFwiYmFyeWNlbnRlclwiLCBcIndlaWdodFwiXSk7XG4gICAgfSk7XG5cbn1cblxuZnVuY3Rpb24gbWVyZ2VFbnRyaWVzKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBzdW0gPSAwO1xuICB2YXIgd2VpZ2h0ID0gMDtcblxuICBpZiAodGFyZ2V0LndlaWdodCkge1xuICAgIHN1bSArPSB0YXJnZXQuYmFyeWNlbnRlciAqIHRhcmdldC53ZWlnaHQ7XG4gICAgd2VpZ2h0ICs9IHRhcmdldC53ZWlnaHQ7XG4gIH1cblxuICBpZiAoc291cmNlLndlaWdodCkge1xuICAgIHN1bSArPSBzb3VyY2UuYmFyeWNlbnRlciAqIHNvdXJjZS53ZWlnaHQ7XG4gICAgd2VpZ2h0ICs9IHNvdXJjZS53ZWlnaHQ7XG4gIH1cblxuICB0YXJnZXQudnMgPSBzb3VyY2UudnMuY29uY2F0KHRhcmdldC52cyk7XG4gIHRhcmdldC5iYXJ5Y2VudGVyID0gc3VtIC8gd2VpZ2h0O1xuICB0YXJnZXQud2VpZ2h0ID0gd2VpZ2h0O1xuICB0YXJnZXQuaSA9IE1hdGgubWluKHNvdXJjZS5pLCB0YXJnZXQuaSk7XG4gIHNvdXJjZS5tZXJnZWQgPSB0cnVlO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvc29ydC1zdWJncmFwaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9vcmRlci9zb3J0LXN1YmdyYXBoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xudmFyIGJhcnljZW50ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2JhcnljZW50ZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL2JhcnljZW50ZXIuanNcIik7XG52YXIgcmVzb2x2ZUNvbmZsaWN0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVzb2x2ZS1jb25mbGljdHMgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL3Jlc29sdmUtY29uZmxpY3RzLmpzXCIpO1xudmFyIHNvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL3NvcnQuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gc29ydFN1YmdyYXBoO1xuXG5mdW5jdGlvbiBzb3J0U3ViZ3JhcGgoZywgdiwgY2csIGJpYXNSaWdodCkge1xuICB2YXIgbW92YWJsZSA9IGcuY2hpbGRyZW4odik7XG4gIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICB2YXIgYmwgPSBub2RlID8gbm9kZS5ib3JkZXJMZWZ0IDogdW5kZWZpbmVkO1xuICB2YXIgYnIgPSBub2RlID8gbm9kZS5ib3JkZXJSaWdodDogdW5kZWZpbmVkO1xuICB2YXIgc3ViZ3JhcGhzID0ge307XG5cbiAgaWYgKGJsKSB7XG4gICAgbW92YWJsZSA9IF8uZmlsdGVyKG1vdmFibGUsIGZ1bmN0aW9uKHcpIHtcbiAgICAgIHJldHVybiB3ICE9PSBibCAmJiB3ICE9PSBicjtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBiYXJ5Y2VudGVycyA9IGJhcnljZW50ZXIoZywgbW92YWJsZSk7XG4gIF8uZm9yRWFjaChiYXJ5Y2VudGVycywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICBpZiAoZy5jaGlsZHJlbihlbnRyeS52KS5sZW5ndGgpIHtcbiAgICAgIHZhciBzdWJncmFwaFJlc3VsdCA9IHNvcnRTdWJncmFwaChnLCBlbnRyeS52LCBjZywgYmlhc1JpZ2h0KTtcbiAgICAgIHN1YmdyYXBoc1tlbnRyeS52XSA9IHN1YmdyYXBoUmVzdWx0O1xuICAgICAgaWYgKF8uaGFzKHN1YmdyYXBoUmVzdWx0LCBcImJhcnljZW50ZXJcIikpIHtcbiAgICAgICAgbWVyZ2VCYXJ5Y2VudGVycyhlbnRyeSwgc3ViZ3JhcGhSZXN1bHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGVudHJpZXMgPSByZXNvbHZlQ29uZmxpY3RzKGJhcnljZW50ZXJzLCBjZyk7XG4gIGV4cGFuZFN1YmdyYXBocyhlbnRyaWVzLCBzdWJncmFwaHMpO1xuXG4gIHZhciByZXN1bHQgPSBzb3J0KGVudHJpZXMsIGJpYXNSaWdodCk7XG5cbiAgaWYgKGJsKSB7XG4gICAgcmVzdWx0LnZzID0gXy5mbGF0dGVuKFtibCwgcmVzdWx0LnZzLCBicl0sIHRydWUpO1xuICAgIGlmIChnLnByZWRlY2Vzc29ycyhibCkubGVuZ3RoKSB7XG4gICAgICB2YXIgYmxQcmVkID0gZy5ub2RlKGcucHJlZGVjZXNzb3JzKGJsKVswXSksXG4gICAgICAgIGJyUHJlZCA9IGcubm9kZShnLnByZWRlY2Vzc29ycyhicilbMF0pO1xuICAgICAgaWYgKCFfLmhhcyhyZXN1bHQsIFwiYmFyeWNlbnRlclwiKSkge1xuICAgICAgICByZXN1bHQuYmFyeWNlbnRlciA9IDA7XG4gICAgICAgIHJlc3VsdC53ZWlnaHQgPSAwO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmJhcnljZW50ZXIgPSAocmVzdWx0LmJhcnljZW50ZXIgKiByZXN1bHQud2VpZ2h0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsUHJlZC5vcmRlciArIGJyUHJlZC5vcmRlcikgLyAocmVzdWx0LndlaWdodCArIDIpO1xuICAgICAgcmVzdWx0LndlaWdodCArPSAyO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFN1YmdyYXBocyhlbnRyaWVzLCBzdWJncmFwaHMpIHtcbiAgXy5mb3JFYWNoKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgZW50cnkudnMgPSBfLmZsYXR0ZW4oZW50cnkudnMubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmIChzdWJncmFwaHNbdl0pIHtcbiAgICAgICAgcmV0dXJuIHN1YmdyYXBoc1t2XS52cztcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH0pLCB0cnVlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlQmFyeWNlbnRlcnModGFyZ2V0LCBvdGhlcikge1xuICBpZiAoIV8uaXNVbmRlZmluZWQodGFyZ2V0LmJhcnljZW50ZXIpKSB7XG4gICAgdGFyZ2V0LmJhcnljZW50ZXIgPSAodGFyZ2V0LmJhcnljZW50ZXIgKiB0YXJnZXQud2VpZ2h0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlci5iYXJ5Y2VudGVyICogb3RoZXIud2VpZ2h0KSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAodGFyZ2V0LndlaWdodCArIG90aGVyLndlaWdodCk7XG4gICAgdGFyZ2V0LndlaWdodCArPSBvdGhlci53ZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LmJhcnljZW50ZXIgPSBvdGhlci5iYXJ5Y2VudGVyO1xuICAgIHRhcmdldC53ZWlnaHQgPSBvdGhlci53ZWlnaHQ7XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL29yZGVyL3NvcnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvb3JkZXIvc29ydC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2xvZGFzaC5qc1wiKTtcbnZhciB1dGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvdXRpbC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuXG5mdW5jdGlvbiBzb3J0KGVudHJpZXMsIGJpYXNSaWdodCkge1xuICB2YXIgcGFydHMgPSB1dGlsLnBhcnRpdGlvbihlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIHJldHVybiBfLmhhcyhlbnRyeSwgXCJiYXJ5Y2VudGVyXCIpO1xuICB9KTtcbiAgdmFyIHNvcnRhYmxlID0gcGFydHMubGhzLFxuICAgIHVuc29ydGFibGUgPSBfLnNvcnRCeShwYXJ0cy5yaHMsIGZ1bmN0aW9uKGVudHJ5KSB7IHJldHVybiAtZW50cnkuaTsgfSksXG4gICAgdnMgPSBbXSxcbiAgICBzdW0gPSAwLFxuICAgIHdlaWdodCA9IDAsXG4gICAgdnNJbmRleCA9IDA7XG5cbiAgc29ydGFibGUuc29ydChjb21wYXJlV2l0aEJpYXMoISFiaWFzUmlnaHQpKTtcblxuICB2c0luZGV4ID0gY29uc3VtZVVuc29ydGFibGUodnMsIHVuc29ydGFibGUsIHZzSW5kZXgpO1xuXG4gIF8uZm9yRWFjaChzb3J0YWJsZSwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgdnNJbmRleCArPSBlbnRyeS52cy5sZW5ndGg7XG4gICAgdnMucHVzaChlbnRyeS52cyk7XG4gICAgc3VtICs9IGVudHJ5LmJhcnljZW50ZXIgKiBlbnRyeS53ZWlnaHQ7XG4gICAgd2VpZ2h0ICs9IGVudHJ5LndlaWdodDtcbiAgICB2c0luZGV4ID0gY29uc3VtZVVuc29ydGFibGUodnMsIHVuc29ydGFibGUsIHZzSW5kZXgpO1xuICB9KTtcblxuICB2YXIgcmVzdWx0ID0geyB2czogXy5mbGF0dGVuKHZzLCB0cnVlKSB9O1xuICBpZiAod2VpZ2h0KSB7XG4gICAgcmVzdWx0LmJhcnljZW50ZXIgPSBzdW0gLyB3ZWlnaHQ7XG4gICAgcmVzdWx0LndlaWdodCA9IHdlaWdodDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjb25zdW1lVW5zb3J0YWJsZSh2cywgdW5zb3J0YWJsZSwgaW5kZXgpIHtcbiAgdmFyIGxhc3Q7XG4gIHdoaWxlICh1bnNvcnRhYmxlLmxlbmd0aCAmJiAobGFzdCA9IF8ubGFzdCh1bnNvcnRhYmxlKSkuaSA8PSBpbmRleCkge1xuICAgIHVuc29ydGFibGUucG9wKCk7XG4gICAgdnMucHVzaChsYXN0LnZzKTtcbiAgICBpbmRleCsrO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVdpdGhCaWFzKGJpYXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVudHJ5ViwgZW50cnlXKSB7XG4gICAgaWYgKGVudHJ5Vi5iYXJ5Y2VudGVyIDwgZW50cnlXLmJhcnljZW50ZXIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKGVudHJ5Vi5iYXJ5Y2VudGVyID4gZW50cnlXLmJhcnljZW50ZXIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAhYmlhcyA/IGVudHJ5Vi5pIC0gZW50cnlXLmkgOiBlbnRyeVcuaSAtIGVudHJ5Vi5pO1xuICB9O1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcGFyZW50LWR1bW15LWNoYWlucy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9wYXJlbnQtZHVtbXktY2hhaW5zLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50RHVtbXlDaGFpbnM7XG5cbmZ1bmN0aW9uIHBhcmVudER1bW15Q2hhaW5zKGcpIHtcbiAgdmFyIHBvc3RvcmRlck51bXMgPSBwb3N0b3JkZXIoZyk7XG5cbiAgXy5mb3JFYWNoKGcuZ3JhcGgoKS5kdW1teUNoYWlucywgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIHZhciBlZGdlT2JqID0gbm9kZS5lZGdlT2JqO1xuICAgIHZhciBwYXRoRGF0YSA9IGZpbmRQYXRoKGcsIHBvc3RvcmRlck51bXMsIGVkZ2VPYmoudiwgZWRnZU9iai53KTtcbiAgICB2YXIgcGF0aCA9IHBhdGhEYXRhLnBhdGg7XG4gICAgdmFyIGxjYSA9IHBhdGhEYXRhLmxjYTtcbiAgICB2YXIgcGF0aElkeCA9IDA7XG4gICAgdmFyIHBhdGhWID0gcGF0aFtwYXRoSWR4XTtcbiAgICB2YXIgYXNjZW5kaW5nID0gdHJ1ZTtcblxuICAgIHdoaWxlICh2ICE9PSBlZGdlT2JqLncpIHtcbiAgICAgIG5vZGUgPSBnLm5vZGUodik7XG5cbiAgICAgIGlmIChhc2NlbmRpbmcpIHtcbiAgICAgICAgd2hpbGUgKChwYXRoViA9IHBhdGhbcGF0aElkeF0pICE9PSBsY2EgJiZcbiAgICAgICAgICAgICAgIGcubm9kZShwYXRoVikubWF4UmFuayA8IG5vZGUucmFuaykge1xuICAgICAgICAgIHBhdGhJZHgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoViA9PT0gbGNhKSB7XG4gICAgICAgICAgYXNjZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhc2NlbmRpbmcpIHtcbiAgICAgICAgd2hpbGUgKHBhdGhJZHggPCBwYXRoLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgICAgICAgIGcubm9kZShwYXRoViA9IHBhdGhbcGF0aElkeCArIDFdKS5taW5SYW5rIDw9IG5vZGUucmFuaykge1xuICAgICAgICAgIHBhdGhJZHgrKztcbiAgICAgICAgfVxuICAgICAgICBwYXRoViA9IHBhdGhbcGF0aElkeF07XG4gICAgICB9XG5cbiAgICAgIGcuc2V0UGFyZW50KHYsIHBhdGhWKTtcbiAgICAgIHYgPSBnLnN1Y2Nlc3NvcnModilbMF07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gRmluZCBhIHBhdGggZnJvbSB2IHRvIHcgdGhyb3VnaCB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciAoTENBKS4gUmV0dXJuIHRoZVxuLy8gZnVsbCBwYXRoIGFuZCB0aGUgTENBLlxuZnVuY3Rpb24gZmluZFBhdGgoZywgcG9zdG9yZGVyTnVtcywgdiwgdykge1xuICB2YXIgdlBhdGggPSBbXTtcbiAgdmFyIHdQYXRoID0gW107XG4gIHZhciBsb3cgPSBNYXRoLm1pbihwb3N0b3JkZXJOdW1zW3ZdLmxvdywgcG9zdG9yZGVyTnVtc1t3XS5sb3cpO1xuICB2YXIgbGltID0gTWF0aC5tYXgocG9zdG9yZGVyTnVtc1t2XS5saW0sIHBvc3RvcmRlck51bXNbd10ubGltKTtcbiAgdmFyIHBhcmVudDtcbiAgdmFyIGxjYTtcblxuICAvLyBUcmF2ZXJzZSB1cCBmcm9tIHYgdG8gZmluZCB0aGUgTENBXG4gIHBhcmVudCA9IHY7XG4gIGRvIHtcbiAgICBwYXJlbnQgPSBnLnBhcmVudChwYXJlbnQpO1xuICAgIHZQYXRoLnB1c2gocGFyZW50KTtcbiAgfSB3aGlsZSAocGFyZW50ICYmXG4gICAgICAgICAgIChwb3N0b3JkZXJOdW1zW3BhcmVudF0ubG93ID4gbG93IHx8IGxpbSA+IHBvc3RvcmRlck51bXNbcGFyZW50XS5saW0pKTtcbiAgbGNhID0gcGFyZW50O1xuXG4gIC8vIFRyYXZlcnNlIGZyb20gdyB0byBMQ0FcbiAgcGFyZW50ID0gdztcbiAgd2hpbGUgKChwYXJlbnQgPSBnLnBhcmVudChwYXJlbnQpKSAhPT0gbGNhKSB7XG4gICAgd1BhdGgucHVzaChwYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIHsgcGF0aDogdlBhdGguY29uY2F0KHdQYXRoLnJldmVyc2UoKSksIGxjYTogbGNhIH07XG59XG5cbmZ1bmN0aW9uIHBvc3RvcmRlcihnKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGxpbSA9IDA7XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICB2YXIgbG93ID0gbGltO1xuICAgIF8uZm9yRWFjaChnLmNoaWxkcmVuKHYpLCBkZnMpO1xuICAgIHJlc3VsdFt2XSA9IHsgbG93OiBsb3csIGxpbTogbGltKysgfTtcbiAgfVxuICBfLmZvckVhY2goZy5jaGlsZHJlbigpLCBkZnMpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9wb3NpdGlvbi9iay5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcG9zaXRpb24vYmsuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvbG9kYXNoLmpzXCIpO1xudmFyIEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZ3JhcGhsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2dyYXBobGliLmpzXCIpLkdyYXBoO1xudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi91dGlsLmpzXCIpO1xuXG4vKlxuICogVGhpcyBtb2R1bGUgcHJvdmlkZXMgY29vcmRpbmF0ZSBhc3NpZ25tZW50IGJhc2VkIG9uIEJyYW5kZXMgYW5kIEvDtnBmLCBcIkZhc3RcbiAqIGFuZCBTaW1wbGUgSG9yaXpvbnRhbCBDb29yZGluYXRlIEFzc2lnbm1lbnQuXCJcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcG9zaXRpb25YOiBwb3NpdGlvblgsXG4gIGZpbmRUeXBlMUNvbmZsaWN0czogZmluZFR5cGUxQ29uZmxpY3RzLFxuICBmaW5kVHlwZTJDb25mbGljdHM6IGZpbmRUeXBlMkNvbmZsaWN0cyxcbiAgYWRkQ29uZmxpY3Q6IGFkZENvbmZsaWN0LFxuICBoYXNDb25mbGljdDogaGFzQ29uZmxpY3QsXG4gIHZlcnRpY2FsQWxpZ25tZW50OiB2ZXJ0aWNhbEFsaWdubWVudCxcbiAgaG9yaXpvbnRhbENvbXBhY3Rpb246IGhvcml6b250YWxDb21wYWN0aW9uLFxuICBhbGlnbkNvb3JkaW5hdGVzOiBhbGlnbkNvb3JkaW5hdGVzLFxuICBmaW5kU21hbGxlc3RXaWR0aEFsaWdubWVudDogZmluZFNtYWxsZXN0V2lkdGhBbGlnbm1lbnQsXG4gIGJhbGFuY2U6IGJhbGFuY2Vcbn07XG5cbi8qXG4gKiBNYXJrcyBhbGwgZWRnZXMgaW4gdGhlIGdyYXBoIHdpdGggYSB0eXBlLTEgY29uZmxpY3Qgd2l0aCB0aGUgXCJ0eXBlMUNvbmZsaWN0XCJcbiAqIHByb3BlcnR5LiBBIHR5cGUtMSBjb25mbGljdCBpcyBvbmUgd2hlcmUgYSBub24taW5uZXIgc2VnbWVudCBjcm9zc2VzIGFuXG4gKiBpbm5lciBzZWdtZW50LiBBbiBpbm5lciBzZWdtZW50IGlzIGFuIGVkZ2Ugd2l0aCBib3RoIGluY2lkZW50IG5vZGVzIG1hcmtlZFxuICogd2l0aCB0aGUgXCJkdW1teVwiIHByb3BlcnR5LlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIHNjYW5zIGxheWVyIGJ5IGxheWVyLCBzdGFydGluZyB3aXRoIHRoZSBzZWNvbmQsIGZvciB0eXBlLTFcbiAqIGNvbmZsaWN0cyBiZXR3ZWVuIHRoZSBjdXJyZW50IGxheWVyIGFuZCB0aGUgcHJldmlvdXMgbGF5ZXIuIEZvciBlYWNoIGxheWVyXG4gKiBpdCBzY2FucyB0aGUgbm9kZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0IHVudGlsIGl0IHJlYWNoZXMgb25lIHRoYXQgaXMgaW5jaWRlbnRcbiAqIG9uIGFuIGlubmVyIHNlZ21lbnQuIEl0IHRoZW4gc2NhbnMgcHJlZGVjZXNzb3JzIHRvIGRldGVybWluZSBpZiB0aGV5IGhhdmVcbiAqIGVkZ2VzIHRoYXQgY3Jvc3MgdGhhdCBpbm5lciBzZWdtZW50LiBBdCB0aGUgZW5kIGEgZmluYWwgc2NhbiBpcyBkb25lIGZvciBhbGxcbiAqIG5vZGVzIG9uIHRoZSBjdXJyZW50IHJhbmsgdG8gc2VlIGlmIHRoZXkgY3Jvc3MgdGhlIGxhc3QgdmlzaXRlZCBpbm5lclxuICogc2VnbWVudC5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSAoc2FmZWx5KSBhc3N1bWVzIHRoYXQgYSBkdW1teSBub2RlIHdpbGwgb25seSBiZSBpbmNpZGVudCBvbiBhXG4gKiBzaW5nbGUgbm9kZSBpbiB0aGUgbGF5ZXJzIGJlaW5nIHNjYW5uZWQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRUeXBlMUNvbmZsaWN0cyhnLCBsYXllcmluZykge1xuICB2YXIgY29uZmxpY3RzID0ge307XG5cbiAgZnVuY3Rpb24gdmlzaXRMYXllcihwcmV2TGF5ZXIsIGxheWVyKSB7XG4gICAgdmFyXG4gICAgICAvLyBsYXN0IHZpc2l0ZWQgbm9kZSBpbiB0aGUgcHJldmlvdXMgbGF5ZXIgdGhhdCBpcyBpbmNpZGVudCBvbiBhbiBpbm5lclxuICAgICAgLy8gc2VnbWVudC5cbiAgICAgIGswID0gMCxcbiAgICAgIC8vIFRyYWNrcyB0aGUgbGFzdCBub2RlIGluIHRoaXMgbGF5ZXIgc2Nhbm5lZCBmb3IgY3Jvc3NpbmdzIHdpdGggYSB0eXBlLTFcbiAgICAgIC8vIHNlZ21lbnQuXG4gICAgICBzY2FuUG9zID0gMCxcbiAgICAgIHByZXZMYXllckxlbmd0aCA9IHByZXZMYXllci5sZW5ndGgsXG4gICAgICBsYXN0Tm9kZSA9IF8ubGFzdChsYXllcik7XG5cbiAgICBfLmZvckVhY2gobGF5ZXIsIGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgIHZhciB3ID0gZmluZE90aGVySW5uZXJTZWdtZW50Tm9kZShnLCB2KSxcbiAgICAgICAgazEgPSB3ID8gZy5ub2RlKHcpLm9yZGVyIDogcHJldkxheWVyTGVuZ3RoO1xuXG4gICAgICBpZiAodyB8fCB2ID09PSBsYXN0Tm9kZSkge1xuICAgICAgICBfLmZvckVhY2gobGF5ZXIuc2xpY2Uoc2NhblBvcywgaSArMSksIGZ1bmN0aW9uKHNjYW5Ob2RlKSB7XG4gICAgICAgICAgXy5mb3JFYWNoKGcucHJlZGVjZXNzb3JzKHNjYW5Ob2RlKSwgZnVuY3Rpb24odSkge1xuICAgICAgICAgICAgdmFyIHVMYWJlbCA9IGcubm9kZSh1KSxcbiAgICAgICAgICAgICAgdVBvcyA9IHVMYWJlbC5vcmRlcjtcbiAgICAgICAgICAgIGlmICgodVBvcyA8IGswIHx8IGsxIDwgdVBvcykgJiZcbiAgICAgICAgICAgICAgICAhKHVMYWJlbC5kdW1teSAmJiBnLm5vZGUoc2Nhbk5vZGUpLmR1bW15KSkge1xuICAgICAgICAgICAgICBhZGRDb25mbGljdChjb25mbGljdHMsIHUsIHNjYW5Ob2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNjYW5Qb3MgPSBpICsgMTtcbiAgICAgICAgazAgPSBrMTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBsYXllcjtcbiAgfVxuXG4gIF8ucmVkdWNlKGxheWVyaW5nLCB2aXNpdExheWVyKTtcbiAgcmV0dXJuIGNvbmZsaWN0cztcbn1cblxuZnVuY3Rpb24gZmluZFR5cGUyQ29uZmxpY3RzKGcsIGxheWVyaW5nKSB7XG4gIHZhciBjb25mbGljdHMgPSB7fTtcblxuICBmdW5jdGlvbiBzY2FuKHNvdXRoLCBzb3V0aFBvcywgc291dGhFbmQsIHByZXZOb3J0aEJvcmRlciwgbmV4dE5vcnRoQm9yZGVyKSB7XG4gICAgdmFyIHY7XG4gICAgXy5mb3JFYWNoKF8ucmFuZ2Uoc291dGhQb3MsIHNvdXRoRW5kKSwgZnVuY3Rpb24oaSkge1xuICAgICAgdiA9IHNvdXRoW2ldO1xuICAgICAgaWYgKGcubm9kZSh2KS5kdW1teSkge1xuICAgICAgICBfLmZvckVhY2goZy5wcmVkZWNlc3NvcnModiksIGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICB2YXIgdU5vZGUgPSBnLm5vZGUodSk7XG4gICAgICAgICAgaWYgKHVOb2RlLmR1bW15ICYmXG4gICAgICAgICAgICAgICh1Tm9kZS5vcmRlciA8IHByZXZOb3J0aEJvcmRlciB8fCB1Tm9kZS5vcmRlciA+IG5leHROb3J0aEJvcmRlcikpIHtcbiAgICAgICAgICAgIGFkZENvbmZsaWN0KGNvbmZsaWN0cywgdSwgdik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gdmlzaXRMYXllcihub3J0aCwgc291dGgpIHtcbiAgICB2YXIgcHJldk5vcnRoUG9zID0gLTEsXG4gICAgICBuZXh0Tm9ydGhQb3MsXG4gICAgICBzb3V0aFBvcyA9IDA7XG5cbiAgICBfLmZvckVhY2goc291dGgsIGZ1bmN0aW9uKHYsIHNvdXRoTG9va2FoZWFkKSB7XG4gICAgICBpZiAoZy5ub2RlKHYpLmR1bW15ID09PSBcImJvcmRlclwiKSB7XG4gICAgICAgIHZhciBwcmVkZWNlc3NvcnMgPSBnLnByZWRlY2Vzc29ycyh2KTtcbiAgICAgICAgaWYgKHByZWRlY2Vzc29ycy5sZW5ndGgpIHtcbiAgICAgICAgICBuZXh0Tm9ydGhQb3MgPSBnLm5vZGUocHJlZGVjZXNzb3JzWzBdKS5vcmRlcjtcbiAgICAgICAgICBzY2FuKHNvdXRoLCBzb3V0aFBvcywgc291dGhMb29rYWhlYWQsIHByZXZOb3J0aFBvcywgbmV4dE5vcnRoUG9zKTtcbiAgICAgICAgICBzb3V0aFBvcyA9IHNvdXRoTG9va2FoZWFkO1xuICAgICAgICAgIHByZXZOb3J0aFBvcyA9IG5leHROb3J0aFBvcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2Nhbihzb3V0aCwgc291dGhQb3MsIHNvdXRoLmxlbmd0aCwgbmV4dE5vcnRoUG9zLCBub3J0aC5sZW5ndGgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNvdXRoO1xuICB9XG5cbiAgXy5yZWR1Y2UobGF5ZXJpbmcsIHZpc2l0TGF5ZXIpO1xuICByZXR1cm4gY29uZmxpY3RzO1xufVxuXG5mdW5jdGlvbiBmaW5kT3RoZXJJbm5lclNlZ21lbnROb2RlKGcsIHYpIHtcbiAgaWYgKGcubm9kZSh2KS5kdW1teSkge1xuICAgIHJldHVybiBfLmZpbmQoZy5wcmVkZWNlc3NvcnModiksIGZ1bmN0aW9uKHUpIHtcbiAgICAgIHJldHVybiBnLm5vZGUodSkuZHVtbXk7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkQ29uZmxpY3QoY29uZmxpY3RzLCB2LCB3KSB7XG4gIGlmICh2ID4gdykge1xuICAgIHZhciB0bXAgPSB2O1xuICAgIHYgPSB3O1xuICAgIHcgPSB0bXA7XG4gIH1cblxuICB2YXIgY29uZmxpY3RzViA9IGNvbmZsaWN0c1t2XTtcbiAgaWYgKCFjb25mbGljdHNWKSB7XG4gICAgY29uZmxpY3RzW3ZdID0gY29uZmxpY3RzViA9IHt9O1xuICB9XG4gIGNvbmZsaWN0c1Zbd10gPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBoYXNDb25mbGljdChjb25mbGljdHMsIHYsIHcpIHtcbiAgaWYgKHYgPiB3KSB7XG4gICAgdmFyIHRtcCA9IHY7XG4gICAgdiA9IHc7XG4gICAgdyA9IHRtcDtcbiAgfVxuICByZXR1cm4gXy5oYXMoY29uZmxpY3RzW3ZdLCB3KTtcbn1cblxuLypcbiAqIFRyeSB0byBhbGlnbiBub2RlcyBpbnRvIHZlcnRpY2FsIFwiYmxvY2tzXCIgd2hlcmUgcG9zc2libGUuIFRoaXMgYWxnb3JpdGhtXG4gKiBhdHRlbXB0cyB0byBhbGlnbiBhIG5vZGUgd2l0aCBvbmUgb2YgaXRzIG1lZGlhbiBuZWlnaGJvcnMuIElmIHRoZSBlZGdlXG4gKiBjb25uZWN0aW5nIGEgbmVpZ2hib3IgaXMgYSB0eXBlLTEgY29uZmxpY3QgdGhlbiB3ZSBpZ25vcmUgdGhhdCBwb3NzaWJpbGl0eS5cbiAqIElmIGEgcHJldmlvdXMgbm9kZSBoYXMgYWxyZWFkeSBmb3JtZWQgYSBibG9jayB3aXRoIGEgbm9kZSBhZnRlciB0aGUgbm9kZVxuICogd2UncmUgdHJ5aW5nIHRvIGZvcm0gYSBibG9jayB3aXRoLCB3ZSBhbHNvIGlnbm9yZSB0aGF0IHBvc3NpYmlsaXR5IC0gb3VyXG4gKiBibG9ja3Mgd291bGQgYmUgc3BsaXQgaW4gdGhhdCBzY2VuYXJpby5cbiAqL1xuZnVuY3Rpb24gdmVydGljYWxBbGlnbm1lbnQoZywgbGF5ZXJpbmcsIGNvbmZsaWN0cywgbmVpZ2hib3JGbikge1xuICB2YXIgcm9vdCA9IHt9LFxuICAgIGFsaWduID0ge30sXG4gICAgcG9zID0ge307XG5cbiAgLy8gV2UgY2FjaGUgdGhlIHBvc2l0aW9uIGhlcmUgYmFzZWQgb24gdGhlIGxheWVyaW5nIGJlY2F1c2UgdGhlIGdyYXBoIGFuZFxuICAvLyBsYXllcmluZyBtYXkgYmUgb3V0IG9mIHN5bmMuIFRoZSBsYXllcmluZyBtYXRyaXggaXMgbWFuaXB1bGF0ZWQgdG9cbiAgLy8gZ2VuZXJhdGUgZGlmZmVyZW50IGV4dHJlbWUgYWxpZ25tZW50cy5cbiAgXy5mb3JFYWNoKGxheWVyaW5nLCBmdW5jdGlvbihsYXllcikge1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odiwgb3JkZXIpIHtcbiAgICAgIHJvb3Rbdl0gPSB2O1xuICAgICAgYWxpZ25bdl0gPSB2O1xuICAgICAgcG9zW3ZdID0gb3JkZXI7XG4gICAgfSk7XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChsYXllcmluZywgZnVuY3Rpb24obGF5ZXIpIHtcbiAgICB2YXIgcHJldklkeCA9IC0xO1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odikge1xuICAgICAgdmFyIHdzID0gbmVpZ2hib3JGbih2KTtcbiAgICAgIGlmICh3cy5sZW5ndGgpIHtcbiAgICAgICAgd3MgPSBfLnNvcnRCeSh3cywgZnVuY3Rpb24odykgeyByZXR1cm4gcG9zW3ddOyB9KTtcbiAgICAgICAgdmFyIG1wID0gKHdzLmxlbmd0aCAtIDEpIC8gMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IE1hdGguZmxvb3IobXApLCBpbCA9IE1hdGguY2VpbChtcCk7IGkgPD0gaWw7ICsraSkge1xuICAgICAgICAgIHZhciB3ID0gd3NbaV07XG4gICAgICAgICAgaWYgKGFsaWduW3ZdID09PSB2ICYmXG4gICAgICAgICAgICAgIHByZXZJZHggPCBwb3Nbd10gJiZcbiAgICAgICAgICAgICAgIWhhc0NvbmZsaWN0KGNvbmZsaWN0cywgdiwgdykpIHtcbiAgICAgICAgICAgIGFsaWduW3ddID0gdjtcbiAgICAgICAgICAgIGFsaWduW3ZdID0gcm9vdFt2XSA9IHJvb3Rbd107XG4gICAgICAgICAgICBwcmV2SWR4ID0gcG9zW3ddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4geyByb290OiByb290LCBhbGlnbjogYWxpZ24gfTtcbn1cblxuZnVuY3Rpb24gaG9yaXpvbnRhbENvbXBhY3Rpb24oZywgbGF5ZXJpbmcsIHJvb3QsIGFsaWduLCByZXZlcnNlU2VwKSB7XG4gIC8vIFRoaXMgcG9ydGlvbiBvZiB0aGUgYWxnb3JpdGhtIGRpZmZlcnMgZnJvbSBCSyBkdWUgdG8gYSBudW1iZXIgb2YgcHJvYmxlbXMuXG4gIC8vIEluc3RlYWQgb2YgdGhlaXIgYWxnb3JpdGhtIHdlIGNvbnN0cnVjdCBhIG5ldyBibG9jayBncmFwaCBhbmQgZG8gdHdvXG4gIC8vIHN3ZWVwcy4gVGhlIGZpcnN0IHN3ZWVwIHBsYWNlcyBibG9ja3Mgd2l0aCB0aGUgc21hbGxlc3QgcG9zc2libGVcbiAgLy8gY29vcmRpbmF0ZXMuIFRoZSBzZWNvbmQgc3dlZXAgcmVtb3ZlcyB1bnVzZWQgc3BhY2UgYnkgbW92aW5nIGJsb2NrcyB0byB0aGVcbiAgLy8gZ3JlYXRlc3QgY29vcmRpbmF0ZXMgd2l0aG91dCB2aW9sYXRpbmcgc2VwYXJhdGlvbi5cbiAgdmFyIHhzID0ge30sXG4gICAgYmxvY2tHID0gYnVpbGRCbG9ja0dyYXBoKGcsIGxheWVyaW5nLCByb290LCByZXZlcnNlU2VwKSxcbiAgICBib3JkZXJUeXBlID0gcmV2ZXJzZVNlcCA/IFwiYm9yZGVyTGVmdFwiIDogXCJib3JkZXJSaWdodFwiO1xuXG4gIGZ1bmN0aW9uIGl0ZXJhdGUoc2V0WHNGdW5jLCBuZXh0Tm9kZXNGdW5jKSB7XG4gICAgdmFyIHN0YWNrID0gYmxvY2tHLm5vZGVzKCk7XG4gICAgdmFyIGVsZW0gPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgdmlzaXRlZCA9IHt9O1xuICAgIHdoaWxlIChlbGVtKSB7XG4gICAgICBpZiAodmlzaXRlZFtlbGVtXSkge1xuICAgICAgICBzZXRYc0Z1bmMoZWxlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aXNpdGVkW2VsZW1dID0gdHJ1ZTtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtKTtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5jb25jYXQobmV4dE5vZGVzRnVuYyhlbGVtKSk7XG4gICAgICB9XG5cbiAgICAgIGVsZW0gPSBzdGFjay5wb3AoKTtcbiAgICB9XG4gIH1cblxuICAvLyBGaXJzdCBwYXNzLCBhc3NpZ24gc21hbGxlc3QgY29vcmRpbmF0ZXNcbiAgZnVuY3Rpb24gcGFzczEoZWxlbSkge1xuICAgIHhzW2VsZW1dID0gYmxvY2tHLmluRWRnZXMoZWxlbSkucmVkdWNlKGZ1bmN0aW9uKGFjYywgZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGFjYywgeHNbZS52XSArIGJsb2NrRy5lZGdlKGUpKTtcbiAgICB9LCAwKTtcbiAgfVxuXG4gIC8vIFNlY29uZCBwYXNzLCBhc3NpZ24gZ3JlYXRlc3QgY29vcmRpbmF0ZXNcbiAgZnVuY3Rpb24gcGFzczIoZWxlbSkge1xuICAgIHZhciBtaW4gPSBibG9ja0cub3V0RWRnZXMoZWxlbSkucmVkdWNlKGZ1bmN0aW9uKGFjYywgZSkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGFjYywgeHNbZS53XSAtIGJsb2NrRy5lZGdlKGUpKTtcbiAgICB9LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuXG4gICAgdmFyIG5vZGUgPSBnLm5vZGUoZWxlbSk7XG4gICAgaWYgKG1pbiAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmIG5vZGUuYm9yZGVyVHlwZSAhPT0gYm9yZGVyVHlwZSkge1xuICAgICAgeHNbZWxlbV0gPSBNYXRoLm1heCh4c1tlbGVtXSwgbWluKTtcbiAgICB9XG4gIH1cblxuICBpdGVyYXRlKHBhc3MxLCBibG9ja0cucHJlZGVjZXNzb3JzLmJpbmQoYmxvY2tHKSk7XG4gIGl0ZXJhdGUocGFzczIsIGJsb2NrRy5zdWNjZXNzb3JzLmJpbmQoYmxvY2tHKSk7XG5cbiAgLy8gQXNzaWduIHggY29vcmRpbmF0ZXMgdG8gYWxsIG5vZGVzXG4gIF8uZm9yRWFjaChhbGlnbiwgZnVuY3Rpb24odikge1xuICAgIHhzW3ZdID0geHNbcm9vdFt2XV07XG4gIH0pO1xuXG4gIHJldHVybiB4cztcbn1cblxuXG5mdW5jdGlvbiBidWlsZEJsb2NrR3JhcGgoZywgbGF5ZXJpbmcsIHJvb3QsIHJldmVyc2VTZXApIHtcbiAgdmFyIGJsb2NrR3JhcGggPSBuZXcgR3JhcGgoKSxcbiAgICBncmFwaExhYmVsID0gZy5ncmFwaCgpLFxuICAgIHNlcEZuID0gc2VwKGdyYXBoTGFiZWwubm9kZXNlcCwgZ3JhcGhMYWJlbC5lZGdlc2VwLCByZXZlcnNlU2VwKTtcblxuICBfLmZvckVhY2gobGF5ZXJpbmcsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIHU7XG4gICAgXy5mb3JFYWNoKGxheWVyLCBmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgdlJvb3QgPSByb290W3ZdO1xuICAgICAgYmxvY2tHcmFwaC5zZXROb2RlKHZSb290KTtcbiAgICAgIGlmICh1KSB7XG4gICAgICAgIHZhciB1Um9vdCA9IHJvb3RbdV0sXG4gICAgICAgICAgcHJldk1heCA9IGJsb2NrR3JhcGguZWRnZSh1Um9vdCwgdlJvb3QpO1xuICAgICAgICBibG9ja0dyYXBoLnNldEVkZ2UodVJvb3QsIHZSb290LCBNYXRoLm1heChzZXBGbihnLCB2LCB1KSwgcHJldk1heCB8fCAwKSk7XG4gICAgICB9XG4gICAgICB1ID0gdjtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGJsb2NrR3JhcGg7XG59XG5cbi8qXG4gKiBSZXR1cm5zIHRoZSBhbGlnbm1lbnQgdGhhdCBoYXMgdGhlIHNtYWxsZXN0IHdpZHRoIG9mIHRoZSBnaXZlbiBhbGlnbm1lbnRzLlxuICovXG5mdW5jdGlvbiBmaW5kU21hbGxlc3RXaWR0aEFsaWdubWVudChnLCB4c3MpIHtcbiAgcmV0dXJuIF8ubWluQnkoXy52YWx1ZXMoeHNzKSwgZnVuY3Rpb24gKHhzKSB7XG4gICAgdmFyIG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gICAgXy5mb3JJbih4cywgZnVuY3Rpb24gKHgsIHYpIHtcbiAgICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aChnLCB2KSAvIDI7XG5cbiAgICAgIG1heCA9IE1hdGgubWF4KHggKyBoYWxmV2lkdGgsIG1heCk7XG4gICAgICBtaW4gPSBNYXRoLm1pbih4IC0gaGFsZldpZHRoLCBtaW4pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1heCAtIG1pbjtcbiAgfSk7XG59XG5cbi8qXG4gKiBBbGlnbiB0aGUgY29vcmRpbmF0ZXMgb2YgZWFjaCBvZiB0aGUgbGF5b3V0IGFsaWdubWVudHMgc3VjaCB0aGF0XG4gKiBsZWZ0LWJpYXNlZCBhbGlnbm1lbnRzIGhhdmUgdGhlaXIgbWluaW11bSBjb29yZGluYXRlIGF0IHRoZSBzYW1lIHBvaW50IGFzXG4gKiB0aGUgbWluaW11bSBjb29yZGluYXRlIG9mIHRoZSBzbWFsbGVzdCB3aWR0aCBhbGlnbm1lbnQgYW5kIHJpZ2h0LWJpYXNlZFxuICogYWxpZ25tZW50cyBoYXZlIHRoZWlyIG1heGltdW0gY29vcmRpbmF0ZSBhdCB0aGUgc2FtZSBwb2ludCBhcyB0aGUgbWF4aW11bVxuICogY29vcmRpbmF0ZSBvZiB0aGUgc21hbGxlc3Qgd2lkdGggYWxpZ25tZW50LlxuICovXG5mdW5jdGlvbiBhbGlnbkNvb3JkaW5hdGVzKHhzcywgYWxpZ25Ubykge1xuICB2YXIgYWxpZ25Ub1ZhbHMgPSBfLnZhbHVlcyhhbGlnblRvKSxcbiAgICBhbGlnblRvTWluID0gXy5taW4oYWxpZ25Ub1ZhbHMpLFxuICAgIGFsaWduVG9NYXggPSBfLm1heChhbGlnblRvVmFscyk7XG5cbiAgXy5mb3JFYWNoKFtcInVcIiwgXCJkXCJdLCBmdW5jdGlvbih2ZXJ0KSB7XG4gICAgXy5mb3JFYWNoKFtcImxcIiwgXCJyXCJdLCBmdW5jdGlvbihob3Jpeikge1xuICAgICAgdmFyIGFsaWdubWVudCA9IHZlcnQgKyBob3JpeixcbiAgICAgICAgeHMgPSB4c3NbYWxpZ25tZW50XSxcbiAgICAgICAgZGVsdGE7XG4gICAgICBpZiAoeHMgPT09IGFsaWduVG8pIHJldHVybjtcblxuICAgICAgdmFyIHhzVmFscyA9IF8udmFsdWVzKHhzKTtcbiAgICAgIGRlbHRhID0gaG9yaXogPT09IFwibFwiID8gYWxpZ25Ub01pbiAtIF8ubWluKHhzVmFscykgOiBhbGlnblRvTWF4IC0gXy5tYXgoeHNWYWxzKTtcblxuICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgIHhzc1thbGlnbm1lbnRdID0gXy5tYXBWYWx1ZXMoeHMsIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKyBkZWx0YTsgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBiYWxhbmNlKHhzcywgYWxpZ24pIHtcbiAgcmV0dXJuIF8ubWFwVmFsdWVzKHhzcy51bCwgZnVuY3Rpb24oaWdub3JlLCB2KSB7XG4gICAgaWYgKGFsaWduKSB7XG4gICAgICByZXR1cm4geHNzW2FsaWduLnRvTG93ZXJDYXNlKCldW3ZdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeHMgPSBfLnNvcnRCeShfLm1hcCh4c3MsIHYpKTtcbiAgICAgIHJldHVybiAoeHNbMV0gKyB4c1syXSkgLyAyO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBvc2l0aW9uWChnKSB7XG4gIHZhciBsYXllcmluZyA9IHV0aWwuYnVpbGRMYXllck1hdHJpeChnKTtcbiAgdmFyIGNvbmZsaWN0cyA9IF8ubWVyZ2UoXG4gICAgZmluZFR5cGUxQ29uZmxpY3RzKGcsIGxheWVyaW5nKSxcbiAgICBmaW5kVHlwZTJDb25mbGljdHMoZywgbGF5ZXJpbmcpKTtcblxuICB2YXIgeHNzID0ge307XG4gIHZhciBhZGp1c3RlZExheWVyaW5nO1xuICBfLmZvckVhY2goW1widVwiLCBcImRcIl0sIGZ1bmN0aW9uKHZlcnQpIHtcbiAgICBhZGp1c3RlZExheWVyaW5nID0gdmVydCA9PT0gXCJ1XCIgPyBsYXllcmluZyA6IF8udmFsdWVzKGxheWVyaW5nKS5yZXZlcnNlKCk7XG4gICAgXy5mb3JFYWNoKFtcImxcIiwgXCJyXCJdLCBmdW5jdGlvbihob3Jpeikge1xuICAgICAgaWYgKGhvcml6ID09PSBcInJcIikge1xuICAgICAgICBhZGp1c3RlZExheWVyaW5nID0gXy5tYXAoYWRqdXN0ZWRMYXllcmluZywgZnVuY3Rpb24oaW5uZXIpIHtcbiAgICAgICAgICByZXR1cm4gXy52YWx1ZXMoaW5uZXIpLnJldmVyc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWlnaGJvckZuID0gKHZlcnQgPT09IFwidVwiID8gZy5wcmVkZWNlc3NvcnMgOiBnLnN1Y2Nlc3NvcnMpLmJpbmQoZyk7XG4gICAgICB2YXIgYWxpZ24gPSB2ZXJ0aWNhbEFsaWdubWVudChnLCBhZGp1c3RlZExheWVyaW5nLCBjb25mbGljdHMsIG5laWdoYm9yRm4pO1xuICAgICAgdmFyIHhzID0gaG9yaXpvbnRhbENvbXBhY3Rpb24oZywgYWRqdXN0ZWRMYXllcmluZyxcbiAgICAgICAgYWxpZ24ucm9vdCwgYWxpZ24uYWxpZ24sIGhvcml6ID09PSBcInJcIik7XG4gICAgICBpZiAoaG9yaXogPT09IFwiclwiKSB7XG4gICAgICAgIHhzID0gXy5tYXBWYWx1ZXMoeHMsIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIC14OyB9KTtcbiAgICAgIH1cbiAgICAgIHhzc1t2ZXJ0ICsgaG9yaXpdID0geHM7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHZhciBzbWFsbGVzdFdpZHRoID0gZmluZFNtYWxsZXN0V2lkdGhBbGlnbm1lbnQoZywgeHNzKTtcbiAgYWxpZ25Db29yZGluYXRlcyh4c3MsIHNtYWxsZXN0V2lkdGgpO1xuICByZXR1cm4gYmFsYW5jZSh4c3MsIGcuZ3JhcGgoKS5hbGlnbik7XG59XG5cbmZ1bmN0aW9uIHNlcChub2RlU2VwLCBlZGdlU2VwLCByZXZlcnNlU2VwKSB7XG4gIHJldHVybiBmdW5jdGlvbihnLCB2LCB3KSB7XG4gICAgdmFyIHZMYWJlbCA9IGcubm9kZSh2KTtcbiAgICB2YXIgd0xhYmVsID0gZy5ub2RlKHcpO1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBkZWx0YTtcblxuICAgIHN1bSArPSB2TGFiZWwud2lkdGggLyAyO1xuICAgIGlmIChfLmhhcyh2TGFiZWwsIFwibGFiZWxwb3NcIikpIHtcbiAgICAgIHN3aXRjaCAodkxhYmVsLmxhYmVscG9zLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJsXCI6IGRlbHRhID0gLXZMYWJlbC53aWR0aCAvIDI7IGJyZWFrO1xuICAgICAgY2FzZSBcInJcIjogZGVsdGEgPSB2TGFiZWwud2lkdGggLyAyOyBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBzdW0gKz0gcmV2ZXJzZVNlcCA/IGRlbHRhIDogLWRlbHRhO1xuICAgIH1cbiAgICBkZWx0YSA9IDA7XG5cbiAgICBzdW0gKz0gKHZMYWJlbC5kdW1teSA/IGVkZ2VTZXAgOiBub2RlU2VwKSAvIDI7XG4gICAgc3VtICs9ICh3TGFiZWwuZHVtbXkgPyBlZGdlU2VwIDogbm9kZVNlcCkgLyAyO1xuXG4gICAgc3VtICs9IHdMYWJlbC53aWR0aCAvIDI7XG4gICAgaWYgKF8uaGFzKHdMYWJlbCwgXCJsYWJlbHBvc1wiKSkge1xuICAgICAgc3dpdGNoICh3TGFiZWwubGFiZWxwb3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgY2FzZSBcImxcIjogZGVsdGEgPSB3TGFiZWwud2lkdGggLyAyOyBicmVhaztcbiAgICAgIGNhc2UgXCJyXCI6IGRlbHRhID0gLXdMYWJlbC53aWR0aCAvIDI7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIHN1bSArPSByZXZlcnNlU2VwID8gZGVsdGEgOiAtZGVsdGE7XG4gICAgfVxuICAgIGRlbHRhID0gMDtcblxuICAgIHJldHVybiBzdW07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHdpZHRoKGcsIHYpIHtcbiAgcmV0dXJuIGcubm9kZSh2KS53aWR0aDtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3Bvc2l0aW9uL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9wb3NpdGlvbi9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG52YXIgdXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3V0aWwuanNcIik7XG52YXIgcG9zaXRpb25YID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9iayAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcG9zaXRpb24vYmsuanNcIikucG9zaXRpb25YO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvc2l0aW9uO1xuXG5mdW5jdGlvbiBwb3NpdGlvbihnKSB7XG4gIGcgPSB1dGlsLmFzTm9uQ29tcG91bmRHcmFwaChnKTtcblxuICBwb3NpdGlvblkoZyk7XG4gIF8uZm9yRWFjaChwb3NpdGlvblgoZyksIGZ1bmN0aW9uKHgsIHYpIHtcbiAgICBnLm5vZGUodikueCA9IHg7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwb3NpdGlvblkoZykge1xuICB2YXIgbGF5ZXJpbmcgPSB1dGlsLmJ1aWxkTGF5ZXJNYXRyaXgoZyk7XG4gIHZhciByYW5rU2VwID0gZy5ncmFwaCgpLnJhbmtzZXA7XG4gIHZhciBwcmV2WSA9IDA7XG4gIF8uZm9yRWFjaChsYXllcmluZywgZnVuY3Rpb24obGF5ZXIpIHtcbiAgICB2YXIgbWF4SGVpZ2h0ID0gXy5tYXgoXy5tYXAobGF5ZXIsIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcubm9kZSh2KS5oZWlnaHQ7IH0pKTtcbiAgICBfLmZvckVhY2gobGF5ZXIsIGZ1bmN0aW9uKHYpIHtcbiAgICAgIGcubm9kZSh2KS55ID0gcHJldlkgKyBtYXhIZWlnaHQgLyAyO1xuICAgIH0pO1xuICAgIHByZXZZICs9IG1heEhlaWdodCArIHJhbmtTZXA7XG4gIH0pO1xufVxuXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9yYW5rL2ZlYXNpYmxlLXRyZWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9yYW5rL2ZlYXNpYmxlLXRyZWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2xvZGFzaC5qc1wiKTtcbnZhciBHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2dyYXBobGliICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9ncmFwaGxpYi5qc1wiKS5HcmFwaDtcbnZhciBzbGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcmFuay91dGlsLmpzXCIpLnNsYWNrO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZlYXNpYmxlVHJlZTtcblxuLypcbiAqIENvbnN0cnVjdHMgYSBzcGFubmluZyB0cmVlIHdpdGggdGlnaHQgZWRnZXMgYW5kIGFkanVzdGVkIHRoZSBpbnB1dCBub2RlJ3NcbiAqIHJhbmtzIHRvIGFjaGlldmUgdGhpcy4gQSB0aWdodCBlZGdlIGlzIG9uZSB0aGF0IGlzIGhhcyBhIGxlbmd0aCB0aGF0IG1hdGNoZXNcbiAqIGl0cyBcIm1pbmxlblwiIGF0dHJpYnV0ZS5cbiAqXG4gKiBUaGUgYmFzaWMgc3RydWN0dXJlIGZvciB0aGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBHYW5zbmVyLCBldCBhbC4sIFwiQVxuICogVGVjaG5pcXVlIGZvciBEcmF3aW5nIERpcmVjdGVkIEdyYXBocy5cIlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEdyYXBoIG11c3QgYmUgYSBEQUcuXG4gKiAgICAyLiBHcmFwaCBtdXN0IGJlIGNvbm5lY3RlZC5cbiAqICAgIDMuIEdyYXBoIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbm9kZS5cbiAqICAgIDUuIEdyYXBoIG5vZGVzIG11c3QgaGF2ZSBiZWVuIHByZXZpb3VzbHkgYXNzaWduZWQgYSBcInJhbmtcIiBwcm9wZXJ0eSB0aGF0XG4gKiAgICAgICByZXNwZWN0cyB0aGUgXCJtaW5sZW5cIiBwcm9wZXJ0eSBvZiBpbmNpZGVudCBlZGdlcy5cbiAqICAgIDYuIEdyYXBoIGVkZ2VzIG11c3QgaGF2ZSBhIFwibWlubGVuXCIgcHJvcGVydHkuXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIC0gR3JhcGggbm9kZXMgd2lsbCBoYXZlIHRoZWlyIHJhbmsgYWRqdXN0ZWQgdG8gZW5zdXJlIHRoYXQgYWxsIGVkZ2VzIGFyZVxuICogICAgICB0aWdodC5cbiAqXG4gKiBSZXR1cm5zIGEgdHJlZSAodW5kaXJlY3RlZCBncmFwaCkgdGhhdCBpcyBjb25zdHJ1Y3RlZCB1c2luZyBvbmx5IFwidGlnaHRcIlxuICogZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIGZlYXNpYmxlVHJlZShnKSB7XG4gIHZhciB0ID0gbmV3IEdyYXBoKHsgZGlyZWN0ZWQ6IGZhbHNlIH0pO1xuXG4gIC8vIENob29zZSBhcmJpdHJhcnkgbm9kZSBmcm9tIHdoaWNoIHRvIHN0YXJ0IG91ciB0cmVlXG4gIHZhciBzdGFydCA9IGcubm9kZXMoKVswXTtcbiAgdmFyIHNpemUgPSBnLm5vZGVDb3VudCgpO1xuICB0LnNldE5vZGUoc3RhcnQsIHt9KTtcblxuICB2YXIgZWRnZSwgZGVsdGE7XG4gIHdoaWxlICh0aWdodFRyZWUodCwgZykgPCBzaXplKSB7XG4gICAgZWRnZSA9IGZpbmRNaW5TbGFja0VkZ2UodCwgZyk7XG4gICAgZGVsdGEgPSB0Lmhhc05vZGUoZWRnZS52KSA/IHNsYWNrKGcsIGVkZ2UpIDogLXNsYWNrKGcsIGVkZ2UpO1xuICAgIHNoaWZ0UmFua3ModCwgZywgZGVsdGEpO1xuICB9XG5cbiAgcmV0dXJuIHQ7XG59XG5cbi8qXG4gKiBGaW5kcyBhIG1heGltYWwgdHJlZSBvZiB0aWdodCBlZGdlcyBhbmQgcmV0dXJucyB0aGUgbnVtYmVyIG9mIG5vZGVzIGluIHRoZVxuICogdHJlZS5cbiAqL1xuZnVuY3Rpb24gdGlnaHRUcmVlKHQsIGcpIHtcbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICBfLmZvckVhY2goZy5ub2RlRWRnZXModiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBlZGdlViA9IGUudixcbiAgICAgICAgdyA9ICh2ID09PSBlZGdlVikgPyBlLncgOiBlZGdlVjtcbiAgICAgIGlmICghdC5oYXNOb2RlKHcpICYmICFzbGFjayhnLCBlKSkge1xuICAgICAgICB0LnNldE5vZGUodywge30pO1xuICAgICAgICB0LnNldEVkZ2Uodiwgdywge30pO1xuICAgICAgICBkZnModyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfLmZvckVhY2godC5ub2RlcygpLCBkZnMpO1xuICByZXR1cm4gdC5ub2RlQ291bnQoKTtcbn1cblxuLypcbiAqIEZpbmRzIHRoZSBlZGdlIHdpdGggdGhlIHNtYWxsZXN0IHNsYWNrIHRoYXQgaXMgaW5jaWRlbnQgb24gdHJlZSBhbmQgcmV0dXJuc1xuICogaXQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRNaW5TbGFja0VkZ2UodCwgZykge1xuICByZXR1cm4gXy5taW5CeShnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodC5oYXNOb2RlKGUudikgIT09IHQuaGFzTm9kZShlLncpKSB7XG4gICAgICByZXR1cm4gc2xhY2soZywgZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2hpZnRSYW5rcyh0LCBnLCBkZWx0YSkge1xuICBfLmZvckVhY2godC5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgZy5ub2RlKHYpLnJhbmsgKz0gZGVsdGE7XG4gIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcmFuay9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9yYW5rL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgcmFua1V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3JhbmsvdXRpbC5qc1wiKTtcbnZhciBsb25nZXN0UGF0aCA9IHJhbmtVdGlsLmxvbmdlc3RQYXRoO1xudmFyIGZlYXNpYmxlVHJlZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmVhc2libGUtdHJlZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcmFuay9mZWFzaWJsZS10cmVlLmpzXCIpO1xudmFyIG5ldHdvcmtTaW1wbGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9uZXR3b3JrLXNpbXBsZXggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3JhbmsvbmV0d29yay1zaW1wbGV4LmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbms7XG5cbi8qXG4gKiBBc3NpZ25zIGEgcmFuayB0byBlYWNoIG5vZGUgaW4gdGhlIGlucHV0IGdyYXBoIHRoYXQgcmVzcGVjdHMgdGhlIFwibWlubGVuXCJcbiAqIGNvbnN0cmFpbnQgc3BlY2lmaWVkIG9uIGVkZ2VzIGJldHdlZW4gbm9kZXMuXG4gKlxuICogVGhpcyBiYXNpYyBzdHJ1Y3R1cmUgaXMgZGVyaXZlZCBmcm9tIEdhbnNuZXIsIGV0IGFsLiwgXCJBIFRlY2huaXF1ZSBmb3JcbiAqIERyYXdpbmcgRGlyZWN0ZWQgR3JhcGhzLlwiXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gR3JhcGggbXVzdCBiZSBhIGNvbm5lY3RlZCBEQUdcbiAqICAgIDIuIEdyYXBoIG5vZGVzIG11c3QgYmUgb2JqZWN0c1xuICogICAgMy4gR3JhcGggZWRnZXMgbXVzdCBoYXZlIFwid2VpZ2h0XCIgYW5kIFwibWlubGVuXCIgYXR0cmlidXRlc1xuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBHcmFwaCBub2RlcyB3aWxsIGhhdmUgYSBcInJhbmtcIiBhdHRyaWJ1dGUgYmFzZWQgb24gdGhlIHJlc3VsdHMgb2YgdGhlXG4gKiAgICAgICBhbGdvcml0aG0uIFJhbmtzIGNhbiBzdGFydCBhdCBhbnkgaW5kZXggKGluY2x1ZGluZyBuZWdhdGl2ZSksIHdlJ2xsXG4gKiAgICAgICBmaXggdGhlbSB1cCBsYXRlci5cbiAqL1xuZnVuY3Rpb24gcmFuayhnKSB7XG4gIHN3aXRjaChnLmdyYXBoKCkucmFua2VyKSB7XG4gIGNhc2UgXCJuZXR3b3JrLXNpbXBsZXhcIjogbmV0d29ya1NpbXBsZXhSYW5rZXIoZyk7IGJyZWFrO1xuICBjYXNlIFwidGlnaHQtdHJlZVwiOiB0aWdodFRyZWVSYW5rZXIoZyk7IGJyZWFrO1xuICBjYXNlIFwibG9uZ2VzdC1wYXRoXCI6IGxvbmdlc3RQYXRoUmFua2VyKGcpOyBicmVhaztcbiAgZGVmYXVsdDogbmV0d29ya1NpbXBsZXhSYW5rZXIoZyk7XG4gIH1cbn1cblxuLy8gQSBmYXN0IGFuZCBzaW1wbGUgcmFua2VyLCBidXQgcmVzdWx0cyBhcmUgZmFyIGZyb20gb3B0aW1hbC5cbnZhciBsb25nZXN0UGF0aFJhbmtlciA9IGxvbmdlc3RQYXRoO1xuXG5mdW5jdGlvbiB0aWdodFRyZWVSYW5rZXIoZykge1xuICBsb25nZXN0UGF0aChnKTtcbiAgZmVhc2libGVUcmVlKGcpO1xufVxuXG5mdW5jdGlvbiBuZXR3b3JrU2ltcGxleFJhbmtlcihnKSB7XG4gIG5ldHdvcmtTaW1wbGV4KGcpO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcmFuay9uZXR3b3JrLXNpbXBsZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3JhbmsvbmV0d29yay1zaW1wbGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL2xvZGFzaC5qc1wiKTtcbnZhciBmZWFzaWJsZVRyZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZlYXNpYmxlLXRyZWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3JhbmsvZmVhc2libGUtdHJlZS5qc1wiKTtcbnZhciBzbGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcmFuay91dGlsLmpzXCIpLnNsYWNrO1xudmFyIGluaXRSYW5rID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9yYW5rL3V0aWwuanNcIikubG9uZ2VzdFBhdGg7XG52YXIgcHJlb3JkZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ncmFwaGxpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvZ3JhcGhsaWIuanNcIikuYWxnLnByZW9yZGVyO1xudmFyIHBvc3RvcmRlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2dyYXBobGliICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9ncmFwaGxpYi5qc1wiKS5hbGcucG9zdG9yZGVyO1xudmFyIHNpbXBsaWZ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvdXRpbC5qc1wiKS5zaW1wbGlmeTtcblxubW9kdWxlLmV4cG9ydHMgPSBuZXR3b3JrU2ltcGxleDtcblxuLy8gRXhwb3NlIHNvbWUgaW50ZXJuYWxzIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG5uZXR3b3JrU2ltcGxleC5pbml0TG93TGltVmFsdWVzID0gaW5pdExvd0xpbVZhbHVlcztcbm5ldHdvcmtTaW1wbGV4LmluaXRDdXRWYWx1ZXMgPSBpbml0Q3V0VmFsdWVzO1xubmV0d29ya1NpbXBsZXguY2FsY0N1dFZhbHVlID0gY2FsY0N1dFZhbHVlO1xubmV0d29ya1NpbXBsZXgubGVhdmVFZGdlID0gbGVhdmVFZGdlO1xubmV0d29ya1NpbXBsZXguZW50ZXJFZGdlID0gZW50ZXJFZGdlO1xubmV0d29ya1NpbXBsZXguZXhjaGFuZ2VFZGdlcyA9IGV4Y2hhbmdlRWRnZXM7XG5cbi8qXG4gKiBUaGUgbmV0d29yayBzaW1wbGV4IGFsZ29yaXRobSBhc3NpZ25zIHJhbmtzIHRvIGVhY2ggbm9kZSBpbiB0aGUgaW5wdXQgZ3JhcGhcbiAqIGFuZCBpdGVyYXRpdmVseSBpbXByb3ZlcyB0aGUgcmFua2luZyB0byByZWR1Y2UgdGhlIGxlbmd0aCBvZiBlZGdlcy5cbiAqXG4gKiBQcmVjb25kaXRpb25zOlxuICpcbiAqICAgIDEuIFRoZSBpbnB1dCBncmFwaCBtdXN0IGJlIGEgREFHLlxuICogICAgMi4gQWxsIG5vZGVzIGluIHRoZSBncmFwaCBtdXN0IGhhdmUgYW4gb2JqZWN0IHZhbHVlLlxuICogICAgMy4gQWxsIGVkZ2VzIGluIHRoZSBncmFwaCBtdXN0IGhhdmUgXCJtaW5sZW5cIiBhbmQgXCJ3ZWlnaHRcIiBhdHRyaWJ1dGVzLlxuICpcbiAqIFBvc3Rjb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEFsbCBub2RlcyBpbiB0aGUgZ3JhcGggd2lsbCBoYXZlIGFuIGFzc2lnbmVkIFwicmFua1wiIGF0dHJpYnV0ZSB0aGF0IGhhc1xuICogICAgICAgYmVlbiBvcHRpbWl6ZWQgYnkgdGhlIG5ldHdvcmsgc2ltcGxleCBhbGdvcml0aG0uIFJhbmtzIHN0YXJ0IGF0IDAuXG4gKlxuICpcbiAqIEEgcm91Z2ggc2tldGNoIG9mIHRoZSBhbGdvcml0aG0gaXMgYXMgZm9sbG93czpcbiAqXG4gKiAgICAxLiBBc3NpZ24gaW5pdGlhbCByYW5rcyB0byBlYWNoIG5vZGUuIFdlIHVzZSB0aGUgbG9uZ2VzdCBwYXRoIGFsZ29yaXRobSxcbiAqICAgICAgIHdoaWNoIGFzc2lnbnMgcmFua3MgdG8gdGhlIGxvd2VzdCBwb3NpdGlvbiBwb3NzaWJsZS4gSW4gZ2VuZXJhbCB0aGlzXG4gKiAgICAgICBsZWFkcyB0byB2ZXJ5IHdpZGUgYm90dG9tIHJhbmtzIGFuZCB1bm5lY2Vzc2FyaWx5IGxvbmcgZWRnZXMuXG4gKiAgICAyLiBDb25zdHJ1Y3QgYSBmZWFzaWJsZSB0aWdodCB0cmVlLiBBIHRpZ2h0IHRyZWUgaXMgb25lIHN1Y2ggdGhhdCBhbGxcbiAqICAgICAgIGVkZ2VzIGluIHRoZSB0cmVlIGhhdmUgbm8gc2xhY2sgKGRpZmZlcmVuY2UgYmV0d2VlbiBsZW5ndGggb2YgZWRnZVxuICogICAgICAgYW5kIG1pbmxlbiBmb3IgdGhlIGVkZ2UpLiBUaGlzIGJ5IGl0c2VsZiBncmVhdGx5IGltcHJvdmVzIHRoZSBhc3NpZ25lZFxuICogICAgICAgcmFua2luZ3MgYnkgc2hvcnRpbmcgZWRnZXMuXG4gKiAgICAzLiBJdGVyYXRpdmVseSBmaW5kIGVkZ2VzIHRoYXQgaGF2ZSBuZWdhdGl2ZSBjdXQgdmFsdWVzLiBHZW5lcmFsbHkgYVxuICogICAgICAgbmVnYXRpdmUgY3V0IHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSBlZGdlIGNvdWxkIGJlIHJlbW92ZWQgYW5kIGEgbmV3XG4gKiAgICAgICB0cmVlIGVkZ2UgY291bGQgYmUgYWRkZWQgdG8gcHJvZHVjZSBhIG1vcmUgY29tcGFjdCBncmFwaC5cbiAqXG4gKiBNdWNoIG9mIHRoZSBhbGdvcml0aG1zIGhlcmUgYXJlIGRlcml2ZWQgZnJvbSBHYW5zbmVyLCBldCBhbC4sIFwiQSBUZWNobmlxdWVcbiAqIGZvciBEcmF3aW5nIERpcmVjdGVkIEdyYXBocy5cIiBUaGUgc3RydWN0dXJlIG9mIHRoZSBmaWxlIHJvdWdobHkgZm9sbG93cyB0aGVcbiAqIHN0cnVjdHVyZSBvZiB0aGUgb3ZlcmFsbCBhbGdvcml0aG0uXG4gKi9cbmZ1bmN0aW9uIG5ldHdvcmtTaW1wbGV4KGcpIHtcbiAgZyA9IHNpbXBsaWZ5KGcpO1xuICBpbml0UmFuayhnKTtcbiAgdmFyIHQgPSBmZWFzaWJsZVRyZWUoZyk7XG4gIGluaXRMb3dMaW1WYWx1ZXModCk7XG4gIGluaXRDdXRWYWx1ZXModCwgZyk7XG5cbiAgdmFyIGUsIGY7XG4gIHdoaWxlICgoZSA9IGxlYXZlRWRnZSh0KSkpIHtcbiAgICBmID0gZW50ZXJFZGdlKHQsIGcsIGUpO1xuICAgIGV4Y2hhbmdlRWRnZXModCwgZywgZSwgZik7XG4gIH1cbn1cblxuLypcbiAqIEluaXRpYWxpemVzIGN1dCB2YWx1ZXMgZm9yIGFsbCBlZGdlcyBpbiB0aGUgdHJlZS5cbiAqL1xuZnVuY3Rpb24gaW5pdEN1dFZhbHVlcyh0LCBnKSB7XG4gIHZhciB2cyA9IHBvc3RvcmRlcih0LCB0Lm5vZGVzKCkpO1xuICB2cyA9IHZzLnNsaWNlKDAsIHZzLmxlbmd0aCAtIDEpO1xuICBfLmZvckVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICBhc3NpZ25DdXRWYWx1ZSh0LCBnLCB2KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkN1dFZhbHVlKHQsIGcsIGNoaWxkKSB7XG4gIHZhciBjaGlsZExhYiA9IHQubm9kZShjaGlsZCk7XG4gIHZhciBwYXJlbnQgPSBjaGlsZExhYi5wYXJlbnQ7XG4gIHQuZWRnZShjaGlsZCwgcGFyZW50KS5jdXR2YWx1ZSA9IGNhbGNDdXRWYWx1ZSh0LCBnLCBjaGlsZCk7XG59XG5cbi8qXG4gKiBHaXZlbiB0aGUgdGlnaHQgdHJlZSwgaXRzIGdyYXBoLCBhbmQgYSBjaGlsZCBpbiB0aGUgZ3JhcGggY2FsY3VsYXRlIGFuZFxuICogcmV0dXJuIHRoZSBjdXQgdmFsdWUgZm9yIHRoZSBlZGdlIGJldHdlZW4gdGhlIGNoaWxkIGFuZCBpdHMgcGFyZW50LlxuICovXG5mdW5jdGlvbiBjYWxjQ3V0VmFsdWUodCwgZywgY2hpbGQpIHtcbiAgdmFyIGNoaWxkTGFiID0gdC5ub2RlKGNoaWxkKTtcbiAgdmFyIHBhcmVudCA9IGNoaWxkTGFiLnBhcmVudDtcbiAgLy8gVHJ1ZSBpZiB0aGUgY2hpbGQgaXMgb24gdGhlIHRhaWwgZW5kIG9mIHRoZSBlZGdlIGluIHRoZSBkaXJlY3RlZCBncmFwaFxuICB2YXIgY2hpbGRJc1RhaWwgPSB0cnVlO1xuICAvLyBUaGUgZ3JhcGgncyB2aWV3IG9mIHRoZSB0cmVlIGVkZ2Ugd2UncmUgaW5zcGVjdGluZ1xuICB2YXIgZ3JhcGhFZGdlID0gZy5lZGdlKGNoaWxkLCBwYXJlbnQpO1xuICAvLyBUaGUgYWNjdW11bGF0ZWQgY3V0IHZhbHVlIGZvciB0aGUgZWRnZSBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgaXRzIHBhcmVudFxuICB2YXIgY3V0VmFsdWUgPSAwO1xuXG4gIGlmICghZ3JhcGhFZGdlKSB7XG4gICAgY2hpbGRJc1RhaWwgPSBmYWxzZTtcbiAgICBncmFwaEVkZ2UgPSBnLmVkZ2UocGFyZW50LCBjaGlsZCk7XG4gIH1cblxuICBjdXRWYWx1ZSA9IGdyYXBoRWRnZS53ZWlnaHQ7XG5cbiAgXy5mb3JFYWNoKGcubm9kZUVkZ2VzKGNoaWxkKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBpc091dEVkZ2UgPSBlLnYgPT09IGNoaWxkLFxuICAgICAgb3RoZXIgPSBpc091dEVkZ2UgPyBlLncgOiBlLnY7XG5cbiAgICBpZiAob3RoZXIgIT09IHBhcmVudCkge1xuICAgICAgdmFyIHBvaW50c1RvSGVhZCA9IGlzT3V0RWRnZSA9PT0gY2hpbGRJc1RhaWwsXG4gICAgICAgIG90aGVyV2VpZ2h0ID0gZy5lZGdlKGUpLndlaWdodDtcblxuICAgICAgY3V0VmFsdWUgKz0gcG9pbnRzVG9IZWFkID8gb3RoZXJXZWlnaHQgOiAtb3RoZXJXZWlnaHQ7XG4gICAgICBpZiAoaXNUcmVlRWRnZSh0LCBjaGlsZCwgb3RoZXIpKSB7XG4gICAgICAgIHZhciBvdGhlckN1dFZhbHVlID0gdC5lZGdlKGNoaWxkLCBvdGhlcikuY3V0dmFsdWU7XG4gICAgICAgIGN1dFZhbHVlICs9IHBvaW50c1RvSGVhZCA/IC1vdGhlckN1dFZhbHVlIDogb3RoZXJDdXRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjdXRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdExvd0xpbVZhbHVlcyh0cmVlLCByb290KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgIHJvb3QgPSB0cmVlLm5vZGVzKClbMF07XG4gIH1cbiAgZGZzQXNzaWduTG93TGltKHRyZWUsIHt9LCAxLCByb290KTtcbn1cblxuZnVuY3Rpb24gZGZzQXNzaWduTG93TGltKHRyZWUsIHZpc2l0ZWQsIG5leHRMaW0sIHYsIHBhcmVudCkge1xuICB2YXIgbG93ID0gbmV4dExpbTtcbiAgdmFyIGxhYmVsID0gdHJlZS5ub2RlKHYpO1xuXG4gIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICBfLmZvckVhY2godHJlZS5uZWlnaGJvcnModiksIGZ1bmN0aW9uKHcpIHtcbiAgICBpZiAoIV8uaGFzKHZpc2l0ZWQsIHcpKSB7XG4gICAgICBuZXh0TGltID0gZGZzQXNzaWduTG93TGltKHRyZWUsIHZpc2l0ZWQsIG5leHRMaW0sIHcsIHYpO1xuICAgIH1cbiAgfSk7XG5cbiAgbGFiZWwubG93ID0gbG93O1xuICBsYWJlbC5saW0gPSBuZXh0TGltKys7XG4gIGlmIChwYXJlbnQpIHtcbiAgICBsYWJlbC5wYXJlbnQgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gVE9ETyBzaG91bGQgYmUgYWJsZSB0byByZW1vdmUgdGhpcyB3aGVuIHdlIGluY3JlbWVudGFsbHkgdXBkYXRlIGxvdyBsaW1cbiAgICBkZWxldGUgbGFiZWwucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIG5leHRMaW07XG59XG5cbmZ1bmN0aW9uIGxlYXZlRWRnZSh0cmVlKSB7XG4gIHJldHVybiBfLmZpbmQodHJlZS5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIHRyZWUuZWRnZShlKS5jdXR2YWx1ZSA8IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbnRlckVkZ2UodCwgZywgZWRnZSkge1xuICB2YXIgdiA9IGVkZ2UudjtcbiAgdmFyIHcgPSBlZGdlLnc7XG5cbiAgLy8gRm9yIHRoZSByZXN0IG9mIHRoaXMgZnVuY3Rpb24gd2UgYXNzdW1lIHRoYXQgdiBpcyB0aGUgdGFpbCBhbmQgdyBpcyB0aGVcbiAgLy8gaGVhZCwgc28gaWYgd2UgZG9uJ3QgaGF2ZSB0aGlzIGVkZ2UgaW4gdGhlIGdyYXBoIHdlIHNob3VsZCBmbGlwIGl0IHRvXG4gIC8vIG1hdGNoIHRoZSBjb3JyZWN0IG9yaWVudGF0aW9uLlxuICBpZiAoIWcuaGFzRWRnZSh2LCB3KSkge1xuICAgIHYgPSBlZGdlLnc7XG4gICAgdyA9IGVkZ2UudjtcbiAgfVxuXG4gIHZhciB2TGFiZWwgPSB0Lm5vZGUodik7XG4gIHZhciB3TGFiZWwgPSB0Lm5vZGUodyk7XG4gIHZhciB0YWlsTGFiZWwgPSB2TGFiZWw7XG4gIHZhciBmbGlwID0gZmFsc2U7XG5cbiAgLy8gSWYgdGhlIHJvb3QgaXMgaW4gdGhlIHRhaWwgb2YgdGhlIGVkZ2UgdGhlbiB3ZSBuZWVkIHRvIGZsaXAgdGhlIGxvZ2ljIHRoYXRcbiAgLy8gY2hlY2tzIGZvciB0aGUgaGVhZCBhbmQgdGFpbCBub2RlcyBpbiB0aGUgY2FuZGlkYXRlcyBmdW5jdGlvbiBiZWxvdy5cbiAgaWYgKHZMYWJlbC5saW0gPiB3TGFiZWwubGltKSB7XG4gICAgdGFpbExhYmVsID0gd0xhYmVsO1xuICAgIGZsaXAgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGNhbmRpZGF0ZXMgPSBfLmZpbHRlcihnLmVkZ2VzKCksIGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICByZXR1cm4gZmxpcCA9PT0gaXNEZXNjZW5kYW50KHQsIHQubm9kZShlZGdlLnYpLCB0YWlsTGFiZWwpICYmXG4gICAgICAgICAgIGZsaXAgIT09IGlzRGVzY2VuZGFudCh0LCB0Lm5vZGUoZWRnZS53KSwgdGFpbExhYmVsKTtcbiAgfSk7XG5cbiAgcmV0dXJuIF8ubWluQnkoY2FuZGlkYXRlcywgZnVuY3Rpb24oZWRnZSkgeyByZXR1cm4gc2xhY2soZywgZWRnZSk7IH0pO1xufVxuXG5mdW5jdGlvbiBleGNoYW5nZUVkZ2VzKHQsIGcsIGUsIGYpIHtcbiAgdmFyIHYgPSBlLnY7XG4gIHZhciB3ID0gZS53O1xuICB0LnJlbW92ZUVkZ2Uodiwgdyk7XG4gIHQuc2V0RWRnZShmLnYsIGYudywge30pO1xuICBpbml0TG93TGltVmFsdWVzKHQpO1xuICBpbml0Q3V0VmFsdWVzKHQsIGcpO1xuICB1cGRhdGVSYW5rcyh0LCBnKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmFua3ModCwgZykge1xuICB2YXIgcm9vdCA9IF8uZmluZCh0Lm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgcmV0dXJuICFnLm5vZGUodikucGFyZW50OyB9KTtcbiAgdmFyIHZzID0gcHJlb3JkZXIodCwgcm9vdCk7XG4gIHZzID0gdnMuc2xpY2UoMSk7XG4gIF8uZm9yRWFjaCh2cywgZnVuY3Rpb24odikge1xuICAgIHZhciBwYXJlbnQgPSB0Lm5vZGUodikucGFyZW50LFxuICAgICAgZWRnZSA9IGcuZWRnZSh2LCBwYXJlbnQpLFxuICAgICAgZmxpcHBlZCA9IGZhbHNlO1xuXG4gICAgaWYgKCFlZGdlKSB7XG4gICAgICBlZGdlID0gZy5lZGdlKHBhcmVudCwgdik7XG4gICAgICBmbGlwcGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBnLm5vZGUodikucmFuayA9IGcubm9kZShwYXJlbnQpLnJhbmsgKyAoZmxpcHBlZCA/IGVkZ2UubWlubGVuIDogLWVkZ2UubWlubGVuKTtcbiAgfSk7XG59XG5cbi8qXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVkZ2UgaXMgaW4gdGhlIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIGlzVHJlZUVkZ2UodHJlZSwgdSwgdikge1xuICByZXR1cm4gdHJlZS5oYXNFZGdlKHUsIHYpO1xufVxuXG4vKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgbm9kZSBpcyBkZXNjZW5kYW50IG9mIHRoZSByb290IG5vZGUgcGVyIHRoZVxuICogYXNzaWduZWQgbG93IGFuZCBsaW0gYXR0cmlidXRlcyBpbiB0aGUgdHJlZS5cbiAqL1xuZnVuY3Rpb24gaXNEZXNjZW5kYW50KHRyZWUsIHZMYWJlbCwgcm9vdExhYmVsKSB7XG4gIHJldHVybiByb290TGFiZWwubG93IDw9IHZMYWJlbC5saW0gJiYgdkxhYmVsLmxpbSA8PSByb290TGFiZWwubGltO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcmFuay91dGlsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvcmFuay91dGlsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb25nZXN0UGF0aDogbG9uZ2VzdFBhdGgsXG4gIHNsYWNrOiBzbGFja1xufTtcblxuLypcbiAqIEluaXRpYWxpemVzIHJhbmtzIGZvciB0aGUgaW5wdXQgZ3JhcGggdXNpbmcgdGhlIGxvbmdlc3QgcGF0aCBhbGdvcml0aG0uIFRoaXNcbiAqIGFsZ29yaXRobSBzY2FsZXMgd2VsbCBhbmQgaXMgZmFzdCBpbiBwcmFjdGljZSwgaXQgeWllbGRzIHJhdGhlciBwb29yXG4gKiBzb2x1dGlvbnMuIE5vZGVzIGFyZSBwdXNoZWQgdG8gdGhlIGxvd2VzdCBsYXllciBwb3NzaWJsZSwgbGVhdmluZyB0aGUgYm90dG9tXG4gKiByYW5rcyB3aWRlIGFuZCBsZWF2aW5nIGVkZ2VzIGxvbmdlciB0aGFuIG5lY2Vzc2FyeS4gSG93ZXZlciwgZHVlIHRvIGl0c1xuICogc3BlZWQsIHRoaXMgYWxnb3JpdGhtIGlzIGdvb2QgZm9yIGdldHRpbmcgYW4gaW5pdGlhbCByYW5raW5nIHRoYXQgY2FuIGJlIGZlZFxuICogaW50byBvdGhlciBhbGdvcml0aG1zLlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIGRvZXMgbm90IG5vcm1hbGl6ZSBsYXllcnMgYmVjYXVzZSBpdCB3aWxsIGJlIHVzZWQgYnkgb3RoZXJcbiAqIGFsZ29yaXRobXMgaW4gbW9zdCBjYXNlcy4gSWYgdXNpbmcgdGhpcyBhbGdvcml0aG0gZGlyZWN0bHksIGJlIHN1cmUgdG9cbiAqIHJ1biBub3JtYWxpemUgYXQgdGhlIGVuZC5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBJbnB1dCBncmFwaCBpcyBhIERBRy5cbiAqICAgIDIuIElucHV0IGdyYXBoIG5vZGUgbGFiZWxzIGNhbiBiZSBhc3NpZ25lZCBwcm9wZXJ0aWVzLlxuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBFYWNoIG5vZGUgd2lsbCBiZSBhc3NpZ24gYW4gKHVubm9ybWFsaXplZCkgXCJyYW5rXCIgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RQYXRoKGcpIHtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIHZhciBsYWJlbCA9IGcubm9kZSh2KTtcbiAgICBpZiAoXy5oYXModmlzaXRlZCwgdikpIHtcbiAgICAgIHJldHVybiBsYWJlbC5yYW5rO1xuICAgIH1cbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcblxuICAgIHZhciByYW5rID0gXy5taW4oXy5tYXAoZy5vdXRFZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIGRmcyhlLncpIC0gZy5lZGdlKGUpLm1pbmxlbjtcbiAgICB9KSk7XG5cbiAgICBpZiAocmFuayA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8IC8vIHJldHVybiB2YWx1ZSBvZiBfLm1hcChbXSkgZm9yIExvZGFzaCAzXG4gICAgICAgIHJhbmsgPT09IHVuZGVmaW5lZCB8fCAvLyByZXR1cm4gdmFsdWUgb2YgXy5tYXAoW10pIGZvciBMb2Rhc2ggNFxuICAgICAgICByYW5rID09PSBudWxsKSB7IC8vIHJldHVybiB2YWx1ZSBvZiBfLm1hcChbbnVsbF0pXG4gICAgICByYW5rID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gKGxhYmVsLnJhbmsgPSByYW5rKTtcbiAgfVxuXG4gIF8uZm9yRWFjaChnLnNvdXJjZXMoKSwgZGZzKTtcbn1cblxuLypcbiAqIFJldHVybnMgdGhlIGFtb3VudCBvZiBzbGFjayBmb3IgdGhlIGdpdmVuIGVkZ2UuIFRoZSBzbGFjayBpcyBkZWZpbmVkIGFzIHRoZVxuICogZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBsZW5ndGggb2YgdGhlIGVkZ2UgYW5kIGl0cyBtaW5pbXVtIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc2xhY2soZywgZSkge1xuICByZXR1cm4gZy5ub2RlKGUudykucmFuayAtIGcubm9kZShlLnYpLnJhbmsgLSBnLmVkZ2UoZSkubWlubGVuO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9saWIvdXRpbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi91dGlsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGVzbGludCBcIm5vLWNvbnNvbGVcIjogb2ZmICovXG5cblxuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9sb2Rhc2guanNcIik7XG52YXIgR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dyYXBobGliICovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi9ncmFwaGxpYi5qc1wiKS5HcmFwaDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFkZER1bW15Tm9kZTogYWRkRHVtbXlOb2RlLFxuICBzaW1wbGlmeTogc2ltcGxpZnksXG4gIGFzTm9uQ29tcG91bmRHcmFwaDogYXNOb25Db21wb3VuZEdyYXBoLFxuICBzdWNjZXNzb3JXZWlnaHRzOiBzdWNjZXNzb3JXZWlnaHRzLFxuICBwcmVkZWNlc3NvcldlaWdodHM6IHByZWRlY2Vzc29yV2VpZ2h0cyxcbiAgaW50ZXJzZWN0UmVjdDogaW50ZXJzZWN0UmVjdCxcbiAgYnVpbGRMYXllck1hdHJpeDogYnVpbGRMYXllck1hdHJpeCxcbiAgbm9ybWFsaXplUmFua3M6IG5vcm1hbGl6ZVJhbmtzLFxuICByZW1vdmVFbXB0eVJhbmtzOiByZW1vdmVFbXB0eVJhbmtzLFxuICBhZGRCb3JkZXJOb2RlOiBhZGRCb3JkZXJOb2RlLFxuICBtYXhSYW5rOiBtYXhSYW5rLFxuICBwYXJ0aXRpb246IHBhcnRpdGlvbixcbiAgdGltZTogdGltZSxcbiAgbm90aW1lOiBub3RpbWVcbn07XG5cbi8qXG4gKiBBZGRzIGEgZHVtbXkgbm9kZSB0byB0aGUgZ3JhcGggYW5kIHJldHVybiB2LlxuICovXG5mdW5jdGlvbiBhZGREdW1teU5vZGUoZywgdHlwZSwgYXR0cnMsIG5hbWUpIHtcbiAgdmFyIHY7XG4gIGRvIHtcbiAgICB2ID0gXy51bmlxdWVJZChuYW1lKTtcbiAgfSB3aGlsZSAoZy5oYXNOb2RlKHYpKTtcblxuICBhdHRycy5kdW1teSA9IHR5cGU7XG4gIGcuc2V0Tm9kZSh2LCBhdHRycyk7XG4gIHJldHVybiB2O1xufVxuXG4vKlxuICogUmV0dXJucyBhIG5ldyBncmFwaCB3aXRoIG9ubHkgc2ltcGxlIGVkZ2VzLiBIYW5kbGVzIGFnZ3JlZ2F0aW9uIG9mIGRhdGFcbiAqIGFzc29jaWF0ZWQgd2l0aCBtdWx0aS1lZGdlcy5cbiAqL1xuZnVuY3Rpb24gc2ltcGxpZnkoZykge1xuICB2YXIgc2ltcGxpZmllZCA9IG5ldyBHcmFwaCgpLnNldEdyYXBoKGcuZ3JhcGgoKSk7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgc2ltcGxpZmllZC5zZXROb2RlKHYsIGcubm9kZSh2KSk7IH0pO1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHNpbXBsZUxhYmVsID0gc2ltcGxpZmllZC5lZGdlKGUudiwgZS53KSB8fCB7IHdlaWdodDogMCwgbWlubGVuOiAxIH07XG4gICAgdmFyIGxhYmVsID0gZy5lZGdlKGUpO1xuICAgIHNpbXBsaWZpZWQuc2V0RWRnZShlLnYsIGUudywge1xuICAgICAgd2VpZ2h0OiBzaW1wbGVMYWJlbC53ZWlnaHQgKyBsYWJlbC53ZWlnaHQsXG4gICAgICBtaW5sZW46IE1hdGgubWF4KHNpbXBsZUxhYmVsLm1pbmxlbiwgbGFiZWwubWlubGVuKVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIGFzTm9uQ29tcG91bmRHcmFwaChnKSB7XG4gIHZhciBzaW1wbGlmaWVkID0gbmV3IEdyYXBoKHsgbXVsdGlncmFwaDogZy5pc011bHRpZ3JhcGgoKSB9KS5zZXRHcmFwaChnLmdyYXBoKCkpO1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgaWYgKCFnLmNoaWxkcmVuKHYpLmxlbmd0aCkge1xuICAgICAgc2ltcGxpZmllZC5zZXROb2RlKHYsIGcubm9kZSh2KSk7XG4gICAgfVxuICB9KTtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHNpbXBsaWZpZWQuc2V0RWRnZShlLCBnLmVkZ2UoZSkpO1xuICB9KTtcbiAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59XG5cbmZ1bmN0aW9uIHN1Y2Nlc3NvcldlaWdodHMoZykge1xuICB2YXIgd2VpZ2h0TWFwID0gXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHN1Y3MgPSB7fTtcbiAgICBfLmZvckVhY2goZy5vdXRFZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgc3Vjc1tlLnddID0gKHN1Y3NbZS53XSB8fCAwKSArIGcuZWRnZShlKS53ZWlnaHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN1Y3M7XG4gIH0pO1xuICByZXR1cm4gXy56aXBPYmplY3QoZy5ub2RlcygpLCB3ZWlnaHRNYXApO1xufVxuXG5mdW5jdGlvbiBwcmVkZWNlc3NvcldlaWdodHMoZykge1xuICB2YXIgd2VpZ2h0TWFwID0gXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHByZWRzID0ge307XG4gICAgXy5mb3JFYWNoKGcuaW5FZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgcHJlZHNbZS52XSA9IChwcmVkc1tlLnZdIHx8IDApICsgZy5lZGdlKGUpLndlaWdodDtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJlZHM7XG4gIH0pO1xuICByZXR1cm4gXy56aXBPYmplY3QoZy5ub2RlcygpLCB3ZWlnaHRNYXApO1xufVxuXG4vKlxuICogRmluZHMgd2hlcmUgYSBsaW5lIHN0YXJ0aW5nIGF0IHBvaW50ICh7eCwgeX0pIHdvdWxkIGludGVyc2VjdCBhIHJlY3RhbmdsZVxuICogKHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSkgaWYgaXQgd2VyZSBwb2ludGluZyBhdCB0aGUgcmVjdGFuZ2xlJ3MgY2VudGVyLlxuICovXG5mdW5jdGlvbiBpbnRlcnNlY3RSZWN0KHJlY3QsIHBvaW50KSB7XG4gIHZhciB4ID0gcmVjdC54O1xuICB2YXIgeSA9IHJlY3QueTtcblxuICAvLyBSZWN0YW5nbGUgaW50ZXJzZWN0aW9uIGFsZ29yaXRobSBmcm9tOlxuICAvLyBodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTA4MTEzL2ZpbmQtZWRnZS1iZXR3ZWVuLXR3by1ib3hlc1xuICB2YXIgZHggPSBwb2ludC54IC0geDtcbiAgdmFyIGR5ID0gcG9pbnQueSAtIHk7XG4gIHZhciB3ID0gcmVjdC53aWR0aCAvIDI7XG4gIHZhciBoID0gcmVjdC5oZWlnaHQgLyAyO1xuXG4gIGlmICghZHggJiYgIWR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHBvc3NpYmxlIHRvIGZpbmQgaW50ZXJzZWN0aW9uIGluc2lkZSBvZiB0aGUgcmVjdGFuZ2xlXCIpO1xuICB9XG5cbiAgdmFyIHN4LCBzeTtcbiAgaWYgKE1hdGguYWJzKGR5KSAqIHcgPiBNYXRoLmFicyhkeCkgKiBoKSB7XG4gICAgLy8gSW50ZXJzZWN0aW9uIGlzIHRvcCBvciBib3R0b20gb2YgcmVjdC5cbiAgICBpZiAoZHkgPCAwKSB7XG4gICAgICBoID0gLWg7XG4gICAgfVxuICAgIHN4ID0gaCAqIGR4IC8gZHk7XG4gICAgc3kgPSBoO1xuICB9IGVsc2Uge1xuICAgIC8vIEludGVyc2VjdGlvbiBpcyBsZWZ0IG9yIHJpZ2h0IG9mIHJlY3QuXG4gICAgaWYgKGR4IDwgMCkge1xuICAgICAgdyA9IC13O1xuICAgIH1cbiAgICBzeCA9IHc7XG4gICAgc3kgPSB3ICogZHkgLyBkeDtcbiAgfVxuXG4gIHJldHVybiB7IHg6IHggKyBzeCwgeTogeSArIHN5IH07XG59XG5cbi8qXG4gKiBHaXZlbiBhIERBRyB3aXRoIGVhY2ggbm9kZSBhc3NpZ25lZCBcInJhbmtcIiBhbmQgXCJvcmRlclwiIHByb3BlcnRpZXMsIHRoaXNcbiAqIGZ1bmN0aW9uIHdpbGwgcHJvZHVjZSBhIG1hdHJpeCB3aXRoIHRoZSBpZHMgb2YgZWFjaCBub2RlLlxuICovXG5mdW5jdGlvbiBidWlsZExheWVyTWF0cml4KGcpIHtcbiAgdmFyIGxheWVyaW5nID0gXy5tYXAoXy5yYW5nZShtYXhSYW5rKGcpICsgMSksIGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0pO1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgdmFyIHJhbmsgPSBub2RlLnJhbms7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHJhbmspKSB7XG4gICAgICBsYXllcmluZ1tyYW5rXVtub2RlLm9yZGVyXSA9IHY7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGxheWVyaW5nO1xufVxuXG4vKlxuICogQWRqdXN0cyB0aGUgcmFua3MgZm9yIGFsbCBub2RlcyBpbiB0aGUgZ3JhcGggc3VjaCB0aGF0IGFsbCBub2RlcyB2IGhhdmVcbiAqIHJhbmsodikgPj0gMCBhbmQgYXQgbGVhc3Qgb25lIG5vZGUgdyBoYXMgcmFuayh3KSA9IDAuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhbmtzKGcpIHtcbiAgdmFyIG1pbiA9IF8ubWluKF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5ub2RlKHYpLnJhbms7IH0pKTtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIGlmIChfLmhhcyhub2RlLCBcInJhbmtcIikpIHtcbiAgICAgIG5vZGUucmFuayAtPSBtaW47XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRW1wdHlSYW5rcyhnKSB7XG4gIC8vIFJhbmtzIG1heSBub3Qgc3RhcnQgYXQgMCwgc28gd2UgbmVlZCB0byBvZmZzZXQgdGhlbVxuICB2YXIgb2Zmc2V0ID0gXy5taW4oXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHJldHVybiBnLm5vZGUodikucmFuazsgfSkpO1xuXG4gIHZhciBsYXllcnMgPSBbXTtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciByYW5rID0gZy5ub2RlKHYpLnJhbmsgLSBvZmZzZXQ7XG4gICAgaWYgKCFsYXllcnNbcmFua10pIHtcbiAgICAgIGxheWVyc1tyYW5rXSA9IFtdO1xuICAgIH1cbiAgICBsYXllcnNbcmFua10ucHVzaCh2KTtcbiAgfSk7XG5cbiAgdmFyIGRlbHRhID0gMDtcbiAgdmFyIG5vZGVSYW5rRmFjdG9yID0gZy5ncmFwaCgpLm5vZGVSYW5rRmFjdG9yO1xuICBfLmZvckVhY2gobGF5ZXJzLCBmdW5jdGlvbih2cywgaSkge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKHZzKSAmJiBpICUgbm9kZVJhbmtGYWN0b3IgIT09IDApIHtcbiAgICAgIC0tZGVsdGE7XG4gICAgfSBlbHNlIGlmIChkZWx0YSkge1xuICAgICAgXy5mb3JFYWNoKHZzLCBmdW5jdGlvbih2KSB7IGcubm9kZSh2KS5yYW5rICs9IGRlbHRhOyB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRCb3JkZXJOb2RlKGcsIHByZWZpeCwgcmFuaywgb3JkZXIpIHtcbiAgdmFyIG5vZGUgPSB7XG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIHtcbiAgICBub2RlLnJhbmsgPSByYW5rO1xuICAgIG5vZGUub3JkZXIgPSBvcmRlcjtcbiAgfVxuICByZXR1cm4gYWRkRHVtbXlOb2RlKGcsIFwiYm9yZGVyXCIsIG5vZGUsIHByZWZpeCk7XG59XG5cbmZ1bmN0aW9uIG1heFJhbmsoZykge1xuICByZXR1cm4gXy5tYXgoXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHJhbmsgPSBnLm5vZGUodikucmFuaztcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocmFuaykpIHtcbiAgICAgIHJldHVybiByYW5rO1xuICAgIH1cbiAgfSkpO1xufVxuXG4vKlxuICogUGFydGl0aW9uIGEgY29sbGVjdGlvbiBpbnRvIHR3byBncm91cHM6IGBsaHNgIGFuZCBgcmhzYC4gSWYgdGhlIHN1cHBsaWVkXG4gKiBmdW5jdGlvbiByZXR1cm5zIHRydWUgZm9yIGFuIGVudHJ5IGl0IGdvZXMgaW50byBgbGhzYC4gT3RoZXJ3aXNlIGl0IGdvZXNcbiAqIGludG8gYHJocy5cbiAqL1xuZnVuY3Rpb24gcGFydGl0aW9uKGNvbGxlY3Rpb24sIGZuKSB7XG4gIHZhciByZXN1bHQgPSB7IGxoczogW10sIHJoczogW10gfTtcbiAgXy5mb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKGZuKHZhbHVlKSkge1xuICAgICAgcmVzdWx0Lmxocy5wdXNoKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnJocy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKlxuICogUmV0dXJucyBhIG5ldyBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmbmAgd2l0aCBhIHRpbWVyLiBUaGUgd3JhcHBlciBsb2dzIHRoZVxuICogdGltZSBpdCB0YWtlcyB0byBleGVjdXRlIHRoZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdGltZShuYW1lLCBmbikge1xuICB2YXIgc3RhcnQgPSBfLm5vdygpO1xuICB0cnkge1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIGNvbnNvbGUubG9nKG5hbWUgKyBcIiB0aW1lOiBcIiArIChfLm5vdygpIC0gc3RhcnQpICsgXCJtc1wiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBub3RpbWUobmFtZSwgZm4pIHtcbiAgcmV0dXJuIGZuKCk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2RhZ3JlQDAuOC41QGRhZ3JlL2xpYi92ZXJzaW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZGFncmVAMC44LjVAZGFncmUvbGliL3ZlcnNpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gXCIwLjguNVwiO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgQ2hyaXMgUGV0dGl0dFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbiAqIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRVxuICogRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAqIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXG4gKiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUlxuICogQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSxcbiAqIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbnZhciBsaWIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvaW5kZXguanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHcmFwaDogbGliLkdyYXBoLFxuICBqc29uOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpYi9qc29uICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9qc29uLmpzXCIpLFxuICBhbGc6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGliL2FsZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL2luZGV4LmpzXCIpLFxuICB2ZXJzaW9uOiBsaWIudmVyc2lvblxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9jb21wb25lbnRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvY29tcG9uZW50cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9sb2Rhc2guanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcG9uZW50cztcblxuZnVuY3Rpb24gY29tcG9uZW50cyhnKSB7XG4gIHZhciB2aXNpdGVkID0ge307XG4gIHZhciBjbXB0cyA9IFtdO1xuICB2YXIgY21wdDtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIGlmIChfLmhhcyh2aXNpdGVkLCB2KSkgcmV0dXJuO1xuICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICAgIGNtcHQucHVzaCh2KTtcbiAgICBfLmVhY2goZy5zdWNjZXNzb3JzKHYpLCBkZnMpO1xuICAgIF8uZWFjaChnLnByZWRlY2Vzc29ycyh2KSwgZGZzKTtcbiAgfVxuXG4gIF8uZWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBjbXB0ID0gW107XG4gICAgZGZzKHYpO1xuICAgIGlmIChjbXB0Lmxlbmd0aCkge1xuICAgICAgY21wdHMucHVzaChjbXB0KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjbXB0cztcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9kZnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL2Rmcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2xvZGFzaC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZnM7XG5cbi8qXG4gKiBBIGhlbHBlciB0aGF0IHByZWZvcm1zIGEgcHJlLSBvciBwb3N0LW9yZGVyIHRyYXZlcnNhbCBvbiB0aGUgaW5wdXQgZ3JhcGhcbiAqIGFuZCByZXR1cm5zIHRoZSBub2RlcyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHZpc2l0ZWQuIElmIHRoZSBncmFwaCBpc1xuICogdW5kaXJlY3RlZCB0aGVuIHRoaXMgYWxnb3JpdGhtIHdpbGwgbmF2aWdhdGUgdXNpbmcgbmVpZ2hib3JzLiBJZiB0aGUgZ3JhcGhcbiAqIGlzIGRpcmVjdGVkIHRoZW4gdGhpcyBhbGdvcml0aG0gd2lsbCBuYXZpZ2F0ZSB1c2luZyBzdWNjZXNzb3JzLlxuICpcbiAqIE9yZGVyIG11c3QgYmUgb25lIG9mIFwicHJlXCIgb3IgXCJwb3N0XCIuXG4gKi9cbmZ1bmN0aW9uIGRmcyhnLCB2cywgb3JkZXIpIHtcbiAgaWYgKCFfLmlzQXJyYXkodnMpKSB7XG4gICAgdnMgPSBbdnNdO1xuICB9XG5cbiAgdmFyIG5hdmlnYXRpb24gPSAoZy5pc0RpcmVjdGVkKCkgPyBnLnN1Y2Nlc3NvcnMgOiBnLm5laWdoYm9ycykuYmluZChnKTtcblxuICB2YXIgYWNjID0gW107XG4gIHZhciB2aXNpdGVkID0ge307XG4gIF8uZWFjaCh2cywgZnVuY3Rpb24odikge1xuICAgIGlmICghZy5oYXNOb2RlKHYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHcmFwaCBkb2VzIG5vdCBoYXZlIG5vZGU6IFwiICsgdik7XG4gICAgfVxuXG4gICAgZG9EZnMoZywgdiwgb3JkZXIgPT09IFwicG9zdFwiLCB2aXNpdGVkLCBuYXZpZ2F0aW9uLCBhY2MpO1xuICB9KTtcbiAgcmV0dXJuIGFjYztcbn1cblxuZnVuY3Rpb24gZG9EZnMoZywgdiwgcG9zdG9yZGVyLCB2aXNpdGVkLCBuYXZpZ2F0aW9uLCBhY2MpIHtcbiAgaWYgKCFfLmhhcyh2aXNpdGVkLCB2KSkge1xuICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuXG4gICAgaWYgKCFwb3N0b3JkZXIpIHsgYWNjLnB1c2godik7IH1cbiAgICBfLmVhY2gobmF2aWdhdGlvbih2KSwgZnVuY3Rpb24odykge1xuICAgICAgZG9EZnMoZywgdywgcG9zdG9yZGVyLCB2aXNpdGVkLCBuYXZpZ2F0aW9uLCBhY2MpO1xuICAgIH0pO1xuICAgIGlmIChwb3N0b3JkZXIpIHsgYWNjLnB1c2godik7IH1cbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL2RpamtzdHJhLWFsbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvZGlqa3N0cmEtYWxsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZGlqa3N0cmEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RpamtzdHJhICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvZGlqa3N0cmEuanNcIik7XG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvbG9kYXNoLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpamtzdHJhQWxsO1xuXG5mdW5jdGlvbiBkaWprc3RyYUFsbChnLCB3ZWlnaHRGdW5jLCBlZGdlRnVuYykge1xuICByZXR1cm4gXy50cmFuc2Zvcm0oZy5ub2RlcygpLCBmdW5jdGlvbihhY2MsIHYpIHtcbiAgICBhY2Nbdl0gPSBkaWprc3RyYShnLCB2LCB3ZWlnaHRGdW5jLCBlZGdlRnVuYyk7XG4gIH0sIHt9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9kaWprc3RyYS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9kaWprc3RyYS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvbG9kYXNoLmpzXCIpO1xudmFyIFByaW9yaXR5UXVldWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhL3ByaW9yaXR5LXF1ZXVlICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9kYXRhL3ByaW9yaXR5LXF1ZXVlLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpamtzdHJhO1xuXG52YXIgREVGQVVMVF9XRUlHSFRfRlVOQyA9IF8uY29uc3RhbnQoMSk7XG5cbmZ1bmN0aW9uIGRpamtzdHJhKGcsIHNvdXJjZSwgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICByZXR1cm4gcnVuRGlqa3N0cmEoZywgU3RyaW5nKHNvdXJjZSksXG4gICAgd2VpZ2h0Rm4gfHwgREVGQVVMVF9XRUlHSFRfRlVOQyxcbiAgICBlZGdlRm4gfHwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5vdXRFZGdlcyh2KTsgfSk7XG59XG5cbmZ1bmN0aW9uIHJ1bkRpamtzdHJhKGcsIHNvdXJjZSwgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICB2YXIgcmVzdWx0cyA9IHt9O1xuICB2YXIgcHEgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xuICB2YXIgdiwgdkVudHJ5O1xuXG4gIHZhciB1cGRhdGVOZWlnaGJvcnMgPSBmdW5jdGlvbihlZGdlKSB7XG4gICAgdmFyIHcgPSBlZGdlLnYgIT09IHYgPyBlZGdlLnYgOiBlZGdlLnc7XG4gICAgdmFyIHdFbnRyeSA9IHJlc3VsdHNbd107XG4gICAgdmFyIHdlaWdodCA9IHdlaWdodEZuKGVkZ2UpO1xuICAgIHZhciBkaXN0YW5jZSA9IHZFbnRyeS5kaXN0YW5jZSArIHdlaWdodDtcblxuICAgIGlmICh3ZWlnaHQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaWprc3RyYSBkb2VzIG5vdCBhbGxvdyBuZWdhdGl2ZSBlZGdlIHdlaWdodHMuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBcIkJhZCBlZGdlOiBcIiArIGVkZ2UgKyBcIiBXZWlnaHQ6IFwiICsgd2VpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAoZGlzdGFuY2UgPCB3RW50cnkuZGlzdGFuY2UpIHtcbiAgICAgIHdFbnRyeS5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgd0VudHJ5LnByZWRlY2Vzc29yID0gdjtcbiAgICAgIHBxLmRlY3JlYXNlKHcsIGRpc3RhbmNlKTtcbiAgICB9XG4gIH07XG5cbiAgZy5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgIHZhciBkaXN0YW5jZSA9IHYgPT09IHNvdXJjZSA/IDAgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgcmVzdWx0c1t2XSA9IHsgZGlzdGFuY2U6IGRpc3RhbmNlIH07XG4gICAgcHEuYWRkKHYsIGRpc3RhbmNlKTtcbiAgfSk7XG5cbiAgd2hpbGUgKHBxLnNpemUoKSA+IDApIHtcbiAgICB2ID0gcHEucmVtb3ZlTWluKCk7XG4gICAgdkVudHJ5ID0gcmVzdWx0c1t2XTtcbiAgICBpZiAodkVudHJ5LmRpc3RhbmNlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGVkZ2VGbih2KS5mb3JFYWNoKHVwZGF0ZU5laWdoYm9ycyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9maW5kLWN5Y2xlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9maW5kLWN5Y2xlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvbG9kYXNoLmpzXCIpO1xudmFyIHRhcmphbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGFyamFuICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvdGFyamFuLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRDeWNsZXM7XG5cbmZ1bmN0aW9uIGZpbmRDeWNsZXMoZykge1xuICByZXR1cm4gXy5maWx0ZXIodGFyamFuKGcpLCBmdW5jdGlvbihjbXB0KSB7XG4gICAgcmV0dXJuIGNtcHQubGVuZ3RoID4gMSB8fCAoY21wdC5sZW5ndGggPT09IDEgJiYgZy5oYXNFZGdlKGNtcHRbMF0sIGNtcHRbMF0pKTtcbiAgfSk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvZmxveWQtd2Fyc2hhbGwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvZmxveWQtd2Fyc2hhbGwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2xvZGFzaC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmbG95ZFdhcnNoYWxsO1xuXG52YXIgREVGQVVMVF9XRUlHSFRfRlVOQyA9IF8uY29uc3RhbnQoMSk7XG5cbmZ1bmN0aW9uIGZsb3lkV2Fyc2hhbGwoZywgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICByZXR1cm4gcnVuRmxveWRXYXJzaGFsbChnLFxuICAgIHdlaWdodEZuIHx8IERFRkFVTFRfV0VJR0hUX0ZVTkMsXG4gICAgZWRnZUZuIHx8IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcub3V0RWRnZXModik7IH0pO1xufVxuXG5mdW5jdGlvbiBydW5GbG95ZFdhcnNoYWxsKGcsIHdlaWdodEZuLCBlZGdlRm4pIHtcbiAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgdmFyIG5vZGVzID0gZy5ub2RlcygpO1xuXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgIHJlc3VsdHNbdl0gPSB7fTtcbiAgICByZXN1bHRzW3ZdW3ZdID0geyBkaXN0YW5jZTogMCB9O1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24odykge1xuICAgICAgaWYgKHYgIT09IHcpIHtcbiAgICAgICAgcmVzdWx0c1t2XVt3XSA9IHsgZGlzdGFuY2U6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVkZ2VGbih2KS5mb3JFYWNoKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHZhciB3ID0gZWRnZS52ID09PSB2ID8gZWRnZS53IDogZWRnZS52O1xuICAgICAgdmFyIGQgPSB3ZWlnaHRGbihlZGdlKTtcbiAgICAgIHJlc3VsdHNbdl1bd10gPSB7IGRpc3RhbmNlOiBkLCBwcmVkZWNlc3NvcjogdiB9O1xuICAgIH0pO1xuICB9KTtcblxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICB2YXIgcm93SyA9IHJlc3VsdHNba107XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgcm93SSA9IHJlc3VsdHNbaV07XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGopIHtcbiAgICAgICAgdmFyIGlrID0gcm93SVtrXTtcbiAgICAgICAgdmFyIGtqID0gcm93S1tqXTtcbiAgICAgICAgdmFyIGlqID0gcm93SVtqXTtcbiAgICAgICAgdmFyIGFsdERpc3RhbmNlID0gaWsuZGlzdGFuY2UgKyBrai5kaXN0YW5jZTtcbiAgICAgICAgaWYgKGFsdERpc3RhbmNlIDwgaWouZGlzdGFuY2UpIHtcbiAgICAgICAgICBpai5kaXN0YW5jZSA9IGFsdERpc3RhbmNlO1xuICAgICAgICAgIGlqLnByZWRlY2Vzc29yID0ga2oucHJlZGVjZXNzb3I7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tcG9uZW50czogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb21wb25lbnRzICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvY29tcG9uZW50cy5qc1wiKSxcbiAgZGlqa3N0cmE6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGlqa3N0cmEgKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9kaWprc3RyYS5qc1wiKSxcbiAgZGlqa3N0cmFBbGw6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGlqa3N0cmEtYWxsICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvZGlqa3N0cmEtYWxsLmpzXCIpLFxuICBmaW5kQ3ljbGVzOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2ZpbmQtY3ljbGVzICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvZmluZC1jeWNsZXMuanNcIiksXG4gIGZsb3lkV2Fyc2hhbGw6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmxveWQtd2Fyc2hhbGwgKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9mbG95ZC13YXJzaGFsbC5qc1wiKSxcbiAgaXNBY3ljbGljOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzLWFjeWNsaWMgKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9pcy1hY3ljbGljLmpzXCIpLFxuICBwb3N0b3JkZXI6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcG9zdG9yZGVyICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvcG9zdG9yZGVyLmpzXCIpLFxuICBwcmVvcmRlcjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wcmVvcmRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL3ByZW9yZGVyLmpzXCIpLFxuICBwcmltOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ByaW0gKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9wcmltLmpzXCIpLFxuICB0YXJqYW46IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGFyamFuICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvdGFyamFuLmpzXCIpLFxuICB0b3Bzb3J0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvcHNvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy90b3Bzb3J0LmpzXCIpXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL2lzLWFjeWNsaWMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9pcy1hY3ljbGljLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvcHNvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvcHNvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy90b3Bzb3J0LmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQWN5Y2xpYztcblxuZnVuY3Rpb24gaXNBY3ljbGljKGcpIHtcbiAgdHJ5IHtcbiAgICB0b3Bzb3J0KGcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiB0b3Bzb3J0LkN5Y2xlRXhjZXB0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvcG9zdG9yZGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9wb3N0b3JkZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkZnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RmcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL2Rmcy5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb3N0b3JkZXI7XG5cbmZ1bmN0aW9uIHBvc3RvcmRlcihnLCB2cykge1xuICByZXR1cm4gZGZzKGcsIHZzLCBcInBvc3RcIik7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvcHJlb3JkZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvcHJlb3JkZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRmcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZGZzICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvZGZzLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByZW9yZGVyO1xuXG5mdW5jdGlvbiBwcmVvcmRlcihnLCB2cykge1xuICByZXR1cm4gZGZzKGcsIHZzLCBcInByZVwiKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy9wcmltLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvcHJpbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9sb2Rhc2guanNcIik7XG52YXIgR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9ncmFwaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvZ3JhcGguanNcIik7XG52YXIgUHJpb3JpdHlRdWV1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEvcHJpb3JpdHktcXVldWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2RhdGEvcHJpb3JpdHktcXVldWUuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcHJpbTtcblxuZnVuY3Rpb24gcHJpbShnLCB3ZWlnaHRGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgR3JhcGgoKTtcbiAgdmFyIHBhcmVudHMgPSB7fTtcbiAgdmFyIHBxID0gbmV3IFByaW9yaXR5UXVldWUoKTtcbiAgdmFyIHY7XG5cbiAgZnVuY3Rpb24gdXBkYXRlTmVpZ2hib3JzKGVkZ2UpIHtcbiAgICB2YXIgdyA9IGVkZ2UudiA9PT0gdiA/IGVkZ2UudyA6IGVkZ2UudjtcbiAgICB2YXIgcHJpID0gcHEucHJpb3JpdHkodyk7XG4gICAgaWYgKHByaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZWRnZVdlaWdodCA9IHdlaWdodEZ1bmMoZWRnZSk7XG4gICAgICBpZiAoZWRnZVdlaWdodCA8IHByaSkge1xuICAgICAgICBwYXJlbnRzW3ddID0gdjtcbiAgICAgICAgcHEuZGVjcmVhc2UodywgZWRnZVdlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGcubm9kZUNvdW50KCkgPT09IDApIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgXy5lYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHBxLmFkZCh2LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIHJlc3VsdC5zZXROb2RlKHYpO1xuICB9KTtcblxuICAvLyBTdGFydCBmcm9tIGFuIGFyYml0cmFyeSBub2RlXG4gIHBxLmRlY3JlYXNlKGcubm9kZXMoKVswXSwgMCk7XG5cbiAgdmFyIGluaXQgPSBmYWxzZTtcbiAgd2hpbGUgKHBxLnNpemUoKSA+IDApIHtcbiAgICB2ID0gcHEucmVtb3ZlTWluKCk7XG4gICAgaWYgKF8uaGFzKHBhcmVudHMsIHYpKSB7XG4gICAgICByZXN1bHQuc2V0RWRnZSh2LCBwYXJlbnRzW3ZdKTtcbiAgICB9IGVsc2UgaWYgKGluaXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGdyYXBoIGlzIG5vdCBjb25uZWN0ZWQ6IFwiICsgZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXQgPSB0cnVlO1xuICAgIH1cblxuICAgIGcubm9kZUVkZ2VzKHYpLmZvckVhY2godXBkYXRlTmVpZ2hib3JzKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvdGFyamFuLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2FsZy90YXJqYW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbG9kYXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9sb2Rhc2guanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gdGFyamFuO1xuXG5mdW5jdGlvbiB0YXJqYW4oZykge1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHZpc2l0ZWQgPSB7fTsgLy8gbm9kZSBpZCAtPiB7IG9uU3RhY2ssIGxvd2xpbmssIGluZGV4IH1cbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIHZhciBlbnRyeSA9IHZpc2l0ZWRbdl0gPSB7XG4gICAgICBvblN0YWNrOiB0cnVlLFxuICAgICAgbG93bGluazogaW5kZXgsXG4gICAgICBpbmRleDogaW5kZXgrK1xuICAgIH07XG4gICAgc3RhY2sucHVzaCh2KTtcblxuICAgIGcuc3VjY2Vzc29ycyh2KS5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcbiAgICAgIGlmICghXy5oYXModmlzaXRlZCwgdykpIHtcbiAgICAgICAgZGZzKHcpO1xuICAgICAgICBlbnRyeS5sb3dsaW5rID0gTWF0aC5taW4oZW50cnkubG93bGluaywgdmlzaXRlZFt3XS5sb3dsaW5rKTtcbiAgICAgIH0gZWxzZSBpZiAodmlzaXRlZFt3XS5vblN0YWNrKSB7XG4gICAgICAgIGVudHJ5Lmxvd2xpbmsgPSBNYXRoLm1pbihlbnRyeS5sb3dsaW5rLCB2aXNpdGVkW3ddLmluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChlbnRyeS5sb3dsaW5rID09PSBlbnRyeS5pbmRleCkge1xuICAgICAgdmFyIGNtcHQgPSBbXTtcbiAgICAgIHZhciB3O1xuICAgICAgZG8ge1xuICAgICAgICB3ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZpc2l0ZWRbd10ub25TdGFjayA9IGZhbHNlO1xuICAgICAgICBjbXB0LnB1c2godyk7XG4gICAgICB9IHdoaWxlICh2ICE9PSB3KTtcbiAgICAgIHJlc3VsdHMucHVzaChjbXB0KTtcbiAgICB9XG4gIH1cblxuICBnLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgaWYgKCFfLmhhcyh2aXNpdGVkLCB2KSkge1xuICAgICAgZGZzKHYpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9hbGcvdG9wc29ydC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvYWxnL3RvcHNvcnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvbG9kYXNoLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRvcHNvcnQ7XG50b3Bzb3J0LkN5Y2xlRXhjZXB0aW9uID0gQ3ljbGVFeGNlcHRpb247XG5cbmZ1bmN0aW9uIHRvcHNvcnQoZykge1xuICB2YXIgdmlzaXRlZCA9IHt9O1xuICB2YXIgc3RhY2sgPSB7fTtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBmdW5jdGlvbiB2aXNpdChub2RlKSB7XG4gICAgaWYgKF8uaGFzKHN0YWNrLCBub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEN5Y2xlRXhjZXB0aW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKCFfLmhhcyh2aXNpdGVkLCBub2RlKSkge1xuICAgICAgc3RhY2tbbm9kZV0gPSB0cnVlO1xuICAgICAgdmlzaXRlZFtub2RlXSA9IHRydWU7XG4gICAgICBfLmVhY2goZy5wcmVkZWNlc3NvcnMobm9kZSksIHZpc2l0KTtcbiAgICAgIGRlbGV0ZSBzdGFja1tub2RlXTtcbiAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICBfLmVhY2goZy5zaW5rcygpLCB2aXNpdCk7XG5cbiAgaWYgKF8uc2l6ZSh2aXNpdGVkKSAhPT0gZy5ub2RlQ291bnQoKSkge1xuICAgIHRocm93IG5ldyBDeWNsZUV4Y2VwdGlvbigpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIEN5Y2xlRXhjZXB0aW9uKCkge31cbkN5Y2xlRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpOyAvLyBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEVycm9yIHRvIHBhc3MgdGVzdGluZ1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2RhdGEvcHJpb3JpdHktcXVldWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvZGF0YS9wcmlvcml0eS1xdWV1ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2xvZGFzaC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcmlvcml0eVF1ZXVlO1xuXG4vKipcbiAqIEEgbWluLXByaW9yaXR5IHF1ZXVlIGRhdGEgc3RydWN0dXJlLiBUaGlzIGFsZ29yaXRobSBpcyBkZXJpdmVkIGZyb20gQ29ybWVuLFxuICogZXQgYWwuLCBcIkludHJvZHVjdGlvbiB0byBBbGdvcml0aG1zXCIuIFRoZSBiYXNpYyBpZGVhIG9mIGEgbWluLXByaW9yaXR5XG4gKiBxdWV1ZSBpcyB0aGF0IHlvdSBjYW4gZWZmaWNpZW50bHkgKGluIE8oMSkgdGltZSkgZ2V0IHRoZSBzbWFsbGVzdCBrZXkgaW5cbiAqIHRoZSBxdWV1ZS4gQWRkaW5nIGFuZCByZW1vdmluZyBlbGVtZW50cyB0YWtlcyBPKGxvZyBuKSB0aW1lLiBBIGtleSBjYW5cbiAqIGhhdmUgaXRzIHByaW9yaXR5IGRlY3JlYXNlZCBpbiBPKGxvZyBuKSB0aW1lLlxuICovXG5mdW5jdGlvbiBQcmlvcml0eVF1ZXVlKCkge1xuICB0aGlzLl9hcnIgPSBbXTtcbiAgdGhpcy5fa2V5SW5kaWNlcyA9IHt9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgcXVldWUuIFRha2VzIGBPKDEpYCB0aW1lLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hcnIubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZXlzIHRoYXQgYXJlIGluIHRoZSBxdWV1ZS4gVGFrZXMgYE8obilgIHRpbWUuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Fyci5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4geC5rZXk7IH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiAqKmtleSoqIGlzIGluIHRoZSBxdWV1ZSBhbmQgYGZhbHNlYCBpZiBub3QuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGtleSkge1xuICByZXR1cm4gXy5oYXModGhpcy5fa2V5SW5kaWNlcywga2V5KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJpb3JpdHkgZm9yICoqa2V5KiouIElmICoqa2V5KiogaXMgbm90IHByZXNlbnQgaW4gdGhlIHF1ZXVlXG4gKiB0aGVuIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYC4gVGFrZXMgYE8oMSlgIHRpbWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGtleVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5wcmlvcml0eSA9IGZ1bmN0aW9uKGtleSkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9rZXlJbmRpY2VzW2tleV07XG4gIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycltpbmRleF0ucHJpb3JpdHk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUga2V5IGZvciB0aGUgbWluaW11bSBlbGVtZW50IGluIHRoaXMgcXVldWUuIElmIHRoZSBxdWV1ZSBpc1xuICogZW1wdHkgdGhpcyBmdW5jdGlvbiB0aHJvd3MgYW4gRXJyb3IuIFRha2VzIGBPKDEpYCB0aW1lLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc2l6ZSgpID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUXVldWUgdW5kZXJmbG93XCIpO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJbMF0ua2V5O1xufTtcblxuLyoqXG4gKiBJbnNlcnRzIGEgbmV3IGtleSBpbnRvIHRoZSBwcmlvcml0eSBxdWV1ZS4gSWYgdGhlIGtleSBhbHJlYWR5IGV4aXN0cyBpblxuICogdGhlIHF1ZXVlIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgOyBvdGhlcndpc2UgaXQgd2lsbCByZXR1cm4gYHRydWVgLlxuICogVGFrZXMgYE8obilgIHRpbWUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGtleSB0aGUga2V5IHRvIGFkZFxuICogQHBhcmFtIHtOdW1iZXJ9IHByaW9yaXR5IHRoZSBpbml0aWFsIHByaW9yaXR5IGZvciB0aGUga2V5XG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGtleSwgcHJpb3JpdHkpIHtcbiAgdmFyIGtleUluZGljZXMgPSB0aGlzLl9rZXlJbmRpY2VzO1xuICBrZXkgPSBTdHJpbmcoa2V5KTtcbiAgaWYgKCFfLmhhcyhrZXlJbmRpY2VzLCBrZXkpKSB7XG4gICAgdmFyIGFyciA9IHRoaXMuX2FycjtcbiAgICB2YXIgaW5kZXggPSBhcnIubGVuZ3RoO1xuICAgIGtleUluZGljZXNba2V5XSA9IGluZGV4O1xuICAgIGFyci5wdXNoKHtrZXk6IGtleSwgcHJpb3JpdHk6IHByaW9yaXR5fSk7XG4gICAgdGhpcy5fZGVjcmVhc2UoaW5kZXgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbmQgcmV0dXJucyB0aGUgc21hbGxlc3Qga2V5IGluIHRoZSBxdWV1ZS4gVGFrZXMgYE8obG9nIG4pYCB0aW1lLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5yZW1vdmVNaW4gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3dhcCgwLCB0aGlzLl9hcnIubGVuZ3RoIC0gMSk7XG4gIHZhciBtaW4gPSB0aGlzLl9hcnIucG9wKCk7XG4gIGRlbGV0ZSB0aGlzLl9rZXlJbmRpY2VzW21pbi5rZXldO1xuICB0aGlzLl9oZWFwaWZ5KDApO1xuICByZXR1cm4gbWluLmtleTtcbn07XG5cbi8qKlxuICogRGVjcmVhc2VzIHRoZSBwcmlvcml0eSBmb3IgKiprZXkqKiB0byAqKnByaW9yaXR5KiouIElmIHRoZSBuZXcgcHJpb3JpdHkgaXNcbiAqIGdyZWF0ZXIgdGhhbiB0aGUgcHJldmlvdXMgcHJpb3JpdHksIHRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBFcnJvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0ga2V5IHRoZSBrZXkgZm9yIHdoaWNoIHRvIHJhaXNlIHByaW9yaXR5XG4gKiBAcGFyYW0ge051bWJlcn0gcHJpb3JpdHkgdGhlIG5ldyBwcmlvcml0eSBmb3IgdGhlIGtleVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5kZWNyZWFzZSA9IGZ1bmN0aW9uKGtleSwgcHJpb3JpdHkpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fa2V5SW5kaWNlc1trZXldO1xuICBpZiAocHJpb3JpdHkgPiB0aGlzLl9hcnJbaW5kZXhdLnByaW9yaXR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTmV3IHByaW9yaXR5IGlzIGdyZWF0ZXIgdGhhbiBjdXJyZW50IHByaW9yaXR5LiBcIiArXG4gICAgICAgIFwiS2V5OiBcIiArIGtleSArIFwiIE9sZDogXCIgKyB0aGlzLl9hcnJbaW5kZXhdLnByaW9yaXR5ICsgXCIgTmV3OiBcIiArIHByaW9yaXR5KTtcbiAgfVxuICB0aGlzLl9hcnJbaW5kZXhdLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gIHRoaXMuX2RlY3JlYXNlKGluZGV4KTtcbn07XG5cblByaW9yaXR5UXVldWUucHJvdG90eXBlLl9oZWFwaWZ5ID0gZnVuY3Rpb24oaSkge1xuICB2YXIgYXJyID0gdGhpcy5fYXJyO1xuICB2YXIgbCA9IDIgKiBpO1xuICB2YXIgciA9IGwgKyAxO1xuICB2YXIgbGFyZ2VzdCA9IGk7XG4gIGlmIChsIDwgYXJyLmxlbmd0aCkge1xuICAgIGxhcmdlc3QgPSBhcnJbbF0ucHJpb3JpdHkgPCBhcnJbbGFyZ2VzdF0ucHJpb3JpdHkgPyBsIDogbGFyZ2VzdDtcbiAgICBpZiAociA8IGFyci5sZW5ndGgpIHtcbiAgICAgIGxhcmdlc3QgPSBhcnJbcl0ucHJpb3JpdHkgPCBhcnJbbGFyZ2VzdF0ucHJpb3JpdHkgPyByIDogbGFyZ2VzdDtcbiAgICB9XG4gICAgaWYgKGxhcmdlc3QgIT09IGkpIHtcbiAgICAgIHRoaXMuX3N3YXAoaSwgbGFyZ2VzdCk7XG4gICAgICB0aGlzLl9oZWFwaWZ5KGxhcmdlc3QpO1xuICAgIH1cbiAgfVxufTtcblxuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuX2RlY3JlYXNlID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgdmFyIGFyciA9IHRoaXMuX2FycjtcbiAgdmFyIHByaW9yaXR5ID0gYXJyW2luZGV4XS5wcmlvcml0eTtcbiAgdmFyIHBhcmVudDtcbiAgd2hpbGUgKGluZGV4ICE9PSAwKSB7XG4gICAgcGFyZW50ID0gaW5kZXggPj4gMTtcbiAgICBpZiAoYXJyW3BhcmVudF0ucHJpb3JpdHkgPCBwcmlvcml0eSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3N3YXAoaW5kZXgsIHBhcmVudCk7XG4gICAgaW5kZXggPSBwYXJlbnQ7XG4gIH1cbn07XG5cblByaW9yaXR5UXVldWUucHJvdG90eXBlLl9zd2FwID0gZnVuY3Rpb24oaSwgaikge1xuICB2YXIgYXJyID0gdGhpcy5fYXJyO1xuICB2YXIga2V5SW5kaWNlcyA9IHRoaXMuX2tleUluZGljZXM7XG4gIHZhciBvcmlnQXJySSA9IGFycltpXTtcbiAgdmFyIG9yaWdBcnJKID0gYXJyW2pdO1xuICBhcnJbaV0gPSBvcmlnQXJySjtcbiAgYXJyW2pdID0gb3JpZ0Fyckk7XG4gIGtleUluZGljZXNbb3JpZ0Fyckoua2V5XSA9IGk7XG4gIGtleUluZGljZXNbb3JpZ0Fyckkua2V5XSA9IGo7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvZ3JhcGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2dyYXBoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvZGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19ncmFwaGxpYkAyLjEuOEBncmFwaGxpYi9saWIvbG9kYXNoLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoO1xuXG52YXIgREVGQVVMVF9FREdFX05BTUUgPSBcIlxceDAwXCI7XG52YXIgR1JBUEhfTk9ERSA9IFwiXFx4MDBcIjtcbnZhciBFREdFX0tFWV9ERUxJTSA9IFwiXFx4MDFcIjtcblxuLy8gSW1wbGVtZW50YXRpb24gbm90ZXM6XG4vL1xuLy8gICogTm9kZSBpZCBxdWVyeSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBzdHJpbmcgaWRzIGZvciB0aGUgbm9kZXNcbi8vICAqIEVkZ2UgaWQgcXVlcnkgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gXCJlZGdlT2JqXCIsIGVkZ2Ugb2JqZWN0LCB0aGF0IGlzXG4vLyAgICBjb21wb3NlZCBvZiBlbm91Z2ggaW5mb3JtYXRpb24gdG8gdW5pcXVlbHkgaWRlbnRpZnkgYW4gZWRnZToge3YsIHcsIG5hbWV9LlxuLy8gICogSW50ZXJuYWxseSB3ZSB1c2UgYW4gXCJlZGdlSWRcIiwgYSBzdHJpbmdpZmllZCBmb3JtIG9mIHRoZSBlZGdlT2JqLCB0b1xuLy8gICAgcmVmZXJlbmNlIGVkZ2VzLiBUaGlzIGlzIGJlY2F1c2Ugd2UgbmVlZCBhIHBlcmZvcm1hbnQgd2F5IHRvIGxvb2sgdGhlc2Vcbi8vICAgIGVkZ2VzIHVwIGFuZCwgb2JqZWN0IHByb3BlcnRpZXMsIHdoaWNoIGhhdmUgc3RyaW5nIGtleXMsIGFyZSB0aGUgY2xvc2VzdFxuLy8gICAgd2UncmUgZ29pbmcgdG8gZ2V0IHRvIGEgcGVyZm9ybWFudCBoYXNodGFibGUgaW4gSmF2YVNjcmlwdC5cblxuZnVuY3Rpb24gR3JhcGgob3B0cykge1xuICB0aGlzLl9pc0RpcmVjdGVkID0gXy5oYXMob3B0cywgXCJkaXJlY3RlZFwiKSA/IG9wdHMuZGlyZWN0ZWQgOiB0cnVlO1xuICB0aGlzLl9pc011bHRpZ3JhcGggPSBfLmhhcyhvcHRzLCBcIm11bHRpZ3JhcGhcIikgPyBvcHRzLm11bHRpZ3JhcGggOiBmYWxzZTtcbiAgdGhpcy5faXNDb21wb3VuZCA9IF8uaGFzKG9wdHMsIFwiY29tcG91bmRcIikgPyBvcHRzLmNvbXBvdW5kIDogZmFsc2U7XG5cbiAgLy8gTGFiZWwgZm9yIHRoZSBncmFwaCBpdHNlbGZcbiAgdGhpcy5fbGFiZWwgPSB1bmRlZmluZWQ7XG5cbiAgLy8gRGVmYXVsdHMgdG8gYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgbm9kZVxuICB0aGlzLl9kZWZhdWx0Tm9kZUxhYmVsRm4gPSBfLmNvbnN0YW50KHVuZGVmaW5lZCk7XG5cbiAgLy8gRGVmYXVsdHMgdG8gYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgZWRnZVxuICB0aGlzLl9kZWZhdWx0RWRnZUxhYmVsRm4gPSBfLmNvbnN0YW50KHVuZGVmaW5lZCk7XG5cbiAgLy8gdiAtPiBsYWJlbFxuICB0aGlzLl9ub2RlcyA9IHt9O1xuXG4gIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgLy8gdiAtPiBwYXJlbnRcbiAgICB0aGlzLl9wYXJlbnQgPSB7fTtcblxuICAgIC8vIHYgLT4gY2hpbGRyZW5cbiAgICB0aGlzLl9jaGlsZHJlbiA9IHt9O1xuICAgIHRoaXMuX2NoaWxkcmVuW0dSQVBIX05PREVdID0ge307XG4gIH1cblxuICAvLyB2IC0+IGVkZ2VPYmpcbiAgdGhpcy5faW4gPSB7fTtcblxuICAvLyB1IC0+IHYgLT4gTnVtYmVyXG4gIHRoaXMuX3ByZWRzID0ge307XG5cbiAgLy8gdiAtPiBlZGdlT2JqXG4gIHRoaXMuX291dCA9IHt9O1xuXG4gIC8vIHYgLT4gdyAtPiBOdW1iZXJcbiAgdGhpcy5fc3VjcyA9IHt9O1xuXG4gIC8vIGUgLT4gZWRnZU9ialxuICB0aGlzLl9lZGdlT2JqcyA9IHt9O1xuXG4gIC8vIGUgLT4gbGFiZWxcbiAgdGhpcy5fZWRnZUxhYmVscyA9IHt9O1xufVxuXG4vKiBOdW1iZXIgb2Ygbm9kZXMgaW4gdGhlIGdyYXBoLiBTaG91bGQgb25seSBiZSBjaGFuZ2VkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbi4gKi9cbkdyYXBoLnByb3RvdHlwZS5fbm9kZUNvdW50ID0gMDtcblxuLyogTnVtYmVyIG9mIGVkZ2VzIGluIHRoZSBncmFwaC4gU2hvdWxkIG9ubHkgYmUgY2hhbmdlZCBieSB0aGUgaW1wbGVtZW50YXRpb24uICovXG5HcmFwaC5wcm90b3R5cGUuX2VkZ2VDb3VudCA9IDA7XG5cblxuLyogPT09IEdyYXBoIGZ1bmN0aW9ucyA9PT09PT09PT0gKi9cblxuR3JhcGgucHJvdG90eXBlLmlzRGlyZWN0ZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2lzRGlyZWN0ZWQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaXNNdWx0aWdyYXBoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pc011bHRpZ3JhcGg7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaXNDb21wb3VuZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXNDb21wb3VuZDtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXRHcmFwaCA9IGZ1bmN0aW9uKGxhYmVsKSB7XG4gIHRoaXMuX2xhYmVsID0gbGFiZWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmdyYXBoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9sYWJlbDtcbn07XG5cblxuLyogPT09IE5vZGUgZnVuY3Rpb25zID09PT09PT09PT0gKi9cblxuR3JhcGgucHJvdG90eXBlLnNldERlZmF1bHROb2RlTGFiZWwgPSBmdW5jdGlvbihuZXdEZWZhdWx0KSB7XG4gIGlmICghXy5pc0Z1bmN0aW9uKG5ld0RlZmF1bHQpKSB7XG4gICAgbmV3RGVmYXVsdCA9IF8uY29uc3RhbnQobmV3RGVmYXVsdCk7XG4gIH1cbiAgdGhpcy5fZGVmYXVsdE5vZGVMYWJlbEZuID0gbmV3RGVmYXVsdDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubm9kZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9ub2RlQ291bnQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubm9kZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF8ua2V5cyh0aGlzLl9ub2Rlcyk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc291cmNlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBfLmZpbHRlcih0aGlzLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gXy5pc0VtcHR5KHNlbGYuX2luW3ZdKTtcbiAgfSk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2lua3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gXy5maWx0ZXIodGhpcy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIF8uaXNFbXB0eShzZWxmLl9vdXRbdl0pO1xuICB9KTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXROb2RlcyA9IGZ1bmN0aW9uKHZzLCB2YWx1ZSkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBfLmVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICBzZWxmLnNldE5vZGUodiwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnNldE5vZGUodik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0Tm9kZSA9IGZ1bmN0aW9uKHYsIHZhbHVlKSB7XG4gIGlmIChfLmhhcyh0aGlzLl9ub2RlcywgdikpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRoaXMuX25vZGVzW3ZdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fbm9kZXNbdl0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHZhbHVlIDogdGhpcy5fZGVmYXVsdE5vZGVMYWJlbEZuKHYpO1xuICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgIHRoaXMuX3BhcmVudFt2XSA9IEdSQVBIX05PREU7XG4gICAgdGhpcy5fY2hpbGRyZW5bdl0gPSB7fTtcbiAgICB0aGlzLl9jaGlsZHJlbltHUkFQSF9OT0RFXVt2XSA9IHRydWU7XG4gIH1cbiAgdGhpcy5faW5bdl0gPSB7fTtcbiAgdGhpcy5fcHJlZHNbdl0gPSB7fTtcbiAgdGhpcy5fb3V0W3ZdID0ge307XG4gIHRoaXMuX3N1Y3Nbdl0gPSB7fTtcbiAgKyt0aGlzLl9ub2RlQ291bnQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiB0aGlzLl9ub2Rlc1t2XTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5oYXNOb2RlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gXy5oYXModGhpcy5fbm9kZXMsIHYpO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnJlbW92ZU5vZGUgPSAgZnVuY3Rpb24odikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChfLmhhcyh0aGlzLl9ub2RlcywgdikpIHtcbiAgICB2YXIgcmVtb3ZlRWRnZSA9IGZ1bmN0aW9uKGUpIHsgc2VsZi5yZW1vdmVFZGdlKHNlbGYuX2VkZ2VPYmpzW2VdKTsgfTtcbiAgICBkZWxldGUgdGhpcy5fbm9kZXNbdl07XG4gICAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUZyb21QYXJlbnRzQ2hpbGRMaXN0KHYpO1xuICAgICAgZGVsZXRlIHRoaXMuX3BhcmVudFt2XTtcbiAgICAgIF8uZWFjaCh0aGlzLmNoaWxkcmVuKHYpLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBzZWxmLnNldFBhcmVudChjaGlsZCk7XG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jaGlsZHJlblt2XTtcbiAgICB9XG4gICAgXy5lYWNoKF8ua2V5cyh0aGlzLl9pblt2XSksIHJlbW92ZUVkZ2UpO1xuICAgIGRlbGV0ZSB0aGlzLl9pblt2XTtcbiAgICBkZWxldGUgdGhpcy5fcHJlZHNbdl07XG4gICAgXy5lYWNoKF8ua2V5cyh0aGlzLl9vdXRbdl0pLCByZW1vdmVFZGdlKTtcbiAgICBkZWxldGUgdGhpcy5fb3V0W3ZdO1xuICAgIGRlbGV0ZSB0aGlzLl9zdWNzW3ZdO1xuICAgIC0tdGhpcy5fbm9kZUNvdW50O1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uKHYsIHBhcmVudCkge1xuICBpZiAoIXRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHBhcmVudCBpbiBhIG5vbi1jb21wb3VuZCBncmFwaFwiKTtcbiAgfVxuXG4gIGlmIChfLmlzVW5kZWZpbmVkKHBhcmVudCkpIHtcbiAgICBwYXJlbnQgPSBHUkFQSF9OT0RFO1xuICB9IGVsc2Uge1xuICAgIC8vIENvZXJjZSBwYXJlbnQgdG8gc3RyaW5nXG4gICAgcGFyZW50ICs9IFwiXCI7XG4gICAgZm9yICh2YXIgYW5jZXN0b3IgPSBwYXJlbnQ7XG4gICAgICAhXy5pc1VuZGVmaW5lZChhbmNlc3Rvcik7XG4gICAgICBhbmNlc3RvciA9IHRoaXMucGFyZW50KGFuY2VzdG9yKSkge1xuICAgICAgaWYgKGFuY2VzdG9yID09PSB2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNldHRpbmcgXCIgKyBwYXJlbnQrIFwiIGFzIHBhcmVudCBvZiBcIiArIHYgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgd291bGQgY3JlYXRlIGEgY3ljbGVcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXROb2RlKHBhcmVudCk7XG4gIH1cblxuICB0aGlzLnNldE5vZGUodik7XG4gIHRoaXMuX3JlbW92ZUZyb21QYXJlbnRzQ2hpbGRMaXN0KHYpO1xuICB0aGlzLl9wYXJlbnRbdl0gPSBwYXJlbnQ7XG4gIHRoaXMuX2NoaWxkcmVuW3BhcmVudF1bdl0gPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5fcmVtb3ZlRnJvbVBhcmVudHNDaGlsZExpc3QgPSBmdW5jdGlvbih2KSB7XG4gIGRlbGV0ZSB0aGlzLl9jaGlsZHJlblt0aGlzLl9wYXJlbnRbdl1dW3ZdO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50W3ZdO1xuICAgIGlmIChwYXJlbnQgIT09IEdSQVBIX05PREUpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuY2hpbGRyZW4gPSBmdW5jdGlvbih2KSB7XG4gIGlmIChfLmlzVW5kZWZpbmVkKHYpKSB7XG4gICAgdiA9IEdSQVBIX05PREU7XG4gIH1cblxuICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuW3ZdO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgcmV0dXJuIF8ua2V5cyhjaGlsZHJlbik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHYgPT09IEdSQVBIX05PREUpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlcygpO1xuICB9IGVsc2UgaWYgKHRoaXMuaGFzTm9kZSh2KSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLnByZWRlY2Vzc29ycyA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHByZWRzViA9IHRoaXMuX3ByZWRzW3ZdO1xuICBpZiAocHJlZHNWKSB7XG4gICAgcmV0dXJuIF8ua2V5cyhwcmVkc1YpO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc3VjY2Vzc29ycyA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHN1Y3NWID0gdGhpcy5fc3Vjc1t2XTtcbiAgaWYgKHN1Y3NWKSB7XG4gICAgcmV0dXJuIF8ua2V5cyhzdWNzVik7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5uZWlnaGJvcnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBwcmVkcyA9IHRoaXMucHJlZGVjZXNzb3JzKHYpO1xuICBpZiAocHJlZHMpIHtcbiAgICByZXR1cm4gXy51bmlvbihwcmVkcywgdGhpcy5zdWNjZXNzb3JzKHYpKTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLmlzTGVhZiA9IGZ1bmN0aW9uICh2KSB7XG4gIHZhciBuZWlnaGJvcnM7XG4gIGlmICh0aGlzLmlzRGlyZWN0ZWQoKSkge1xuICAgIG5laWdoYm9ycyA9IHRoaXMuc3VjY2Vzc29ycyh2KTtcbiAgfSBlbHNlIHtcbiAgICBuZWlnaGJvcnMgPSB0aGlzLm5laWdoYm9ycyh2KTtcbiAgfVxuICByZXR1cm4gbmVpZ2hib3JzLmxlbmd0aCA9PT0gMDtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5maWx0ZXJOb2RlcyA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICB2YXIgY29weSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHtcbiAgICBkaXJlY3RlZDogdGhpcy5faXNEaXJlY3RlZCxcbiAgICBtdWx0aWdyYXBoOiB0aGlzLl9pc011bHRpZ3JhcGgsXG4gICAgY29tcG91bmQ6IHRoaXMuX2lzQ29tcG91bmRcbiAgfSk7XG5cbiAgY29weS5zZXRHcmFwaCh0aGlzLmdyYXBoKCkpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgXy5lYWNoKHRoaXMuX25vZGVzLCBmdW5jdGlvbih2YWx1ZSwgdikge1xuICAgIGlmIChmaWx0ZXIodikpIHtcbiAgICAgIGNvcHkuc2V0Tm9kZSh2LCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcblxuICBfLmVhY2godGhpcy5fZWRnZU9ianMsIGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoY29weS5oYXNOb2RlKGUudikgJiYgY29weS5oYXNOb2RlKGUudykpIHtcbiAgICAgIGNvcHkuc2V0RWRnZShlLCBzZWxmLmVkZ2UoZSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHBhcmVudHMgPSB7fTtcbiAgZnVuY3Rpb24gZmluZFBhcmVudCh2KSB7XG4gICAgdmFyIHBhcmVudCA9IHNlbGYucGFyZW50KHYpO1xuICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCB8fCBjb3B5Lmhhc05vZGUocGFyZW50KSkge1xuICAgICAgcGFyZW50c1t2XSA9IHBhcmVudDtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfSBlbHNlIGlmIChwYXJlbnQgaW4gcGFyZW50cykge1xuICAgICAgcmV0dXJuIHBhcmVudHNbcGFyZW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZpbmRQYXJlbnQocGFyZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgIF8uZWFjaChjb3B5Lm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICAgIGNvcHkuc2V0UGFyZW50KHYsIGZpbmRQYXJlbnQodikpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59O1xuXG4vKiA9PT0gRWRnZSBmdW5jdGlvbnMgPT09PT09PT09PSAqL1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0RGVmYXVsdEVkZ2VMYWJlbCA9IGZ1bmN0aW9uKG5ld0RlZmF1bHQpIHtcbiAgaWYgKCFfLmlzRnVuY3Rpb24obmV3RGVmYXVsdCkpIHtcbiAgICBuZXdEZWZhdWx0ID0gXy5jb25zdGFudChuZXdEZWZhdWx0KTtcbiAgfVxuICB0aGlzLl9kZWZhdWx0RWRnZUxhYmVsRm4gPSBuZXdEZWZhdWx0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5lZGdlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2VkZ2VDb3VudDtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5lZGdlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXy52YWx1ZXModGhpcy5fZWRnZU9ianMpO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNldFBhdGggPSBmdW5jdGlvbih2cywgdmFsdWUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgXy5yZWR1Y2UodnMsIGZ1bmN0aW9uKHYsIHcpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICBzZWxmLnNldEVkZ2UodiwgdywgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnNldEVkZ2Uodiwgdyk7XG4gICAgfVxuICAgIHJldHVybiB3O1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKlxuICogc2V0RWRnZSh2LCB3LCBbdmFsdWUsIFtuYW1lXV0pXG4gKiBzZXRFZGdlKHsgdiwgdywgW25hbWVdIH0sIFt2YWx1ZV0pXG4gKi9cbkdyYXBoLnByb3RvdHlwZS5zZXRFZGdlID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2LCB3LCBuYW1lLCB2YWx1ZTtcbiAgdmFyIHZhbHVlU3BlY2lmaWVkID0gZmFsc2U7XG4gIHZhciBhcmcwID0gYXJndW1lbnRzWzBdO1xuXG4gIGlmICh0eXBlb2YgYXJnMCA9PT0gXCJvYmplY3RcIiAmJiBhcmcwICE9PSBudWxsICYmIFwidlwiIGluIGFyZzApIHtcbiAgICB2ID0gYXJnMC52O1xuICAgIHcgPSBhcmcwLnc7XG4gICAgbmFtZSA9IGFyZzAubmFtZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YWx1ZVNwZWNpZmllZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHYgPSBhcmcwO1xuICAgIHcgPSBhcmd1bWVudHNbMV07XG4gICAgbmFtZSA9IGFyZ3VtZW50c1szXTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFsdWVTcGVjaWZpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHYgPSBcIlwiICsgdjtcbiAgdyA9IFwiXCIgKyB3O1xuICBpZiAoIV8uaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBuYW1lID0gXCJcIiArIG5hbWU7XG4gIH1cblxuICB2YXIgZSA9IGVkZ2VBcmdzVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCB2LCB3LCBuYW1lKTtcbiAgaWYgKF8uaGFzKHRoaXMuX2VkZ2VMYWJlbHMsIGUpKSB7XG4gICAgaWYgKHZhbHVlU3BlY2lmaWVkKSB7XG4gICAgICB0aGlzLl9lZGdlTGFiZWxzW2VdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKG5hbWUpICYmICF0aGlzLl9pc011bHRpZ3JhcGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IGEgbmFtZWQgZWRnZSB3aGVuIGlzTXVsdGlncmFwaCA9IGZhbHNlXCIpO1xuICB9XG5cbiAgLy8gSXQgZGlkbid0IGV4aXN0LCBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBpdC5cbiAgLy8gRmlyc3QgZW5zdXJlIHRoZSBub2RlcyBleGlzdC5cbiAgdGhpcy5zZXROb2RlKHYpO1xuICB0aGlzLnNldE5vZGUodyk7XG5cbiAgdGhpcy5fZWRnZUxhYmVsc1tlXSA9IHZhbHVlU3BlY2lmaWVkID8gdmFsdWUgOiB0aGlzLl9kZWZhdWx0RWRnZUxhYmVsRm4odiwgdywgbmFtZSk7XG5cbiAgdmFyIGVkZ2VPYmogPSBlZGdlQXJnc1RvT2JqKHRoaXMuX2lzRGlyZWN0ZWQsIHYsIHcsIG5hbWUpO1xuICAvLyBFbnN1cmUgd2UgYWRkIHVuZGlyZWN0ZWQgZWRnZXMgaW4gYSBjb25zaXN0ZW50IHdheS5cbiAgdiA9IGVkZ2VPYmoudjtcbiAgdyA9IGVkZ2VPYmoudztcblxuICBPYmplY3QuZnJlZXplKGVkZ2VPYmopO1xuICB0aGlzLl9lZGdlT2Jqc1tlXSA9IGVkZ2VPYmo7XG4gIGluY3JlbWVudE9ySW5pdEVudHJ5KHRoaXMuX3ByZWRzW3ddLCB2KTtcbiAgaW5jcmVtZW50T3JJbml0RW50cnkodGhpcy5fc3Vjc1t2XSwgdyk7XG4gIHRoaXMuX2luW3ddW2VdID0gZWRnZU9iajtcbiAgdGhpcy5fb3V0W3ZdW2VdID0gZWRnZU9iajtcbiAgdGhpcy5fZWRnZUNvdW50Kys7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmVkZ2UgPSBmdW5jdGlvbih2LCB3LCBuYW1lKSB7XG4gIHZhciBlID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICA/IGVkZ2VPYmpUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIGFyZ3VtZW50c1swXSlcbiAgICA6IGVkZ2VBcmdzVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCB2LCB3LCBuYW1lKSk7XG4gIHJldHVybiB0aGlzLl9lZGdlTGFiZWxzW2VdO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmhhc0VkZ2UgPSBmdW5jdGlvbih2LCB3LCBuYW1lKSB7XG4gIHZhciBlID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICA/IGVkZ2VPYmpUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIGFyZ3VtZW50c1swXSlcbiAgICA6IGVkZ2VBcmdzVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCB2LCB3LCBuYW1lKSk7XG4gIHJldHVybiBfLmhhcyh0aGlzLl9lZGdlTGFiZWxzLCBlKTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5yZW1vdmVFZGdlID0gZnVuY3Rpb24odiwgdywgbmFtZSkge1xuICB2YXIgZSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgPyBlZGdlT2JqVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCBhcmd1bWVudHNbMF0pXG4gICAgOiBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSkpO1xuICB2YXIgZWRnZSA9IHRoaXMuX2VkZ2VPYmpzW2VdO1xuICBpZiAoZWRnZSkge1xuICAgIHYgPSBlZGdlLnY7XG4gICAgdyA9IGVkZ2UudztcbiAgICBkZWxldGUgdGhpcy5fZWRnZUxhYmVsc1tlXTtcbiAgICBkZWxldGUgdGhpcy5fZWRnZU9ianNbZV07XG4gICAgZGVjcmVtZW50T3JSZW1vdmVFbnRyeSh0aGlzLl9wcmVkc1t3XSwgdik7XG4gICAgZGVjcmVtZW50T3JSZW1vdmVFbnRyeSh0aGlzLl9zdWNzW3ZdLCB3KTtcbiAgICBkZWxldGUgdGhpcy5faW5bd11bZV07XG4gICAgZGVsZXRlIHRoaXMuX291dFt2XVtlXTtcbiAgICB0aGlzLl9lZGdlQ291bnQtLTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5pbkVkZ2VzID0gZnVuY3Rpb24odiwgdSkge1xuICB2YXIgaW5WID0gdGhpcy5faW5bdl07XG4gIGlmIChpblYpIHtcbiAgICB2YXIgZWRnZXMgPSBfLnZhbHVlcyhpblYpO1xuICAgIGlmICghdSkge1xuICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gXy5maWx0ZXIoZWRnZXMsIGZ1bmN0aW9uKGVkZ2UpIHsgcmV0dXJuIGVkZ2UudiA9PT0gdTsgfSk7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5vdXRFZGdlcyA9IGZ1bmN0aW9uKHYsIHcpIHtcbiAgdmFyIG91dFYgPSB0aGlzLl9vdXRbdl07XG4gIGlmIChvdXRWKSB7XG4gICAgdmFyIGVkZ2VzID0gXy52YWx1ZXMob3V0Vik7XG4gICAgaWYgKCF3KSB7XG4gICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIHJldHVybiBfLmZpbHRlcihlZGdlcywgZnVuY3Rpb24oZWRnZSkgeyByZXR1cm4gZWRnZS53ID09PSB3OyB9KTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLm5vZGVFZGdlcyA9IGZ1bmN0aW9uKHYsIHcpIHtcbiAgdmFyIGluRWRnZXMgPSB0aGlzLmluRWRnZXModiwgdyk7XG4gIGlmIChpbkVkZ2VzKSB7XG4gICAgcmV0dXJuIGluRWRnZXMuY29uY2F0KHRoaXMub3V0RWRnZXModiwgdykpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpbmNyZW1lbnRPckluaXRFbnRyeShtYXAsIGspIHtcbiAgaWYgKG1hcFtrXSkge1xuICAgIG1hcFtrXSsrO1xuICB9IGVsc2Uge1xuICAgIG1hcFtrXSA9IDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjcmVtZW50T3JSZW1vdmVFbnRyeShtYXAsIGspIHtcbiAgaWYgKCEtLW1hcFtrXSkgeyBkZWxldGUgbWFwW2tdOyB9XG59XG5cbmZ1bmN0aW9uIGVkZ2VBcmdzVG9JZChpc0RpcmVjdGVkLCB2Xywgd18sIG5hbWUpIHtcbiAgdmFyIHYgPSBcIlwiICsgdl87XG4gIHZhciB3ID0gXCJcIiArIHdfO1xuICBpZiAoIWlzRGlyZWN0ZWQgJiYgdiA+IHcpIHtcbiAgICB2YXIgdG1wID0gdjtcbiAgICB2ID0gdztcbiAgICB3ID0gdG1wO1xuICB9XG4gIHJldHVybiB2ICsgRURHRV9LRVlfREVMSU0gKyB3ICsgRURHRV9LRVlfREVMSU0gK1xuICAgICAgICAgICAgIChfLmlzVW5kZWZpbmVkKG5hbWUpID8gREVGQVVMVF9FREdFX05BTUUgOiBuYW1lKTtcbn1cblxuZnVuY3Rpb24gZWRnZUFyZ3NUb09iaihpc0RpcmVjdGVkLCB2Xywgd18sIG5hbWUpIHtcbiAgdmFyIHYgPSBcIlwiICsgdl87XG4gIHZhciB3ID0gXCJcIiArIHdfO1xuICBpZiAoIWlzRGlyZWN0ZWQgJiYgdiA+IHcpIHtcbiAgICB2YXIgdG1wID0gdjtcbiAgICB2ID0gdztcbiAgICB3ID0gdG1wO1xuICB9XG4gIHZhciBlZGdlT2JqID0gIHsgdjogdiwgdzogdyB9O1xuICBpZiAobmFtZSkge1xuICAgIGVkZ2VPYmoubmFtZSA9IG5hbWU7XG4gIH1cbiAgcmV0dXJuIGVkZ2VPYmo7XG59XG5cbmZ1bmN0aW9uIGVkZ2VPYmpUb0lkKGlzRGlyZWN0ZWQsIGVkZ2VPYmopIHtcbiAgcmV0dXJuIGVkZ2VBcmdzVG9JZChpc0RpcmVjdGVkLCBlZGdlT2JqLnYsIGVkZ2VPYmoudywgZWRnZU9iai5uYW1lKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIEluY2x1ZGVzIG9ubHkgdGhlIFwiY29yZVwiIG9mIGdyYXBobGliXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgR3JhcGg6IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ3JhcGggKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2dyYXBoLmpzXCIpLFxuICB2ZXJzaW9uOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ZlcnNpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL3ZlcnNpb24uanNcIilcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi9qc29uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2pzb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9sb2Rhc2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2xvZGFzaC5qc1wiKTtcbnZhciBHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZ3JhcGggKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2dyYXBoLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd3JpdGU6IHdyaXRlLFxuICByZWFkOiByZWFkXG59O1xuXG5mdW5jdGlvbiB3cml0ZShnKSB7XG4gIHZhciBqc29uID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIGRpcmVjdGVkOiBnLmlzRGlyZWN0ZWQoKSxcbiAgICAgIG11bHRpZ3JhcGg6IGcuaXNNdWx0aWdyYXBoKCksXG4gICAgICBjb21wb3VuZDogZy5pc0NvbXBvdW5kKClcbiAgICB9LFxuICAgIG5vZGVzOiB3cml0ZU5vZGVzKGcpLFxuICAgIGVkZ2VzOiB3cml0ZUVkZ2VzKGcpXG4gIH07XG4gIGlmICghXy5pc1VuZGVmaW5lZChnLmdyYXBoKCkpKSB7XG4gICAganNvbi52YWx1ZSA9IF8uY2xvbmUoZy5ncmFwaCgpKTtcbiAgfVxuICByZXR1cm4ganNvbjtcbn1cblxuZnVuY3Rpb24gd3JpdGVOb2RlcyhnKSB7XG4gIHJldHVybiBfLm1hcChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZVZhbHVlID0gZy5ub2RlKHYpO1xuICAgIHZhciBwYXJlbnQgPSBnLnBhcmVudCh2KTtcbiAgICB2YXIgbm9kZSA9IHsgdjogdiB9O1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChub2RlVmFsdWUpKSB7XG4gICAgICBub2RlLnZhbHVlID0gbm9kZVZhbHVlO1xuICAgIH1cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyZW50KSkge1xuICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gd3JpdGVFZGdlcyhnKSB7XG4gIHJldHVybiBfLm1hcChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZVZhbHVlID0gZy5lZGdlKGUpO1xuICAgIHZhciBlZGdlID0geyB2OiBlLnYsIHc6IGUudyB9O1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChlLm5hbWUpKSB7XG4gICAgICBlZGdlLm5hbWUgPSBlLm5hbWU7XG4gICAgfVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChlZGdlVmFsdWUpKSB7XG4gICAgICBlZGdlLnZhbHVlID0gZWRnZVZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlYWQoanNvbikge1xuICB2YXIgZyA9IG5ldyBHcmFwaChqc29uLm9wdGlvbnMpLnNldEdyYXBoKGpzb24udmFsdWUpO1xuICBfLmVhY2goanNvbi5ub2RlcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICBnLnNldE5vZGUoZW50cnkudiwgZW50cnkudmFsdWUpO1xuICAgIGlmIChlbnRyeS5wYXJlbnQpIHtcbiAgICAgIGcuc2V0UGFyZW50KGVudHJ5LnYsIGVudHJ5LnBhcmVudCk7XG4gICAgfVxuICB9KTtcbiAgXy5lYWNoKGpzb24uZWRnZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgZy5zZXRFZGdlKHsgdjogZW50cnkudiwgdzogZW50cnkudywgbmFtZTogZW50cnkubmFtZSB9LCBlbnRyeS52YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gZztcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2xvZGFzaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL2xvZGFzaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBnbG9iYWwgd2luZG93ICovXG5cbnZhciBsb2Rhc2g7XG5cbmlmICh0cnVlKSB7XG4gIHRyeSB7XG4gICAgbG9kYXNoID0ge1xuICAgICAgY2xvbmU6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9jbG9uZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvY2xvbmUuanNcIiksXG4gICAgICBjb25zdGFudDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL2NvbnN0YW50ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9jb25zdGFudC5qc1wiKSxcbiAgICAgIGVhY2g6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9lYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9lYWNoLmpzXCIpLFxuICAgICAgZmlsdGVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvZmlsdGVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9maWx0ZXIuanNcIiksXG4gICAgICBoYXM6ICBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9oYXMuanNcIiksXG4gICAgICBpc0FycmF5OiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvaXNBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheS5qc1wiKSxcbiAgICAgIGlzRW1wdHk6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9pc0VtcHR5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0VtcHR5LmpzXCIpLFxuICAgICAgaXNGdW5jdGlvbjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL2lzRnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzRnVuY3Rpb24uanNcIiksXG4gICAgICBpc1VuZGVmaW5lZDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL2lzVW5kZWZpbmVkICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1VuZGVmaW5lZC5qc1wiKSxcbiAgICAgIGtleXM6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzLmpzXCIpLFxuICAgICAgbWFwOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvbWFwICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9tYXAuanNcIiksXG4gICAgICByZWR1Y2U6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9yZWR1Y2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3JlZHVjZS5qc1wiKSxcbiAgICAgIHNpemU6IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC9zaXplICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9zaXplLmpzXCIpLFxuICAgICAgdHJhbnNmb3JtOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2gvdHJhbnNmb3JtICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC90cmFuc2Zvcm0uanNcIiksXG4gICAgICB1bmlvbjogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL3VuaW9uICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC91bmlvbi5qc1wiKSxcbiAgICAgIHZhbHVlczogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgbG9kYXNoL3ZhbHVlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdmFsdWVzLmpzXCIpXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3JcbiAgfVxufVxuXG5pZiAoIWxvZGFzaCkge1xuICBsb2Rhc2ggPSB3aW5kb3cuXztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsb2Rhc2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2dyYXBobGliQDIuMS44QGdyYXBobGliL2xpYi92ZXJzaW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fZ3JhcGhsaWJAMi4xLjhAZ3JhcGhsaWIvbGliL3ZlcnNpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gJzIuMS44JztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9faXNhcnJheUAwLjAuMUBpc2FycmF5L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2lzYXJyYXlAMC4wLjFAaXNhcnJheS9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19EYXRhVmlldy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19EYXRhVmlldy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0TmF0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0TmF0aXZlLmpzXCIpLFxuICAgIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yb290ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fcm9vdC5qc1wiKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX0hhc2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19IYXNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhc2hDbGVhciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hhc2hDbGVhciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2hhc2hDbGVhci5qc1wiKSxcbiAgICBoYXNoRGVsZXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGFzaERlbGV0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2hhc2hEZWxldGUuanNcIiksXG4gICAgaGFzaEdldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hhc2hHZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19oYXNoR2V0LmpzXCIpLFxuICAgIGhhc2hIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oYXNoSGFzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzaEhhcy5qc1wiKSxcbiAgICBoYXNoU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGFzaFNldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2hhc2hTZXQuanNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fTGlzdENhY2hlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19MaXN0Q2FjaGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBsaXN0Q2FjaGVDbGVhciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2xpc3RDYWNoZUNsZWFyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanNcIiksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbGlzdENhY2hlRGVsZXRlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzXCIpLFxuICAgIGxpc3RDYWNoZUdldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2xpc3RDYWNoZUdldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2xpc3RDYWNoZUdldC5qc1wiKSxcbiAgICBsaXN0Q2FjaGVIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19saXN0Q2FjaGVIYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19saXN0Q2FjaGVIYXMuanNcIiksXG4gICAgbGlzdENhY2hlU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbGlzdENhY2hlU2V0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbGlzdENhY2hlU2V0LmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX01hcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fTWFwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0TmF0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0TmF0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0TmF0aXZlLmpzXCIpLFxuICAgIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yb290ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fcm9vdC5qc1wiKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX01hcENhY2hlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX01hcENhY2hlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBtYXBDYWNoZUNsZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbWFwQ2FjaGVDbGVhciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcENhY2hlQ2xlYXIuanNcIiksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19tYXBDYWNoZURlbGV0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzXCIpLFxuICAgIG1hcENhY2hlR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbWFwQ2FjaGVHZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19tYXBDYWNoZUdldC5qc1wiKSxcbiAgICBtYXBDYWNoZUhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX21hcENhY2hlSGFzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWFwQ2FjaGVIYXMuanNcIiksXG4gICAgbWFwQ2FjaGVTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19tYXBDYWNoZVNldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcENhY2hlU2V0LmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19Qcm9taXNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fUHJvbWlzZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXROYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXROYXRpdmUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXROYXRpdmUuanNcIiksXG4gICAgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3Jvb3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19yb290LmpzXCIpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU2V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19TZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXROYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXROYXRpdmUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXROYXRpdmUuanNcIiksXG4gICAgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3Jvb3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19yb290LmpzXCIpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU2V0Q2FjaGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU2V0Q2FjaGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIE1hcENhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fTWFwQ2FjaGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19NYXBDYWNoZS5qc1wiKSxcbiAgICBzZXRDYWNoZUFkZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3NldENhY2hlQWRkICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2V0Q2FjaGVBZGQuanNcIiksXG4gICAgc2V0Q2FjaGVIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zZXRDYWNoZUhhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3NldENhY2hlSGFzLmpzXCIpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU3RhY2suanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU3RhY2suanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIExpc3RDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX0xpc3RDYWNoZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX0xpc3RDYWNoZS5qc1wiKSxcbiAgICBzdGFja0NsZWFyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc3RhY2tDbGVhciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3N0YWNrQ2xlYXIuanNcIiksXG4gICAgc3RhY2tEZWxldGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zdGFja0RlbGV0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3N0YWNrRGVsZXRlLmpzXCIpLFxuICAgIHN0YWNrR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc3RhY2tHZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdGFja0dldC5qc1wiKSxcbiAgICBzdGFja0hhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3N0YWNrSGFzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RhY2tIYXMuanNcIiksXG4gICAgc3RhY2tTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zdGFja1NldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3N0YWNrU2V0LmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU3ltYm9sLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19TeW1ib2wuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcm9vdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3Jvb3QuanNcIik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19VaW50OEFycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fVWludDhBcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcm9vdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3Jvb3QuanNcIik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19XZWFrTWFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fV2Vha01hcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXROYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXROYXRpdmUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXROYXRpdmUuanNcIiksXG4gICAgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3Jvb3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19yb290LmpzXCIpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXBwbHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXBwbHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5RWFjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlFYWNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5RmlsdGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5RmlsdGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUluY2x1ZGVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlJbmNsdWRlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VJbmRleE9mICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUluZGV4T2YuanNcIik7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlJbmNsdWRlcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUluY2x1ZGVzV2l0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUluY2x1ZGVzV2l0aC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5TGlrZUtleXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VUaW1lcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VUaW1lcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VUaW1lcy5qc1wiKSxcbiAgICBpc0FyZ3VtZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcmd1bWVudHMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJndW1lbnRzLmpzXCIpLFxuICAgIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXkuanNcIiksXG4gICAgaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQnVmZmVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0J1ZmZlci5qc1wiKSxcbiAgICBpc0luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNJbmRleCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzSW5kZXguanNcIiksXG4gICAgaXNUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1R5cGVkQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzVHlwZWRBcnJheS5qc1wiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5TGlrZUtleXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlNYXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlNYXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheVB1c2guanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5UHVzaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UHVzaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheVJlZHVjZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheVJlZHVjZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlSZWR1Y2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlTb21lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheVNvbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlTb21lO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FzY2lpU2l6ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXNjaWlTaXplLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVByb3BlcnR5LmpzXCIpO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYW4gQVNDSUkgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbnZhciBhc2NpaVNpemUgPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzY2lpU2l6ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXNzaWduTWVyZ2VWYWx1ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlQXNzaWduVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlQXNzaWduVmFsdWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanNcIiksXG4gICAgZXEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VxICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9lcS5qc1wiKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFzc2lnblZhbHVlYCBleGNlcHQgdGhhdCBpdCBkb2Vzbid0IGFzc2lnblxuICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmICgodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25NZXJnZVZhbHVlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Fzc2lnblZhbHVlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Fzc2lnblZhbHVlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlQXNzaWduVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlQXNzaWduVmFsdWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanNcIiksXG4gICAgZXEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VxICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9lcS5qc1wiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ25WYWx1ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc3NvY0luZGV4T2YuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGVxID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lcSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZXEuanNcIik7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VBc3NpZ24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQXNzaWduLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNvcHlPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3B5T2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29weU9iamVjdC5qc1wiKSxcbiAgICBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzLmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQXNzaWduSW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VBc3NpZ25Jbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNvcHlPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3B5T2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29weU9iamVjdC5qc1wiKSxcbiAgICBrZXlzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2tleXNJbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gva2V5c0luLmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbkluO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19kZWZpbmVQcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQ2xvbmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VDbG9uZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFN0YWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fU3RhY2sgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19TdGFjay5qc1wiKSxcbiAgICBhcnJheUVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hcnJheUVhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUVhY2guanNcIiksXG4gICAgYXNzaWduVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hc3NpZ25WYWx1ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Fzc2lnblZhbHVlLmpzXCIpLFxuICAgIGJhc2VBc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlQXNzaWduICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUFzc2lnbi5qc1wiKSxcbiAgICBiYXNlQXNzaWduSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlQXNzaWduSW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQXNzaWduSW4uanNcIiksXG4gICAgY2xvbmVCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jbG9uZUJ1ZmZlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lQnVmZmVyLmpzXCIpLFxuICAgIGNvcHlBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NvcHlBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvcHlBcnJheS5qc1wiKSxcbiAgICBjb3B5U3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NvcHlTeW1ib2xzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29weVN5bWJvbHMuanNcIiksXG4gICAgY29weVN5bWJvbHNJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NvcHlTeW1ib2xzSW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzXCIpLFxuICAgIGdldEFsbEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRBbGxLZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0QWxsS2V5cy5qc1wiKSxcbiAgICBnZXRBbGxLZXlzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRBbGxLZXlzSW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRBbGxLZXlzSW4uanNcIiksXG4gICAgZ2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0VGFnLmpzXCIpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faW5pdENsb25lQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qc1wiKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2luaXRDbG9uZUJ5VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faW5pdENsb25lQnlUYWcuanNcIiksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faW5pdENsb25lT2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzXCIpLFxuICAgIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXkuanNcIiksXG4gICAgaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQnVmZmVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0J1ZmZlci5qc1wiKSxcbiAgICBpc01hcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNNYXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzTWFwLmpzXCIpLFxuICAgIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3QuanNcIiksXG4gICAgaXNTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzU2V0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1NldC5qc1wiKSxcbiAgICBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzLmpzXCIpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICA6IChpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzKTtcblxuICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ2xvbmU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUNyZWF0ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VDcmVhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzT2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdC5qc1wiKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VFYWNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VFYWNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlRm9yT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUZvck93biAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VGb3JPd24uanNcIiksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jcmVhdGVCYXNlRWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRXh0cmVtdW0uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VFeHRyZW11bS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1N5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNTeW1ib2wuanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gKiBgY29tcGFyYXRvcmAgdG8gZGV0ZXJtaW5lIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGN1cnJlbnQgPSBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXG4gICAgICAgICAgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKVxuICAgICAgICApKSB7XG4gICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFeHRyZW11bTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRmlsdGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZpbHRlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VFYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUVhY2guanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmlsdGVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRmluZEluZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbmRJbmRleDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRmxhdHRlbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRmxhdHRlbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlQdXNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXlQdXNoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlQdXNoLmpzXCIpLFxuICAgIGlzRmxhdHRlbmFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pc0ZsYXR0ZW5hYmxlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNGbGF0dGVuYWJsZS5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VGb3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY3JlYXRlQmFzZUZvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NyZWF0ZUJhc2VGb3IgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRm9yT3duLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZvck93bi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlRm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUZvciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VGb3IuanNcIiksXG4gICAga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4va2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gva2V5cy5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUdldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2FzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jYXN0UGF0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nhc3RQYXRoLmpzXCIpLFxuICAgIHRvS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG9LZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL190b0tleS5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheVB1c2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hcnJheVB1c2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheVB1c2guanNcIiksXG4gICAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheS5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHZXRUYWcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR2V0VGFnLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1N5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1N5bWJvbC5qc1wiKSxcbiAgICBnZXRSYXdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRSYXdUYWcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRSYXdUYWcuanNcIiksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3RUb1N0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzXCIpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUd0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmd0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlR3QodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA+IG90aGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSGFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUhhcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VIYXNJbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUhhc0luLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUluZGV4T2YuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUluZGV4T2YuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VGaW5kSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlRmluZEluZGV4ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZpbmRJbmRleC5qc1wiKSxcbiAgICBiYXNlSXNOYU4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXNOYU4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNOYU4uanNcIiksXG4gICAgc3RyaWN0SW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3N0cmljdEluZGV4T2YgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdHJpY3RJbmRleE9mLmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJbmRleE9mO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VHZXRUYWcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR2V0VGFnLmpzXCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3RMaWtlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdExpa2UuanNcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSXNFcXVhbERlZXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXNFcXVhbERlZXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNFcXVhbERlZXAuanNcIiksXG4gICAgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdExpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNFcXVhbERlZXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTdGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1N0YWNrICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU3RhY2suanNcIiksXG4gICAgZXF1YWxBcnJheXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19lcXVhbEFycmF5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2VxdWFsQXJyYXlzLmpzXCIpLFxuICAgIGVxdWFsQnlUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19lcXVhbEJ5VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZXF1YWxCeVRhZy5qc1wiKSxcbiAgICBlcXVhbE9iamVjdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19lcXVhbE9iamVjdHMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19lcXVhbE9iamVjdHMuanNcIiksXG4gICAgZ2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0VGFnLmpzXCIpLFxuICAgIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXkuanNcIiksXG4gICAgaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQnVmZmVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0J1ZmZlci5qc1wiKSxcbiAgICBpc1R5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzVHlwZWRBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNUeXBlZEFycmF5LmpzXCIpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbERlZXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzTWFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNNYXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRUYWcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRUYWcuanNcIiksXG4gICAgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdExpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1wiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWFwO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc01hdGNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc01hdGNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTdGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1N0YWNrICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU3RhY2suanNcIiksXG4gICAgYmFzZUlzRXF1YWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXNFcXVhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzXCIpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNOYU4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc05hTi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hTmAgd2l0aG91dCBzdXBwb3J0IGZvciBudW1iZXIgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYU47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzTmF0aXZlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNOYXRpdmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0Z1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0Z1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0Z1bmN0aW9uLmpzXCIpLFxuICAgIGlzTWFza2VkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNNYXNrZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc01hc2tlZC5qc1wiKSxcbiAgICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0LmpzXCIpLFxuICAgIHRvU291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG9Tb3VyY2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL190b1NvdXJjZS5qc1wiKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzU2V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNTZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRUYWcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRUYWcuanNcIiksXG4gICAgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdExpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1wiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzU2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VHZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlR2V0VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUdldFRhZy5qc1wiKSxcbiAgICBpc0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNMZW5ndGggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzTGVuZ3RoLmpzXCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3RMaWtlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdExpa2UuanNcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZU1hdGNoZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlTWF0Y2hlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzXCIpLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlTWF0Y2hlc1Byb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qc1wiKSxcbiAgICBpZGVudGl0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaWRlbnRpdHkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lkZW50aXR5LmpzXCIpLFxuICAgIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXkuanNcIiksXG4gICAgcHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Byb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9wcm9wZXJ0eS5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUtleXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUtleXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNQcm90b3R5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc1Byb3RvdHlwZS5qc1wiKSxcbiAgICBuYXRpdmVLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbmF0aXZlS2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX25hdGl2ZUtleXMuanNcIik7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlS2V5c0luLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUtleXNJbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0LmpzXCIpLFxuICAgIGlzUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNQcm90b3R5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc1Byb3RvdHlwZS5qc1wiKSxcbiAgICBuYXRpdmVLZXlzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19uYXRpdmVLZXlzSW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19uYXRpdmVLZXlzSW4uanNcIik7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTHQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VMdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5sdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTHQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZU1hcC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VNYXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlRWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VFYWNoLmpzXCIpLFxuICAgIGlzQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5TGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheUxpa2UuanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hcDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTWF0Y2hlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUlzTWF0Y2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXNNYXRjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc01hdGNoLmpzXCIpLFxuICAgIGdldE1hdGNoRGF0YSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldE1hdGNoRGF0YSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldE1hdGNoRGF0YS5qc1wiKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VJc0VxdWFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUlzRXF1YWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNFcXVhbC5qc1wiKSxcbiAgICBnZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2dldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZ2V0LmpzXCIpLFxuICAgIGhhc0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9oYXNJbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaGFzSW4uanNcIiksXG4gICAgaXNLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pc0tleSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzS2V5LmpzXCIpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzU3RyaWN0Q29tcGFyYWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qc1wiKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanNcIiksXG4gICAgdG9LZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190b0tleSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3RvS2V5LmpzXCIpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXNQcm9wZXJ0eTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTWVyZ2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VNZXJnZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFN0YWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fU3RhY2sgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19TdGFjay5qc1wiKSxcbiAgICBhc3NpZ25NZXJnZVZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXNzaWduTWVyZ2VWYWx1ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Fzc2lnbk1lcmdlVmFsdWUuanNcIiksXG4gICAgYmFzZUZvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VGb3IgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRm9yLmpzXCIpLFxuICAgIGJhc2VNZXJnZURlZXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlTWVyZ2VEZWVwICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZU1lcmdlRGVlcC5qc1wiKSxcbiAgICBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0LmpzXCIpLFxuICAgIGtleXNJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4va2V5c0luICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzSW4uanNcIiksXG4gICAgc2FmZUdldCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3NhZmVHZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zYWZlR2V0LmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIGlmIChpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgPyBjdXN0b21pemVyKHNhZmVHZXQob2JqZWN0LCBrZXkpLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH0sIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1lcmdlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VNZXJnZURlZXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTWVyZ2VEZWVwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFzc2lnbk1lcmdlVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hc3NpZ25NZXJnZVZhbHVlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXNzaWduTWVyZ2VWYWx1ZS5qc1wiKSxcbiAgICBjbG9uZUJ1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Nsb25lQnVmZmVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2xvbmVCdWZmZXIuanNcIiksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2xvbmVUeXBlZEFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2xvbmVUeXBlZEFycmF5LmpzXCIpLFxuICAgIGNvcHlBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NvcHlBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvcHlBcnJheS5qc1wiKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pbml0Q2xvbmVPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanNcIiksXG4gICAgaXNBcmd1bWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJndW1lbnRzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FyZ3VtZW50cy5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5TGlrZU9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanNcIiksXG4gICAgaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQnVmZmVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0J1ZmZlci5qc1wiKSxcbiAgICBpc0Z1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0Z1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0Z1bmN0aW9uLmpzXCIpLFxuICAgIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3QuanNcIiksXG4gICAgaXNQbGFpbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNQbGFpbk9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNQbGFpbk9iamVjdC5qc1wiKSxcbiAgICBpc1R5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzVHlwZWRBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNUeXBlZEFycmF5LmpzXCIpLFxuICAgIHNhZmVHZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zYWZlR2V0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2FmZUdldC5qc1wiKSxcbiAgICB0b1BsYWluT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90b1BsYWluT2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC90b1BsYWluT2JqZWN0LmpzXCIpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksXG4gICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgaWYgKHN0YWNrZWQpIHtcbiAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICA6IHVuZGVmaW5lZDtcblxuICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gIGlmIChpc0NvbW1vbikge1xuICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLFxuICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNDb21tb24pIHtcbiAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBtZXJnZUZ1bmMobmV3VmFsdWUsIHNyY1ZhbHVlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spO1xuICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gIH1cbiAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNZXJnZURlZXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZU9yZGVyQnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZU9yZGVyQnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5TWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXlNYXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheU1hcC5qc1wiKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXRlcmF0ZWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXRlcmF0ZWUuanNcIiksXG4gICAgYmFzZU1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VNYXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTWFwLmpzXCIpLFxuICAgIGJhc2VTb3J0QnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlU29ydEJ5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVNvcnRCeS5qc1wiKSxcbiAgICBiYXNlVW5hcnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlVW5hcnkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlVW5hcnkuanNcIiksXG4gICAgY29tcGFyZU11bHRpcGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY29tcGFyZU11bHRpcGxlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29tcGFyZU11bHRpcGxlLmpzXCIpLFxuICAgIGlkZW50aXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pZGVudGl0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaWRlbnRpdHkuanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xO1xuICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMubGVuZ3RoID8gaXRlcmF0ZWVzIDogW2lkZW50aXR5XSwgYmFzZVVuYXJ5KGJhc2VJdGVyYXRlZSkpO1xuXG4gIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICB9KTtcblxuICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VPcmRlckJ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VQaWNrLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VQaWNrLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlUGlja0J5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVBpY2tCeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VQaWNrQnkuanNcIiksXG4gICAgaGFzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hhc0luICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9oYXNJbi5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VQaWNrQnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlUGlja0J5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VHZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlR2V0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUdldC5qc1wiKSxcbiAgICBiYXNlU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVNldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VTZXQuanNcIiksXG4gICAgY2FzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jYXN0UGF0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nhc3RQYXRoLmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUGlja0J5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVByb3BlcnR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUdldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHZXQuanNcIik7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVJhbmdlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlUmFuZ2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmdlYCBhbmQgYF8ucmFuZ2VSaWdodGAgd2hpY2ggZG9lc24ndFxuICogY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICByZXN1bHRbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF0gPSBzdGFydDtcbiAgICBzdGFydCArPSBzdGVwO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJhbmdlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VSZWR1Y2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlUmVkdWNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZWR1Y2VgIGFuZCBgXy5yZWR1Y2VSaWdodGAsIHdpdGhvdXQgc3VwcG9ydFxuICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXG4gKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGVhY2hGdW5jKSB7XG4gIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICA/IChpbml0QWNjdW0gPSBmYWxzZSwgdmFsdWUpXG4gICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZWR1Y2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVJlc3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVJlc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlkZW50aXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pZGVudGl0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaWRlbnRpdHkuanNcIiksXG4gICAgb3ZlclJlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vdmVyUmVzdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX292ZXJSZXN0LmpzXCIpLFxuICAgIHNldFRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc2V0VG9TdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zZXRUb1N0cmluZy5qc1wiKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlc3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVNldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VTZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXNzaWduVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hc3NpZ25WYWx1ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Fzc2lnblZhbHVlLmpzXCIpLFxuICAgIGNhc3RQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2FzdFBhdGggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jYXN0UGF0aC5qc1wiKSxcbiAgICBpc0luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNJbmRleCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzSW5kZXguanNcIiksXG4gICAgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzT2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdC5qc1wiKSxcbiAgICB0b0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvS2V5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fdG9LZXkuanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjb25zdGFudCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29uc3RhbnQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2NvbnN0YW50LmpzXCIpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZGVmaW5lUHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qc1wiKSxcbiAgICBpZGVudGl0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaWRlbnRpdHkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lkZW50aXR5LmpzXCIpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgJ3ZhbHVlJzogY29uc3RhbnQoc3RyaW5nKSxcbiAgICAnd3JpdGFibGUnOiB0cnVlXG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0VG9TdHJpbmc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVNvcnRCeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VTb3J0QnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTb3J0Qnk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVRpbWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlVGltZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRpbWVzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VUb1N0cmluZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVRvU3RyaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fU3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU3ltYm9sLmpzXCIpLFxuICAgIGFycmF5TWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXlNYXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheU1hcC5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpLFxuICAgIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1N5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNTeW1ib2wuanNcIik7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VVbmFyeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVVuYXJ5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VVbmlxLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VVbmlxLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTZXRDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1NldENhY2hlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU2V0Q2FjaGUuanNcIiksXG4gICAgYXJyYXlJbmNsdWRlcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5SW5jbHVkZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUluY2x1ZGVzLmpzXCIpLFxuICAgIGFycmF5SW5jbHVkZXNXaXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXlJbmNsdWRlc1dpdGggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUluY2x1ZGVzV2l0aC5qc1wiKSxcbiAgICBjYWNoZUhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NhY2hlSGFzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2FjaGVIYXMuanNcIiksXG4gICAgY3JlYXRlU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY3JlYXRlU2V0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY3JlYXRlU2V0LmpzXCIpLFxuICAgIHNldFRvQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zZXRUb0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2V0VG9BcnJheS5qc1wiKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICBzZWVuID0gcmVzdWx0O1xuXG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICB9XG4gIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgaWYgKHNldCkge1xuICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICB9XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gIH1cbiAgZWxzZSB7XG4gICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5pcTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlVmFsdWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVZhbHVlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheU1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5TWFwICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlNYXAuanNcIik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VWYWx1ZXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVppcE9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VaaXBPYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoaXMgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy56aXBPYmplY3RgIHdoaWNoIGFzc2lnbnMgdmFsdWVzIHVzaW5nIGBhc3NpZ25GdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25GdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVppcE9iamVjdChwcm9wcywgdmFsdWVzLCBhc3NpZ25GdW5jKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoLFxuICAgICAgdmFsc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgYXNzaWduRnVuYyhyZXN1bHQsIHByb3BzW2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVppcE9iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jYWNoZUhhcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jYWNoZUhhcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jYXN0RnVuY3Rpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nhc3RGdW5jdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlkZW50aXR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pZGVudGl0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaWRlbnRpdHkuanNcIik7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdEZ1bmN0aW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nhc3RQYXRoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nhc3RQYXRoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpLFxuICAgIGlzS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNLZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0tleS5qc1wiKSxcbiAgICBzdHJpbmdUb1BhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zdHJpbmdUb1BhdGggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdHJpbmdUb1BhdGguanNcIiksXG4gICAgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvU3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC90b1N0cmluZy5qc1wiKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVaW50OEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fVWludDhBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1VpbnQ4QXJyYXkuanNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUFycmF5QnVmZmVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lQnVmZmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lQnVmZmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUpIHt2YXIgcm9vdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3Jvb3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19yb290LmpzXCIpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gIHRydWUgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi9fd2VicGFja0A0LjQyLjFAd2VicGFjay9idWlsZGluL21vZHVsZS5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL193ZWJwYWNrQDQuNDIuMUB3ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzXCIpKG1vZHVsZSkpKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZURhdGFWaWV3LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2xvbmVEYXRhVmlldy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjbG9uZUFycmF5QnVmZmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2xvbmVBcnJheUJ1ZmZlciAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lQXJyYXlCdWZmZXIuanNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEYXRhVmlldztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZVJlZ0V4cC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZVJlZ0V4cC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lUmVnRXhwO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lU3ltYm9sLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lU3ltYm9sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19TeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19TeW1ib2wuanNcIik7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVN5bWJvbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNsb25lQXJyYXlCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jbG9uZUFycmF5QnVmZmVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29tcGFyZUFzY2VuZGluZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvbXBhcmVBc2NlbmRpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzU3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1N5bWJvbC5qc1wiKTtcblxuLyoqXG4gKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXG4gICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG5cbiAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVBc2NlbmRpbmc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29tcGFyZU11bHRpcGxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb21wYXJlTXVsdGlwbGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjb21wYXJlQXNjZW5kaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY29tcGFyZUFzY2VuZGluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvbXBhcmVBc2NlbmRpbmcuanNcIik7XG5cbi8qKlxuICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAqXG4gKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgfVxuICB9XG4gIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZU11bHRpcGxlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvcHlBcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29weUFycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5QXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29weU9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvcHlPYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXNzaWduVmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hc3NpZ25WYWx1ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Fzc2lnblZhbHVlLmpzXCIpLFxuICAgIGJhc2VBc3NpZ25WYWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VBc3NpZ25WYWx1ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qc1wiKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb3B5U3ltYm9scy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb3B5U3ltYm9scy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY29weU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NvcHlPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb3B5T2JqZWN0LmpzXCIpLFxuICAgIGdldFN5bWJvbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRTeW1ib2xzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0U3ltYm9scy5qc1wiKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvcHlTeW1ib2xzSW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNvcHlPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3B5T2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29weU9iamVjdC5qc1wiKSxcbiAgICBnZXRTeW1ib2xzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRTeW1ib2xzSW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRTeW1ib2xzSW4uanNcIik7XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9sc0luO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NvcmVKc0RhdGEuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb3JlSnNEYXRhLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHJvb3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yb290ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fcm9vdC5qc1wiKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NyZWF0ZUFzc2lnbmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlUmVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VSZXN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVJlc3QuanNcIiksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pc0l0ZXJhdGVlQ2FsbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYXNzaWduZXIgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAxID8gc291cmNlc1tsZW5ndGggLSAxXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgIGN1c3RvbWl6ZXIgPSAoYXNzaWduZXIubGVuZ3RoID4gMyAmJiB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nKVxuICAgICAgPyAobGVuZ3RoLS0sIGN1c3RvbWl6ZXIpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcbiAgICAgIGxlbmd0aCA9IDE7XG4gICAgfVxuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheUxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXlMaWtlLmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVGaW5kLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY3JlYXRlRmluZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSXRlcmF0ZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXRlcmF0ZWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXRlcmF0ZWUuanNcIiksXG4gICAgaXNBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXlMaWtlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5TGlrZS5qc1wiKSxcbiAgICBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzLmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRmluZDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVSYW5nZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVSYW5nZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZVJhbmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVJhbmdlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVJhbmdlLmpzXCIpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNJdGVyYXRlZUNhbGwgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qc1wiKSxcbiAgICB0b0Zpbml0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG9GaW5pdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3RvRmluaXRlLmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmFuZ2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RhcnQsIGVuZCwgc3RlcCkge1xuICAgIGlmIChzdGVwICYmIHR5cGVvZiBzdGVwICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBFbnN1cmUgdGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZCA/IChzdGFydCA8IGVuZCA/IDEgOiAtMSkgOiB0b0Zpbml0ZShzdGVwKTtcbiAgICByZXR1cm4gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUmFuZ2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY3JlYXRlU2V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVTZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19TZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19TZXQuanNcIiksXG4gICAgbm9vcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbm9vcCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbm9vcC5qc1wiKSxcbiAgICBzZXRUb0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc2V0VG9BcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3NldFRvQXJyYXkuanNcIik7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAqL1xudmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXROYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXROYXRpdmUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXROYXRpdmUuanNcIik7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2VxdWFsQXJyYXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2VxdWFsQXJyYXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTZXRDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1NldENhY2hlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU2V0Q2FjaGUuanNcIiksXG4gICAgYXJyYXlTb21lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXlTb21lICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlTb21lLmpzXCIpLFxuICAgIGNhY2hlSGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2FjaGVIYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jYWNoZUhhcy5qc1wiKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19lcXVhbEJ5VGFnLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZXF1YWxCeVRhZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19TeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19TeW1ib2wuanNcIiksXG4gICAgVWludDhBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX1VpbnQ4QXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19VaW50OEFycmF5LmpzXCIpLFxuICAgIGVxID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lcSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZXEuanNcIiksXG4gICAgZXF1YWxBcnJheXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19lcXVhbEFycmF5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2VxdWFsQXJyYXlzLmpzXCIpLFxuICAgIG1hcFRvQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19tYXBUb0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWFwVG9BcnJheS5qc1wiKSxcbiAgICBzZXRUb0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc2V0VG9BcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3NldFRvQXJyYXkuanNcIik7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19lcXVhbE9iamVjdHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldEFsbEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRBbGxLZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0QWxsS2V5cy5qc1wiKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2ZsYXRSZXN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2ZsYXRSZXN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmbGF0dGVuID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mbGF0dGVuICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9mbGF0dGVuLmpzXCIpLFxuICAgIG92ZXJSZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb3ZlclJlc3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19vdmVyUmVzdC5qc1wiKSxcbiAgICBzZXRUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3NldFRvU3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2V0VG9TdHJpbmcuanNcIik7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0UmVzdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19mcmVlR2xvYmFsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZnJlZUdsb2JhbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLy4uL193ZWJwYWNrQDQuNDIuMUB3ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzICovIFwiLi9ub2RlX21vZHVsZXMvX3dlYnBhY2tANC40Mi4xQHdlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcIikpKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRBbGxLZXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0QWxsS2V5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0QWxsS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VHZXRBbGxLZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUdldEFsbEtleXMuanNcIiksXG4gICAgZ2V0U3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldFN5bWJvbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRTeW1ib2xzLmpzXCIpLFxuICAgIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2tleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2tleXMuanNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRBbGxLZXlzSW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldEFsbEtleXNJbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VHZXRBbGxLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUdldEFsbEtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qc1wiKSxcbiAgICBnZXRTeW1ib2xzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRTeW1ib2xzSW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRTeW1ib2xzSW4uanNcIiksXG4gICAga2V5c0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9rZXlzSW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2tleXNJbi5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzSW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0TWFwRGF0YS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldE1hcERhdGEuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNLZXlhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNLZXlhYmxlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNLZXlhYmxlLmpzXCIpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRNYXRjaERhdGEuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldE1hdGNoRGF0YS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzU3RyaWN0Q29tcGFyYWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzU3RyaWN0Q29tcGFyYWJsZS5qc1wiKSxcbiAgICBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzLmpzXCIpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRjaERhdGE7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0TmF0aXZlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXROYXRpdmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSXNOYXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXNOYXRpdmUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNOYXRpdmUuanNcIiksXG4gICAgZ2V0VmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRWYWx1ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldFZhbHVlLmpzXCIpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRQcm90b3R5cGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldFByb3RvdHlwZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIG92ZXJBcmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vdmVyQXJnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fb3ZlckFyZy5qc1wiKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldFJhd1RhZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0UmF3VGFnLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fU3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU3ltYm9sLmpzXCIpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldFN5bWJvbHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRTeW1ib2xzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5RmlsdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXlGaWx0ZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUZpbHRlci5qc1wiKSxcbiAgICBzdHViQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0dWJBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvc3R1YkFycmF5LmpzXCIpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRTeW1ib2xzSW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5UHVzaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5UHVzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2FycmF5UHVzaC5qc1wiKSxcbiAgICBnZXRQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRQcm90b3R5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRQcm90b3R5cGUuanNcIiksXG4gICAgZ2V0U3ltYm9scyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldFN5bWJvbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRTeW1ib2xzLmpzXCIpLFxuICAgIHN0dWJBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3R1YkFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9zdHViQXJyYXkuanNcIik7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldFRhZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0VGFnLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgRGF0YVZpZXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19EYXRhVmlldyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX0RhdGFWaWV3LmpzXCIpLFxuICAgIE1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX01hcCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX01hcC5qc1wiKSxcbiAgICBQcm9taXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fUHJvbWlzZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX1Byb21pc2UuanNcIiksXG4gICAgU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fU2V0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU2V0LmpzXCIpLFxuICAgIFdlYWtNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19XZWFrTWFwICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fV2Vha01hcC5qc1wiKSxcbiAgICBiYXNlR2V0VGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUdldFRhZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHZXRUYWcuanNcIiksXG4gICAgdG9Tb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190b1NvdXJjZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3RvU291cmNlLmpzXCIpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRWYWx1ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRWYWx1ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19oYXNQYXRoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzUGF0aC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjYXN0UGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Nhc3RQYXRoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2FzdFBhdGguanNcIiksXG4gICAgaXNBcmd1bWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJndW1lbnRzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FyZ3VtZW50cy5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpLFxuICAgIGlzSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pc0luZGV4ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNJbmRleC5qc1wiKSxcbiAgICBpc0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNMZW5ndGggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzTGVuZ3RoLmpzXCIpLFxuICAgIHRvS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG9LZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL190b0tleS5qc1wiKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19oYXNVbmljb2RlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzVW5pY29kZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbnZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1VuaWNvZGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzaENsZWFyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19oYXNoQ2xlYXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBuYXRpdmVDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19uYXRpdmVDcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19uYXRpdmVDcmVhdGUuanNcIik7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19oYXNoRGVsZXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzaERlbGV0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19oYXNoR2V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzaEdldC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBuYXRpdmVDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19uYXRpdmVDcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19uYXRpdmVDcmVhdGUuanNcIik7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2hhc2hIYXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19oYXNoSGFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIG5hdGl2ZUNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX25hdGl2ZUNyZWF0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qc1wiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzaFNldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2hhc2hTZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgbmF0aXZlQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbmF0aXZlQ3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzXCIpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2luaXRDbG9uZUFycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2luaXRDbG9uZUFycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faW5pdENsb25lQnlUYWcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faW5pdENsb25lQnlUYWcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNsb25lQXJyYXlCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jbG9uZUFycmF5QnVmZmVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qc1wiKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2xvbmVEYXRhVmlldyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lRGF0YVZpZXcuanNcIiksXG4gICAgY2xvbmVSZWdFeHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jbG9uZVJlZ0V4cCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nsb25lUmVnRXhwLmpzXCIpLFxuICAgIGNsb25lU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2xvbmVTeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZVN5bWJvbC5qc1wiKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jbG9uZVR5cGVkQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanNcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VDcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQ3JlYXRlLmpzXCIpLFxuICAgIGdldFByb3RvdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldFByb3RvdHlwZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldFByb3RvdHlwZS5qc1wiKSxcbiAgICBpc1Byb3RvdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzUHJvdG90eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNQcm90b3R5cGUuanNcIik7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNGbGF0dGVuYWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fU3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fU3ltYm9sLmpzXCIpLFxuICAgIGlzQXJndW1lbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FyZ3VtZW50cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcmd1bWVudHMuanNcIiksXG4gICAgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheS5qc1wiKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNJbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBlcSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXEgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2VxLmpzXCIpLFxuICAgIGlzQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5TGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheUxpa2UuanNcIiksXG4gICAgaXNJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzSW5kZXggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0luZGV4LmpzXCIpLFxuICAgIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3QuanNcIik7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0tleS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0tleS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheS5qc1wiKSxcbiAgICBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNTeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzU3ltYm9sLmpzXCIpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNLZXlhYmxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0tleWFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNNYXNrZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNNYXNrZWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNvcmVKc0RhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3JlSnNEYXRhICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fY29yZUpzRGF0YS5qc1wiKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc1Byb3RvdHlwZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc1Byb3RvdHlwZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0LmpzXCIpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFzc29jSW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Fzc29jSW5kZXhPZiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Fzc29jSW5kZXhPZi5qc1wiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19saXN0Q2FjaGVHZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFzc29jSW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Fzc29jSW5kZXhPZiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Fzc29jSW5kZXhPZi5qc1wiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbGlzdENhY2hlSGFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19saXN0Q2FjaGVIYXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhc3NvY0luZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hc3NvY0luZGV4T2YgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc3NvY0luZGV4T2YuanNcIik7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19saXN0Q2FjaGVTZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFzc29jSW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Fzc29jSW5kZXhPZiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Fzc29jSW5kZXhPZi5qc1wiKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBIYXNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fSGFzaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX0hhc2guanNcIiksXG4gICAgTGlzdENhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fTGlzdENhY2hlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fTGlzdENhY2hlLmpzXCIpLFxuICAgIE1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX01hcCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX01hcC5qc1wiKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlQ2xlYXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldE1hcERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRNYXBEYXRhICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0TWFwRGF0YS5qc1wiKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWFwQ2FjaGVHZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWFwQ2FjaGVHZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldE1hcERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRNYXBEYXRhICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0TWFwRGF0YS5qc1wiKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcENhY2hlSGFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcENhY2hlSGFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRNYXBEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0TWFwRGF0YSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldE1hcERhdGEuanNcIik7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWFwQ2FjaGVTZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWFwQ2FjaGVTZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldE1hcERhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRNYXBEYXRhICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0TWFwRGF0YS5qc1wiKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hcFRvQXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19tYXBUb0FycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBtZW1vaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9tZW1vaXplICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9tZW1vaXplLmpzXCIpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19uYXRpdmVDcmVhdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdldE5hdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dldE5hdGl2ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2dldE5hdGl2ZS5qc1wiKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbmF0aXZlS2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX25hdGl2ZUtleXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgb3ZlckFyZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX292ZXJBcmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19vdmVyQXJnLmpzXCIpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19uYXRpdmVLZXlzSW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5c0luO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX25vZGVVdGlsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX25vZGVVdGlsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUpIHt2YXIgZnJlZUdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2ZyZWVHbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19mcmVlR2xvYmFsLmpzXCIpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gIHRydWUgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi9fd2VicGFja0A0LjQyLjFAd2VicGFjay9idWlsZGluL21vZHVsZS5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL193ZWJwYWNrQDQuNDIuMUB3ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzXCIpKG1vZHVsZSkpKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19vYmplY3RUb1N0cmluZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvYmplY3RUb1N0cmluZztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19vdmVyQXJnLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fb3ZlckFyZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJBcmc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fb3ZlclJlc3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fb3ZlclJlc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFwcGx5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXBwbHkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcHBseS5qc1wiKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19yb290LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fcm9vdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmcmVlR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZnJlZUdsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2ZyZWVHbG9iYWwuanNcIik7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3NhZmVHZXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zYWZlR2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICBpZiAoa2V5ID09PSAnY29uc3RydWN0b3InICYmIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2FmZUdldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zZXRDYWNoZUFkZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zZXRDYWNoZUFkZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zZXRDYWNoZUhhcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zZXRDYWNoZUhhcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVIYXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2V0VG9BcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3NldFRvQXJyYXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2V0VG9TdHJpbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2V0VG9TdHJpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VTZXRUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VTZXRUb1N0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qc1wiKSxcbiAgICBzaG9ydE91dCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3Nob3J0T3V0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2hvcnRPdXQuanNcIik7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2hvcnRPdXQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc2hvcnRPdXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3N0YWNrQ2xlYXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdGFja0NsZWFyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIExpc3RDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX0xpc3RDYWNoZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX0xpc3RDYWNoZS5qc1wiKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3N0YWNrRGVsZXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3N0YWNrRGVsZXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdGFja0dldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdGFja0dldC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tHZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RhY2tIYXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RhY2tIYXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdGFja1NldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdGFja1NldC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgTGlzdENhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fTGlzdENhY2hlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fTGlzdENhY2hlLmpzXCIpLFxuICAgIE1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX01hcCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX01hcC5qc1wiKSxcbiAgICBNYXBDYWNoZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX01hcENhY2hlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fTWFwQ2FjaGUuanNcIik7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3N0cmljdEluZGV4T2YuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdHJpY3RJbmRleE9mLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmljdEluZGV4T2Y7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RyaW5nU2l6ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3N0cmluZ1NpemUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXNjaWlTaXplID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXNjaWlTaXplICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXNjaWlTaXplLmpzXCIpLFxuICAgIGhhc1VuaWNvZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oYXNVbmljb2RlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faGFzVW5pY29kZS5qc1wiKSxcbiAgICB1bmljb2RlU2l6ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3VuaWNvZGVTaXplICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fdW5pY29kZVNpemUuanNcIik7XG5cbi8qKlxuICogR2V0cyB0aGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1NpemUoc3RyaW5nKSB7XG4gIHJldHVybiBoYXNVbmljb2RlKHN0cmluZylcbiAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcbiAgICA6IGFzY2lpU2l6ZShzdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZ1NpemU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RyaW5nVG9QYXRoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19zdHJpbmdUb1BhdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBtZW1vaXplQ2FwcGVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbWVtb2l6ZUNhcHBlZCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX21lbW9pemVDYXBwZWQuanNcIik7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fdG9LZXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fdG9LZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1N5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNTeW1ib2wuanNcIik7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3RvU291cmNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3RvU291cmNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1NvdXJjZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL191bmljb2RlU2l6ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL191bmljb2RlU2l6ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4vKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xudmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG5mdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICsrcmVzdWx0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pY29kZVNpemU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9jbG9uZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvY2xvbmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUNsb25lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUNsb25lICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUNsb25lLmpzXCIpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvY2xvbmVEZWVwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvY2xvbmVEZWVwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlQ2xvbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlQ2xvbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQ2xvbmUuanNcIik7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZVxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURlZXA7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9jb25zdGFudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvY29uc3RhbnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2RlZmF1bHRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9kZWZhdWx0cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlUmVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VSZXN0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVJlc3QuanNcIiksXG4gICAgZXEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VxICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9lcS5qc1wiKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzSXRlcmF0ZWVDYWxsICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNJdGVyYXRlZUNhbGwuanNcIiksXG4gICAga2V5c0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9rZXlzSW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2tleXNJbi5qc1wiKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG52YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTE7XG4gIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgdmFyIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgIGxlbmd0aCA9IDE7XG4gIH1cblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICB2YXIgcHJvcHMgPSBrZXlzSW4oc291cmNlKTtcbiAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZWFjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9lYWNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZm9yRWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZm9yRWFjaC5qc1wiKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2VxLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9lcS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZmlsdGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZmlsdGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheUZpbHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5RmlsdGVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlGaWx0ZXIuanNcIiksXG4gICAgYmFzZUZpbHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VGaWx0ZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRmlsdGVyLmpzXCIpLFxuICAgIGJhc2VJdGVyYXRlZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VJdGVyYXRlZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICogQHNlZSBfLnJlamVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9maW5kLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2ZpbmQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjcmVhdGVGaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY3JlYXRlRmluZCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NyZWF0ZUZpbmQuanNcIiksXG4gICAgZmluZEluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9maW5kSW5kZXggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2ZpbmRJbmRleC5qc1wiKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKi9cbnZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9maW5kSW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9maW5kSW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VGaW5kSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlRmluZEluZGV4ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZpbmRJbmRleC5qc1wiKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXRlcmF0ZWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXRlcmF0ZWUuanNcIiksXG4gICAgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90b0ludGVnZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3RvSW50ZWdlci5qc1wiKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kSW5kZXg7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9mbGF0dGVuLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2ZsYXR0ZW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlRmxhdHRlbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VGbGF0dGVuICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZsYXR0ZW4uanNcIik7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9mb3JFYWNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2ZvckVhY2guanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheUVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hcnJheUVhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUVhY2guanNcIiksXG4gICAgYmFzZUVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlRWFjaCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VFYWNoLmpzXCIpLFxuICAgIGNhc3RGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Nhc3RGdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Nhc3RGdW5jdGlvbi5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogKipOb3RlOioqIEFzIHdpdGggb3RoZXIgXCJDb2xsZWN0aW9uc1wiIG1ldGhvZHMsIG9iamVjdHMgd2l0aCBhIFwibGVuZ3RoXCJcbiAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBlYWNoXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqIEBzZWUgXy5mb3JFYWNoUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5mb3JFYWNoKFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzIGAxYCB0aGVuIGAyYC5cbiAqXG4gKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZm9ySW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2ZvckluLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VGb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlRm9yICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZvci5qc1wiKSxcbiAgICBjYXN0RnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jYXN0RnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jYXN0RnVuY3Rpb24uanNcIiksXG4gICAga2V5c0luID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9rZXlzSW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2tleXNJbi5qc1wiKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW5cbiAqIG9iamVjdCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXRcbiAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4zLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uZm9ySW5SaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmZvckluKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgY29uc29sZS5sb2coa2V5KTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyAnYScsICdiJywgdGhlbiAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gKi9cbmZ1bmN0aW9uIGZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgPyBvYmplY3RcbiAgICA6IGJhc2VGb3Iob2JqZWN0LCBjYXN0RnVuY3Rpb24oaXRlcmF0ZWUpLCBrZXlzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckluO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZ2V0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvZ2V0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlR2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUdldCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHZXQuanNcIik7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9oYXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9oYXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSGFzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUhhcy5qc1wiKSxcbiAgICBoYXNQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGFzUGF0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2hhc1BhdGguanNcIik7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IDIgfSB9O1xuICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG90aGVyLCAnYScpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2hhc0luLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9oYXNJbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSGFzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSGFzSW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSGFzSW4uanNcIiksXG4gICAgaGFzUGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hhc1BhdGggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19oYXNQYXRoLmpzXCIpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pZGVudGl0eS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaWRlbnRpdHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcmd1bWVudHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJndW1lbnRzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VJc0FyZ3VtZW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VJc0FyZ3VtZW50cyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qc1wiKSxcbiAgICBpc09iamVjdExpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzT2JqZWN0TGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3RMaWtlLmpzXCIpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXlMaWtlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5TGlrZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0Z1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0Z1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0Z1bmN0aW9uLmpzXCIpLFxuICAgIGlzTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0xlbmd0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNMZW5ndGguanNcIik7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheUxpa2VPYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5TGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheUxpa2UuanNcIiksXG4gICAgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdExpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1wiKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNCdWZmZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQnVmZmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKG1vZHVsZSkge3ZhciByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcm9vdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3Jvb3QuanNcIiksXG4gICAgc3R1YkZhbHNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdHViRmFsc2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3N0dWJGYWxzZS5qc1wiKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9ICB0cnVlICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi9fd2VicGFja0A0LjQyLjFAd2VicGFjay9idWlsZGluL21vZHVsZS5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL193ZWJwYWNrQDQuNDIuMUB3ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzXCIpKG1vZHVsZSkpKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzRW1wdHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNFbXB0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlS2V5cy5qc1wiKSxcbiAgICBnZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRUYWcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRUYWcuanNcIiksXG4gICAgaXNBcmd1bWVudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJndW1lbnRzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FyZ3VtZW50cy5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpLFxuICAgIGlzQXJyYXlMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5TGlrZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNBcnJheUxpa2UuanNcIiksXG4gICAgaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQnVmZmVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0J1ZmZlci5qc1wiKSxcbiAgICBpc1Byb3RvdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzUHJvdG90eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNQcm90b3R5cGUuanNcIiksXG4gICAgaXNUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1R5cGVkQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzVHlwZWRBcnJheS5qc1wiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gKlxuICogT2JqZWN0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgbm8gb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkXG4gKiBwcm9wZXJ0aWVzLlxuICpcbiAqIEFycmF5LWxpa2UgdmFsdWVzIHN1Y2ggYXMgYGFyZ3VtZW50c2Agb2JqZWN0cywgYXJyYXlzLCBidWZmZXJzLCBzdHJpbmdzLCBvclxuICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0VtcHR5KG51bGwpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSh0cnVlKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoMSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNFbXB0eSh7ICdhJzogMSB9KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gIH1cbiAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gIH1cbiAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgIHJldHVybiAhYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VtcHR5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNGdW5jdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0Z1bmN0aW9uLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VHZXRUYWcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR2V0VGFnLmpzXCIpLFxuICAgIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3QuanNcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzTGVuZ3RoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0xlbmd0aC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzTWFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc01hcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlSXNNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXNNYXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNNYXAuanNcIiksXG4gICAgYmFzZVVuYXJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVVuYXJ5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVVuYXJ5LmpzXCIpLFxuICAgIG5vZGVVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbm9kZVV0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19ub2RlVXRpbC5qc1wiKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNNYXAobmV3IE1hcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc01hcDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3RMaWtlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3RMaWtlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzUGxhaW5PYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNQbGFpbk9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VHZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlR2V0VGFnICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUdldFRhZy5qc1wiKSxcbiAgICBnZXRQcm90b3R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRQcm90b3R5cGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRQcm90b3R5cGUuanNcIiksXG4gICAgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdExpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1wiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1NldC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNTZXQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUlzU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUlzU2V0ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUlzU2V0LmpzXCIpLFxuICAgIGJhc2VVbmFyeSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VVbmFyeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VVbmFyeS5qc1wiKSxcbiAgICBub2RlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX25vZGVVdGlsICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbm9kZVV0aWwuanNcIik7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU2V0KG5ldyBTZXQpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTZXQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1N0cmluZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNTdHJpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VHZXRUYWcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR2V0VGFnLmpzXCIpLFxuICAgIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXkuanNcIiksXG4gICAgaXNPYmplY3RMaWtlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdExpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzT2JqZWN0TGlrZS5qc1wiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpbmc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1N5bWJvbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNTeW1ib2wuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUdldFRhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VHZXRUYWcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlR2V0VGFnLmpzXCIpLFxuICAgIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNPYmplY3RMaWtlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc09iamVjdExpa2UuanNcIik7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzVHlwZWRBcnJheS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzVHlwZWRBcnJheS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUlzVHlwZWRBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VJc1R5cGVkQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzXCIpLFxuICAgIGJhc2VVbmFyeSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VVbmFyeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VVbmFyeS5qc1wiKSxcbiAgICBub2RlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX25vZGVVdGlsICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fbm9kZVV0aWwuanNcIik7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZWRBcnJheTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzVW5kZWZpbmVkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1VuZGVmaW5lZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1VuZGVmaW5lZDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2tleXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gva2V5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5TGlrZUtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hcnJheUxpa2VLZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYXJyYXlMaWtlS2V5cy5qc1wiKSxcbiAgICBiYXNlS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VLZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUtleXMuanNcIiksXG4gICAgaXNBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXlMaWtlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5TGlrZS5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2tleXNJbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2tleXNJbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYXJyYXlMaWtlS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5TGlrZUtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzXCIpLFxuICAgIGJhc2VLZXlzSW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlS2V5c0luICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUtleXNJbi5qc1wiKSxcbiAgICBpc0FycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheUxpa2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXlMaWtlLmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9sYXN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2xhc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogR2V0cyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubGFzdChbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiBsYXN0KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxhc3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9tYXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9tYXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5TWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXlNYXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheU1hcC5qc1wiKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXRlcmF0ZWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXRlcmF0ZWUuanNcIiksXG4gICAgYmFzZU1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VNYXAgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTWFwLmpzXCIpLFxuICAgIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXkuanNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnVcbiAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gKlxuICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICogYGZpbGxgLCBgaW52ZXJ0YCwgYHBhcnNlSW50YCwgYHJhbmRvbWAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlcGVhdGAsXG4gKiBgc2FtcGxlU2l6ZWAsIGBzbGljZWAsIGBzb21lYCwgYHNvcnRCeWAsIGBzcGxpdGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICogICByZXR1cm4gbiAqIG47XG4gKiB9XG4gKlxuICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF1cbiAqXG4gKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gKiAvLyA9PiBbMTYsIDY0XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICogXTtcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gKi9cbmZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL21hcFZhbHVlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL21hcFZhbHVlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUFzc2lnblZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUFzc2lnblZhbHVlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzXCIpLFxuICAgIGJhc2VGb3JPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlRm9yT3duICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZvck93bi5qc1wiKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXRlcmF0ZWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXRlcmF0ZWUuanNcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gKiBAc2VlIF8ubWFwS2V5c1xuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSB7XG4gKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICogfTtcbiAqXG4gKiBfLm1hcFZhbHVlcyh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2U7IH0pO1xuICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFZhbHVlcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL21heC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL21heC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUV4dHJlbXVtID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUV4dHJlbXVtICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUV4dHJlbXVtLmpzXCIpLFxuICAgIGJhc2VHdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VHdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VHdC5qc1wiKSxcbiAgICBpZGVudGl0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaWRlbnRpdHkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lkZW50aXR5LmpzXCIpO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAqIC8vID0+IDhcbiAqXG4gKiBfLm1heChbXSk7XG4gKiAvLyA9PiB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gbWF4KGFycmF5KSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUd0KVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1heDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL21lbW9pemUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWVtb2l6ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIE1hcENhY2hlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fTWFwQ2FjaGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19NYXBDYWNoZS5qc1wiKTtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9tZXJnZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWVyZ2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZU1lcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZU1lcmdlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZU1lcmdlLmpzXCIpLFxuICAgIGNyZWF0ZUFzc2lnbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY3JlYXRlQXNzaWduZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jcmVhdGVBc3NpZ25lci5qc1wiKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7XG4gKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gKiB9O1xuICpcbiAqIHZhciBvdGhlciA9IHtcbiAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAqIH07XG4gKlxuICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAqL1xudmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVyZ2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9taW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9taW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VFeHRyZW11bSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VFeHRyZW11bSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VFeHRyZW11bS5qc1wiKSxcbiAgICBiYXNlTHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlTHQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTHQuanNcIiksXG4gICAgaWRlbnRpdHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lkZW50aXR5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pZGVudGl0eS5qc1wiKTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gKiAvLyA9PiAyXG4gKlxuICogXy5taW4oW10pO1xuICogLy8gPT4gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIG1pbihhcnJheSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VMdClcbiAgICA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtaW47XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9taW5CeS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbWluQnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZUV4dHJlbXVtID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUV4dHJlbXVtICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUV4dHJlbXVtLmpzXCIpLFxuICAgIGJhc2VJdGVyYXRlZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VJdGVyYXRlZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qc1wiKSxcbiAgICBiYXNlTHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlTHQgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlTHQuanNcIik7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5taW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gKlxuICogXy5taW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICogLy8gPT4geyAnbic6IDEgfVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5taW5CeShvYmplY3RzLCAnbicpO1xuICogLy8gPT4geyAnbic6IDEgfVxuICovXG5mdW5jdGlvbiBtaW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VMdClcbiAgICA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtaW5CeTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL25vb3AuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbm9vcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub29wO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbm93LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvbm93LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciByb290ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcm9vdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3Jvb3QuanNcIik7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm93O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvcGljay5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9waWNrLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZVBpY2sgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlUGljayAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VQaWNrLmpzXCIpLFxuICAgIGZsYXRSZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZmxhdFJlc3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19mbGF0UmVzdC5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAqXG4gKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG52YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBpY2s7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9wcm9wZXJ0eS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvcHJvcGVydHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYmFzZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVByb3BlcnR5LmpzXCIpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlUHJvcGVydHlEZWVwICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qc1wiKSxcbiAgICBpc0tleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzS2V5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9faXNLZXkuanNcIiksXG4gICAgdG9LZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190b0tleSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX3RvS2V5LmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9yYW5nZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvcmFuZ2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY3JlYXRlUmFuZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jcmVhdGVSYW5nZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2NyZWF0ZVJhbmdlLmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICogYHN0YXJ0YCBpcyBzcGVjaWZpZWQgd2l0aG91dCBhbiBgZW5kYCBvciBgc3RlcGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsXG4gKiBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gKlxuICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5yYW5nZSg0KTtcbiAqIC8vID0+IFswLCAxLCAyLCAzXVxuICpcbiAqIF8ucmFuZ2UoLTQpO1xuICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gKlxuICogXy5yYW5nZSgxLCA1KTtcbiAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICpcbiAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAqXG4gKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAqXG4gKiBfLnJhbmdlKDEsIDQsIDApO1xuICogLy8gPT4gWzEsIDEsIDFdXG4gKlxuICogXy5yYW5nZSgwKTtcbiAqIC8vID0+IFtdXG4gKi9cbnZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmFuZ2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9yZWR1Y2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9yZWR1Y2UuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5UmVkdWNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXlSZWR1Y2UgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheVJlZHVjZS5qc1wiKSxcbiAgICBiYXNlRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VFYWNoICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUVhY2guanNcIiksXG4gICAgYmFzZUl0ZXJhdGVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUl0ZXJhdGVlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzXCIpLFxuICAgIGJhc2VSZWR1Y2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlUmVkdWNlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVJlZHVjZS5qc1wiKSxcbiAgICBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0FycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5LmpzXCIpO1xuXG4vKipcbiAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gKiBhbmQgYHNvcnRCeWBcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIF8ucmVkdWNlUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAqICAgcmV0dXJuIHN1bSArIG47XG4gKiB9LCAwKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gKiAgIHJldHVybiByZXN1bHQ7XG4gKiB9LCB7fSk7XG4gKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxuICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZHVjZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3NpemUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvc2l6ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlS2V5cy5qc1wiKSxcbiAgICBnZXRUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nZXRUYWcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19nZXRUYWcuanNcIiksXG4gICAgaXNBcnJheUxpa2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXlMaWtlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0FycmF5TGlrZS5qc1wiKSxcbiAgICBpc1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNTdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzU3RyaW5nLmpzXCIpLFxuICAgIHN0cmluZ1NpemUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zdHJpbmdTaXplICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fc3RyaW5nU2l6ZS5qc1wiKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICogLy8gPT4gMlxuICpcbiAqIF8uc2l6ZSgncGViYmxlcycpO1xuICogLy8gPT4gN1xuICovXG5mdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgfVxuICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNpemU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9zb3J0QnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9zb3J0QnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VGbGF0dGVuID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZUZsYXR0ZW4gKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlRmxhdHRlbi5qc1wiKSxcbiAgICBiYXNlT3JkZXJCeSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VPcmRlckJ5ICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZU9yZGVyQnkuanNcIiksXG4gICAgYmFzZVJlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlUmVzdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VSZXN0LmpzXCIpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXNJdGVyYXRlZUNhbGwgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qc1wiKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gKiBdO1xuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAqXG4gKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXSwgWydmcmVkJywgNDhdXVxuICovXG52YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtdO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcbiAgfVxuICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgW10pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc29ydEJ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvc3R1YkFycmF5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvc3R1YkFycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvc3R1YkZhbHNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvc3R1YkZhbHNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC90b0Zpbml0ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdG9GaW5pdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9OdW1iZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RvTnVtYmVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC90b051bWJlci5qc1wiKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9GaW5pdGUoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgfVxuICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9GaW5pdGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC90b0ludGVnZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC90b0ludGVnZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvRmluaXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90b0Zpbml0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdG9GaW5pdGUuanNcIik7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9JbnRlZ2VyKDMuMik7XG4gKiAvLyA9PiAzXG4gKlxuICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiAwXG4gKlxuICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9JbnRlZ2VyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdG9OdW1iZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3RvTnVtYmVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3QuanNcIiksXG4gICAgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzU3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc1N5bWJvbC5qc1wiKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdG9QbGFpbk9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC90b1BsYWluT2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY29weU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NvcHlPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19jb3B5T2JqZWN0LmpzXCIpLFxuICAgIGtleXNJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4va2V5c0luICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzSW4uanNcIik7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICpcbiAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1BsYWluT2JqZWN0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdG9TdHJpbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3RvU3RyaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VUb1N0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VUb1N0cmluZy5qc1wiKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdHJhbnNmb3JtLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvdHJhbnNmb3JtLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhcnJheUVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hcnJheUVhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hcnJheUVhY2guanNcIiksXG4gICAgYmFzZUNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VDcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlQ3JlYXRlLmpzXCIpLFxuICAgIGJhc2VGb3JPd24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlRm9yT3duICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZvck93bi5qc1wiKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlSXRlcmF0ZWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlSXRlcmF0ZWUuanNcIiksXG4gICAgZ2V0UHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2V0UHJvdG90eXBlICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fZ2V0UHJvdG90eXBlLmpzXCIpLFxuICAgIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXkuanNcIiksXG4gICAgaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2lzQnVmZmVyICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0J1ZmZlci5qc1wiKSxcbiAgICBpc0Z1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc0Z1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9pc0Z1bmN0aW9uLmpzXCIpLFxuICAgIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc09iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvaXNPYmplY3QuanNcIiksXG4gICAgaXNUeXBlZEFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pc1R5cGVkQXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzVHlwZWRBcnJheS5qc1wiKTtcblxuLyoqXG4gKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gKiBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIHRocnUgYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb25cbiAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gSWYgYGFjY3VtdWxhdG9yYCBpcyBub3RcbiAqIHByb3ZpZGVkLCBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBgW1tQcm90b3R5cGVdXWAgd2lsbCBiZSB1c2VkLiBUaGVcbiAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4zLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xuICogICByZXN1bHQucHVzaChuICo9IG4pO1xuICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAqIH0sIFtdKTtcbiAqIC8vID0+IFs0LCA5XVxuICpcbiAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAqIH0sIHt9KTtcbiAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIGlzQXJyTGlrZSA9IGlzQXJyIHx8IGlzQnVmZmVyKG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG5cbiAgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDQpO1xuICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoaXNBcnJMaWtlKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGlzQXJyID8gbmV3IEN0b3IgOiBbXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpc0Z1bmN0aW9uKEN0b3IpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhY2N1bXVsYXRvciA9IHt9O1xuICAgIH1cbiAgfVxuICAoaXNBcnJMaWtlID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICB9KTtcbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3VuaW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC91bmlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiYXNlRmxhdHRlbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Jhc2VGbGF0dGVuICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZUZsYXR0ZW4uanNcIiksXG4gICAgYmFzZVJlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlUmVzdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VSZXN0LmpzXCIpLFxuICAgIGJhc2VVbmlxID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVVuaXEgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19iYXNlVW5pcS5qc1wiKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vaXNBcnJheUxpa2VPYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqL1xudmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmlvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3VuaXF1ZUlkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC91bmlxdWVJZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdG9TdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL3RvU3RyaW5nLmpzXCIpO1xuXG4vKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xudmFyIGlkQ291bnRlciA9IDA7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAqXG4gKiBfLnVuaXF1ZUlkKCk7XG4gKiAvLyA9PiAnMTA1J1xuICovXG5mdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlSWQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC92YWx1ZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC92YWx1ZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJhc2VWYWx1ZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19iYXNlVmFsdWVzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9fYmFzZVZhbHVlcy5qc1wiKSxcbiAgICBrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC9rZXlzLmpzXCIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWx1ZXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC96aXBPYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX2xvZGFzaEA0LjE3LjE1QGxvZGFzaC96aXBPYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFzc2lnblZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXNzaWduVmFsdWUgKi8gXCIuL25vZGVfbW9kdWxlcy9fbG9kYXNoQDQuMTcuMTVAbG9kYXNoL19hc3NpZ25WYWx1ZS5qc1wiKSxcbiAgICBiYXNlWmlwT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmFzZVppcE9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL19sb2Rhc2hANC4xNy4xNUBsb2Rhc2gvX2Jhc2VaaXBPYmplY3QuanNcIik7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mcm9tUGFpcnNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgdHdvIGFycmF5cyxcbiAqIG9uZSBvZiBwcm9wZXJ0eSBpZGVudGlmaWVycyBhbmQgb25lIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC40LjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzPVtdXSBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy56aXBPYmplY3QoWydhJywgJ2InXSwgWzEsIDJdKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG5mdW5jdGlvbiB6aXBPYmplY3QocHJvcHMsIHZhbHVlcykge1xuICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBhc3NpZ25WYWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gemlwT2JqZWN0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19wYXJzZS1zdmctcGF0aEAwLjEuMkBwYXJzZS1zdmctcGF0aC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX3BhcnNlLXN2Zy1wYXRoQDAuMS4yQHBhcnNlLXN2Zy1wYXRoL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VcblxuLyoqXG4gKiBleHBlY3RlZCBhcmd1bWVudCBsZW5ndGhzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbnZhciBsZW5ndGggPSB7YTogNywgYzogNiwgaDogMSwgbDogMiwgbTogMiwgcTogNCwgczogNCwgdDogMiwgdjogMSwgejogMH1cblxuLyoqXG4gKiBzZWdtZW50IHBhdHRlcm5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cblxudmFyIHNlZ21lbnQgPSAvKFthc3R2enFtaGxjXSkoW15hc3R2enFtaGxjXSopL2lnXG5cbi8qKlxuICogcGFyc2UgYW4gc3ZnIHBhdGggZGF0YSBzdHJpbmcuIEdlbmVyYXRlcyBhbiBBcnJheVxuICogb2YgY29tbWFuZHMgd2hlcmUgZWFjaCBjb21tYW5kIGlzIGFuIEFycmF5IG9mIHRoZVxuICogZm9ybSBgW2NvbW1hbmQsIGFyZzEsIGFyZzIsIC4uLl1gXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcblx0dmFyIGRhdGEgPSBbXVxuXHRwYXRoLnJlcGxhY2Uoc2VnbWVudCwgZnVuY3Rpb24oXywgY29tbWFuZCwgYXJncyl7XG5cdFx0dmFyIHR5cGUgPSBjb21tYW5kLnRvTG93ZXJDYXNlKClcblx0XHRhcmdzID0gcGFyc2VWYWx1ZXMoYXJncylcblxuXHRcdC8vIG92ZXJsb2FkZWQgbW92ZVRvXG5cdFx0aWYgKHR5cGUgPT0gJ20nICYmIGFyZ3MubGVuZ3RoID4gMikge1xuXHRcdFx0ZGF0YS5wdXNoKFtjb21tYW5kXS5jb25jYXQoYXJncy5zcGxpY2UoMCwgMikpKVxuXHRcdFx0dHlwZSA9ICdsJ1xuXHRcdFx0Y29tbWFuZCA9IGNvbW1hbmQgPT0gJ20nID8gJ2wnIDogJ0wnXG5cdFx0fVxuXG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdGlmIChhcmdzLmxlbmd0aCA9PSBsZW5ndGhbdHlwZV0pIHtcblx0XHRcdFx0YXJncy51bnNoaWZ0KGNvbW1hbmQpXG5cdFx0XHRcdHJldHVybiBkYXRhLnB1c2goYXJncylcblx0XHRcdH1cblx0XHRcdGlmIChhcmdzLmxlbmd0aCA8IGxlbmd0aFt0eXBlXSkgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgcGF0aCBkYXRhJylcblx0XHRcdGRhdGEucHVzaChbY29tbWFuZF0uY29uY2F0KGFyZ3Muc3BsaWNlKDAsIGxlbmd0aFt0eXBlXSkpKVxuXHRcdH1cblx0fSlcblx0cmV0dXJuIGRhdGFcbn1cblxudmFyIG51bWJlciA9IC8tP1swLTldKlxcLj9bMC05XSsoPzplWy0rXT9cXGQrKT8vaWdcblxuZnVuY3Rpb24gcGFyc2VWYWx1ZXMoYXJncykge1xuXHR2YXIgbnVtYmVycyA9IGFyZ3MubWF0Y2gobnVtYmVyKVxuXHRyZXR1cm4gbnVtYmVycyA/IG51bWJlcnMubWFwKE51bWJlcikgOiBbXVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19wb2ludC1hdC1sZW5ndGhAMS4xLjBAcG9pbnQtYXQtbGVuZ3RoL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL19wb2ludC1hdC1sZW5ndGhAMS4xLjBAcG9pbnQtYXQtbGVuZ3RoL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHBhcnNlLXN2Zy1wYXRoICovIFwiLi9ub2RlX21vZHVsZXMvX3BhcnNlLXN2Zy1wYXRoQDAuMS4yQHBhcnNlLXN2Zy1wYXRoL2luZGV4LmpzXCIpO1xyXG52YXIgaXNhcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGlzYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9faXNhcnJheUAwLjAuMUBpc2FycmF5L2luZGV4LmpzXCIpO1xyXG52YXIgYWJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgYWJzLXN2Zy1wYXRoICovIFwiLi9ub2RlX21vZHVsZXMvX2Ficy1zdmctcGF0aEAwLjEuMUBhYnMtc3ZnLXBhdGgvaW5kZXguanNcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50cztcclxuXHJcbmZ1bmN0aW9uIFBvaW50cyAocGF0aCkge1xyXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBvaW50cykpIHJldHVybiBuZXcgUG9pbnRzKHBhdGgpO1xyXG4gICAgdGhpcy5fcGF0aCA9IGlzYXJyYXkocGF0aCkgPyBwYXRoIDogcGFyc2UocGF0aCk7XHJcbiAgICB0aGlzLl9wYXRoID0gYWJzKHRoaXMuX3BhdGgpO1xyXG4gICAgdGhpcy5fcGF0aCA9IHp2aFRvTCh0aGlzLl9wYXRoKTtcclxuICAgIHRoaXMuX3BhdGggPSBsb25naGFuZCh0aGlzLl9wYXRoKTtcclxufVxyXG5cclxuUG9pbnRzLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChwb3MsIG9wdHMpIHtcclxuICAgIHJldHVybiB0aGlzLl93YWxrKHBvcywgb3B0cykucG9zO1xyXG59O1xyXG5cclxuUG9pbnRzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fd2FsayhudWxsKS5sZW5ndGg7XHJcbn07XHJcblxyXG5Qb2ludHMucHJvdG90eXBlLl93YWxrID0gZnVuY3Rpb24gKHBvcywgb3B0cykge1xyXG4gICAgdmFyIGN1ciA9IFsgMCwgMCBdO1xyXG4gICAgdmFyIHByZXYgPSBbIDAsIDAsIDAgXTtcclxuICAgIHZhciBwMCA9IFsgMCwgMCBdO1xyXG4gICAgdmFyIGxlbiA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wYXRoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHAgPSB0aGlzLl9wYXRoW2ldO1xyXG4gICAgICAgIGlmIChwWzBdID09PSAnTScpIHtcclxuICAgICAgICAgICAgY3VyWzBdID0gcFsxXTtcclxuICAgICAgICAgICAgY3VyWzFdID0gcFsyXTtcclxuICAgICAgICAgICAgaWYgKHBvcyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbGVuZ3RoOiBsZW4sIHBvczogY3VyIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocFswXSA9PT0gJ0MnKSB7XHJcbiAgICAgICAgICAgIHByZXZbMF0gPSBwMFswXSA9IGN1clswXTtcclxuICAgICAgICAgICAgcHJldlsxXSA9IHAwWzFdID0gY3VyWzFdO1xyXG4gICAgICAgICAgICBwcmV2WzJdID0gbGVuO1xyXG5cclxuICAgICAgICAgICAgdmFyIG4gPSAxMDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDw9IG47IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHQgPSBqIC8gbjtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0geG9mX0MocCwgdCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHlvZl9DKHAsIHQpO1xyXG4gICAgICAgICAgICAgICAgbGVuICs9IGRpc3QoY3VyWzBdLCBjdXJbMV0sIHgsIHkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGN1clswXSA9IHg7XHJcbiAgICAgICAgICAgICAgICBjdXJbMV0gPSB5O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zID09PSAnbnVtYmVyJyAmJiBsZW4gPj0gcG9zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR2ID0gKGxlbiAtIHBvcykgLyAobGVuIC0gcHJldlsyXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBucG9zID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJbMF0gKiAoMSAtIGR2KSArIHByZXZbMF0gKiBkdixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyWzFdICogKDEgLSBkdikgKyBwcmV2WzFdICogZHZcclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxlbmd0aDogbGVuLCBwb3M6IG5wb3MgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByZXZbMF0gPSBjdXJbMF07XHJcbiAgICAgICAgICAgICAgICBwcmV2WzFdID0gY3VyWzFdO1xyXG4gICAgICAgICAgICAgICAgcHJldlsyXSA9IGxlbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwWzBdID09PSAnUScpIHtcclxuICAgICAgICAgICAgcHJldlswXSA9IHAwWzBdID0gY3VyWzBdO1xyXG4gICAgICAgICAgICBwcmV2WzFdID0gcDBbMV0gPSBjdXJbMV07XHJcbiAgICAgICAgICAgIHByZXZbMl0gPSBsZW47XHJcblxyXG4gICAgICAgICAgICB2YXIgbiA9IDEwMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPD0gbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGogLyBuO1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSB4b2ZfUShwLCB0KTtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0geW9mX1EocCwgdCk7XHJcbiAgICAgICAgICAgICAgICBsZW4gKz0gZGlzdChjdXJbMF0sIGN1clsxXSwgeCwgeSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY3VyWzBdID0geDtcclxuICAgICAgICAgICAgICAgIGN1clsxXSA9IHk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3MgPT09ICdudW1iZXInICYmIGxlbiA+PSBwb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHYgPSAobGVuIC0gcG9zKSAvIChsZW4gLSBwcmV2WzJdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5wb3MgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clswXSAqICgxIC0gZHYpICsgcHJldlswXSAqIGR2LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJbMV0gKiAoMSAtIGR2KSArIHByZXZbMV0gKiBkdlxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGVuZ3RoOiBsZW4sIHBvczogbnBvcyB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJldlswXSA9IGN1clswXTtcclxuICAgICAgICAgICAgICAgIHByZXZbMV0gPSBjdXJbMV07XHJcbiAgICAgICAgICAgICAgICBwcmV2WzJdID0gbGVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBbMF0gPT09ICdMJykge1xyXG4gICAgICAgICAgICBwcmV2WzBdID0gY3VyWzBdO1xyXG4gICAgICAgICAgICBwcmV2WzFdID0gY3VyWzFdO1xyXG4gICAgICAgICAgICBwcmV2WzJdID0gbGVuO1xyXG5cclxuICAgICAgICAgICAgbGVuICAgKz0gZGlzdChjdXJbMF0sIGN1clsxXSwgcFsxXSwgcFsyXSk7XHJcbiAgICAgICAgICAgIGN1clswXSA9IHBbMV07XHJcbiAgICAgICAgICAgIGN1clsxXSA9IHBbMl07XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvcyA9PT0gJ251bWJlcicgJiYgbGVuID49IHBvcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGR2ID0gKGxlbiAtIHBvcykgLyAobGVuIC0gcHJldlsyXSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnBvcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICBjdXJbMF0gKiAoMSAtIGR2KSArIHByZXZbMF0gKiBkdixcclxuICAgICAgICAgICAgICAgICAgICBjdXJbMV0gKiAoMSAtIGR2KSArIHByZXZbMV0gKiBkdlxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGxlbmd0aDogbGVuLCBwb3M6IG5wb3MgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcmV2WzBdID0gY3VyWzBdO1xyXG4gICAgICAgICAgICBwcmV2WzFdID0gY3VyWzFdO1xyXG4gICAgICAgICAgICBwcmV2WzJdID0gbGVuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBsZW5ndGg6IGxlbiwgcG9zOiBjdXIgfTtcclxuICAgIGZ1bmN0aW9uIHhvZl9DIChwLCB0KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KCgxLXQpLCAzKSAqIHAwWzBdXHJcbiAgICAgICAgICAgICsgMyAqIE1hdGgucG93KCgxLXQpLCAyKSAqIHQgKiBwWzFdXHJcbiAgICAgICAgICAgICsgMyAqICgxLXQpICogTWF0aC5wb3codCwgMikgKiBwWzNdXHJcbiAgICAgICAgICAgICsgTWF0aC5wb3codCwgMykgKiBwWzVdXHJcbiAgICAgICAgO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24geW9mX0MgKHAsIHQpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5wb3coKDEtdCksIDMpICogcDBbMV1cclxuICAgICAgICAgICAgKyAzICogTWF0aC5wb3coKDEtdCksIDIpICogdCAqIHBbMl1cclxuICAgICAgICAgICAgKyAzICogKDEtdCkgKiBNYXRoLnBvdyh0LCAyKSAqIHBbNF1cclxuICAgICAgICAgICAgKyBNYXRoLnBvdyh0LCAzKSAqIHBbNl1cclxuICAgICAgICA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24geG9mX1EgKHAsIHQpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5wb3coKDEtdCksIDIpICogcDBbMF1cclxuICAgICAgICAgICAgKyAyICogKDEtdCkgKiB0ICogcFsxXVxyXG4gICAgICAgICAgICArIE1hdGgucG93KHQsIDIpICogcFszXVxyXG4gICAgICAgIDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHlvZl9RIChwLCB0KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KCgxLXQpLCAyKSAqIHAwWzFdXHJcbiAgICAgICAgICAgICsgMiAqICgxLXQpICogdCAqIHBbMl1cclxuICAgICAgICAgICAgKyBNYXRoLnBvdyh0LCAyKSAqIHBbNF1cclxuICAgICAgICA7XHJcbiAgICB9XHJcbn07XHJcblxyXG5mdW5jdGlvbiBkaXN0IChheCwgYXksIGJ4LCBieSkge1xyXG4gICAgdmFyIHggPSBheCAtIGJ4O1xyXG4gICAgdmFyIHkgPSBheSAtIGJ5O1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkpO1xyXG59XHJcblxyXG4vLyBFeHBhbmQgc2hvcnRoYW5kIGN1cnZlIGNvbW1hbmRzIHRvIGZ1bGwgdmVyc2lvbnM7IG11dGF0ZXMgdGhlIHBhdGggaW4gcGxhY2UgZm9yIGVmZmljaWVuY3lcclxuLy8gUmVxdWlyZXMgY29tbWFuZHMgaGF2ZSBhbHJlYWR5IGJlZW4gY29udmVydGVkIHRvIGFic29sdXRlIHZlcnNpb25zXHJcbmZ1bmN0aW9uIGxvbmdoYW5kKHBhdGgpe1xyXG4gICAgdmFyIHByZXYseDE9MCx5MT0wO1xyXG4gICAgdmFyIGNvbnZlcnNpb24gPSB7IFM6e3RvOidDJyx4OjN9LCBUOnt0bzonUScseDoxfSB9O1xyXG4gICAgZm9yKHZhciBpPTAsIGxlbj1wYXRoLmxlbmd0aDsgaTxsZW47IGkrKyl7XHJcbiAgICAgICAgdmFyIGNtZCA9IHBhdGhbaV07XHJcbiAgICAgICAgdmFyIGNvbnZlcnQgPSBjb252ZXJzaW9uW2NtZFswXV07XHJcblxyXG4gICAgICAgIGlmIChjb252ZXJ0KSB7XHJcbiAgICAgICAgICAgIGNtZFswXSA9IGNvbnZlcnQudG87XHJcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldlswXSA9PT0gY29udmVydC50bykge1xyXG4gICAgICAgICAgICAgICAgICAgIHgxID0gMipwcmV2W2NvbnZlcnQueCsyXS1wcmV2W2NvbnZlcnQueCAgXTtcclxuICAgICAgICAgICAgICAgICAgICB5MSA9IDIqcHJldltjb252ZXJ0LngrM10tcHJldltjb252ZXJ0LngrMV07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHgxID0gcHJldltwcmV2Lmxlbmd0aC0yXTtcclxuICAgICAgICAgICAgICAgICAgICB5MSA9IHByZXZbcHJldi5sZW5ndGgtMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY21kLnNwbGljZSgxLDAseDEseTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2PWNtZDtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoO1xyXG59XHJcblxyXG4vLyBDb252ZXJ0ICdaJywgJ1YnIGFuZCAnSCcgc2VnbWVudHMgdG8gJ0wnIHNlZ21lbnRzXHJcbmZ1bmN0aW9uIHp2aFRvTChwYXRoKXtcclxuICAgIHZhciByZXQgPSBbXTtcclxuICAgIHZhciBzdGFydFBvaW50ID0gWydMJywwLDBdO1xyXG4gICAgdmFyIGxhc3RfcG9pbnQ7XHJcblxyXG4gICAgZm9yKHZhciBpPTAsIGxlbj1wYXRoLmxlbmd0aDsgaTxsZW47IGkrKyl7XHJcbiAgICAgICAgdmFyIHB0ID0gcGF0aFtpXTtcclxuICAgICAgICBzd2l0Y2gocHRbMF0pe1xyXG4gICAgICAgICAgICBjYXNlICdNJzpcclxuICAgICAgICAgICAgICAgIHN0YXJ0UG9pbnQgPSBbJ0wnLCBwdFsxXSwgcHRbMl1dO1xyXG4gICAgICAgICAgICAgICAgcmV0LnB1c2gocHQpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ1onOlxyXG4gICAgICAgICAgICAgICAgcmV0LnB1c2goc3RhcnRQb2ludCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnSCc6XHJcbiAgICAgICAgICAgICAgICBsYXN0X3BvaW50ID0gcmV0W3JldC5sZW5ndGggLSAxXSB8fCBbJ0wnLDAsMF07XHJcbiAgICAgICAgICAgICAgICByZXQucHVzaCggWydMJywgcHRbMV0sIGxhc3RfcG9pbnRbbGFzdF9wb2ludC5sZW5ndGggLSAxXV0gKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdWJzpcclxuICAgICAgICAgICAgICAgIGxhc3RfcG9pbnQgPSByZXRbcmV0Lmxlbmd0aCAtIDFdIHx8IFsnTCcsMCwwXTtcclxuICAgICAgICAgICAgICAgIHJldC5wdXNoKCBbJ0wnLCBsYXN0X3BvaW50W2xhc3RfcG9pbnQubGVuZ3RoIC0gMl0sIHB0WzFdXSApO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXQucHVzaChwdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX3JlZ3Jlc3Npb25AMi4wLjFAcmVncmVzc2lvbi9kaXN0L3JlZ3Jlc3Npb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX3JlZ3Jlc3Npb25AMi4wLjFAcmVncmVzc2lvbi9kaXN0L3JlZ3Jlc3Npb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgaWYgKHRydWUpIHtcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbbW9kdWxlXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cblx0XHRcdFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG4gIH0gZWxzZSB7IHZhciBtb2Q7IH1cbn0pKHRoaXMsIGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyMltpXSA9IGFycltpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycjI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gICAgfVxuICB9XG5cbiAgdmFyIERFRkFVTFRfT1BUSU9OUyA9IHsgb3JkZXI6IDIsIHByZWNpc2lvbjogMiwgcGVyaW9kOiBudWxsIH07XG5cbiAgLyoqXG4gICogRGV0ZXJtaW5lIHRoZSBjb2VmZmljaWVudCBvZiBkZXRlcm1pbmF0aW9uIChyXjIpIG9mIGEgZml0IGZyb20gdGhlIG9ic2VydmF0aW9uc1xuICAqIGFuZCBwcmVkaWN0aW9ucy5cbiAgKlxuICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGRhdGEgLSBQYWlycyBvZiBvYnNlcnZlZCB4LXkgdmFsdWVzXG4gICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gcmVzdWx0cyAtIFBhaXJzIG9mIG9ic2VydmVkIHByZWRpY3RlZCB4LXkgdmFsdWVzXG4gICpcbiAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHJeMiB2YWx1ZSwgb3IgTmFOIGlmIG9uZSBjYW5ub3QgYmUgY2FsY3VsYXRlZC5cbiAgKi9cbiAgZnVuY3Rpb24gZGV0ZXJtaW5hdGlvbkNvZWZmaWNpZW50KGRhdGEsIHJlc3VsdHMpIHtcbiAgICB2YXIgcHJlZGljdGlvbnMgPSBbXTtcbiAgICB2YXIgb2JzZXJ2YXRpb25zID0gW107XG5cbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIGlmIChkWzFdICE9PSBudWxsKSB7XG4gICAgICAgIG9ic2VydmF0aW9ucy5wdXNoKGQpO1xuICAgICAgICBwcmVkaWN0aW9ucy5wdXNoKHJlc3VsdHNbaV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHN1bSA9IG9ic2VydmF0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKGEsIG9ic2VydmF0aW9uKSB7XG4gICAgICByZXR1cm4gYSArIG9ic2VydmF0aW9uWzFdO1xuICAgIH0sIDApO1xuICAgIHZhciBtZWFuID0gc3VtIC8gb2JzZXJ2YXRpb25zLmxlbmd0aDtcblxuICAgIHZhciBzc3l5ID0gb2JzZXJ2YXRpb25zLnJlZHVjZShmdW5jdGlvbiAoYSwgb2JzZXJ2YXRpb24pIHtcbiAgICAgIHZhciBkaWZmZXJlbmNlID0gb2JzZXJ2YXRpb25bMV0gLSBtZWFuO1xuICAgICAgcmV0dXJuIGEgKyBkaWZmZXJlbmNlICogZGlmZmVyZW5jZTtcbiAgICB9LCAwKTtcblxuICAgIHZhciBzc2UgPSBvYnNlcnZhdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgb2JzZXJ2YXRpb24sIGluZGV4KSB7XG4gICAgICB2YXIgcHJlZGljdGlvbiA9IHByZWRpY3Rpb25zW2luZGV4XTtcbiAgICAgIHZhciByZXNpZHVhbCA9IG9ic2VydmF0aW9uWzFdIC0gcHJlZGljdGlvblsxXTtcbiAgICAgIHJldHVybiBhY2N1bSArIHJlc2lkdWFsICogcmVzaWR1YWw7XG4gICAgfSwgMCk7XG5cbiAgICByZXR1cm4gMSAtIHNzZSAvIHNzeXk7XG4gIH1cblxuICAvKipcbiAgKiBEZXRlcm1pbmUgdGhlIHNvbHV0aW9uIG9mIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgQSAqIHggPSBiIHVzaW5nXG4gICogR2F1c3NpYW4gZWxpbWluYXRpb24uXG4gICpcbiAgKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBpbnB1dCAtIEEgMi1kIG1hdHJpeCBvZiBkYXRhIGluIHJvdy1tYWpvciBmb3JtIFsgQSB8IGIgXVxuICAqIEBwYXJhbSB7bnVtYmVyfSBvcmRlciAtIEhvdyBtYW55IGRlZ3JlZXMgdG8gc29sdmUgZm9yXG4gICpcbiAgKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSAtIFZlY3RvciBvZiBub3JtYWxpemVkIHNvbHV0aW9uIGNvZWZmaWNpZW50cyBtYXRyaXggKHgpXG4gICovXG4gIGZ1bmN0aW9uIGdhdXNzaWFuRWxpbWluYXRpb24oaW5wdXQsIG9yZGVyKSB7XG4gICAgdmFyIG1hdHJpeCA9IGlucHV0O1xuICAgIHZhciBuID0gaW5wdXQubGVuZ3RoIC0gMTtcbiAgICB2YXIgY29lZmZpY2llbnRzID0gW29yZGVyXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICB2YXIgbWF4cm93ID0gaTtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG47IGorKykge1xuICAgICAgICBpZiAoTWF0aC5hYnMobWF0cml4W2ldW2pdKSA+IE1hdGguYWJzKG1hdHJpeFtpXVttYXhyb3ddKSkge1xuICAgICAgICAgIG1heHJvdyA9IGo7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgayA9IGk7IGsgPCBuICsgMTsgaysrKSB7XG4gICAgICAgIHZhciB0bXAgPSBtYXRyaXhba11baV07XG4gICAgICAgIG1hdHJpeFtrXVtpXSA9IG1hdHJpeFtrXVttYXhyb3ddO1xuICAgICAgICBtYXRyaXhba11bbWF4cm93XSA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2ogPSBpICsgMTsgX2ogPCBuOyBfaisrKSB7XG4gICAgICAgIGZvciAodmFyIF9rID0gbjsgX2sgPj0gaTsgX2stLSkge1xuICAgICAgICAgIG1hdHJpeFtfa11bX2pdIC09IG1hdHJpeFtfa11baV0gKiBtYXRyaXhbaV1bX2pdIC8gbWF0cml4W2ldW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2oyID0gbiAtIDE7IF9qMiA+PSAwOyBfajItLSkge1xuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgIGZvciAodmFyIF9rMiA9IF9qMiArIDE7IF9rMiA8IG47IF9rMisrKSB7XG4gICAgICAgIHRvdGFsICs9IG1hdHJpeFtfazJdW19qMl0gKiBjb2VmZmljaWVudHNbX2syXTtcbiAgICAgIH1cblxuICAgICAgY29lZmZpY2llbnRzW19qMl0gPSAobWF0cml4W25dW19qMl0gLSB0b3RhbCkgLyBtYXRyaXhbX2oyXVtfajJdO1xuICAgIH1cblxuICAgIHJldHVybiBjb2VmZmljaWVudHM7XG4gIH1cblxuICAvKipcbiAgKiBSb3VuZCBhIG51bWJlciB0byBhIHByZWNpc2lvbiwgc3BlY2lmaWNlZCBpbiBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXNcbiAgKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgLSBUaGUgbnVtYmVyIHRvIHJvdW5kXG4gICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAtIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdG8gcm91bmQgdG86XG4gICogICAgICAgICAgICAgICAgICAgICAgICAgICAgID4gMCBtZWFucyBkZWNpbWFscywgPCAwIG1lYW5zIHBvd2VycyBvZiAxMFxuICAqXG4gICpcbiAgKiBAcmV0dXJuIHtudW1icn0gLSBUaGUgbnVtYmVyLCByb3VuZGVkXG4gICovXG4gIGZ1bmN0aW9uIHJvdW5kKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gICAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIH1cblxuICAvKipcbiAgKiBUaGUgc2V0IG9mIGFsbCBmaXR0aW5nIG1ldGhvZHNcbiAgKlxuICAqIEBuYW1lc3BhY2VcbiAgKi9cbiAgdmFyIG1ldGhvZHMgPSB7XG4gICAgbGluZWFyOiBmdW5jdGlvbiBsaW5lYXIoZGF0YSwgb3B0aW9ucykge1xuICAgICAgdmFyIHN1bSA9IFswLCAwLCAwLCAwLCAwXTtcbiAgICAgIHZhciBsZW4gPSAwO1xuXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGRhdGEubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgaWYgKGRhdGFbbl1bMV0gIT09IG51bGwpIHtcbiAgICAgICAgICBsZW4rKztcbiAgICAgICAgICBzdW1bMF0gKz0gZGF0YVtuXVswXTtcbiAgICAgICAgICBzdW1bMV0gKz0gZGF0YVtuXVsxXTtcbiAgICAgICAgICBzdW1bMl0gKz0gZGF0YVtuXVswXSAqIGRhdGFbbl1bMF07XG4gICAgICAgICAgc3VtWzNdICs9IGRhdGFbbl1bMF0gKiBkYXRhW25dWzFdO1xuICAgICAgICAgIHN1bVs0XSArPSBkYXRhW25dWzFdICogZGF0YVtuXVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcnVuID0gbGVuICogc3VtWzJdIC0gc3VtWzBdICogc3VtWzBdO1xuICAgICAgdmFyIHJpc2UgPSBsZW4gKiBzdW1bM10gLSBzdW1bMF0gKiBzdW1bMV07XG4gICAgICB2YXIgZ3JhZGllbnQgPSBydW4gPT09IDAgPyAwIDogcm91bmQocmlzZSAvIHJ1biwgb3B0aW9ucy5wcmVjaXNpb24pO1xuICAgICAgdmFyIGludGVyY2VwdCA9IHJvdW5kKHN1bVsxXSAvIGxlbiAtIGdyYWRpZW50ICogc3VtWzBdIC8gbGVuLCBvcHRpb25zLnByZWNpc2lvbik7XG5cbiAgICAgIHZhciBwcmVkaWN0ID0gZnVuY3Rpb24gcHJlZGljdCh4KSB7XG4gICAgICAgIHJldHVybiBbcm91bmQoeCwgb3B0aW9ucy5wcmVjaXNpb24pLCByb3VuZChncmFkaWVudCAqIHggKyBpbnRlcmNlcHQsIG9wdGlvbnMucHJlY2lzaW9uKV07XG4gICAgICB9O1xuXG4gICAgICB2YXIgcG9pbnRzID0gZGF0YS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBwcmVkaWN0KHBvaW50WzBdKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgcHJlZGljdDogcHJlZGljdCxcbiAgICAgICAgZXF1YXRpb246IFtncmFkaWVudCwgaW50ZXJjZXB0XSxcbiAgICAgICAgcjI6IHJvdW5kKGRldGVybWluYXRpb25Db2VmZmljaWVudChkYXRhLCBwb2ludHMpLCBvcHRpb25zLnByZWNpc2lvbiksXG4gICAgICAgIHN0cmluZzogaW50ZXJjZXB0ID09PSAwID8gJ3kgPSAnICsgZ3JhZGllbnQgKyAneCcgOiAneSA9ICcgKyBncmFkaWVudCArICd4ICsgJyArIGludGVyY2VwdFxuICAgICAgfTtcbiAgICB9LFxuICAgIGV4cG9uZW50aWFsOiBmdW5jdGlvbiBleHBvbmVudGlhbChkYXRhLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc3VtID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuXG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGRhdGEubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgaWYgKGRhdGFbbl1bMV0gIT09IG51bGwpIHtcbiAgICAgICAgICBzdW1bMF0gKz0gZGF0YVtuXVswXTtcbiAgICAgICAgICBzdW1bMV0gKz0gZGF0YVtuXVsxXTtcbiAgICAgICAgICBzdW1bMl0gKz0gZGF0YVtuXVswXSAqIGRhdGFbbl1bMF0gKiBkYXRhW25dWzFdO1xuICAgICAgICAgIHN1bVszXSArPSBkYXRhW25dWzFdICogTWF0aC5sb2coZGF0YVtuXVsxXSk7XG4gICAgICAgICAgc3VtWzRdICs9IGRhdGFbbl1bMF0gKiBkYXRhW25dWzFdICogTWF0aC5sb2coZGF0YVtuXVsxXSk7XG4gICAgICAgICAgc3VtWzVdICs9IGRhdGFbbl1bMF0gKiBkYXRhW25dWzFdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkZW5vbWluYXRvciA9IHN1bVsxXSAqIHN1bVsyXSAtIHN1bVs1XSAqIHN1bVs1XTtcbiAgICAgIHZhciBhID0gTWF0aC5leHAoKHN1bVsyXSAqIHN1bVszXSAtIHN1bVs1XSAqIHN1bVs0XSkgLyBkZW5vbWluYXRvcik7XG4gICAgICB2YXIgYiA9IChzdW1bMV0gKiBzdW1bNF0gLSBzdW1bNV0gKiBzdW1bM10pIC8gZGVub21pbmF0b3I7XG4gICAgICB2YXIgY29lZmZBID0gcm91bmQoYSwgb3B0aW9ucy5wcmVjaXNpb24pO1xuICAgICAgdmFyIGNvZWZmQiA9IHJvdW5kKGIsIG9wdGlvbnMucHJlY2lzaW9uKTtcbiAgICAgIHZhciBwcmVkaWN0ID0gZnVuY3Rpb24gcHJlZGljdCh4KSB7XG4gICAgICAgIHJldHVybiBbcm91bmQoeCwgb3B0aW9ucy5wcmVjaXNpb24pLCByb3VuZChjb2VmZkEgKiBNYXRoLmV4cChjb2VmZkIgKiB4KSwgb3B0aW9ucy5wcmVjaXNpb24pXTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBwb2ludHMgPSBkYXRhLm1hcChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY3QocG9pbnRbMF0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICBwcmVkaWN0OiBwcmVkaWN0LFxuICAgICAgICBlcXVhdGlvbjogW2NvZWZmQSwgY29lZmZCXSxcbiAgICAgICAgc3RyaW5nOiAneSA9ICcgKyBjb2VmZkEgKyAnZV4oJyArIGNvZWZmQiArICd4KScsXG4gICAgICAgIHIyOiByb3VuZChkZXRlcm1pbmF0aW9uQ29lZmZpY2llbnQoZGF0YSwgcG9pbnRzKSwgb3B0aW9ucy5wcmVjaXNpb24pXG4gICAgICB9O1xuICAgIH0sXG4gICAgbG9nYXJpdGhtaWM6IGZ1bmN0aW9uIGxvZ2FyaXRobWljKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdW0gPSBbMCwgMCwgMCwgMF07XG4gICAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgaWYgKGRhdGFbbl1bMV0gIT09IG51bGwpIHtcbiAgICAgICAgICBzdW1bMF0gKz0gTWF0aC5sb2coZGF0YVtuXVswXSk7XG4gICAgICAgICAgc3VtWzFdICs9IGRhdGFbbl1bMV0gKiBNYXRoLmxvZyhkYXRhW25dWzBdKTtcbiAgICAgICAgICBzdW1bMl0gKz0gZGF0YVtuXVsxXTtcbiAgICAgICAgICBzdW1bM10gKz0gTWF0aC5wb3coTWF0aC5sb2coZGF0YVtuXVswXSksIDIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBhID0gKGxlbiAqIHN1bVsxXSAtIHN1bVsyXSAqIHN1bVswXSkgLyAobGVuICogc3VtWzNdIC0gc3VtWzBdICogc3VtWzBdKTtcbiAgICAgIHZhciBjb2VmZkIgPSByb3VuZChhLCBvcHRpb25zLnByZWNpc2lvbik7XG4gICAgICB2YXIgY29lZmZBID0gcm91bmQoKHN1bVsyXSAtIGNvZWZmQiAqIHN1bVswXSkgLyBsZW4sIG9wdGlvbnMucHJlY2lzaW9uKTtcblxuICAgICAgdmFyIHByZWRpY3QgPSBmdW5jdGlvbiBwcmVkaWN0KHgpIHtcbiAgICAgICAgcmV0dXJuIFtyb3VuZCh4LCBvcHRpb25zLnByZWNpc2lvbiksIHJvdW5kKHJvdW5kKGNvZWZmQSArIGNvZWZmQiAqIE1hdGgubG9nKHgpLCBvcHRpb25zLnByZWNpc2lvbiksIG9wdGlvbnMucHJlY2lzaW9uKV07XG4gICAgICB9O1xuXG4gICAgICB2YXIgcG9pbnRzID0gZGF0YS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBwcmVkaWN0KHBvaW50WzBdKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgcHJlZGljdDogcHJlZGljdCxcbiAgICAgICAgZXF1YXRpb246IFtjb2VmZkEsIGNvZWZmQl0sXG4gICAgICAgIHN0cmluZzogJ3kgPSAnICsgY29lZmZBICsgJyArICcgKyBjb2VmZkIgKyAnIGxuKHgpJyxcbiAgICAgICAgcjI6IHJvdW5kKGRldGVybWluYXRpb25Db2VmZmljaWVudChkYXRhLCBwb2ludHMpLCBvcHRpb25zLnByZWNpc2lvbilcbiAgICAgIH07XG4gICAgfSxcbiAgICBwb3dlcjogZnVuY3Rpb24gcG93ZXIoZGF0YSwgb3B0aW9ucykge1xuICAgICAgdmFyIHN1bSA9IFswLCAwLCAwLCAwLCAwXTtcbiAgICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICBpZiAoZGF0YVtuXVsxXSAhPT0gbnVsbCkge1xuICAgICAgICAgIHN1bVswXSArPSBNYXRoLmxvZyhkYXRhW25dWzBdKTtcbiAgICAgICAgICBzdW1bMV0gKz0gTWF0aC5sb2coZGF0YVtuXVsxXSkgKiBNYXRoLmxvZyhkYXRhW25dWzBdKTtcbiAgICAgICAgICBzdW1bMl0gKz0gTWF0aC5sb2coZGF0YVtuXVsxXSk7XG4gICAgICAgICAgc3VtWzNdICs9IE1hdGgucG93KE1hdGgubG9nKGRhdGFbbl1bMF0pLCAyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYiA9IChsZW4gKiBzdW1bMV0gLSBzdW1bMF0gKiBzdW1bMl0pIC8gKGxlbiAqIHN1bVszXSAtIE1hdGgucG93KHN1bVswXSwgMikpO1xuICAgICAgdmFyIGEgPSAoc3VtWzJdIC0gYiAqIHN1bVswXSkgLyBsZW47XG4gICAgICB2YXIgY29lZmZBID0gcm91bmQoTWF0aC5leHAoYSksIG9wdGlvbnMucHJlY2lzaW9uKTtcbiAgICAgIHZhciBjb2VmZkIgPSByb3VuZChiLCBvcHRpb25zLnByZWNpc2lvbik7XG5cbiAgICAgIHZhciBwcmVkaWN0ID0gZnVuY3Rpb24gcHJlZGljdCh4KSB7XG4gICAgICAgIHJldHVybiBbcm91bmQoeCwgb3B0aW9ucy5wcmVjaXNpb24pLCByb3VuZChyb3VuZChjb2VmZkEgKiBNYXRoLnBvdyh4LCBjb2VmZkIpLCBvcHRpb25zLnByZWNpc2lvbiksIG9wdGlvbnMucHJlY2lzaW9uKV07XG4gICAgICB9O1xuXG4gICAgICB2YXIgcG9pbnRzID0gZGF0YS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBwcmVkaWN0KHBvaW50WzBdKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb2ludHM6IHBvaW50cyxcbiAgICAgICAgcHJlZGljdDogcHJlZGljdCxcbiAgICAgICAgZXF1YXRpb246IFtjb2VmZkEsIGNvZWZmQl0sXG4gICAgICAgIHN0cmluZzogJ3kgPSAnICsgY29lZmZBICsgJ3heJyArIGNvZWZmQixcbiAgICAgICAgcjI6IHJvdW5kKGRldGVybWluYXRpb25Db2VmZmljaWVudChkYXRhLCBwb2ludHMpLCBvcHRpb25zLnByZWNpc2lvbilcbiAgICAgIH07XG4gICAgfSxcbiAgICBwb2x5bm9taWFsOiBmdW5jdGlvbiBwb2x5bm9taWFsKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsaHMgPSBbXTtcbiAgICAgIHZhciByaHMgPSBbXTtcbiAgICAgIHZhciBhID0gMDtcbiAgICAgIHZhciBiID0gMDtcbiAgICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgIHZhciBrID0gb3B0aW9ucy5vcmRlciArIDE7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGVuOyBsKyspIHtcbiAgICAgICAgICBpZiAoZGF0YVtsXVsxXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYSArPSBNYXRoLnBvdyhkYXRhW2xdWzBdLCBpKSAqIGRhdGFbbF1bMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGhzLnB1c2goYSk7XG4gICAgICAgIGEgPSAwO1xuXG4gICAgICAgIHZhciBjID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2wgPSAwOyBfbCA8IGxlbjsgX2wrKykge1xuICAgICAgICAgICAgaWYgKGRhdGFbX2xdWzFdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGIgKz0gTWF0aC5wb3coZGF0YVtfbF1bMF0sIGkgKyBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYy5wdXNoKGIpO1xuICAgICAgICAgIGIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJocy5wdXNoKGMpO1xuICAgICAgfVxuICAgICAgcmhzLnB1c2gobGhzKTtcblxuICAgICAgdmFyIGNvZWZmaWNpZW50cyA9IGdhdXNzaWFuRWxpbWluYXRpb24ocmhzLCBrKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHJvdW5kKHYsIG9wdGlvbnMucHJlY2lzaW9uKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcHJlZGljdCA9IGZ1bmN0aW9uIHByZWRpY3QoeCkge1xuICAgICAgICByZXR1cm4gW3JvdW5kKHgsIG9wdGlvbnMucHJlY2lzaW9uKSwgcm91bmQoY29lZmZpY2llbnRzLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBjb2VmZiwgcG93ZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3VtICsgY29lZmYgKiBNYXRoLnBvdyh4LCBwb3dlcik7XG4gICAgICAgIH0sIDApLCBvcHRpb25zLnByZWNpc2lvbildO1xuICAgICAgfTtcblxuICAgICAgdmFyIHBvaW50cyA9IGRhdGEubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICByZXR1cm4gcHJlZGljdChwb2ludFswXSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHN0cmluZyA9ICd5ID0gJztcbiAgICAgIGZvciAodmFyIF9pID0gY29lZmZpY2llbnRzLmxlbmd0aCAtIDE7IF9pID49IDA7IF9pLS0pIHtcbiAgICAgICAgaWYgKF9pID4gMSkge1xuICAgICAgICAgIHN0cmluZyArPSBjb2VmZmljaWVudHNbX2ldICsgJ3heJyArIF9pICsgJyArICc7XG4gICAgICAgIH0gZWxzZSBpZiAoX2kgPT09IDEpIHtcbiAgICAgICAgICBzdHJpbmcgKz0gY29lZmZpY2llbnRzW19pXSArICd4ICsgJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJpbmcgKz0gY29lZmZpY2llbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICAgIHByZWRpY3Q6IHByZWRpY3QsXG4gICAgICAgIGVxdWF0aW9uOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGNvZWZmaWNpZW50cykpLnJldmVyc2UoKSxcbiAgICAgICAgcjI6IHJvdW5kKGRldGVybWluYXRpb25Db2VmZmljaWVudChkYXRhLCBwb2ludHMpLCBvcHRpb25zLnByZWNpc2lvbilcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZXIoKSB7XG4gICAgdmFyIHJlZHVjZSA9IGZ1bmN0aW9uIHJlZHVjZShhY2N1bXVsYXRvciwgbmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgX3JvdW5kOiByb3VuZFxuICAgICAgfSwgYWNjdW11bGF0b3IsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgbmFtZSwgZnVuY3Rpb24gKGRhdGEsIHN1cHBsaWVkKSB7XG4gICAgICAgIHJldHVybiBtZXRob2RzW25hbWVdKGRhdGEsIF9leHRlbmRzKHt9LCBERUZBVUxUX09QVElPTlMsIHN1cHBsaWVkKSk7XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIHJldHVybiBPYmplY3Qua2V5cyhtZXRob2RzKS5yZWR1Y2UocmVkdWNlLCB7fSk7XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVdyYXBwZXIoKTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL19zaW1wbGUtc3RhdGlzdGljc0A2LjEuMUBzaW1wbGUtc3RhdGlzdGljcy9kaXN0L3NpbXBsZS1zdGF0aXN0aWNzLm1pbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvX3NpbXBsZS1zdGF0aXN0aWNzQDYuMS4xQHNpbXBsZS1zdGF0aXN0aWNzL2Rpc3Qvc2ltcGxlLXN0YXRpc3RpY3MubWluLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4hZnVuY3Rpb24odCxyKXsgdHJ1ZT9yKGV4cG9ydHMpOnVuZGVmaW5lZH0odGhpcyxmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKHQpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gMDtmb3IodmFyIHIsbj10WzBdLGU9MCxhPTE7YTx0Lmxlbmd0aDthKyspcj1uK3RbYV0sTWF0aC5hYnMobik+PU1hdGguYWJzKHRbYV0pP2UrPW4tcit0W2FdOmUrPXRbYV0tcituLG49cjtyZXR1cm4gbitlfWZ1bmN0aW9uIGcodCl7aWYoMD09PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIm1lYW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7cmV0dXJuIHIodCkvdC5sZW5ndGh9ZnVuY3Rpb24gbih0LHIpe3ZhciBuLGUsYT1nKHQpLG89MDtpZigyPT09cilmb3IoZT0wO2U8dC5sZW5ndGg7ZSsrKW8rPShuPXRbZV0tYSkqbjtlbHNlIGZvcihlPTA7ZTx0Lmxlbmd0aDtlKyspbys9TWF0aC5wb3codFtlXS1hLHIpO3JldHVybiBvfWZ1bmN0aW9uIGUodCl7aWYoMD09PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInZhcmlhbmNlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO3JldHVybiBuKHQsMikvdC5sZW5ndGh9ZnVuY3Rpb24gYSh0KXtpZigxPT09dC5sZW5ndGgpcmV0dXJuIDA7dmFyIHI9ZSh0KTtyZXR1cm4gTWF0aC5zcXJ0KHIpfWZ1bmN0aW9uIG8odCl7aWYoMD09PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIm1vZGUgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7aWYoMT09PXQubGVuZ3RoKXJldHVybiB0WzBdO2Zvcih2YXIgcj10WzBdLG49TmFOLGU9MCxhPTEsbz0xO288dC5sZW5ndGgrMTtvKyspdFtvXSE9PXI/KGU8YSYmKGU9YSxuPXIpLGE9MSxyPXRbb10pOmErKztyZXR1cm4gbn1mdW5jdGlvbiBmKHQpe3JldHVybiB0LnNsaWNlKCkuc29ydChmdW5jdGlvbih0LHIpe3JldHVybiB0LXJ9KX1mdW5jdGlvbiB1KHQpe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJtaW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7Zm9yKHZhciByPXRbMF0sbj0xO248dC5sZW5ndGg7bisrKXRbbl08ciYmKHI9dFtuXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gaCh0KXtpZigwPT09dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibWF4IHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO2Zvcih2YXIgcj10WzBdLG49MTtuPHQubGVuZ3RoO24rKyl0W25dPnImJihyPXRbbl0pO3JldHVybiByfWZ1bmN0aW9uIGkodCxyKXt2YXIgbj10Lmxlbmd0aCpyO2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJxdWFudGlsZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludC5cIik7aWYocjwwfHwxPHIpdGhyb3cgbmV3IEVycm9yKFwicXVhbnRpbGVzIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxXCIpO3JldHVybiAxPT09cj90W3QubGVuZ3RoLTFdOjA9PT1yP3RbMF06biUxIT0wP3RbTWF0aC5jZWlsKG4pLTFdOnQubGVuZ3RoJTI9PTA/KHRbbi0xXSt0W25dKS8yOnRbbl19ZnVuY3Rpb24gYyh0LHIsbixlKXtmb3Iobj1ufHwwLGU9ZXx8dC5sZW5ndGgtMTtuPGU7KXtpZig2MDA8ZS1uKXt2YXIgYT1lLW4rMSxvPXItbisxLGk9TWF0aC5sb2coYSksdT0uNSpNYXRoLmV4cCgyKmkvMyksaD0uNSpNYXRoLnNxcnQoaSp1KihhLXUpL2EpO28tYS8yPDAmJihoKj0tMSksYyh0LHIsTWF0aC5tYXgobixNYXRoLmZsb29yKHItbyp1L2EraCkpLE1hdGgubWluKGUsTWF0aC5mbG9vcihyKyhhLW8pKnUvYStoKSkpfXZhciBmPXRbcl0scz1uLGw9ZTtmb3IocCh0LG4sciksdFtlXT5mJiZwKHQsbixlKTtzPGw7KXtmb3IocCh0LHMsbCkscysrLGwtLTt0W3NdPGY7KXMrKztmb3IoO3RbbF0+ZjspbC0tfXRbbl09PT1mP3AodCxuLGwpOnAodCwrK2wsZSksbDw9ciYmKG49bCsxKSxyPD1sJiYoZT1sLTEpfX1mdW5jdGlvbiBwKHQscixuKXt2YXIgZT10W3JdO3Rbcl09dFtuXSx0W25dPWV9ZnVuY3Rpb24gcyh0LHIpe3ZhciBuPXQuc2xpY2UoKTtpZihBcnJheS5pc0FycmF5KHIpKXshZnVuY3Rpb24odCxyKXtmb3IodmFyIG49WzBdLGU9MDtlPHIubGVuZ3RoO2UrKyluLnB1c2godyh0Lmxlbmd0aCxyW2VdKSk7bi5wdXNoKHQubGVuZ3RoLTEpLG4uc29ydCh2KTt2YXIgYT1bMCxuLmxlbmd0aC0xXTtmb3IoO2EubGVuZ3RoOyl7dmFyIG89TWF0aC5jZWlsKGEucG9wKCkpLGk9TWF0aC5mbG9vcihhLnBvcCgpKTtpZighKG8taTw9MSkpe3ZhciB1PU1hdGguZmxvb3IoKGkrbykvMik7bCh0LG5bdV0sbltpXSxuW29dKSxhLnB1c2goaSx1LHUsbyl9fX0obixyKTtmb3IodmFyIGU9W10sYT0wO2E8ci5sZW5ndGg7YSsrKWVbYV09aShuLHJbYV0pO3JldHVybiBlfXJldHVybiBsKG4sdyhuLmxlbmd0aCxyKSwwLG4ubGVuZ3RoLTEpLGkobixyKX1mdW5jdGlvbiBsKHQscixuLGUpe3IlMT09MD9jKHQscixuLGUpOihjKHQscj1NYXRoLmZsb29yKHIpLG4sZSksYyh0LHIrMSxyKzEsZSkpfWZ1bmN0aW9uIHYodCxyKXtyZXR1cm4gdC1yfWZ1bmN0aW9uIHcodCxyKXt2YXIgbj10KnI7cmV0dXJuIDE9PT1yP3QtMTowPT09cj8wOm4lMSE9MD9NYXRoLmNlaWwobiktMTp0JTI9PTA/bi0uNTpufWZ1bmN0aW9uIE0odCxyKXtpZihyPHRbMF0pcmV0dXJuIDA7aWYocj50W3QubGVuZ3RoLTFdKXJldHVybiAxO3ZhciBuPWZ1bmN0aW9uKHQscil7dmFyIG49MCxlPTAsYT10Lmxlbmd0aDtmb3IoO2U8YTspcjw9dFtuPWUrYT4+PjFdP2E9bjplPS1+bjtyZXR1cm4gZX0odCxyKTtpZih0W25dIT09cilyZXR1cm4gbi90Lmxlbmd0aDtuKys7dmFyIGU9ZnVuY3Rpb24odCxyKXt2YXIgbj0wLGU9MCxhPXQubGVuZ3RoO2Zvcig7ZTxhOylyPj10W249ZSthPj4+MV0/ZT0tfm46YT1uO3JldHVybiBlfSh0LHIpO2lmKGU9PT1uKXJldHVybiBuL3QubGVuZ3RoO3ZhciBhPWUtbisxO3JldHVybiBhKihlK24pLzIvYS90Lmxlbmd0aH1mdW5jdGlvbiBtKHQpe3ZhciByPXModCwuNzUpLG49cyh0LC4yNSk7aWYoXCJudW1iZXJcIj09dHlwZW9mIHImJlwibnVtYmVyXCI9PXR5cGVvZiBuKXJldHVybiByLW59ZnVuY3Rpb24gZCh0KXtyZXR1cm4rcyh0LC41KX1mdW5jdGlvbiBiKHQpe2Zvcih2YXIgcj1kKHQpLG49W10sZT0wO2U8dC5sZW5ndGg7ZSsrKW4ucHVzaChNYXRoLmFicyh0W2VdLXIpKTtyZXR1cm4gZChuKX1mdW5jdGlvbiBxKHQscil7cj1yfHxNYXRoLnJhbmRvbTtmb3IodmFyIG4sZSxhPXQubGVuZ3RoOzA8YTspZT1NYXRoLmZsb29yKHIoKSphLS0pLG49dFthXSx0W2FdPXRbZV0sdFtlXT1uO3JldHVybiB0fWZ1bmN0aW9uIEUodCxyKXtyZXR1cm4gcSh0LnNsaWNlKCkuc2xpY2UoKSxyKX1mdW5jdGlvbiB5KHQpe2Zvcih2YXIgcixuPTAsZT0wO2U8dC5sZW5ndGg7ZSsrKTAhPT1lJiZ0W2VdPT09cnx8KHI9dFtlXSxuKyspO3JldHVybiBufWZ1bmN0aW9uIFModCxyKXtmb3IodmFyIG49W10sZT0wO2U8dDtlKyspe2Zvcih2YXIgYT1bXSxvPTA7bzxyO28rKylhLnB1c2goMCk7bi5wdXNoKGEpfXJldHVybiBufWZ1bmN0aW9uIHgodCxyLG4sZSl7dmFyIGE7aWYoMDx0KXt2YXIgbz0obltyXS1uW3QtMV0pLyhyLXQrMSk7YT1lW3JdLWVbdC0xXS0oci10KzEpKm8qb31lbHNlIGE9ZVtyXS1uW3JdKm5bcl0vKHIrMSk7cmV0dXJuIGE8MD8wOmF9ZnVuY3Rpb24gUCh0LHIsbixlLGEsbyxpKXtpZighKHI8dCkpe3ZhciB1PU1hdGguZmxvb3IoKHQrcikvMik7ZVtuXVt1XT1lW24tMV1bdS0xXSxhW25dW3VdPXU7dmFyIGg9bjtuPHQmJihoPU1hdGgubWF4KGgsYVtuXVt0LTFdfHwwKSksaD1NYXRoLm1heChoLGFbbi0xXVt1XXx8MCk7dmFyIGYscyxsLGM9dS0xO3I8ZS5sZW5ndGgtMSYmKGM9TWF0aC5taW4oYyxhW25dW3IrMV18fDApKTtmb3IodmFyIGc9YztoPD1nJiYhKChmPXgoZyx1LG8saSkpK2Vbbi0xXVtoLTFdPj1lW25dW3VdKTstLWcpKHM9eChoLHUsbyxpKStlW24tMV1baC0xXSk8ZVtuXVt1XSYmKGVbbl1bdV09cyxhW25dW3VdPWgpLGgrKywobD1mK2Vbbi0xXVtnLTFdKTxlW25dW3VdJiYoZVtuXVt1XT1sLGFbbl1bdV09Zyk7UCh0LHUtMSxuLGUsYSxvLGkpLFAodSsxLHIsbixlLGEsbyxpKX19ZnVuY3Rpb24gayh0LHIpe2lmKHQubGVuZ3RoIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic2FtcGxlQ292YXJpYW5jZSByZXF1aXJlcyBzYW1wbGVzIHdpdGggZXF1YWwgbGVuZ3Roc1wiKTtpZih0Lmxlbmd0aDwyKXRocm93IG5ldyBFcnJvcihcInNhbXBsZUNvdmFyaWFuY2UgcmVxdWlyZXMgYXQgbGVhc3QgdHdvIGRhdGEgcG9pbnRzIGluIGVhY2ggc2FtcGxlXCIpO2Zvcih2YXIgbj1nKHQpLGU9ZyhyKSxhPTAsbz0wO288dC5sZW5ndGg7bysrKWErPSh0W29dLW4pKihyW29dLWUpO3JldHVybiBhLyh0Lmxlbmd0aC0xKX1mdW5jdGlvbiBJKHQpe2lmKHQubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwic2FtcGxlVmFyaWFuY2UgcmVxdWlyZXMgYXQgbGVhc3QgdHdvIGRhdGEgcG9pbnRzXCIpO3JldHVybiBuKHQsMikvKHQubGVuZ3RoLTEpfWZ1bmN0aW9uIEQodCl7dmFyIHI9SSh0KTtyZXR1cm4gTWF0aC5zcXJ0KHIpfWZ1bmN0aW9uIEModCxyLG4sZSl7cmV0dXJuKHQqcituKmUpLyhyK2UpfWZ1bmN0aW9uIFQodCl7aWYoMD09PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInJvb3RNZWFuU3F1YXJlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO2Zvcih2YXIgcj0wLG49MDtuPHQubGVuZ3RoO24rKylyKz1NYXRoLnBvdyh0W25dLDIpO3JldHVybiBNYXRoLnNxcnQoci90Lmxlbmd0aCl9ZnVuY3Rpb24gXygpe3RoaXMudG90YWxDb3VudD0wLHRoaXMuZGF0YT17fX1mdW5jdGlvbiBGKCl7dGhpcy53ZWlnaHRzPVtdLHRoaXMuYmlhcz0wfV8ucHJvdG90eXBlLnRyYWluPWZ1bmN0aW9uKHQscil7Zm9yKHZhciBuIGluIHRoaXMuZGF0YVtyXXx8KHRoaXMuZGF0YVtyXT17fSksdCl7dmFyIGU9dFtuXTt2b2lkIDA9PT10aGlzLmRhdGFbcl1bbl0mJih0aGlzLmRhdGFbcl1bbl09e30pLHZvaWQgMD09PXRoaXMuZGF0YVtyXVtuXVtlXSYmKHRoaXMuZGF0YVtyXVtuXVtlXT0wKSx0aGlzLmRhdGFbcl1bbl1bZV0rK310aGlzLnRvdGFsQ291bnQrK30sXy5wcm90b3R5cGUuc2NvcmU9ZnVuY3Rpb24odCl7dmFyIHIsbj17fTtmb3IodmFyIGUgaW4gdCl7dmFyIGE9dFtlXTtmb3IociBpbiB0aGlzLmRhdGEpbltyXT17fSx0aGlzLmRhdGFbcl1bZV0/bltyXVtlK1wiX1wiK2FdPSh0aGlzLmRhdGFbcl1bZV1bYV18fDApL3RoaXMudG90YWxDb3VudDpuW3JdW2UrXCJfXCIrYV09MH12YXIgbz17fTtmb3IociBpbiBuKWZvcih2YXIgaSBpbiBvW3JdPTAsbltyXSlvW3JdKz1uW3JdW2ldO3JldHVybiBvfSxGLnByb3RvdHlwZS5wcmVkaWN0PWZ1bmN0aW9uKHQpe2lmKHQubGVuZ3RoIT09dGhpcy53ZWlnaHRzLmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIHI9MCxuPTA7bjx0aGlzLndlaWdodHMubGVuZ3RoO24rKylyKz10aGlzLndlaWdodHNbbl0qdFtuXTtyZXR1cm4gMDwocis9dGhpcy5iaWFzKT8xOjB9LEYucHJvdG90eXBlLnRyYWluPWZ1bmN0aW9uKHQscil7aWYoMCE9PXImJjEhPT1yKXJldHVybiBudWxsO3QubGVuZ3RoIT09dGhpcy53ZWlnaHRzLmxlbmd0aCYmKHRoaXMud2VpZ2h0cz10LHRoaXMuYmlhcz0xKTt2YXIgbj10aGlzLnByZWRpY3QodCk7aWYobiE9PXIpe2Zvcih2YXIgZT1yLW4sYT0wO2E8dGhpcy53ZWlnaHRzLmxlbmd0aDthKyspdGhpcy53ZWlnaHRzW2FdKz1lKnRbYV07dGhpcy5iaWFzKz1lfXJldHVybiB0aGlzfTt2YXIgTj0xZS00O2Z1bmN0aW9uIFIodCl7aWYodDwwKXRocm93IG5ldyBFcnJvcihcImZhY3RvcmlhbCByZXF1aXJlcyBhIG5vbi1uZWdhdGl2ZSB2YWx1ZVwiKTtpZihNYXRoLmZsb29yKHQpIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJmYWN0b3JpYWwgcmVxdWlyZXMgYW4gaW50ZWdlciBpbnB1dFwiKTtmb3IodmFyIHI9MSxuPTI7bjw9dDtuKyspcio9bjtyZXR1cm4gcn12YXIgQT1bLjk5OTk5OTk5OTk5OTk5NzEsNTcuMTU2MjM1NjY1ODYyOTIsLTU5LjU5Nzk2MDM1NTQ3NTQ5LDE0LjEzNjA5Nzk3NDc0MTc0NiwtLjQ5MTkxMzgxNjA5NzYyMDIsMzM5OTQ2NDk5ODQ4MTE4OWUtMjAsNDY1MjM2Mjg5MjcwNDg1OGUtMjAsLTk4Mzc0NDc1MzA0ODc5NTZlLTIwLC4wMDAxNTgwODg3MDMyMjQ5MTI1LC0uMDAwMjEwMjY0NDQxNzI0MTA0ODgsLjAwMDIxNzQzOTYxODExNTIxMjY1LC0uMDAwMTY0MzE4MTA2NTM2NzYzOSw4NDQxODIyMzk4Mzg1Mjc1ZS0yMCwtMjYxOTA4Mzg0MDE1ODE0MDhlLTIxLDM2ODk5MTgyNjU5NTMxNjI1ZS0yMl0sej1NYXRoLmxvZyhNYXRoLnNxcnQoMipNYXRoLlBJKSk7dmFyIFY9ezE6ey45OTU6MCwuOTk6MCwuOTc1OjAsLjk1OjAsLjk6LjAyLC41Oi40NSwuMToyLjcxLC4wNTozLjg0LC4wMjU6NS4wMiwuMDE6Ni42MywuMDA1OjcuODh9LDI6ey45OTU6LjAxLC45OTouMDIsLjk3NTouMDUsLjk1Oi4xLC45Oi4yMSwuNToxLjM5LC4xOjQuNjEsLjA1OjUuOTksLjAyNTo3LjM4LC4wMTo5LjIxLC4wMDU6MTAuNn0sMzp7Ljk5NTouMDcsLjk5Oi4xMSwuOTc1Oi4yMiwuOTU6LjM1LC45Oi41OCwuNToyLjM3LC4xOjYuMjUsLjA1OjcuODEsLjAyNTo5LjM1LC4wMToxMS4zNCwuMDA1OjEyLjg0fSw0OnsuOTk1Oi4yMSwuOTk6LjMsLjk3NTouNDgsLjk1Oi43MSwuOToxLjA2LC41OjMuMzYsLjE6Ny43OCwuMDU6OS40OSwuMDI1OjExLjE0LC4wMToxMy4yOCwuMDA1OjE0Ljg2fSw1OnsuOTk1Oi40MSwuOTk6LjU1LC45NzU6LjgzLC45NToxLjE1LC45OjEuNjEsLjU6NC4zNSwuMTo5LjI0LC4wNToxMS4wNywuMDI1OjEyLjgzLC4wMToxNS4wOSwuMDA1OjE2Ljc1fSw2OnsuOTk1Oi42OCwuOTk6Ljg3LC45NzU6MS4yNCwuOTU6MS42NCwuOToyLjIsLjU6NS4zNSwuMToxMC42NSwuMDU6MTIuNTksLjAyNToxNC40NSwuMDE6MTYuODEsLjAwNToxOC41NX0sNzp7Ljk5NTouOTksLjk5OjEuMjUsLjk3NToxLjY5LC45NToyLjE3LC45OjIuODMsLjU6Ni4zNSwuMToxMi4wMiwuMDU6MTQuMDcsLjAyNToxNi4wMSwuMDE6MTguNDgsLjAwNToyMC4yOH0sODp7Ljk5NToxLjM0LC45OToxLjY1LC45NzU6Mi4xOCwuOTU6Mi43MywuOTozLjQ5LC41OjcuMzQsLjE6MTMuMzYsLjA1OjE1LjUxLC4wMjU6MTcuNTMsLjAxOjIwLjA5LC4wMDU6MjEuOTZ9LDk6ey45OTU6MS43MywuOTk6Mi4wOSwuOTc1OjIuNywuOTU6My4zMywuOTo0LjE3LC41OjguMzQsLjE6MTQuNjgsLjA1OjE2LjkyLC4wMjU6MTkuMDIsLjAxOjIxLjY3LC4wMDU6MjMuNTl9LDEwOnsuOTk1OjIuMTYsLjk5OjIuNTYsLjk3NTozLjI1LC45NTozLjk0LC45OjQuODcsLjU6OS4zNCwuMToxNS45OSwuMDU6MTguMzEsLjAyNToyMC40OCwuMDE6MjMuMjEsLjAwNToyNS4xOX0sMTE6ey45OTU6Mi42LC45OTozLjA1LC45NzU6My44MiwuOTU6NC41NywuOTo1LjU4LC41OjEwLjM0LC4xOjE3LjI4LC4wNToxOS42OCwuMDI1OjIxLjkyLC4wMToyNC43MiwuMDA1OjI2Ljc2fSwxMjp7Ljk5NTozLjA3LC45OTozLjU3LC45NzU6NC40LC45NTo1LjIzLC45OjYuMywuNToxMS4zNCwuMToxOC41NSwuMDU6MjEuMDMsLjAyNToyMy4zNCwuMDE6MjYuMjIsLjAwNToyOC4zfSwxMzp7Ljk5NTozLjU3LC45OTo0LjExLC45NzU6NS4wMSwuOTU6NS44OSwuOTo3LjA0LC41OjEyLjM0LC4xOjE5LjgxLC4wNToyMi4zNiwuMDI1OjI0Ljc0LC4wMToyNy42OSwuMDA1OjI5LjgyfSwxNDp7Ljk5NTo0LjA3LC45OTo0LjY2LC45NzU6NS42MywuOTU6Ni41NywuOTo3Ljc5LC41OjEzLjM0LC4xOjIxLjA2LC4wNToyMy42OCwuMDI1OjI2LjEyLC4wMToyOS4xNCwuMDA1OjMxLjMyfSwxNTp7Ljk5NTo0LjYsLjk5OjUuMjMsLjk3NTo2LjI3LC45NTo3LjI2LC45OjguNTUsLjU6MTQuMzQsLjE6MjIuMzEsLjA1OjI1LC4wMjU6MjcuNDksLjAxOjMwLjU4LC4wMDU6MzIuOH0sMTY6ey45OTU6NS4xNCwuOTk6NS44MSwuOTc1OjYuOTEsLjk1OjcuOTYsLjk6OS4zMSwuNToxNS4zNCwuMToyMy41NCwuMDU6MjYuMywuMDI1OjI4Ljg1LC4wMTozMiwuMDA1OjM0LjI3fSwxNzp7Ljk5NTo1LjcsLjk5OjYuNDEsLjk3NTo3LjU2LC45NTo4LjY3LC45OjEwLjA5LC41OjE2LjM0LC4xOjI0Ljc3LC4wNToyNy41OSwuMDI1OjMwLjE5LC4wMTozMy40MSwuMDA1OjM1LjcyfSwxODp7Ljk5NTo2LjI2LC45OTo3LjAxLC45NzU6OC4yMywuOTU6OS4zOSwuOToxMC44NywuNToxNy4zNCwuMToyNS45OSwuMDU6MjguODcsLjAyNTozMS41MywuMDE6MzQuODEsLjAwNTozNy4xNn0sMTk6ey45OTU6Ni44NCwuOTk6Ny42MywuOTc1OjguOTEsLjk1OjEwLjEyLC45OjExLjY1LC41OjE4LjM0LC4xOjI3LjIsLjA1OjMwLjE0LC4wMjU6MzIuODUsLjAxOjM2LjE5LC4wMDU6MzguNTh9LDIwOnsuOTk1OjcuNDMsLjk5OjguMjYsLjk3NTo5LjU5LC45NToxMC44NSwuOToxMi40NCwuNToxOS4zNCwuMToyOC40MSwuMDU6MzEuNDEsLjAyNTozNC4xNywuMDE6MzcuNTcsLjAwNTo0MH0sMjE6ey45OTU6OC4wMywuOTk6OC45LC45NzU6MTAuMjgsLjk1OjExLjU5LC45OjEzLjI0LC41OjIwLjM0LC4xOjI5LjYyLC4wNTozMi42NywuMDI1OjM1LjQ4LC4wMTozOC45MywuMDA1OjQxLjR9LDIyOnsuOTk1OjguNjQsLjk5OjkuNTQsLjk3NToxMC45OCwuOTU6MTIuMzQsLjk6MTQuMDQsLjU6MjEuMzQsLjE6MzAuODEsLjA1OjMzLjkyLC4wMjU6MzYuNzgsLjAxOjQwLjI5LC4wMDU6NDIuOH0sMjM6ey45OTU6OS4yNiwuOTk6MTAuMiwuOTc1OjExLjY5LC45NToxMy4wOSwuOToxNC44NSwuNToyMi4zNCwuMTozMi4wMSwuMDU6MzUuMTcsLjAyNTozOC4wOCwuMDE6NDEuNjQsLjAwNTo0NC4xOH0sMjQ6ey45OTU6OS44OSwuOTk6MTAuODYsLjk3NToxMi40LC45NToxMy44NSwuOToxNS42NiwuNToyMy4zNCwuMTozMy4yLC4wNTozNi40MiwuMDI1OjM5LjM2LC4wMTo0Mi45OCwuMDA1OjQ1LjU2fSwyNTp7Ljk5NToxMC41MiwuOTk6MTEuNTIsLjk3NToxMy4xMiwuOTU6MTQuNjEsLjk6MTYuNDcsLjU6MjQuMzQsLjE6MzQuMjgsLjA1OjM3LjY1LC4wMjU6NDAuNjUsLjAxOjQ0LjMxLC4wMDU6NDYuOTN9LDI2OnsuOTk1OjExLjE2LC45OToxMi4yLC45NzU6MTMuODQsLjk1OjE1LjM4LC45OjE3LjI5LC41OjI1LjM0LC4xOjM1LjU2LC4wNTozOC44OSwuMDI1OjQxLjkyLC4wMTo0NS42NCwuMDA1OjQ4LjI5fSwyNzp7Ljk5NToxMS44MSwuOTk6MTIuODgsLjk3NToxNC41NywuOTU6MTYuMTUsLjk6MTguMTEsLjU6MjYuMzQsLjE6MzYuNzQsLjA1OjQwLjExLC4wMjU6NDMuMTksLjAxOjQ2Ljk2LC4wMDU6NDkuNjV9LDI4OnsuOTk1OjEyLjQ2LC45OToxMy41NywuOTc1OjE1LjMxLC45NToxNi45MywuOToxOC45NCwuNToyNy4zNCwuMTozNy45MiwuMDU6NDEuMzQsLjAyNTo0NC40NiwuMDE6NDguMjgsLjAwNTo1MC45OX0sMjk6ey45OTU6MTMuMTIsLjk5OjE0LjI2LC45NzU6MTYuMDUsLjk1OjE3LjcxLC45OjE5Ljc3LC41OjI4LjM0LC4xOjM5LjA5LC4wNTo0Mi41NiwuMDI1OjQ1LjcyLC4wMTo0OS41OSwuMDA1OjUyLjM0fSwzMDp7Ljk5NToxMy43OSwuOTk6MTQuOTUsLjk3NToxNi43OSwuOTU6MTguNDksLjk6MjAuNiwuNToyOS4zNCwuMTo0MC4yNiwuMDU6NDMuNzcsLjAyNTo0Ni45OCwuMDE6NTAuODksLjAwNTo1My42N30sNDA6ey45OTU6MjAuNzEsLjk5OjIyLjE2LC45NzU6MjQuNDMsLjk1OjI2LjUxLC45OjI5LjA1LC41OjM5LjM0LC4xOjUxLjgxLC4wNTo1NS43NiwuMDI1OjU5LjM0LC4wMTo2My42OSwuMDA1OjY2Ljc3fSw1MDp7Ljk5NToyNy45OSwuOTk6MjkuNzEsLjk3NTozMi4zNiwuOTU6MzQuNzYsLjk6MzcuNjksLjU6NDkuMzMsLjE6NjMuMTcsLjA1OjY3LjUsLjAyNTo3MS40MiwuMDE6NzYuMTUsLjAwNTo3OS40OX0sNjA6ey45OTU6MzUuNTMsLjk5OjM3LjQ4LC45NzU6NDAuNDgsLjk1OjQzLjE5LC45OjQ2LjQ2LC41OjU5LjMzLC4xOjc0LjQsLjA1Ojc5LjA4LC4wMjU6ODMuMywuMDE6ODguMzgsLjAwNTo5MS45NX0sNzA6ey45OTU6NDMuMjgsLjk5OjQ1LjQ0LC45NzU6NDguNzYsLjk1OjUxLjc0LC45OjU1LjMzLC41OjY5LjMzLC4xOjg1LjUzLC4wNTo5MC41MywuMDI1Ojk1LjAyLC4wMToxMDAuNDIsLjAwNToxMDQuMjJ9LDgwOnsuOTk1OjUxLjE3LC45OTo1My41NCwuOTc1OjU3LjE1LC45NTo2MC4zOSwuOTo2NC4yOCwuNTo3OS4zMywuMTo5Ni41OCwuMDU6MTAxLjg4LC4wMjU6MTA2LjYzLC4wMToxMTIuMzMsLjAwNToxMTYuMzJ9LDkwOnsuOTk1OjU5LjIsLjk5OjYxLjc1LC45NzU6NjUuNjUsLjk1OjY5LjEzLC45OjczLjI5LC41Ojg5LjMzLC4xOjEwNy41NywuMDU6MTEzLjE0LC4wMjU6MTE4LjE0LC4wMToxMjQuMTIsLjAwNToxMjguM30sMTAwOnsuOTk1OjY3LjMzLC45OTo3MC4wNiwuOTc1Ojc0LjIyLC45NTo3Ny45MywuOTo4Mi4zNiwuNTo5OS4zMywuMToxMTguNSwuMDU6MTI0LjM0LC4wMjU6MTI5LjU2LC4wMToxMzUuODEsLjAwNToxNDAuMTd9fTt2YXIgaj1NYXRoLnNxcnQoMipNYXRoLlBJKSxCPXtnYXVzc2lhbjpmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5leHAoLS41KnQqdCkvan19LEs9e25yZDpmdW5jdGlvbih0KXt2YXIgcj1EKHQpLG49bSh0KTtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgbiYmKHI9TWF0aC5taW4ocixuLzEuMzQpKSwxLjA2KnIqTWF0aC5wb3codC5sZW5ndGgsLS4yKX19O2Z1bmN0aW9uIE8oZSx0LHIpe3ZhciBhLG87aWYodm9pZCAwPT09dClhPUIuZ2F1c3NpYW47ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgdCl7aWYoIUJbdF0pdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGtlcm5lbCBcIicrdCsnXCInKTthPUJbdF19ZWxzZSBhPXQ7aWYodm9pZCAwPT09cilvPUsubnJkKGUpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIHIpe2lmKCFLW3JdKXRocm93IG5ldyBFcnJvcignVW5rbm93biBiYW5kd2lkdGggbWV0aG9kIFwiJytyKydcIicpO289S1tyXShlKX1lbHNlIG89cjtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIHI9MCxuPTA7Zm9yKHI9MDtyPGUubGVuZ3RoO3IrKyluKz1hKCh0LWVbcl0pL28pO3JldHVybiBuL28vZS5sZW5ndGh9fXZhciBVPU1hdGguc3FydCgyKk1hdGguUEkpO2Z1bmN0aW9uIEcodCl7Zm9yKHZhciByPXQsbj10LGU9MTtlPDE1O2UrKylyKz1uKj10KnQvKDIqZSsxKTtyZXR1cm4gTWF0aC5yb3VuZCgxZTQqKC41K3IvVSpNYXRoLmV4cCgtdCp0LzIpKSkvMWU0fWZvcih2YXIgSD1bXSxMPTA7TDw9My4wOTtMKz0uMDEpSC5wdXNoKEcoTCkpO2Z1bmN0aW9uIFcodCl7dmFyIHI9MS8oMSsuNSpNYXRoLmFicyh0KSksbj1yKk1hdGguZXhwKC1NYXRoLnBvdyh0LDIpLTEuMjY1NTEyMjMrMS4wMDAwMjM2OCpyKy4zNzQwOTE5NipNYXRoLnBvdyhyLDIpKy4wOTY3ODQxOCpNYXRoLnBvdyhyLDMpLS4xODYyODgwNipNYXRoLnBvdyhyLDQpKy4yNzg4NjgwNypNYXRoLnBvdyhyLDUpLTEuMTM1MjAzOTgqTWF0aC5wb3cociw2KSsxLjQ4ODUxNTg3Kk1hdGgucG93KHIsNyktLjgyMjE1MjIzKk1hdGgucG93KHIsOCkrLjE3MDg3Mjc3Kk1hdGgucG93KHIsOSkpO3JldHVybiAwPD10PzEtbjpuLTF9ZnVuY3Rpb24gSih0KXt2YXIgcj04KihNYXRoLlBJLTMpLygzKk1hdGguUEkqKDQtTWF0aC5QSSkpLG49TWF0aC5zcXJ0KE1hdGguc3FydChNYXRoLnBvdygyLyhNYXRoLlBJKnIpK01hdGgubG9nKDEtdCp0KS8yLDIpLU1hdGgubG9nKDEtdCp0KS9yKS0oMi8oTWF0aC5QSSpyKStNYXRoLmxvZygxLXQqdCkvMikpO3JldHVybiAwPD10P246LW59ZnVuY3Rpb24gUSh0KXtpZihcIm51bWJlclwiPT10eXBlb2YgdClyZXR1cm4gdDwwPy0xOjA9PT10PzA6MTt0aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgbnVtYmVyXCIpfXQubGluZWFyUmVncmVzc2lvbj1mdW5jdGlvbih0KXt2YXIgcixuLGU9dC5sZW5ndGg7aWYoMT09PWUpbj10W3I9MF1bMV07ZWxzZXtmb3IodmFyIGEsbyxpLHU9MCxoPTAsZj0wLHM9MCxsPTA7bDxlO2wrKyl1Kz1vPShhPXRbbF0pWzBdLGgrPWk9YVsxXSxmKz1vKm8scys9byppO249aC9lLShyPShlKnMtdSpoKS8oZSpmLXUqdSkpKnUvZX1yZXR1cm57bTpyLGI6bn19LHQubGluZWFyUmVncmVzc2lvbkxpbmU9ZnVuY3Rpb24ocil7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiByLmIrci5tKnR9fSx0LnN0YW5kYXJkRGV2aWF0aW9uPWEsdC5yU3F1YXJlZD1mdW5jdGlvbih0LHIpe2lmKHQubGVuZ3RoPDIpcmV0dXJuIDE7Zm9yKHZhciBuLGU9MCxhPTA7YTx0Lmxlbmd0aDthKyspZSs9dFthXVsxXTtuPWUvdC5sZW5ndGg7Zm9yKHZhciBvPTAsaT0wO2k8dC5sZW5ndGg7aSsrKW8rPU1hdGgucG93KG4tdFtpXVsxXSwyKTtmb3IodmFyIHU9MCxoPTA7aDx0Lmxlbmd0aDtoKyspdSs9TWF0aC5wb3codFtoXVsxXS1yKHRbaF1bMF0pLDIpO3JldHVybiAxLXUvb30sdC5tb2RlPWZ1bmN0aW9uKHQpe3JldHVybiBvKGYodCkpfSx0Lm1vZGVGYXN0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgcixuPW5ldyBNYXAsZT0wLGE9MDthPHQubGVuZ3RoO2ErKyl7dmFyIG89bi5nZXQodFthXSk7dm9pZCAwPT09bz9vPTE6bysrLGU8byYmKHI9dFthXSxlPW8pLG4uc2V0KHRbYV0sbyl9aWYoMD09PWUpdGhyb3cgbmV3IEVycm9yKFwibW9kZSByZXF1aXJlcyBhdCBsYXN0IG9uZSBkYXRhIHBvaW50XCIpO3JldHVybiByfSx0Lm1vZGVTb3J0ZWQ9byx0Lm1pbj11LHQubWF4PWgsdC5leHRlbnQ9ZnVuY3Rpb24odCl7aWYoMD09PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImV4dGVudCByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtmb3IodmFyIHI9dFswXSxuPXRbMF0sZT0xO2U8dC5sZW5ndGg7ZSsrKXRbZV0+biYmKG49dFtlXSksdFtlXTxyJiYocj10W2VdKTtyZXR1cm5bcixuXX0sdC5taW5Tb3J0ZWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRbMF19LHQubWF4U29ydGVkPWZ1bmN0aW9uKHQpe3JldHVybiB0W3QubGVuZ3RoLTFdfSx0LmV4dGVudFNvcnRlZD1mdW5jdGlvbih0KXtyZXR1cm5bdFswXSx0W3QubGVuZ3RoLTFdXX0sdC5zdW09cix0LnN1bVNpbXBsZT1mdW5jdGlvbih0KXtmb3IodmFyIHI9MCxuPTA7bjx0Lmxlbmd0aDtuKyspcis9dFtuXTtyZXR1cm4gcn0sdC5wcm9kdWN0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgcj0xLG49MDtuPHQubGVuZ3RoO24rKylyKj10W25dO3JldHVybiByfSx0LnF1YW50aWxlPXMsdC5xdWFudGlsZVNvcnRlZD1pLHQucXVhbnRpbGVSYW5rPWZ1bmN0aW9uKHQscil7cmV0dXJuIE0oZih0KSxyKX0sdC5xdWFudGlsZVJhbmtTb3J0ZWQ9TSx0LmludGVycXVhcnRpbGVSYW5nZT1tLHQuaXFyPW0sdC5tZWRpYW5BYnNvbHV0ZURldmlhdGlvbj1iLHQubWFkPWIsdC5jaHVuaz1mdW5jdGlvbih0LHIpe3ZhciBuPVtdO2lmKHI8MSl0aHJvdyBuZXcgRXJyb3IoXCJjaHVuayBzaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcIik7aWYoTWF0aC5mbG9vcihyKSE9PXIpdGhyb3cgbmV3IEVycm9yKFwiY2h1bmsgc2l6ZSBtdXN0IGJlIGFuIGludGVnZXJcIik7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKz1yKW4ucHVzaCh0LnNsaWNlKGUsZStyKSk7cmV0dXJuIG59LHQuc2FtcGxlV2l0aFJlcGxhY2VtZW50PWZ1bmN0aW9uKHQscixuKXtpZigwPT09dC5sZW5ndGgpcmV0dXJuW107bj1ufHxNYXRoLnJhbmRvbTtmb3IodmFyIGU9dC5sZW5ndGgsYT1bXSxvPTA7bzxyO28rKyl7dmFyIGk9TWF0aC5mbG9vcihuKCkqZSk7YS5wdXNoKHRbaV0pfXJldHVybiBhfSx0LnNodWZmbGU9RSx0LnNodWZmbGVJblBsYWNlPXEsdC5zYW1wbGU9ZnVuY3Rpb24odCxyLG4pe3JldHVybiBFKHQsbikuc2xpY2UoMCxyKX0sdC5ja21lYW5zPWZ1bmN0aW9uKHQscil7aWYocj50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2VuZXJhdGUgbW9yZSBjbGFzc2VzIHRoYW4gdGhlcmUgYXJlIGRhdGEgdmFsdWVzXCIpO3ZhciBuPWYodCk7aWYoMT09PXkobikpcmV0dXJuW25dO3ZhciBlPVMocixuLmxlbmd0aCksYT1TKHIsbi5sZW5ndGgpOyFmdW5jdGlvbih0LHIsbil7Zm9yKHZhciBlLGE9clswXS5sZW5ndGgsbz10W01hdGguZmxvb3IoYS8yKV0saT1bXSx1PVtdLGg9MDtoPGE7KytoKWU9dFtoXS1vLDA9PT1oPyhpLnB1c2goZSksdS5wdXNoKGUqZSkpOihpLnB1c2goaVtoLTFdK2UpLHUucHVzaCh1W2gtMV0rZSplKSksclswXVtoXT14KDAsaCxpLHUpLG5bMF1baF09MDtmb3IodmFyIGY9MTtmPHIubGVuZ3RoOysrZilQKGY8ci5sZW5ndGgtMT9mOmEtMSxhLTEsZixyLG4saSx1KX0obixlLGEpO2Zvcih2YXIgbz1bXSxpPWFbMF0ubGVuZ3RoLTEsdT1hLmxlbmd0aC0xOzA8PXU7dS0tKXt2YXIgaD1hW3VdW2ldO29bdV09bi5zbGljZShoLGkrMSksMDx1JiYoaT1oLTEpfXJldHVybiBvfSx0LnVuaXF1ZUNvdW50U29ydGVkPXksdC5zdW1OdGhQb3dlckRldmlhdGlvbnM9bix0LmVxdWFsSW50ZXJ2YWxCcmVha3M9ZnVuY3Rpb24odCxyKXtpZih0Lmxlbmd0aDwyKXJldHVybiB0O2Zvcih2YXIgbj11KHQpLGU9aCh0KSxhPVtuXSxvPShlLW4pL3IsaT0xO2k8cjtpKyspYS5wdXNoKGFbMF0rbyppKTtyZXR1cm4gYS5wdXNoKGUpLGF9LHQuc2FtcGxlQ292YXJpYW5jZT1rLHQuc2FtcGxlQ29ycmVsYXRpb249ZnVuY3Rpb24odCxyKXtyZXR1cm4gayh0LHIpL0QodCkvRChyKX0sdC5zYW1wbGVWYXJpYW5jZT1JLHQuc2FtcGxlU3RhbmRhcmREZXZpYXRpb249RCx0LnNhbXBsZVNrZXduZXNzPWZ1bmN0aW9uKHQpe2lmKHQubGVuZ3RoPDMpdGhyb3cgbmV3IEVycm9yKFwic2FtcGxlU2tld25lc3MgcmVxdWlyZXMgYXQgbGVhc3QgdGhyZWUgZGF0YSBwb2ludHNcIik7Zm9yKHZhciByLG49Zyh0KSxlPTAsYT0wLG89MDtvPHQubGVuZ3RoO28rKyllKz0ocj10W29dLW4pKnIsYSs9cipyKnI7dmFyIGk9dC5sZW5ndGgtMSx1PU1hdGguc3FydChlL2kpLGg9dC5sZW5ndGg7cmV0dXJuIGgqYS8oKGgtMSkqKGgtMikqTWF0aC5wb3codSwzKSl9LHQuc2FtcGxlS3VydG9zaXM9ZnVuY3Rpb24odCl7dmFyIHI9dC5sZW5ndGg7aWYocjw0KXRocm93IG5ldyBFcnJvcihcInNhbXBsZUt1cnRvc2lzIHJlcXVpcmVzIGF0IGxlYXN0IGZvdXIgZGF0YSBwb2ludHNcIik7Zm9yKHZhciBuLGU9Zyh0KSxhPTAsbz0wLGk9MDtpPHI7aSsrKWErPShuPXRbaV0tZSkqbixvKz1uKm4qbipuO3JldHVybihyLTEpLygoci0yKSooci0zKSkqKHIqKHIrMSkqby8oYSphKS0zKihyLTEpKX0sdC5wZXJtdXRhdGlvbnNIZWFwPWZ1bmN0aW9uKHQpe2Zvcih2YXIgcj1uZXcgQXJyYXkodC5sZW5ndGgpLG49W3Quc2xpY2UoKV0sZT0wO2U8dC5sZW5ndGg7ZSsrKXJbZV09MDtmb3IoZT0wO2U8dC5sZW5ndGg7KWlmKHJbZV08ZSl7dmFyIGE9MDtlJTIhPTAmJihhPXJbZV0pO3ZhciBvPXRbYV07dFthXT10W2VdLHRbZV09byxuLnB1c2godC5zbGljZSgpKSxyW2VdKyssZT0wfWVsc2UgcltlXT0wLGUrKztyZXR1cm4gbn0sdC5jb21iaW5hdGlvbnM9ZnVuY3Rpb24gdChyLG4pe3ZhciBlLGEsbyxpLHU9W107Zm9yKGU9MDtlPHIubGVuZ3RoO2UrKylpZigxPT09bil1LnB1c2goW3JbZV1dKTtlbHNlIGZvcihvPXQoci5zbGljZShlKzEsci5sZW5ndGgpLG4tMSksYT0wO2E8by5sZW5ndGg7YSsrKShpPW9bYV0pLnVuc2hpZnQocltlXSksdS5wdXNoKGkpO3JldHVybiB1fSx0LmNvbWJpbmF0aW9uc1JlcGxhY2VtZW50PWZ1bmN0aW9uIHQocixuKXtmb3IodmFyIGU9W10sYT0wO2E8ci5sZW5ndGg7YSsrKWlmKDE9PT1uKWUucHVzaChbclthXV0pO2Vsc2UgZm9yKHZhciBvPXQoci5zbGljZShhLHIubGVuZ3RoKSxuLTEpLGk9MDtpPG8ubGVuZ3RoO2krKyllLnB1c2goW3JbYV1dLmNvbmNhdChvW2ldKSk7cmV0dXJuIGV9LHQuYWRkVG9NZWFuPWZ1bmN0aW9uKHQscixuKXtyZXR1cm4gdCsobi10KS8ocisxKX0sdC5jb21iaW5lTWVhbnM9Qyx0LmNvbWJpbmVWYXJpYW5jZXM9ZnVuY3Rpb24odCxyLG4sZSxhLG8pe3ZhciBpPUMocixuLGEsbyk7cmV0dXJuKG4qKHQrTWF0aC5wb3coci1pLDIpKStvKihlK01hdGgucG93KGEtaSwyKSkpLyhuK28pfSx0Lmdlb21ldHJpY01lYW49ZnVuY3Rpb24odCl7aWYoMD09PXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImdlb21ldHJpY01lYW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7Zm9yKHZhciByPTEsbj0wO248dC5sZW5ndGg7bisrKXtpZih0W25dPD0wKXRocm93IG5ldyBFcnJvcihcImdlb21ldHJpY01lYW4gcmVxdWlyZXMgb25seSBwb3NpdGl2ZSBudW1iZXJzIGFzIGlucHV0XCIpO3IqPXRbbl19cmV0dXJuIE1hdGgucG93KHIsMS90Lmxlbmd0aCl9LHQuaGFybW9uaWNNZWFuPWZ1bmN0aW9uKHQpe2lmKDA9PT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJoYXJtb25pY01lYW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7Zm9yKHZhciByPTAsbj0wO248dC5sZW5ndGg7bisrKXtpZih0W25dPD0wKXRocm93IG5ldyBFcnJvcihcImhhcm1vbmljTWVhbiByZXF1aXJlcyBvbmx5IHBvc2l0aXZlIG51bWJlcnMgYXMgaW5wdXRcIik7cis9MS90W25dfXJldHVybiB0Lmxlbmd0aC9yfSx0LmF2ZXJhZ2U9Zyx0Lm1lYW49Zyx0Lm1lZGlhbj1kLHQubWVkaWFuU29ydGVkPWZ1bmN0aW9uKHQpe3JldHVybiBpKHQsLjUpfSx0LnN1YnRyYWN0RnJvbU1lYW49ZnVuY3Rpb24odCxyLG4pe3JldHVybih0KnItbikvKHItMSl9LHQucm9vdE1lYW5TcXVhcmU9VCx0LnJtcz1ULHQudmFyaWFuY2U9ZSx0LnRUZXN0PWZ1bmN0aW9uKHQscil7cmV0dXJuKGcodCktcikvKGEodCkvTWF0aC5zcXJ0KHQubGVuZ3RoKSl9LHQudFRlc3RUd29TYW1wbGU9ZnVuY3Rpb24odCxyLG4pe3ZhciBlPXQubGVuZ3RoLGE9ci5sZW5ndGg7aWYoIWV8fCFhKXJldHVybiBudWxsO258fChuPTApO3ZhciBvPWcodCksaT1nKHIpLHU9SSh0KSxoPUkocik7aWYoXCJudW1iZXJcIj09dHlwZW9mIG8mJlwibnVtYmVyXCI9PXR5cGVvZiBpJiZcIm51bWJlclwiPT10eXBlb2YgdSYmXCJudW1iZXJcIj09dHlwZW9mIGgpe3ZhciBmPSgoZS0xKSp1KyhhLTEpKmgpLyhlK2EtMik7cmV0dXJuKG8taS1uKS9NYXRoLnNxcnQoZiooMS9lKzEvYSkpfX0sdC5CYXllc2lhbkNsYXNzaWZpZXI9Xyx0LmJheWVzaWFuPV8sdC5QZXJjZXB0cm9uTW9kZWw9Rix0LnBlcmNlcHRyb249Rix0LmVwc2lsb249Tix0LmZhY3RvcmlhbD1SLHQuZ2FtbWE9ZnVuY3Rpb24gdChyKXtpZihcIm51bWJlclwiPT10eXBlb2Yobj1yKSYmaXNGaW5pdGUobikmJk1hdGguZmxvb3Iobik9PT1uKXJldHVybiByPD0wP05hTjpSKHItMSk7dmFyIG47aWYoLS1yPDApcmV0dXJuIE1hdGguUEkvKE1hdGguc2luKE1hdGguUEkqLXIpKnQoLXIpKTt2YXIgZT1yKy4yNTtyZXR1cm4gTWF0aC5wb3coci9NYXRoLkUscikqTWF0aC5zcXJ0KDIqTWF0aC5QSSoocisxLzYpKSooMSsxLzE0NC9NYXRoLnBvdyhlLDIpLTEvMTI5NjAvTWF0aC5wb3coZSwzKS0yNTcvMjA3MzYwL01hdGgucG93KGUsNCktNTIvMjYxMjczNi9NYXRoLnBvdyhlLDUpKzU3NDExNzMvOTQwNTg0OTYwMC9NYXRoLnBvdyhlLDYpKzM3NTI5LzE4ODExNjk5MjAwL01hdGgucG93KGUsNykpfSx0LmdhbW1hbG49ZnVuY3Rpb24odCl7aWYodDw9MClyZXR1cm4gMS8wO3QtLTtmb3IodmFyIHI9QVswXSxuPTE7bjwxNTtuKyspcis9QVtuXS8odCtuKTt2YXIgZT01LjI0MjE4NzUrdDtyZXR1cm4geitNYXRoLmxvZyhyKS1lKyh0Ky41KSpNYXRoLmxvZyhlKX0sdC5iZXJub3VsbGlEaXN0cmlidXRpb249ZnVuY3Rpb24odCl7aWYodDwwfHwxPHQpdGhyb3cgbmV3IEVycm9yKFwiYmVybm91bGxpRGlzdHJpYnV0aW9uIHJlcXVpcmVzIHByb2JhYmlsaXR5IHRvIGJlIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmVcIik7cmV0dXJuWzEtdCx0XX0sdC5iaW5vbWlhbERpc3RyaWJ1dGlvbj1mdW5jdGlvbih0LHIpe2lmKCEocjwwfHwxPHJ8fHQ8PTB8fHQlMSE9MCkpe2Zvcih2YXIgbj0wLGU9MCxhPVtdLG89MTthW25dPW8qTWF0aC5wb3cocixuKSpNYXRoLnBvdygxLXIsdC1uKSxlKz1hW25dLG89byoodC0rK24rMSkvbixlPDEtTjspO3JldHVybiBhfX0sdC5wb2lzc29uRGlzdHJpYnV0aW9uPWZ1bmN0aW9uKHQpe2lmKCEodDw9MCkpe2Zvcih2YXIgcj0wLG49MCxlPVtdLGE9MTtlW3JdPU1hdGguZXhwKC10KSpNYXRoLnBvdyh0LHIpL2Esbis9ZVtyXSxhKj0rK3IsbjwxLU47KTtyZXR1cm4gZX19LHQuY2hpU3F1YXJlZERpc3RyaWJ1dGlvblRhYmxlPVYsdC5jaGlTcXVhcmVkR29vZG5lc3NPZkZpdD1mdW5jdGlvbih0LHIsbil7Zm9yKHZhciBlLGEsbz0wLGk9cihnKHQpKSx1PVtdLGg9W10sZj0wO2Y8dC5sZW5ndGg7ZisrKXZvaWQgMD09PXVbdFtmXV0mJih1W3RbZl1dPTApLHVbdFtmXV0rKztmb3IoZj0wO2Y8dS5sZW5ndGg7ZisrKXZvaWQgMD09PXVbZl0mJih1W2ZdPTApO2ZvcihhIGluIGkpYSBpbiB1JiYoaFsrYV09aVthXSp0Lmxlbmd0aCk7Zm9yKGE9aC5sZW5ndGgtMTswPD1hO2EtLSloW2FdPDMmJihoW2EtMV0rPWhbYV0saC5wb3AoKSx1W2EtMV0rPXVbYV0sdS5wb3AoKSk7Zm9yKGE9MDthPHUubGVuZ3RoO2ErKylvKz1NYXRoLnBvdyh1W2FdLWhbYV0sMikvaFthXTtyZXR1cm4gZT11Lmxlbmd0aC0xLTEsVltlXVtuXTxvfSx0Lmtlcm5lbERlbnNpdHlFc3RpbWF0aW9uPU8sdC5rZGU9Tyx0LnpTY29yZT1mdW5jdGlvbih0LHIsbil7cmV0dXJuKHQtcikvbn0sdC5jdW11bGF0aXZlU3RkTm9ybWFsUHJvYmFiaWxpdHk9ZnVuY3Rpb24odCl7dmFyIHI9TWF0aC5hYnModCksbj1NYXRoLm1pbihNYXRoLnJvdW5kKDEwMCpyKSxILmxlbmd0aC0xKTtyZXR1cm4gMDw9dD9IW25dOisoMS1IW25dKS50b0ZpeGVkKDQpfSx0LnN0YW5kYXJkTm9ybWFsVGFibGU9SCx0LmVycm9yRnVuY3Rpb249Vyx0LmVyZj1XLHQuaW52ZXJzZUVycm9yRnVuY3Rpb249Six0LnByb2JpdD1mdW5jdGlvbih0KXtyZXR1cm4gMD09PXQ/dD1OOjE8PXQmJih0PTEtTiksTWF0aC5zcXJ0KDIpKkooMip0LTEpfSx0LnBlcm11dGF0aW9uVGVzdD1mdW5jdGlvbih0LHIsbixlKXtpZih2b2lkIDA9PT1lJiYoZT0xZTQpLHZvaWQgMD09PW4mJihuPVwidHdvX3NpZGVcIiksXCJ0d29fc2lkZVwiIT09biYmXCJncmVhdGVyXCIhPT1uJiZcImxlc3NcIiE9PW4pdGhyb3cgbmV3IEVycm9yKFwiYGFsdGVybmF0aXZlYCBtdXN0IGJlIGVpdGhlciAndHdvX3NpZGUnLCAnZ3JlYXRlcicsIG9yICdsZXNzJ1wiKTtmb3IodmFyIGE9Zyh0KS1nKHIpLG89bmV3IEFycmF5KGUpLGk9dC5jb25jYXQociksdT1NYXRoLmZsb29yKGkubGVuZ3RoLzIpLGg9MDtoPGU7aCsrKXtxKGkpO3ZhciBmPWkuc2xpY2UoMCx1KSxzPWkuc2xpY2UodSxpLmxlbmd0aCksbD1nKGYpLWcocyk7b1toXT1sfXZhciBjPTA7aWYoXCJ0d29fc2lkZVwiPT09bilmb3IoaD0wO2g8PWU7aCsrKU1hdGguYWJzKG9baF0pPj1NYXRoLmFicyhhKSYmKGMrPTEpO2Vsc2UgaWYoXCJncmVhdGVyXCI9PT1uKWZvcihoPTA7aDw9ZTtoKyspb1toXT49YSYmKGMrPTEpO2Vsc2UgZm9yKGg9MDtoPD1lO2grKylvW2hdPD1hJiYoYys9MSk7cmV0dXJuIGMvZX0sdC5iaXNlY3Q9ZnVuY3Rpb24odCxyLG4sZSxhKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJmdW5jIG11c3QgYmUgYSBmdW5jdGlvblwiKTtmb3IodmFyIG89MDtvPGU7bysrKXt2YXIgaT0ocituKS8yO2lmKDA9PT10KGkpfHxNYXRoLmFicygobi1yKS8yKTxhKXJldHVybiBpO1EodChpKSk9PT1RKHQocikpP3I9aTpuPWl9dGhyb3cgbmV3IEVycm9yKFwibWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyBleGNlZWRlZFwiKX0sdC5xdWlja3NlbGVjdD1jLHQuc2lnbj1RLHQubnVtZXJpY1NvcnQ9ZixPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2ltcGxlLXN0YXRpc3RpY3MubWluLmpzLm1hcFxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL190b3BvanNvbi1jbGllbnRAMy4xLjBAdG9wb2pzb24tY2xpZW50L2Rpc3QvdG9wb2pzb24tY2xpZW50LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL190b3BvanNvbi1jbGllbnRAMy4xLjBAdG9wb2pzb24tY2xpZW50L2Rpc3QvdG9wb2pzb24tY2xpZW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90b3BvanNvbi90b3BvanNvbi1jbGllbnQgdjMuMS4wIENvcHlyaWdodCAyMDE5IE1pa2UgQm9zdG9ja1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiB0cnVlID8gZmFjdG9yeShleHBvcnRzKSA6XG51bmRlZmluZWQ7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICBpZiAodHJhbnNmb3JtID09IG51bGwpIHJldHVybiBpZGVudGl0eTtcbiAgdmFyIHgwLFxuICAgICAgeTAsXG4gICAgICBreCA9IHRyYW5zZm9ybS5zY2FsZVswXSxcbiAgICAgIGt5ID0gdHJhbnNmb3JtLnNjYWxlWzFdLFxuICAgICAgZHggPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzBdLFxuICAgICAgZHkgPSB0cmFuc2Zvcm0udHJhbnNsYXRlWzFdO1xuICByZXR1cm4gZnVuY3Rpb24oaW5wdXQsIGkpIHtcbiAgICBpZiAoIWkpIHgwID0geTAgPSAwO1xuICAgIHZhciBqID0gMiwgbiA9IGlucHV0Lmxlbmd0aCwgb3V0cHV0ID0gbmV3IEFycmF5KG4pO1xuICAgIG91dHB1dFswXSA9ICh4MCArPSBpbnB1dFswXSkgKiBreCArIGR4O1xuICAgIG91dHB1dFsxXSA9ICh5MCArPSBpbnB1dFsxXSkgKiBreSArIGR5O1xuICAgIHdoaWxlIChqIDwgbikgb3V0cHV0W2pdID0gaW5wdXRbal0sICsrajtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufVxuXG5mdW5jdGlvbiBiYm94KHRvcG9sb2d5KSB7XG4gIHZhciB0ID0gdHJhbnNmb3JtKHRvcG9sb2d5LnRyYW5zZm9ybSksIGtleSxcbiAgICAgIHgwID0gSW5maW5pdHksIHkwID0geDAsIHgxID0gLXgwLCB5MSA9IC14MDtcblxuICBmdW5jdGlvbiBiYm94UG9pbnQocCkge1xuICAgIHAgPSB0KHApO1xuICAgIGlmIChwWzBdIDwgeDApIHgwID0gcFswXTtcbiAgICBpZiAocFswXSA+IHgxKSB4MSA9IHBbMF07XG4gICAgaWYgKHBbMV0gPCB5MCkgeTAgPSBwWzFdO1xuICAgIGlmIChwWzFdID4geTEpIHkxID0gcFsxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJib3hHZW9tZXRyeShvKSB7XG4gICAgc3dpdGNoIChvLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogby5nZW9tZXRyaWVzLmZvckVhY2goYmJveEdlb21ldHJ5KTsgYnJlYWs7XG4gICAgICBjYXNlIFwiUG9pbnRcIjogYmJveFBvaW50KG8uY29vcmRpbmF0ZXMpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6IG8uY29vcmRpbmF0ZXMuZm9yRWFjaChiYm94UG9pbnQpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICB0b3BvbG9neS5hcmNzLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IGFyYy5sZW5ndGgsIHA7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHAgPSB0KGFyY1tpXSwgaSk7XG4gICAgICBpZiAocFswXSA8IHgwKSB4MCA9IHBbMF07XG4gICAgICBpZiAocFswXSA+IHgxKSB4MSA9IHBbMF07XG4gICAgICBpZiAocFsxXSA8IHkwKSB5MCA9IHBbMV07XG4gICAgICBpZiAocFsxXSA+IHkxKSB5MSA9IHBbMV07XG4gICAgfVxuICB9KTtcblxuICBmb3IgKGtleSBpbiB0b3BvbG9neS5vYmplY3RzKSB7XG4gICAgYmJveEdlb21ldHJ5KHRvcG9sb2d5Lm9iamVjdHNba2V5XSk7XG4gIH1cblxuICByZXR1cm4gW3gwLCB5MCwgeDEsIHkxXTtcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZShhcnJheSwgbikge1xuICB2YXIgdCwgaiA9IGFycmF5Lmxlbmd0aCwgaSA9IGogLSBuO1xuICB3aGlsZSAoaSA8IC0taikgdCA9IGFycmF5W2ldLCBhcnJheVtpKytdID0gYXJyYXlbal0sIGFycmF5W2pdID0gdDtcbn1cblxuZnVuY3Rpb24gZmVhdHVyZSh0b3BvbG9neSwgbykge1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIG8gPSB0b3BvbG9neS5vYmplY3RzW29dO1xuICByZXR1cm4gby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiXG4gICAgICA/IHt0eXBlOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsIGZlYXR1cmVzOiBvLmdlb21ldHJpZXMubWFwKGZ1bmN0aW9uKG8pIHsgcmV0dXJuIGZlYXR1cmUkMSh0b3BvbG9neSwgbyk7IH0pfVxuICAgICAgOiBmZWF0dXJlJDEodG9wb2xvZ3ksIG8pO1xufVxuXG5mdW5jdGlvbiBmZWF0dXJlJDEodG9wb2xvZ3ksIG8pIHtcbiAgdmFyIGlkID0gby5pZCxcbiAgICAgIGJib3ggPSBvLmJib3gsXG4gICAgICBwcm9wZXJ0aWVzID0gby5wcm9wZXJ0aWVzID09IG51bGwgPyB7fSA6IG8ucHJvcGVydGllcyxcbiAgICAgIGdlb21ldHJ5ID0gb2JqZWN0KHRvcG9sb2d5LCBvKTtcbiAgcmV0dXJuIGlkID09IG51bGwgJiYgYmJveCA9PSBudWxsID8ge3R5cGU6IFwiRmVhdHVyZVwiLCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9XG4gICAgICA6IGJib3ggPT0gbnVsbCA/IHt0eXBlOiBcIkZlYXR1cmVcIiwgaWQ6IGlkLCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9XG4gICAgICA6IHt0eXBlOiBcIkZlYXR1cmVcIiwgaWQ6IGlkLCBiYm94OiBiYm94LCBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLCBnZW9tZXRyeTogZ2VvbWV0cnl9O1xufVxuXG5mdW5jdGlvbiBvYmplY3QodG9wb2xvZ3ksIG8pIHtcbiAgdmFyIHRyYW5zZm9ybVBvaW50ID0gdHJhbnNmb3JtKHRvcG9sb2d5LnRyYW5zZm9ybSksXG4gICAgICBhcmNzID0gdG9wb2xvZ3kuYXJjcztcblxuICBmdW5jdGlvbiBhcmMoaSwgcG9pbnRzKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGgpIHBvaW50cy5wb3AoKTtcbiAgICBmb3IgKHZhciBhID0gYXJjc1tpIDwgMCA/IH5pIDogaV0sIGsgPSAwLCBuID0gYS5sZW5ndGg7IGsgPCBuOyArK2spIHtcbiAgICAgIHBvaW50cy5wdXNoKHRyYW5zZm9ybVBvaW50KGFba10sIGspKTtcbiAgICB9XG4gICAgaWYgKGkgPCAwKSByZXZlcnNlKHBvaW50cywgbik7XG4gIH1cblxuICBmdW5jdGlvbiBwb2ludChwKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBvaW50KHApO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZShhcmNzKSB7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJjcy5sZW5ndGg7IGkgPCBuOyArK2kpIGFyYyhhcmNzW2ldLCBwb2ludHMpO1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMikgcG9pbnRzLnB1c2gocG9pbnRzWzBdKTsgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIHBlciB0aGUgc3BlY2lmaWNhdGlvbi5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmluZyhhcmNzKSB7XG4gICAgdmFyIHBvaW50cyA9IGxpbmUoYXJjcyk7XG4gICAgd2hpbGUgKHBvaW50cy5sZW5ndGggPCA0KSBwb2ludHMucHVzaChwb2ludHNbMF0pOyAvLyBUaGlzIG1heSBoYXBwZW4gaWYgYW4gYXJjIGhhcyBvbmx5IHR3byBwb2ludHMuXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb24oYXJjcykge1xuICAgIHJldHVybiBhcmNzLm1hcChyaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICB2YXIgdHlwZSA9IG8udHlwZSwgY29vcmRpbmF0ZXM7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IHJldHVybiB7dHlwZTogdHlwZSwgZ2VvbWV0cmllczogby5nZW9tZXRyaWVzLm1hcChnZW9tZXRyeSl9O1xuICAgICAgY2FzZSBcIlBvaW50XCI6IGNvb3JkaW5hdGVzID0gcG9pbnQoby5jb29yZGluYXRlcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogY29vcmRpbmF0ZXMgPSBvLmNvb3JkaW5hdGVzLm1hcChwb2ludCk7IGJyZWFrO1xuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjogY29vcmRpbmF0ZXMgPSBsaW5lKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOiBjb29yZGluYXRlcyA9IG8uYXJjcy5tYXAobGluZSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjogY29vcmRpbmF0ZXMgPSBwb2x5Z29uKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiBjb29yZGluYXRlcyA9IG8uYXJjcy5tYXAocG9seWdvbik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7dHlwZTogdHlwZSwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzfTtcbiAgfVxuXG4gIHJldHVybiBnZW9tZXRyeShvKTtcbn1cblxuZnVuY3Rpb24gc3RpdGNoKHRvcG9sb2d5LCBhcmNzKSB7XG4gIHZhciBzdGl0Y2hlZEFyY3MgPSB7fSxcbiAgICAgIGZyYWdtZW50QnlTdGFydCA9IHt9LFxuICAgICAgZnJhZ21lbnRCeUVuZCA9IHt9LFxuICAgICAgZnJhZ21lbnRzID0gW10sXG4gICAgICBlbXB0eUluZGV4ID0gLTE7XG5cbiAgLy8gU3RpdGNoIGVtcHR5IGFyY3MgZmlyc3QsIHNpbmNlIHRoZXkgbWF5IGJlIHN1YnN1bWVkIGJ5IG90aGVyIGFyY3MuXG4gIGFyY3MuZm9yRWFjaChmdW5jdGlvbihpLCBqKSB7XG4gICAgdmFyIGFyYyA9IHRvcG9sb2d5LmFyY3NbaSA8IDAgPyB+aSA6IGldLCB0O1xuICAgIGlmIChhcmMubGVuZ3RoIDwgMyAmJiAhYXJjWzFdWzBdICYmICFhcmNbMV1bMV0pIHtcbiAgICAgIHQgPSBhcmNzWysrZW1wdHlJbmRleF0sIGFyY3NbZW1wdHlJbmRleF0gPSBpLCBhcmNzW2pdID0gdDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyY3MuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgdmFyIGUgPSBlbmRzKGkpLFxuICAgICAgICBzdGFydCA9IGVbMF0sXG4gICAgICAgIGVuZCA9IGVbMV0sXG4gICAgICAgIGYsIGc7XG5cbiAgICBpZiAoZiA9IGZyYWdtZW50QnlFbmRbc3RhcnRdKSB7XG4gICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtmLmVuZF07XG4gICAgICBmLnB1c2goaSk7XG4gICAgICBmLmVuZCA9IGVuZDtcbiAgICAgIGlmIChnID0gZnJhZ21lbnRCeVN0YXJ0W2VuZF0pIHtcbiAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtnLnN0YXJ0XTtcbiAgICAgICAgdmFyIGZnID0gZyA9PT0gZiA/IGYgOiBmLmNvbmNhdChnKTtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2ZnLnN0YXJ0ID0gZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2ZnLmVuZCA9IGcuZW5kXSA9IGZnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZF0gPSBmO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZiA9IGZyYWdtZW50QnlTdGFydFtlbmRdKSB7XG4gICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgZi51bnNoaWZ0KGkpO1xuICAgICAgZi5zdGFydCA9IHN0YXJ0O1xuICAgICAgaWYgKGcgPSBmcmFnbWVudEJ5RW5kW3N0YXJ0XSkge1xuICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtnLmVuZF07XG4gICAgICAgIHZhciBnZiA9IGcgPT09IGYgPyBmIDogZy5jb25jYXQoZik7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtnZi5zdGFydCA9IGcuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtnZi5lbmQgPSBmLmVuZF0gPSBnZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0gZjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZiA9IFtpXTtcbiAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0ID0gc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZCA9IGVuZF0gPSBmO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZW5kcyhpKSB7XG4gICAgdmFyIGFyYyA9IHRvcG9sb2d5LmFyY3NbaSA8IDAgPyB+aSA6IGldLCBwMCA9IGFyY1swXSwgcDE7XG4gICAgaWYgKHRvcG9sb2d5LnRyYW5zZm9ybSkgcDEgPSBbMCwgMF0sIGFyYy5mb3JFYWNoKGZ1bmN0aW9uKGRwKSB7IHAxWzBdICs9IGRwWzBdLCBwMVsxXSArPSBkcFsxXTsgfSk7XG4gICAgZWxzZSBwMSA9IGFyY1thcmMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGkgPCAwID8gW3AxLCBwMF0gOiBbcDAsIHAxXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKGZyYWdtZW50QnlFbmQsIGZyYWdtZW50QnlTdGFydCkge1xuICAgIGZvciAodmFyIGsgaW4gZnJhZ21lbnRCeUVuZCkge1xuICAgICAgdmFyIGYgPSBmcmFnbWVudEJ5RW5kW2tdO1xuICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgIGRlbGV0ZSBmLnN0YXJ0O1xuICAgICAgZGVsZXRlIGYuZW5kO1xuICAgICAgZi5mb3JFYWNoKGZ1bmN0aW9uKGkpIHsgc3RpdGNoZWRBcmNzW2kgPCAwID8gfmkgOiBpXSA9IDE7IH0pO1xuICAgICAgZnJhZ21lbnRzLnB1c2goZik7XG4gICAgfVxuICB9XG5cbiAgZmx1c2goZnJhZ21lbnRCeUVuZCwgZnJhZ21lbnRCeVN0YXJ0KTtcbiAgZmx1c2goZnJhZ21lbnRCeVN0YXJ0LCBmcmFnbWVudEJ5RW5kKTtcbiAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHsgaWYgKCFzdGl0Y2hlZEFyY3NbaSA8IDAgPyB+aSA6IGldKSBmcmFnbWVudHMucHVzaChbaV0pOyB9KTtcblxuICByZXR1cm4gZnJhZ21lbnRzO1xufVxuXG5mdW5jdGlvbiBtZXNoKHRvcG9sb2d5KSB7XG4gIHJldHVybiBvYmplY3QodG9wb2xvZ3ksIG1lc2hBcmNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufVxuXG5mdW5jdGlvbiBtZXNoQXJjcyh0b3BvbG9neSwgb2JqZWN0LCBmaWx0ZXIpIHtcbiAgdmFyIGFyY3MsIGksIG47XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgYXJjcyA9IGV4dHJhY3RBcmNzKHRvcG9sb2d5LCBvYmplY3QsIGZpbHRlcik7XG4gIGVsc2UgZm9yIChpID0gMCwgYXJjcyA9IG5ldyBBcnJheShuID0gdG9wb2xvZ3kuYXJjcy5sZW5ndGgpOyBpIDwgbjsgKytpKSBhcmNzW2ldID0gaTtcbiAgcmV0dXJuIHt0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLCBhcmNzOiBzdGl0Y2godG9wb2xvZ3ksIGFyY3MpfTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEFyY3ModG9wb2xvZ3ksIG9iamVjdCwgZmlsdGVyKSB7XG4gIHZhciBhcmNzID0gW10sXG4gICAgICBnZW9tc0J5QXJjID0gW10sXG4gICAgICBnZW9tO1xuXG4gIGZ1bmN0aW9uIGV4dHJhY3QwKGkpIHtcbiAgICB2YXIgaiA9IGkgPCAwID8gfmkgOiBpO1xuICAgIChnZW9tc0J5QXJjW2pdIHx8IChnZW9tc0J5QXJjW2pdID0gW10pKS5wdXNoKHtpOiBpLCBnOiBnZW9tfSk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0MShhcmNzKSB7XG4gICAgYXJjcy5mb3JFYWNoKGV4dHJhY3QwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QyKGFyY3MpIHtcbiAgICBhcmNzLmZvckVhY2goZXh0cmFjdDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDMoYXJjcykge1xuICAgIGFyY3MuZm9yRWFjaChleHRyYWN0Mik7XG4gIH1cblxuICBmdW5jdGlvbiBnZW9tZXRyeShvKSB7XG4gICAgc3dpdGNoIChnZW9tID0gbywgby50eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IG8uZ2VvbWV0cmllcy5mb3JFYWNoKGdlb21ldHJ5KTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOiBleHRyYWN0MShvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aUxpbmVTdHJpbmdcIjogY2FzZSBcIlBvbHlnb25cIjogZXh0cmFjdDIoby5hcmNzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2x5Z29uXCI6IGV4dHJhY3QzKG8uYXJjcyk7IGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGdlb21ldHJ5KG9iamVjdCk7XG5cbiAgZ2VvbXNCeUFyYy5mb3JFYWNoKGZpbHRlciA9PSBudWxsXG4gICAgICA/IGZ1bmN0aW9uKGdlb21zKSB7IGFyY3MucHVzaChnZW9tc1swXS5pKTsgfVxuICAgICAgOiBmdW5jdGlvbihnZW9tcykgeyBpZiAoZmlsdGVyKGdlb21zWzBdLmcsIGdlb21zW2dlb21zLmxlbmd0aCAtIDFdLmcpKSBhcmNzLnB1c2goZ2VvbXNbMF0uaSk7IH0pO1xuXG4gIHJldHVybiBhcmNzO1xufVxuXG5mdW5jdGlvbiBwbGFuYXJSaW5nQXJlYShyaW5nKSB7XG4gIHZhciBpID0gLTEsIG4gPSByaW5nLmxlbmd0aCwgYSwgYiA9IHJpbmdbbiAtIDFdLCBhcmVhID0gMDtcbiAgd2hpbGUgKCsraSA8IG4pIGEgPSBiLCBiID0gcmluZ1tpXSwgYXJlYSArPSBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdO1xuICByZXR1cm4gTWF0aC5hYnMoYXJlYSk7IC8vIE5vdGU6IGRvdWJsZWQgYXJlYSFcbn1cblxuZnVuY3Rpb24gbWVyZ2UodG9wb2xvZ3kpIHtcbiAgcmV0dXJuIG9iamVjdCh0b3BvbG9neSwgbWVyZ2VBcmNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufVxuXG5mdW5jdGlvbiBtZXJnZUFyY3ModG9wb2xvZ3ksIG9iamVjdHMpIHtcbiAgdmFyIHBvbHlnb25zQnlBcmMgPSB7fSxcbiAgICAgIHBvbHlnb25zID0gW10sXG4gICAgICBncm91cHMgPSBbXTtcblxuICBvYmplY3RzLmZvckVhY2goZ2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjogZXh0cmFjdChvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogby5hcmNzLmZvckVhY2goZXh0cmFjdCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QocG9seWdvbikge1xuICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgIChwb2x5Z29uc0J5QXJjW2FyYyA9IGFyYyA8IDAgPyB+YXJjIDogYXJjXSB8fCAocG9seWdvbnNCeUFyY1thcmNdID0gW10pKS5wdXNoKHBvbHlnb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZWEocmluZykge1xuICAgIHJldHVybiBwbGFuYXJSaW5nQXJlYShvYmplY3QodG9wb2xvZ3ksIHt0eXBlOiBcIlBvbHlnb25cIiwgYXJjczogW3JpbmddfSkuY29vcmRpbmF0ZXNbMF0pO1xuICB9XG5cbiAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgaWYgKCFwb2x5Z29uLl8pIHtcbiAgICAgIHZhciBncm91cCA9IFtdLFxuICAgICAgICAgIG5laWdoYm9ycyA9IFtwb2x5Z29uXTtcbiAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgICB3aGlsZSAocG9seWdvbiA9IG5laWdoYm9ycy5wb3AoKSkge1xuICAgICAgICBncm91cC5wdXNoKHBvbHlnb24pO1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgIHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICAgICAgICBpZiAoIXBvbHlnb24uXykge1xuICAgICAgICAgICAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocG9seWdvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgIGRlbGV0ZSBwb2x5Z29uLl87XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJNdWx0aVBvbHlnb25cIixcbiAgICBhcmNzOiBncm91cHMubWFwKGZ1bmN0aW9uKHBvbHlnb25zKSB7XG4gICAgICB2YXIgYXJjcyA9IFtdLCBuO1xuXG4gICAgICAvLyBFeHRyYWN0IHRoZSBleHRlcmlvciAodW5pcXVlKSBhcmNzLlxuICAgICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICAgICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAgICAgaWYgKHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgYXJjcy5wdXNoKGFyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFN0aXRjaCB0aGUgYXJjcyBpbnRvIG9uZSBvciBtb3JlIHJpbmdzLlxuICAgICAgYXJjcyA9IHN0aXRjaCh0b3BvbG9neSwgYXJjcyk7XG5cbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgcmluZyBpcyByZXR1cm5lZCxcbiAgICAgIC8vIGF0IG1vc3Qgb25lIG9mIHRoZXNlIHJpbmdzIGNhbiBiZSB0aGUgZXh0ZXJpb3I7XG4gICAgICAvLyBjaG9vc2UgdGhlIG9uZSB3aXRoIHRoZSBncmVhdGVzdCBhYnNvbHV0ZSBhcmVhLlxuICAgICAgaWYgKChuID0gYXJjcy5sZW5ndGgpID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgayA9IGFyZWEoYXJjc1swXSksIGtpLCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgaWYgKChraSA9IGFyZWEoYXJjc1tpXSkpID4gaykge1xuICAgICAgICAgICAgdCA9IGFyY3NbMF0sIGFyY3NbMF0gPSBhcmNzW2ldLCBhcmNzW2ldID0gdCwgayA9IGtpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJjcztcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24oYXJjcykge1xuICAgICAgcmV0dXJuIGFyY3MubGVuZ3RoID4gMDtcbiAgICB9KVxuICB9O1xufVxuXG5mdW5jdGlvbiBiaXNlY3QoYSwgeCkge1xuICB2YXIgbG8gPSAwLCBoaSA9IGEubGVuZ3RoO1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgIGlmIChhW21pZF0gPCB4KSBsbyA9IG1pZCArIDE7XG4gICAgZWxzZSBoaSA9IG1pZDtcbiAgfVxuICByZXR1cm4gbG87XG59XG5cbmZ1bmN0aW9uIG5laWdoYm9ycyhvYmplY3RzKSB7XG4gIHZhciBpbmRleGVzQnlBcmMgPSB7fSwgLy8gYXJjIGluZGV4IC0+IGFycmF5IG9mIG9iamVjdCBpbmRleGVzXG4gICAgICBuZWlnaGJvcnMgPSBvYmplY3RzLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcblxuICBmdW5jdGlvbiBsaW5lKGFyY3MsIGkpIHtcbiAgICBhcmNzLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgaWYgKGEgPCAwKSBhID0gfmE7XG4gICAgICB2YXIgbyA9IGluZGV4ZXNCeUFyY1thXTtcbiAgICAgIGlmIChvKSBvLnB1c2goaSk7XG4gICAgICBlbHNlIGluZGV4ZXNCeUFyY1thXSA9IFtpXTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb24oYXJjcywgaSkge1xuICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHsgbGluZShhcmMsIGkpOyB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8sIGkpIHtcbiAgICBpZiAoby50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKSBvLmdlb21ldHJpZXMuZm9yRWFjaChmdW5jdGlvbihvKSB7IGdlb21ldHJ5KG8sIGkpOyB9KTtcbiAgICBlbHNlIGlmIChvLnR5cGUgaW4gZ2VvbWV0cnlUeXBlKSBnZW9tZXRyeVR5cGVbby50eXBlXShvLmFyY3MsIGkpO1xuICB9XG5cbiAgdmFyIGdlb21ldHJ5VHlwZSA9IHtcbiAgICBMaW5lU3RyaW5nOiBsaW5lLFxuICAgIE11bHRpTGluZVN0cmluZzogcG9seWdvbixcbiAgICBQb2x5Z29uOiBwb2x5Z29uLFxuICAgIE11bHRpUG9seWdvbjogZnVuY3Rpb24oYXJjcywgaSkgeyBhcmNzLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7IHBvbHlnb24oYXJjLCBpKTsgfSk7IH1cbiAgfTtcblxuICBvYmplY3RzLmZvckVhY2goZ2VvbWV0cnkpO1xuXG4gIGZvciAodmFyIGkgaW4gaW5kZXhlc0J5QXJjKSB7XG4gICAgZm9yICh2YXIgaW5kZXhlcyA9IGluZGV4ZXNCeUFyY1tpXSwgbSA9IGluZGV4ZXMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgbTsgKytrKSB7XG4gICAgICAgIHZhciBpaiA9IGluZGV4ZXNbal0sIGlrID0gaW5kZXhlc1trXSwgbjtcbiAgICAgICAgaWYgKChuID0gbmVpZ2hib3JzW2lqXSlbaSA9IGJpc2VjdChuLCBpayldICE9PSBpaykgbi5zcGxpY2UoaSwgMCwgaWspO1xuICAgICAgICBpZiAoKG4gPSBuZWlnaGJvcnNbaWtdKVtpID0gYmlzZWN0KG4sIGlqKV0gIT09IGlqKSBuLnNwbGljZShpLCAwLCBpaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5laWdoYm9ycztcbn1cblxuZnVuY3Rpb24gdW50cmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gIGlmICh0cmFuc2Zvcm0gPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICB2YXIgeDAsXG4gICAgICB5MCxcbiAgICAgIGt4ID0gdHJhbnNmb3JtLnNjYWxlWzBdLFxuICAgICAga3kgPSB0cmFuc2Zvcm0uc2NhbGVbMV0sXG4gICAgICBkeCA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMF0sXG4gICAgICBkeSA9IHRyYW5zZm9ybS50cmFuc2xhdGVbMV07XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaSkge1xuICAgIGlmICghaSkgeDAgPSB5MCA9IDA7XG4gICAgdmFyIGogPSAyLFxuICAgICAgICBuID0gaW5wdXQubGVuZ3RoLFxuICAgICAgICBvdXRwdXQgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHgxID0gTWF0aC5yb3VuZCgoaW5wdXRbMF0gLSBkeCkgLyBreCksXG4gICAgICAgIHkxID0gTWF0aC5yb3VuZCgoaW5wdXRbMV0gLSBkeSkgLyBreSk7XG4gICAgb3V0cHV0WzBdID0geDEgLSB4MCwgeDAgPSB4MTtcbiAgICBvdXRwdXRbMV0gPSB5MSAtIHkwLCB5MCA9IHkxO1xuICAgIHdoaWxlIChqIDwgbikgb3V0cHV0W2pdID0gaW5wdXRbal0sICsrajtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufVxuXG5mdW5jdGlvbiBxdWFudGl6ZSh0b3BvbG9neSwgdHJhbnNmb3JtKSB7XG4gIGlmICh0b3BvbG9neS50cmFuc2Zvcm0pIHRocm93IG5ldyBFcnJvcihcImFscmVhZHkgcXVhbnRpemVkXCIpO1xuXG4gIGlmICghdHJhbnNmb3JtIHx8ICF0cmFuc2Zvcm0uc2NhbGUpIHtcbiAgICBpZiAoISgobiA9IE1hdGguZmxvb3IodHJhbnNmb3JtKSkgPj0gMikpIHRocm93IG5ldyBFcnJvcihcIm4gbXVzdCBiZSDiiaUyXCIpO1xuICAgIGJveCA9IHRvcG9sb2d5LmJib3ggfHwgYmJveCh0b3BvbG9neSk7XG4gICAgdmFyIHgwID0gYm94WzBdLCB5MCA9IGJveFsxXSwgeDEgPSBib3hbMl0sIHkxID0gYm94WzNdLCBuO1xuICAgIHRyYW5zZm9ybSA9IHtzY2FsZTogW3gxIC0geDAgPyAoeDEgLSB4MCkgLyAobiAtIDEpIDogMSwgeTEgLSB5MCA/ICh5MSAtIHkwKSAvIChuIC0gMSkgOiAxXSwgdHJhbnNsYXRlOiBbeDAsIHkwXX07XG4gIH0gZWxzZSB7XG4gICAgYm94ID0gdG9wb2xvZ3kuYmJveDtcbiAgfVxuXG4gIHZhciB0ID0gdW50cmFuc2Zvcm0odHJhbnNmb3JtKSwgYm94LCBrZXksIGlucHV0cyA9IHRvcG9sb2d5Lm9iamVjdHMsIG91dHB1dHMgPSB7fTtcblxuICBmdW5jdGlvbiBxdWFudGl6ZVBvaW50KHBvaW50KSB7XG4gICAgcmV0dXJuIHQocG9pbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcXVhbnRpemVHZW9tZXRyeShpbnB1dCkge1xuICAgIHZhciBvdXRwdXQ7XG4gICAgc3dpdGNoIChpbnB1dC50eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IG91dHB1dCA9IHt0eXBlOiBcIkdlb21ldHJ5Q29sbGVjdGlvblwiLCBnZW9tZXRyaWVzOiBpbnB1dC5nZW9tZXRyaWVzLm1hcChxdWFudGl6ZUdlb21ldHJ5KX07IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvaW50XCI6IG91dHB1dCA9IHt0eXBlOiBcIlBvaW50XCIsIGNvb3JkaW5hdGVzOiBxdWFudGl6ZVBvaW50KGlucHV0LmNvb3JkaW5hdGVzKX07IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogb3V0cHV0ID0ge3R5cGU6IFwiTXVsdGlQb2ludFwiLCBjb29yZGluYXRlczogaW5wdXQuY29vcmRpbmF0ZXMubWFwKHF1YW50aXplUG9pbnQpfTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGlmIChpbnB1dC5pZCAhPSBudWxsKSBvdXRwdXQuaWQgPSBpbnB1dC5pZDtcbiAgICBpZiAoaW5wdXQuYmJveCAhPSBudWxsKSBvdXRwdXQuYmJveCA9IGlucHV0LmJib3g7XG4gICAgaWYgKGlucHV0LnByb3BlcnRpZXMgIT0gbnVsbCkgb3V0cHV0LnByb3BlcnRpZXMgPSBpbnB1dC5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGl6ZUFyYyhpbnB1dCkge1xuICAgIHZhciBpID0gMCwgaiA9IDEsIG4gPSBpbnB1dC5sZW5ndGgsIHAsIG91dHB1dCA9IG5ldyBBcnJheShuKTsgLy8gcGVzc2ltaXN0aWNcbiAgICBvdXRwdXRbMF0gPSB0KGlucHV0WzBdLCAwKTtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKChwID0gdChpbnB1dFtpXSwgaSkpWzBdIHx8IHBbMV0pIG91dHB1dFtqKytdID0gcDsgLy8gbm9uLWNvaW5jaWRlbnQgcG9pbnRzXG4gICAgaWYgKGogPT09IDEpIG91dHB1dFtqKytdID0gWzAsIDBdOyAvLyBhbiBhcmMgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBwb2ludHNcbiAgICBvdXRwdXQubGVuZ3RoID0gajtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgZm9yIChrZXkgaW4gaW5wdXRzKSBvdXRwdXRzW2tleV0gPSBxdWFudGl6ZUdlb21ldHJ5KGlucHV0c1trZXldKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVG9wb2xvZ3lcIixcbiAgICBiYm94OiBib3gsXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgb2JqZWN0czogb3V0cHV0cyxcbiAgICBhcmNzOiB0b3BvbG9neS5hcmNzLm1hcChxdWFudGl6ZUFyYylcbiAgfTtcbn1cblxuZXhwb3J0cy5iYm94ID0gYmJveDtcbmV4cG9ydHMuZmVhdHVyZSA9IGZlYXR1cmU7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5leHBvcnRzLm1lcmdlQXJjcyA9IG1lcmdlQXJjcztcbmV4cG9ydHMubWVzaCA9IG1lc2g7XG5leHBvcnRzLm1lc2hBcmNzID0gbWVzaEFyY3M7XG5leHBvcnRzLm5laWdoYm9ycyA9IG5laWdoYm9ycztcbmV4cG9ydHMucXVhbnRpemUgPSBxdWFudGl6ZTtcbmV4cG9ydHMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuZXhwb3J0cy51bnRyYW5zZm9ybSA9IHVudHJhbnNmb3JtO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7dmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBnbG9iYWwsIGRlZmluZSwgU3lzdGVtLCBSZWZsZWN0LCBQcm9taXNlICovXHJcbnZhciBfX2V4dGVuZHM7XHJcbnZhciBfX2Fzc2lnbjtcclxudmFyIF9fcmVzdDtcclxudmFyIF9fZGVjb3JhdGU7XHJcbnZhciBfX3BhcmFtO1xyXG52YXIgX19tZXRhZGF0YTtcclxudmFyIF9fYXdhaXRlcjtcclxudmFyIF9fZ2VuZXJhdG9yO1xyXG52YXIgX19leHBvcnRTdGFyO1xyXG52YXIgX192YWx1ZXM7XHJcbnZhciBfX3JlYWQ7XHJcbnZhciBfX3NwcmVhZDtcclxudmFyIF9fc3ByZWFkQXJyYXlzO1xyXG52YXIgX19hd2FpdDtcclxudmFyIF9fYXN5bmNHZW5lcmF0b3I7XHJcbnZhciBfX2FzeW5jRGVsZWdhdG9yO1xyXG52YXIgX19hc3luY1ZhbHVlcztcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0O1xyXG52YXIgX19pbXBvcnRTdGFyO1xyXG52YXIgX19pbXBvcnREZWZhdWx0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQ7XHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDoge307XHJcbiAgICBpZiAodHJ1ZSkge1xyXG4gICAgICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtleHBvcnRzXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzKSkpOyB9KS5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSxcblx0XHRcdFx0X19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7fVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cywgcHJldmlvdXMpIHtcclxuICAgICAgICBpZiAoZXhwb3J0cyAhPT0gcm9vdCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGlkLCB2KSB7IHJldHVybiBleHBvcnRzW2lkXSA9IHByZXZpb3VzID8gcHJldmlvdXMoaWQsIHYpIDogdjsgfTtcclxuICAgIH1cclxufSlcclxuKGZ1bmN0aW9uIChleHBvcnRlcikge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3Jlc3QgPSBmdW5jdGlvbiAocywgZSkge1xyXG4gICAgICAgIHZhciB0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZGVjb3JhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3BhcmFtID0gZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdGVyID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZ2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgX19leHBvcnRTdGFyID0gZnVuY3Rpb24gKG0sIGV4cG9ydHMpIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fdmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3JlYWQgPSBmdW5jdGlvbiAobywgbikge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgICAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc3ByZWFkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZEFycmF5cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXQgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgIH1cclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY0RlbGVnYXRvciA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIGksIHA7XHJcbiAgICAgICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNWYWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgICAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3QgPSBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgICAgIHJldHVybiBjb29rZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0U3RhciA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnREZWZhdWx0ID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gZnVuY3Rpb24gKHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XHJcbiAgICAgICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGV4cG9ydGVyKFwiX19leHRlbmRzXCIsIF9fZXh0ZW5kcyk7XHJcbiAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZXN0XCIsIF9fcmVzdCk7XHJcbiAgICBleHBvcnRlcihcIl9fZGVjb3JhdGVcIiwgX19kZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbSk7XHJcbiAgICBleHBvcnRlcihcIl9fbWV0YWRhdGFcIiwgX19tZXRhZGF0YSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRlclwiLCBfX2F3YWl0ZXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fZXhwb3J0U3RhclwiLCBfX2V4cG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlzXCIsIF9fc3ByZWFkQXJyYXlzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0KTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgX19tYWtlVGVtcGxhdGVPYmplY3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydFN0YXJcIiwgX19pbXBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCk7XHJcbn0pO1xyXG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLy4uL193ZWJwYWNrQDQuNDIuMUB3ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzICovIFwiLi9ub2RlX21vZHVsZXMvX3dlYnBhY2tANC40Mi4xQHdlYnBhY2svYnVpbGRpbi9nbG9iYWwuanNcIikpKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9fd2VicGFja0A0LjQyLjFAd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvX3dlYnBhY2tANC40Mi4xQHdlYnBhY2svYnVpbGRpbi9tb2R1bGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL193b2xmeTg3LWV2ZW50ZW1pdHRlckA1LjIuOUB3b2xmeTg3LWV2ZW50ZW1pdHRlci9FdmVudEVtaXR0ZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9fd29sZnk4Ny1ldmVudGVtaXR0ZXJANS4yLjlAd29sZnk4Ny1ldmVudGVtaXR0ZXIvRXZlbnRFbWl0dGVyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIVxuICogRXZlbnRFbWl0dGVyIHY1LjIuOSAtIGdpdC5pby9lZVxuICogVW5saWNlbnNlIC0gaHR0cDovL3VubGljZW5zZS5vcmcvXG4gKiBPbGl2ZXIgQ2FsZHdlbGwgLSBodHRwczovL29saS5tZS51ay9cbiAqIEBwcmVzZXJ2ZVxuICovXG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBmb3IgbWFuYWdpbmcgZXZlbnRzLlxuICAgICAqIENhbiBiZSBleHRlbmRlZCB0byBwcm92aWRlIGV2ZW50IGZ1bmN0aW9uYWxpdHkgaW4gb3RoZXIgY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIEBjbGFzcyBFdmVudEVtaXR0ZXIgTWFuYWdlcyBldmVudCByZWdpc3RlcmluZyBhbmQgZW1pdHRpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge31cblxuICAgIC8vIFNob3J0Y3V0cyB0byBpbXByb3ZlIHNwZWVkIGFuZCBzaXplXG4gICAgdmFyIHByb3RvID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZTtcbiAgICB2YXIgb3JpZ2luYWxHbG9iYWxWYWx1ZSA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyO1xuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50IGluIGl0cyBzdG9yYWdlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfSBsaXN0ZW5lcnMgQXJyYXkgb2YgbGlzdGVuZXJzIHRvIHNlYXJjaCB0aHJvdWdoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBsb29rIGZvci5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIsIC0xIGlmIG5vdCBmb3VuZFxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnMsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBpID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBhIG1ldGhvZCB3aGlsZSBrZWVwaW5nIHRoZSBjb250ZXh0IGNvcnJlY3QsIHRvIGFsbG93IGZvciBvdmVyd3JpdGluZyBvZiB0YXJnZXQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhcmdldCBtZXRob2QuXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBhbGlhc2VkIG1ldGhvZFxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFsaWFzKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFsaWFzQ2xvc3VyZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogV2lsbCBpbml0aWFsaXNlIHRoZSBldmVudCBvYmplY3QgYW5kIGxpc3RlbmVyIGFycmF5cyBpZiByZXF1aXJlZC5cbiAgICAgKiBXaWxsIHJldHVybiBhbiBvYmplY3QgaWYgeW91IHVzZSBhIHJlZ2V4IHNlYXJjaC4gVGhlIG9iamVjdCBjb250YWlucyBrZXlzIGZvciBlYWNoIG1hdGNoZWQgZXZlbnQuIFNvIC9iYVtyel0vIG1pZ2h0IHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBiYXIgYW5kIGJhei4gQnV0IG9ubHkgaWYgeW91IGhhdmUgZWl0aGVyIGRlZmluZWQgdGhlbSB3aXRoIGRlZmluZUV2ZW50IG9yIGFkZGVkIHNvbWUgbGlzdGVuZXJzIHRvIHRoZW0uXG4gICAgICogRWFjaCBwcm9wZXJ0eSBpbiB0aGUgb2JqZWN0IHJlc3BvbnNlIGlzIGFuIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIHJldHVybiB0aGUgbGlzdGVuZXJzIGZyb20uXG4gICAgICogQHJldHVybiB7RnVuY3Rpb25bXXxPYmplY3R9IEFsbCBsaXN0ZW5lciBmdW5jdGlvbnMgZm9yIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBwcm90by5nZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRMaXN0ZW5lcnMoZXZ0KSB7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9nZXRFdmVudHMoKTtcbiAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICB2YXIga2V5O1xuXG4gICAgICAgIC8vIFJldHVybiBhIGNvbmNhdGVuYXRlZCBhcnJheSBvZiBhbGwgbWF0Y2hpbmcgZXZlbnRzIGlmXG4gICAgICAgIC8vIHRoZSBzZWxlY3RvciBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgICAgaWYgKGV2dCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB7fTtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIGV2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBldnQudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlW2tleV0gPSBldmVudHNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGV2ZW50c1tldnRdIHx8IChldmVudHNbZXZ0XSA9IFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBsaXN0IG9mIGxpc3RlbmVyIG9iamVjdHMgYW5kIGZsYXR0ZW5zIGl0IGludG8gYSBsaXN0IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IGxpc3RlbmVycyBSYXcgbGlzdGVuZXIgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbltdfSBKdXN0IHRoZSBsaXN0ZW5lciBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgcHJvdG8uZmxhdHRlbkxpc3RlbmVycyA9IGZ1bmN0aW9uIGZsYXR0ZW5MaXN0ZW5lcnMobGlzdGVuZXJzKSB7XG4gICAgICAgIHZhciBmbGF0TGlzdGVuZXJzID0gW107XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGZsYXRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcnNbaV0ubGlzdGVuZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZsYXRMaXN0ZW5lcnM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIHJlcXVlc3RlZCBsaXN0ZW5lcnMgdmlhIGdldExpc3RlbmVycyBidXQgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSByZXN1bHRzIGluc2lkZSBhbiBvYmplY3QuIFRoaXMgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UgYnV0IG90aGVycyBtYXkgZmluZCBpdCB1c2VmdWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byByZXR1cm4gdGhlIGxpc3RlbmVycyBmcm9tLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQWxsIGxpc3RlbmVyIGZ1bmN0aW9ucyBmb3IgYW4gZXZlbnQgaW4gYW4gb2JqZWN0LlxuICAgICAqL1xuICAgIHByb3RvLmdldExpc3RlbmVyc0FzT2JqZWN0ID0gZnVuY3Rpb24gZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVycyhldnQpO1xuICAgICAgICB2YXIgcmVzcG9uc2U7XG5cbiAgICAgICAgaWYgKGxpc3RlbmVycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IHt9O1xuICAgICAgICAgICAgcmVzcG9uc2VbZXZ0XSA9IGxpc3RlbmVycztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZSB8fCBsaXN0ZW5lcnM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzVmFsaWRMaXN0ZW5lciAobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyB8fCBsaXN0ZW5lciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lciAmJiB0eXBlb2YgbGlzdGVuZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNWYWxpZExpc3RlbmVyKGxpc3RlbmVyLmxpc3RlbmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgZnVuY3Rpb24gdG8gdGhlIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBUaGUgbGlzdGVuZXIgd2lsbCBub3QgYmUgYWRkZWQgaWYgaXQgaXMgYSBkdXBsaWNhdGUuXG4gICAgICogSWYgdGhlIGxpc3RlbmVyIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBpdCBpcyBjYWxsZWQuXG4gICAgICogSWYgeW91IHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gYXMgdGhlIGV2ZW50IG5hbWUgdGhlbiB0aGUgbGlzdGVuZXIgd2lsbCBiZSBhZGRlZCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBhdHRhY2ggdGhlIGxpc3RlbmVyIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZC4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhZnRlciBjYWxsaW5nLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIWlzVmFsaWRMaXN0ZW5lcihsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcbiAgICAgICAgdmFyIGxpc3RlbmVySXNXcmFwcGVkID0gdHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0JztcbiAgICAgICAgdmFyIGtleTtcblxuICAgICAgICBmb3IgKGtleSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzW2tleV0sIGxpc3RlbmVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XS5wdXNoKGxpc3RlbmVySXNXcmFwcGVkID8gbGlzdGVuZXIgOiB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgICAgICAgICAgICAgICAgb25jZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiBhZGRMaXN0ZW5lclxuICAgICAqL1xuICAgIHByb3RvLm9uID0gYWxpYXMoJ2FkZExpc3RlbmVyJyk7XG5cbiAgICAvKipcbiAgICAgKiBTZW1pLWFsaWFzIG9mIGFkZExpc3RlbmVyLiBJdCB3aWxsIGFkZCBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZVxuICAgICAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBhZnRlciBpdHMgZmlyc3QgZXhlY3V0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gYXR0YWNoIHRoZSBsaXN0ZW5lciB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWQuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgY2FsbGluZy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5hZGRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRPbmNlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRMaXN0ZW5lcihldnQsIHtcbiAgICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFsaWFzIG9mIGFkZE9uY2VMaXN0ZW5lci5cbiAgICAgKi9cbiAgICBwcm90by5vbmNlID0gYWxpYXMoJ2FkZE9uY2VMaXN0ZW5lcicpO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBhbiBldmVudCBuYW1lLiBUaGlzIGlzIHJlcXVpcmVkIGlmIHlvdSB3YW50IHRvIHVzZSBhIHJlZ2V4IHRvIGFkZCBhIGxpc3RlbmVyIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBJZiB5b3UgZG9uJ3QgZG8gdGhpcyB0aGVuIGhvdyBkbyB5b3UgZXhwZWN0IGl0IHRvIGtub3cgd2hhdCBldmVudCB0byBhZGQgdG8/IFNob3VsZCBpdCBqdXN0IGFkZCB0byBldmVyeSBwb3NzaWJsZSBtYXRjaCBmb3IgYSByZWdleD8gTm8uIFRoYXQgaXMgc2NhcnkgYW5kIGJhZC5cbiAgICAgKiBZb3UgbmVlZCB0byB0ZWxsIGl0IHdoYXQgZXZlbnQgbmFtZXMgc2hvdWxkIGJlIG1hdGNoZWQgYnkgYSByZWdleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gY3JlYXRlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLmRlZmluZUV2ZW50ID0gZnVuY3Rpb24gZGVmaW5lRXZlbnQoZXZ0KSB7XG4gICAgICAgIHRoaXMuZ2V0TGlzdGVuZXJzKGV2dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGRlZmluZUV2ZW50IHRvIGRlZmluZSBtdWx0aXBsZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBldnRzIEFuIGFycmF5IG9mIGV2ZW50IG5hbWVzIHRvIGRlZmluZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5kZWZpbmVFdmVudHMgPSBmdW5jdGlvbiBkZWZpbmVFdmVudHMoZXZ0cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2dHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5lRXZlbnQoZXZ0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmdW5jdGlvbiBmcm9tIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogV2hlbiBwYXNzZWQgYSByZWd1bGFyIGV4cHJlc3Npb24gYXMgdGhlIGV2ZW50IG5hbWUsIGl0IHdpbGwgcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBNZXRob2QgdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnNBc09iamVjdChldnQpO1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIHZhciBrZXk7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnNba2V5XSwgbGlzdGVuZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNba2V5XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiByZW1vdmVMaXN0ZW5lclxuICAgICAqL1xuICAgIHByb3RvLm9mZiA9IGFsaWFzKCdyZW1vdmVMaXN0ZW5lcicpO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBsaXN0ZW5lcnMgaW4gYnVsayB1c2luZyB0aGUgbWFuaXB1bGF0ZUxpc3RlbmVycyBtZXRob2QuXG4gICAgICogSWYgeW91IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBmaXJzdCBhcmd1bWVudCB5b3UgY2FuIGFkZCB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiBrZXkgdmFsdWUgcGFpcnMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMgb3IgbGlzdGVuZXIgYXJyYXlzLiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhbiBldmVudCBuYW1lIGFuZCBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYmUgYWRkZWQuXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gYWRkIHRoZSBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqIFllYWgsIHRoaXMgZnVuY3Rpb24gZG9lcyBxdWl0ZSBhIGJpdC4gVGhhdCdzIHByb2JhYmx5IGEgYmFkIHRoaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fFJlZ0V4cH0gZXZ0IEFuIGV2ZW50IG5hbWUgaWYgeW91IHdpbGwgcGFzcyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgbmV4dC4gQW4gb2JqZWN0IGlmIHlvdSB3aXNoIHRvIGFkZCB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IFtsaXN0ZW5lcnNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8uYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkTGlzdGVuZXJzKGV2dCwgbGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIFBhc3MgdGhyb3VnaCB0byBtYW5pcHVsYXRlTGlzdGVuZXJzXG4gICAgICAgIHJldHVybiB0aGlzLm1hbmlwdWxhdGVMaXN0ZW5lcnMoZmFsc2UsIGV2dCwgbGlzdGVuZXJzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsaXN0ZW5lcnMgaW4gYnVsayB1c2luZyB0aGUgbWFuaXB1bGF0ZUxpc3RlbmVycyBtZXRob2QuXG4gICAgICogSWYgeW91IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBmaXJzdCBhcmd1bWVudCB5b3UgY2FuIHJlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBUaGUgb2JqZWN0IHNob3VsZCBjb250YWluIGtleSB2YWx1ZSBwYWlycyBvZiBldmVudHMgYW5kIGxpc3RlbmVycyBvciBsaXN0ZW5lciBhcnJheXMuXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIHJlbW92ZWQuXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgZnJvbSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBldnQgQW4gZXZlbnQgbmFtZSBpZiB5b3Ugd2lsbCBwYXNzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBuZXh0LiBBbiBvYmplY3QgaWYgeW91IHdpc2ggdG8gcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfSBbbGlzdGVuZXJzXSBBbiBvcHRpb25hbCBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLnJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycyhldnQsIGxpc3RlbmVycykge1xuICAgICAgICAvLyBQYXNzIHRocm91Z2ggdG8gbWFuaXB1bGF0ZUxpc3RlbmVyc1xuICAgICAgICByZXR1cm4gdGhpcy5tYW5pcHVsYXRlTGlzdGVuZXJzKHRydWUsIGV2dCwgbGlzdGVuZXJzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRWRpdHMgbGlzdGVuZXJzIGluIGJ1bGsuIFRoZSBhZGRMaXN0ZW5lcnMgYW5kIHJlbW92ZUxpc3RlbmVycyBtZXRob2RzIGJvdGggdXNlIHRoaXMgdG8gZG8gdGhlaXIgam9iLiBZb3Ugc2hvdWxkIHJlYWxseSB1c2UgdGhvc2UgaW5zdGVhZCwgdGhpcyBpcyBhIGxpdHRsZSBsb3dlciBsZXZlbC5cbiAgICAgKiBUaGUgZmlyc3QgYXJndW1lbnQgd2lsbCBkZXRlcm1pbmUgaWYgdGhlIGxpc3RlbmVycyBhcmUgcmVtb3ZlZCAodHJ1ZSkgb3IgYWRkZWQgKGZhbHNlKS5cbiAgICAgKiBJZiB5b3UgcGFzcyBhbiBvYmplY3QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB5b3UgY2FuIGFkZC9yZW1vdmUgZnJvbSBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiBrZXkgdmFsdWUgcGFpcnMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMgb3IgbGlzdGVuZXIgYXJyYXlzLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGFuIGV2ZW50IG5hbWUgYW5kIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0byBiZSBhZGRlZC9yZW1vdmVkLlxuICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGEgcmVndWxhciBleHByZXNzaW9uIHRvIG1hbmlwdWxhdGUgdGhlIGxpc3RlbmVycyBvZiBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbW92ZSBUcnVlIGlmIHlvdSB3YW50IHRvIHJlbW92ZSBsaXN0ZW5lcnMsIGZhbHNlIGlmIHlvdSB3YW50IHRvIGFkZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBldnQgQW4gZXZlbnQgbmFtZSBpZiB5b3Ugd2lsbCBwYXNzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBuZXh0LiBBbiBvYmplY3QgaWYgeW91IHdpc2ggdG8gYWRkL3JlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gW2xpc3RlbmVyc10gQW4gb3B0aW9uYWwgYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRvIGFkZC9yZW1vdmUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgcHJvdG8ubWFuaXB1bGF0ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIG1hbmlwdWxhdGVMaXN0ZW5lcnMocmVtb3ZlLCBldnQsIGxpc3RlbmVycykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICB2YXIgc2luZ2xlID0gcmVtb3ZlID8gdGhpcy5yZW1vdmVMaXN0ZW5lciA6IHRoaXMuYWRkTGlzdGVuZXI7XG4gICAgICAgIHZhciBtdWx0aXBsZSA9IHJlbW92ZSA/IHRoaXMucmVtb3ZlTGlzdGVuZXJzIDogdGhpcy5hZGRMaXN0ZW5lcnM7XG5cbiAgICAgICAgLy8gSWYgZXZ0IGlzIGFuIG9iamVjdCB0aGVuIHBhc3MgZWFjaCBvZiBpdHMgcHJvcGVydGllcyB0byB0aGlzIG1ldGhvZFxuICAgICAgICBpZiAodHlwZW9mIGV2dCA9PT0gJ29iamVjdCcgJiYgIShldnQgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gZXZ0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2dC5oYXNPd25Qcm9wZXJ0eShpKSAmJiAodmFsdWUgPSBldnRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgdGhlIHNpbmdsZSBsaXN0ZW5lciBzdHJhaWdodCB0aHJvdWdoIHRvIHRoZSBzaW5ndWxhciBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2luZ2xlLmNhbGwodGhpcywgaSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHBhc3MgYmFjayB0byB0aGUgbXVsdGlwbGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlLmNhbGwodGhpcywgaSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU28gZXZ0IG11c3QgYmUgYSBzdHJpbmdcbiAgICAgICAgICAgIC8vIEFuZCBsaXN0ZW5lcnMgbXVzdCBiZSBhbiBhcnJheSBvZiBsaXN0ZW5lcnNcbiAgICAgICAgICAgIC8vIExvb3Agb3ZlciBpdCBhbmQgcGFzcyBlYWNoIG9uZSB0byB0aGUgbXVsdGlwbGUgbWV0aG9kXG4gICAgICAgICAgICBpID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBzaW5nbGUuY2FsbCh0aGlzLCBldnQsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZyb20gYSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogSWYgeW91IGRvIG5vdCBzcGVjaWZ5IGFuIGV2ZW50IHRoZW4gYWxsIGxpc3RlbmVycyB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICogVGhhdCBtZWFucyBldmVyeSBldmVudCB3aWxsIGJlIGVtcHRpZWQuXG4gICAgICogWW91IGNhbiBhbHNvIHBhc3MgYSByZWdleCB0byByZW1vdmUgYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBbZXZ0XSBPcHRpb25hbCBuYW1lIG9mIHRoZSBldmVudCB0byByZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IuIFdpbGwgcmVtb3ZlIGZyb20gZXZlcnkgZXZlbnQgaWYgbm90IHBhc3NlZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBwcm90by5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50KGV2dCkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBldnQ7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9nZXRFdmVudHMoKTtcbiAgICAgICAgdmFyIGtleTtcblxuICAgICAgICAvLyBSZW1vdmUgZGlmZmVyZW50IHRoaW5ncyBkZXBlbmRpbmcgb24gdGhlIHN0YXRlIG9mIGV2dFxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50XG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW2V2dF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgYWxsIGV2ZW50cyBtYXRjaGluZyB0aGUgcmVnZXguXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGtleSkgJiYgZXZ0LnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgaW4gYWxsIGV2ZW50c1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiByZW1vdmVFdmVudC5cbiAgICAgKlxuICAgICAqIEFkZGVkIHRvIG1pcnJvciB0aGUgbm9kZSBBUEkuXG4gICAgICovXG4gICAgcHJvdG8ucmVtb3ZlQWxsTGlzdGVuZXJzID0gYWxpYXMoJ3JlbW92ZUV2ZW50Jyk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBvZiB5b3VyIGNob2ljZS5cbiAgICAgKiBXaGVuIGVtaXR0ZWQsIGV2ZXJ5IGxpc3RlbmVyIGF0dGFjaGVkIHRvIHRoYXQgZXZlbnQgd2lsbCBiZSBleGVjdXRlZC5cbiAgICAgKiBJZiB5b3UgcGFzcyB0aGUgb3B0aW9uYWwgYXJndW1lbnQgYXJyYXkgdGhlbiB0aG9zZSBhcmd1bWVudHMgd2lsbCBiZSBwYXNzZWQgdG8gZXZlcnkgbGlzdGVuZXIgdXBvbiBleGVjdXRpb24uXG4gICAgICogQmVjYXVzZSBpdCB1c2VzIGBhcHBseWAsIHlvdXIgYXJyYXkgb2YgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIGFzIGlmIHlvdSB3cm90ZSB0aGVtIG91dCBzZXBhcmF0ZWx5LlxuICAgICAqIFNvIHRoZXkgd2lsbCBub3QgYXJyaXZlIHdpdGhpbiB0aGUgYXJyYXkgb24gdGhlIG90aGVyIHNpZGUsIHRoZXkgd2lsbCBiZSBzZXBhcmF0ZS5cbiAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBlbWl0IHRvIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXQgYW5kIGV4ZWN1dGUgbGlzdGVuZXJzIGZvci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJnc10gT3B0aW9uYWwgYXJyYXkgb2YgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byBlYWNoIGxpc3RlbmVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLmVtaXRFdmVudCA9IGZ1bmN0aW9uIGVtaXRFdmVudChldnQsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyc01hcCA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcbiAgICAgICAgdmFyIGxpc3RlbmVycztcbiAgICAgICAgdmFyIGxpc3RlbmVyO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgdmFyIHJlc3BvbnNlO1xuXG4gICAgICAgIGZvciAoa2V5IGluIGxpc3RlbmVyc01hcCkge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc01hcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzTWFwW2tleV0uc2xpY2UoMCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsaXN0ZW5lciByZXR1cm5zIHRydWUgdGhlbiBpdCBzaGFsbCBiZSByZW1vdmVkIGZyb20gdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCBlaXRoZXIgd2l0aCBhIGJhc2ljIGNhbGwgb3IgYW4gYXBwbHkgaWYgdGhlcmUgaXMgYW4gYXJncyBhcnJheVxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIub25jZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldnQsIGxpc3RlbmVyLmxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gbGlzdGVuZXIubGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyB8fCBbXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSB0aGlzLl9nZXRPbmNlUmV0dXJuVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihldnQsIGxpc3RlbmVyLmxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbGlhcyBvZiBlbWl0RXZlbnRcbiAgICAgKi9cbiAgICBwcm90by50cmlnZ2VyID0gYWxpYXMoJ2VtaXRFdmVudCcpO1xuXG4gICAgLyoqXG4gICAgICogU3VidGx5IGRpZmZlcmVudCBmcm9tIGVtaXRFdmVudCBpbiB0aGF0IGl0IHdpbGwgcGFzcyBpdHMgYXJndW1lbnRzIG9uIHRvIHRoZSBsaXN0ZW5lcnMsIGFzIG9wcG9zZWQgdG8gdGFraW5nIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIG9uLlxuICAgICAqIEFzIHdpdGggZW1pdEV2ZW50LCB5b3UgY2FuIHBhc3MgYSByZWdleCBpbiBwbGFjZSBvZiB0aGUgZXZlbnQgbmFtZSB0byBlbWl0IHRvIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXQgYW5kIGV4ZWN1dGUgbGlzdGVuZXJzIGZvci5cbiAgICAgKiBAcGFyYW0gey4uLip9IE9wdGlvbmFsIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byBlYWNoIGxpc3RlbmVyLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2dCkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXRFdmVudChldnQsIGFyZ3MpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHZhbHVlIHRvIGNoZWNrIGFnYWluc3Qgd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLiBJZiBhXG4gICAgICogbGlzdGVuZXJzIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoZSBvbmUgc2V0IGhlcmUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWRcbiAgICAgKiBhZnRlciBleGVjdXRpb24uIFRoaXMgdmFsdWUgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBjaGVjayBmb3Igd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHByb3RvLnNldE9uY2VSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uIHNldE9uY2VSZXR1cm5WYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9vbmNlUmV0dXJuVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgYWdhaW5zdCB3aGVuIGV4ZWN1dGluZyBsaXN0ZW5lcnMuIElmXG4gICAgICogdGhlIGxpc3RlbmVycyByZXR1cm4gdmFsdWUgbWF0Y2hlcyB0aGlzIG9uZSB0aGVuIGl0IHNob3VsZCBiZSByZW1vdmVkXG4gICAgICogYXV0b21hdGljYWxseS4gSXQgd2lsbCByZXR1cm4gdHJ1ZSBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7KnxCb29sZWFufSBUaGUgY3VycmVudCB2YWx1ZSB0byBjaGVjayBmb3Igb3IgdGhlIGRlZmF1bHQsIHRydWUuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgcHJvdG8uX2dldE9uY2VSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uIF9nZXRPbmNlUmV0dXJuVmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KCdfb25jZVJldHVyblZhbHVlJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmNlUmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIHRoZSBldmVudHMgb2JqZWN0IGFuZCBjcmVhdGVzIG9uZSBpZiByZXF1aXJlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGV2ZW50cyBzdG9yYWdlIG9iamVjdC5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBwcm90by5fZ2V0RXZlbnRzID0gZnVuY3Rpb24gX2dldEV2ZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXZlcnRzIHRoZSBnbG9iYWwge0BsaW5rIEV2ZW50RW1pdHRlcn0gdG8gaXRzIHByZXZpb3VzIHZhbHVlIGFuZCByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoaXMgdmVyc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBOb24gY29uZmxpY3RpbmcgRXZlbnRFbWl0dGVyIGNsYXNzLlxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgICAgZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBvcmlnaW5hbEdsb2JhbFZhbHVlO1xuICAgICAgICByZXR1cm4gRXZlbnRFbWl0dGVyO1xuICAgIH07XG5cbiAgICAvLyBFeHBvc2UgdGhlIGNsYXNzIGVpdGhlciB2aWEgQU1ELCBDb21tb25KUyBvciB0aGUgZ2xvYmFsIG9iamVjdFxuICAgIGlmICh0cnVlKSB7XG4gICAgICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbiAgICAgICAgfSkuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG4gICAgfVxuICAgIGVsc2Uge31cbn0odHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzIHx8IHt9KSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvYXBpL2dlby50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2FwaS9nZW8udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGQzX2dlb18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtZ2VvICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWdlb0AxLjYuNEBkMy1nZW8vYnVpbGQvZDMtZ2VvLmpzXCIpO1xudmFyIGQzX2dlb19wcm9qZWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1nZW8tcHJvamVjdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1nZW8tcHJvamVjdGlvbkAyLjEuMkBkMy1nZW8tcHJvamVjdGlvbi9idWlsZC9kMy1nZW8tcHJvamVjdGlvbi5qc1wiKTtcbnZhciB2aWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi92aWV3ICovIFwiLi9zcmMvdmlldy50c1wiKTtcbnZhciBnZXRfZ2VvX3Byb2plY3Rpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvZ2V0LWdlby1wcm9qZWN0aW9uICovIFwiLi9zcmMvdXRpbC9nZXQtZ2VvLXByb2plY3Rpb24udHNcIikpO1xudmFyIGFwaSA9IHtcbiAgICAvLyBnZW8gbWFpbnRhaW5cbiAgICBnZW9BcmVhOiBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICByZXR1cm4gZDNfZ2VvXzEuZ2VvQXJlYShmZWF0dXJlKTtcbiAgICB9LFxuICAgIGdlb0FyZWFCeU5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBkM19nZW9fMS5nZW9BcmVhKHRoaXMuZ2VvRmVhdHVyZUJ5TmFtZShuYW1lKSk7XG4gICAgfSxcbiAgICBnZW9DZW50cm9pZDogZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIGQzX2dlb18xLmdlb0NlbnRyb2lkKGZlYXR1cmUpO1xuICAgIH0sXG4gICAgZ2VvQ2VudHJvaWRCeU5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBkM19nZW9fMS5nZW9DZW50cm9pZCh0aGlzLmdlb0ZlYXR1cmVCeU5hbWUobmFtZSkpO1xuICAgIH0sXG4gICAgZ2VvRGlzdGFuY2U6IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICAgICAgcmV0dXJuIGQzX2dlb18xLmdlb0Rpc3RhbmNlKHAxLCBwMik7XG4gICAgfSxcbiAgICBnZW9MZW5ndGg6IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIHJldHVybiBkM19nZW9fMS5nZW9MZW5ndGgoZmVhdHVyZSk7XG4gICAgfSxcbiAgICBnZW9MZW5ndGhCeU5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBkM19nZW9fMS5nZW9MZW5ndGgodGhpcy5nZW9GZWF0dXJlQnlOYW1lKG5hbWUpKTtcbiAgICB9LFxuICAgIGdlb0NvbnRhaW5zOiBmdW5jdGlvbiAoZmVhdHVyZSwgcG9zaXRpb24gLyogW2xvbmdpdHVkZSwgbGF0aXR1ZGVdICovKSB7XG4gICAgICAgIHJldHVybiBkM19nZW9fMS5nZW9Db250YWlucyhmZWF0dXJlLCBwb3NpdGlvbik7XG4gICAgfSxcbiAgICBnZW9GZWF0dXJlQnlOYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgcm93cyA9IHRoaXMucm93cztcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgcm93cy5zb21lKGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgICBpZiAoZmVhdHVyZS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmVhdHVyZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICBnZW9GZWF0dXJlQnlQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciByb3dzID0gdGhpcy5yb3dzO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICByb3dzLnNvbWUoZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIGlmIChkM19nZW9fMS5nZW9Db250YWlucyhmZWF0dXJlLCBwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmZWF0dXJlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIGdlb05hbWVCeVBvc2l0aW9uOiBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSB0aGlzLmdlb0ZlYXR1cmVCeVBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgaWYgKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBmZWF0dXJlLm5hbWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIHByb2plY3Rpb25cbiAgICAvLyBleHBvcnQgZ2V0R2VvUHJvamVjdGlvbiBmb3IgY3VzdG9tIHVzZWQuXG4gICAgZ2V0R2VvUHJvamVjdGlvbjogZ2V0X2dlb19wcm9qZWN0aW9uXzEuZGVmYXVsdCxcbiAgICBnZW9Qcm9qZWN0OiBmdW5jdGlvbiAoZmVhdHVyZSwgcHJvamVjdGlvbiwgZXhwb3J0UmF3KSB7XG4gICAgICAgIHByb2plY3Rpb24gPSBnZXRfZ2VvX3Byb2plY3Rpb25fMS5kZWZhdWx0KHByb2plY3Rpb24sIGV4cG9ydFJhdyk7XG4gICAgICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbl8xLmdlb1Byb2plY3QoZmVhdHVyZSwgcHJvamVjdGlvbik7XG4gICAgfSxcbiAgICBnZW9Qcm9qZWN0QnlOYW1lOiBmdW5jdGlvbiAobmFtZSwgcHJvamVjdGlvbiwgZXhwb3J0UmF3KSB7XG4gICAgICAgIHByb2plY3Rpb24gPSBnZXRfZ2VvX3Byb2plY3Rpb25fMS5kZWZhdWx0KHByb2plY3Rpb24sIGV4cG9ydFJhdyk7XG4gICAgICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbl8xLmdlb1Byb2plY3QodGhpcy5nZW9GZWF0dXJlQnlOYW1lKG5hbWUpLCBwcm9qZWN0aW9uKTtcbiAgICB9LFxuICAgIGdlb1Byb2plY3RQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uLCBwcm9qZWN0aW9uLCBleHBvcnRSYXcpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBnZXRfZ2VvX3Byb2plY3Rpb25fMS5kZWZhdWx0KHByb2plY3Rpb24sIGV4cG9ydFJhdyk7XG4gICAgICAgIHJldHVybiBmdW5jKHBvc2l0aW9uKTtcbiAgICB9LFxuICAgIGdlb1Byb2plY3RJbnZlcnQ6IGZ1bmN0aW9uIChwb3NpdGlvbiAvKiBbeCwgeV0gKi8sIHByb2plY3Rpb24sIGV4cG9ydFJhdykge1xuICAgICAgICB2YXIgZnVuYyA9IGdldF9nZW9fcHJvamVjdGlvbl8xLmRlZmF1bHQocHJvamVjdGlvbiwgZXhwb3J0UmF3KTtcbiAgICAgICAgcmV0dXJuIGZ1bmMuaW52ZXJ0KHBvc2l0aW9uKTtcbiAgICB9LFxufTtcbnV0aWxfMS5hc3NpZ24odmlld18xLlZpZXcucHJvdG90eXBlLCBhcGkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2FwaS9oaWVyYXJjaHkudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9hcGkvaGllcmFyY2h5LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgdmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdmlldyAqLyBcIi4vc3JjL3ZpZXcudHNcIik7XG51dGlsXzEuYXNzaWduKHZpZXdfMS5WaWV3LnByb3RvdHlwZSwge1xuICAgIGdldEFsbE5vZGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgaWYgKHJvb3QgJiYgcm9vdC5lYWNoKSB7XG4gICAgICAgICAgICAvLyBkMy1oaWVyYXJjaHlcbiAgICAgICAgICAgIHJvb3QuZWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290ICYmIHJvb3QuZWFjaE5vZGUpIHtcbiAgICAgICAgICAgIC8vIEBhbnR2L2hpZXJhcmNoeVxuICAgICAgICAgICAgcm9vdC5lYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfSxcbiAgICBnZXRBbGxMaW5rczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGlua3MgPSBbXTtcbiAgICAgICAgdmFyIG5vZGVzID0gW3RoaXMucm9vdF07XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB3aGlsZSAoKG5vZGUgPSBub2Rlcy5wb3AoKSkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogY2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlua3M7XG4gICAgfSxcbn0pO1xudXRpbF8xLmFzc2lnbih2aWV3XzEuVmlldy5wcm90b3R5cGUsIHtcbiAgICBnZXRBbGxFZGdlczogdmlld18xLlZpZXcucHJvdG90eXBlLmdldEFsbExpbmtzLFxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvYXBpL3BhcnRpdGlvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2FwaS9wYXJ0aXRpb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIHBhcnRpdGlvbl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9wYXJ0aXRpb24gKi8gXCIuL3NyYy91dGlsL3BhcnRpdGlvbi50c1wiKSk7XG52YXIgdmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdmlldyAqLyBcIi4vc3JjL3ZpZXcudHNcIik7XG51dGlsXzEuYXNzaWduKHZpZXdfMS5WaWV3LnByb3RvdHlwZSwge1xuICAgIHBhcnRpdGlvbjogZnVuY3Rpb24gKGdyb3VwX2J5LCBvcmRlcl9ieSkge1xuICAgICAgICBpZiAob3JkZXJfYnkgPT09IHZvaWQgMCkgeyBvcmRlcl9ieSA9IFtdOyB9XG4gICAgICAgIHJldHVybiBwYXJ0aXRpb25fMS5kZWZhdWx0KHRoaXMucm93cywgZ3JvdXBfYnksIG9yZGVyX2J5KTtcbiAgICB9LFxuICAgIGdyb3VwOiBmdW5jdGlvbiAoZ3JvdXBfYnksIG9yZGVyX2J5KSB7XG4gICAgICAgIGlmIChvcmRlcl9ieSA9PT0gdm9pZCAwKSB7IG9yZGVyX2J5ID0gW107IH1cbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMucGFydGl0aW9uKGdyb3VwX2J5LCBvcmRlcl9ieSk7XG4gICAgICAgIHJldHVybiB1dGlsXzEudmFsdWVzKGdyb3Vwcyk7XG4gICAgfSxcbiAgICBncm91cHM6IGZ1bmN0aW9uIChncm91cF9ieSwgb3JkZXJfYnkpIHtcbiAgICAgICAgaWYgKG9yZGVyX2J5ID09PSB2b2lkIDApIHsgb3JkZXJfYnkgPSBbXTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5ncm91cChncm91cF9ieSwgb3JkZXJfYnkpO1xuICAgIH0sXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9hcGkvc3RhdGlzdGljcy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9hcGkvc3RhdGlzdGljcy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgc2ltcGxlU3RhdGlzdGljcyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIHNpbXBsZS1zdGF0aXN0aWNzICovIFwiLi9ub2RlX21vZHVsZXMvX3NpbXBsZS1zdGF0aXN0aWNzQDYuMS4xQHNpbXBsZS1zdGF0aXN0aWNzL2Rpc3Qvc2ltcGxlLXN0YXRpc3RpY3MubWluLmpzXCIpKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgdmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdmlldyAqLyBcIi4vc3JjL3ZpZXcudHNcIik7XG52YXIgcF9ieV9mcmFjdGlvbl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9wLWJ5LWZyYWN0aW9uICovIFwiLi9zcmMvdXRpbC9wLWJ5LWZyYWN0aW9uLnRzXCIpKTtcbnZhciBjb25zdGFudHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NvbnN0YW50cyAqLyBcIi4vc3JjL2NvbnN0YW50cy50c1wiKSk7XG52YXIgU1RBVElTVElDU19NRVRIT0RTID0gY29uc3RhbnRzXzEuZGVmYXVsdC5TVEFUSVNUSUNTX01FVEhPRFM7XG5mdW5jdGlvbiBnZXRDb2x1bW5WYWx1ZXModmlldywgY29sdW1uKSB7XG4gICAgdmFyIHZhbHVlcyA9IHZpZXcuZ2V0Q29sdW1uKGNvbHVtbik7XG4gICAgaWYgKHV0aWxfMS5pc0FycmF5KHZhbHVlcykgJiYgdXRpbF8xLmlzQXJyYXkodmFsdWVzWzBdKSkge1xuICAgICAgICB2YWx1ZXMgPSB1dGlsXzEuZmxhdHRlbkRlZXAodmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbi8vIHN0YXRpc3RpY3NcblNUQVRJU1RJQ1NfTUVUSE9EUy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAvLyBAdHMtaWdub3JlO1xuICAgIHZpZXdfMS5WaWV3LnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBzaW1wbGVTdGF0aXN0aWNzW21ldGhvZF0oZ2V0Q29sdW1uVmFsdWVzKHRoaXMsIGNvbHVtbikpO1xuICAgIH07XG59KTtcbnZhciBxdWFudGlsZSA9IHNpbXBsZVN0YXRpc3RpY3MucXVhbnRpbGU7XG51dGlsXzEuYXNzaWduKHZpZXdfMS5WaWV3LnByb3RvdHlwZSwge1xuICAgIGF2ZXJhZ2U6IHZpZXdfMS5WaWV3LnByb3RvdHlwZS5tZWFuLFxuICAgIHF1YW50aWxlOiBmdW5jdGlvbiAoY29sdW1uLCBwKSB7XG4gICAgICAgIHJldHVybiBxdWFudGlsZShnZXRDb2x1bW5WYWx1ZXModGhpcywgY29sdW1uKSwgcCk7XG4gICAgfSxcbiAgICBxdWFudGlsZXM6IGZ1bmN0aW9uIChjb2x1bW4sIHBBcnIpIHtcbiAgICAgICAgdmFyIGNvbHVtbkFyciA9IGdldENvbHVtblZhbHVlcyh0aGlzLCBjb2x1bW4pO1xuICAgICAgICByZXR1cm4gcEFyci5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHF1YW50aWxlKGNvbHVtbkFyciwgcCk7IH0pO1xuICAgIH0sXG4gICAgcXVhbnRpbGVzQnlGcmFjdGlvbjogZnVuY3Rpb24gKGNvbHVtbiwgZnJhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhbnRpbGVzKGNvbHVtbiwgcF9ieV9mcmFjdGlvbl8xLmRlZmF1bHQoZnJhY3Rpb24pKTtcbiAgICB9LFxuICAgIHJhbmdlOiBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5taW4oY29sdW1uKSwgdGhpcy5tYXgoY29sdW1uKV07XG4gICAgfSxcbiAgICBleHRlbnQ6IGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgICAgLy8gYWxpYXNcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2UoY29sdW1uKTtcbiAgICB9LFxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29ubmVjdG9yL2RlZmF1bHQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29ubmVjdG9yL2RlZmF1bHQudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IoJ2RlZmF1bHQnLCBmdW5jdGlvbiAoZGF0YSwgZGF0YVNldCkge1xuICAgIHZhciB2aWV3O1xuICAgIGlmICh1dGlsXzEuaXNTdHJpbmcoZGF0YSkpIHtcbiAgICAgICAgdmlldyA9IGRhdGFTZXQuZ2V0VmlldyhkYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcgPSBkYXRhO1xuICAgIH1cbiAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBkYXRhVmlldycpO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbF8xLmRlZXBNaXgoW10sIHZpZXcucm93cyk7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb25uZWN0b3IvZHN2LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29ubmVjdG9yL2Rzdi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGQzX2Rzdl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtZHN2ICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWRzdkAxLjIuMEBkMy1kc3YvZGlzdC9kMy1kc3YuanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IoJ2RzdicsIGZ1bmN0aW9uIChzdHIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBkZWxpbWl0ZXIgPSBvcHRpb25zLmRlbGltaXRlciB8fCAnLCc7XG4gICAgaWYgKCF1dGlsXzEuaXNTdHJpbmcoZGVsaW1pdGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGRlbGltaXRlcjogbXVzdCBiZSBhIHN0cmluZyEnKTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX2Rzdl8xLmRzdkZvcm1hdChkZWxpbWl0ZXIpLnBhcnNlKHN0cik7XG59KTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlckNvbm5lY3RvcignY3N2JywgZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBkM19kc3ZfMS5jc3ZQYXJzZShzdHIpO1xufSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IoJ3RzdicsIGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gZDNfZHN2XzEudHN2UGFyc2Uoc3RyKTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2Nvbm5lY3Rvci9nZW8tZ3JhdGljdWxlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Nvbm5lY3Rvci9nZW8tZ3JhdGljdWxlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZDNfZ2VvXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1nZW8gKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtZ2VvQDEuNi40QGQzLWdlby9idWlsZC9kMy1nZW8uanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG5mdW5jdGlvbiBjb25uZWN0b3IoX29wdGlvbnMsIGRhdGFWaWV3KSB7XG4gICAgZGF0YVZpZXcuZGF0YVR5cGUgPSAnZ2VvLWdyYXRpY3VsZSc7XG4gICAgdmFyIGRhdGEgPSBkM19nZW9fMS5nZW9HcmF0aWN1bGUoKS5saW5lcygpO1xuICAgIGRhdGEubWFwKGZ1bmN0aW9uIChyb3csIGluZGV4KSB7XG4gICAgICAgIHJvdy5pbmRleCA9IFwiXCIgKyBpbmRleDtcbiAgICAgICAgcmV0dXJuIHJvdztcbiAgICB9KTtcbiAgICBkYXRhVmlldy5yb3dzID0gZGF0YTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGNvbm5lY3RvcjtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlckNvbm5lY3RvcignZ2VvLWdyYXRpY3VsZScsIGNvbm5lY3Rvcik7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29ubmVjdG9yL2dlb2pzb24udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29ubmVjdG9yL2dlb2pzb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIHBvaW50X2F0X2xlbmd0aF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcG9pbnQtYXQtbGVuZ3RoICovIFwiLi9ub2RlX21vZHVsZXMvX3BvaW50LWF0LWxlbmd0aEAxLjEuMEBwb2ludC1hdC1sZW5ndGgvaW5kZXguanNcIikpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkM19nZW9fMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWdlbyAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1nZW9AMS42LjRAZDMtZ2VvL2J1aWxkL2QzLWdlby5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBnZW9QYXRoR2VuZXJhdG9yID0gZDNfZ2VvXzEuZ2VvUGF0aCgpO1xuZnVuY3Rpb24gR2VvSlNPTkNvbm5lY3RvcihkYXRhLCBfb3B0aW9ucywgZGF0YVZpZXcpIHtcbiAgICBkYXRhVmlldy5kYXRhVHlwZSA9IGRhdGFfc2V0XzEuRGF0YVNldC5DT05TVEFOVFMuR0VPO1xuICAgIHZhciBmZWF0dXJlcyA9IHV0aWxfMS5kZWVwTWl4KFtdLCBkYXRhLmZlYXR1cmVzKTtcbiAgICAvLyBwcmUtcHJvY2Vzc1xuICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgZmVhdHVyZS5uYW1lID0gZmVhdHVyZS5wcm9wZXJ0aWVzLm5hbWU7XG4gICAgICAgIGZlYXR1cmUubG9uZ2l0dWRlID0gW107XG4gICAgICAgIGZlYXR1cmUubGF0aXR1ZGUgPSBbXTtcbiAgICAgICAgdmFyIHBhdGhEYXRhID0gKGZlYXR1cmUucGF0aERhdGEgPSBnZW9QYXRoR2VuZXJhdG9yKGZlYXR1cmUpKTtcbiAgICAgICAgdmFyIHBvaW50cyA9IHBvaW50X2F0X2xlbmd0aF8xLmRlZmF1bHQocGF0aERhdGEpO1xuICAgICAgICBwb2ludHMuX3BhdGguZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIGZlYXR1cmUubG9uZ2l0dWRlLnB1c2gocG9pbnRbMV0pO1xuICAgICAgICAgICAgZmVhdHVyZS5sYXRpdHVkZS5wdXNoKHBvaW50WzJdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjZW50cm9pZCA9IGdlb1BhdGhHZW5lcmF0b3IuY2VudHJvaWQoZmVhdHVyZSk7XG4gICAgICAgIGZlYXR1cmUuY2VudHJvaWRYID0gY2VudHJvaWRbMF07XG4gICAgICAgIGZlYXR1cmUuY2VudHJvaWRZID0gY2VudHJvaWRbMV07XG4gICAgfSk7XG4gICAgLy8gZGF0YVZpZXcub3JpZ2luID0gZmVhdHVyZXM7XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yKCdnZW8nLCBHZW9KU09OQ29ubmVjdG9yKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlckNvbm5lY3RvcignZ2VvanNvbicsIEdlb0pTT05Db25uZWN0b3IpO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yKCdHZW9KU09OJywgR2VvSlNPTkNvbm5lY3Rvcik7XG5leHBvcnRzLmRlZmF1bHQgPSBHZW9KU09OQ29ubmVjdG9yO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2Nvbm5lY3Rvci9ncmFwaC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29ubmVjdG9yL2dyYXBoLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgbm9kZXM6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsXG4gICAgICAgIHJldHVybiBkLm5vZGVzO1xuICAgIH0sXG4gICAgZWRnZXM6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsXG4gICAgICAgIHJldHVybiBkLmVkZ2VzO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY29ubmVjdG9yKGRhdGEsIG9wdGlvbnMsIGRhdGFWaWV3KSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgZGF0YVZpZXcuZGF0YVR5cGUgPSBkYXRhX3NldF8xLkRhdGFTZXQuQ09OU1RBTlRTLkdSQVBIO1xuICAgIHZhciBub2RlcyA9IG9wdGlvbnMubm9kZXMsIGVkZ2VzID0gb3B0aW9ucy5lZGdlcztcbiAgICBpZiAobm9kZXMgJiYgIXV0aWxfMS5pc0Z1bmN0aW9uKG5vZGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vZGVzOiBtdXN0IGJlIGEgZnVuY3Rpb24hJyk7XG4gICAgfVxuICAgIGlmIChlZGdlcyAmJiAhdXRpbF8xLmlzRnVuY3Rpb24oZWRnZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZWRnZXM6IG11c3QgYmUgYSBmdW5jdGlvbiEnKTtcbiAgICB9XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGRhdGFWaWV3LnJvd3MgPSBkYXRhVmlldy5ncmFwaCA9IHtcbiAgICAgICAgbm9kZXM6IG5vZGVzKGRhdGEpLFxuICAgICAgICBlZGdlczogZWRnZXMoZGF0YSksXG4gICAgfTtcbiAgICB1dGlsXzEuYXNzaWduKGRhdGFWaWV3LCBkYXRhVmlldy5ncmFwaCk7XG4gICAgcmV0dXJuIGRhdGFWaWV3LnJvd3M7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IoJ2dyYXBoJywgY29ubmVjdG9yKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlckNvbm5lY3RvcignZGlhZ3JhbScsIGNvbm5lY3Rvcik7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29ubmVjdG9yL2hleGpzb24udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29ubmVjdG9yL2hleGpzb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZDNfaGV4anNvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtaGV4anNvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1oZXhqc29uQDEuMS4wQGQzLWhleGpzb24vYnVpbGQvZDMtaGV4anNvbi5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgd2lkdGg6IDEsXG4gICAgaGVpZ2h0OiAxLFxufTtcbmZ1bmN0aW9uIHByb2Nlc3NSb3cocm93KSB7XG4gICAgcm93LmN4ID0gcm93Lng7XG4gICAgcm93LmN5ID0gcm93Lnk7XG4gICAgcm93LnggPSBbXTtcbiAgICByb3cueSA9IFtdO1xuICAgIHJvdy52ZXJ0aWNlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJvdy54LnB1c2godi54ICsgcm93LmN4KTtcbiAgICAgICAgcm93LnkucHVzaCh2LnkgKyByb3cuY3kpO1xuICAgIH0pO1xuICAgIHJldHVybiByb3c7XG59XG5mdW5jdGlvbiBIZXhKU09OQ29ubmVjdG9yKGRhdGEsIG9wdGlvbnMsIGRhdGFWaWV3KSB7XG4gICAgZGF0YVZpZXcuZGF0YVR5cGUgPSBkYXRhX3NldF8xLkRhdGFTZXQuQ09OU1RBTlRTLkhFWDtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoLCBoZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICB2YXIgSGV4SlNPTiA9IHV0aWxfMS5kZWVwTWl4KFtdLCBkYXRhKTtcbiAgICBkYXRhVmlldy5fSGV4SlNPTiA9IEhleEpTT047XG4gICAgdmFyIGdyaWQgPSAoZGF0YVZpZXcuX0dyaWRIZXhKU09OID0gZDNfaGV4anNvbl8xLmdldEdyaWRGb3JIZXhKU09OKEhleEpTT04pKTtcbiAgICB2YXIgcm93cyA9IChkYXRhVmlldy5yb3dzID0gZDNfaGV4anNvbl8xLnJlbmRlckhleEpTT04oSGV4SlNPTiwgd2lkdGgsIGhlaWdodCkubWFwKHByb2Nlc3NSb3cpKTtcbiAgICBkYXRhVmlldy5fZ3JpZFJvd3MgPSBkM19oZXhqc29uXzEucmVuZGVySGV4SlNPTihncmlkLCB3aWR0aCwgaGVpZ2h0KS5tYXAocHJvY2Vzc1Jvdyk7XG4gICAgcmV0dXJuIHJvd3M7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IoJ2hleCcsIEhleEpTT05Db25uZWN0b3IpO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yKCdoZXhqc29uJywgSGV4SlNPTkNvbm5lY3Rvcik7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IoJ2hleC1qc29uJywgSGV4SlNPTkNvbm5lY3Rvcik7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IoJ0hleEpTT04nLCBIZXhKU09OQ29ubmVjdG9yKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhleEpTT05Db25uZWN0b3I7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY29ubmVjdG9yL2hpZXJhcmNoeS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2Nvbm5lY3Rvci9oaWVyYXJjaHkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkM19oaWVyYXJjaHlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWhpZXJhcmNoeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1oaWVyYXJjaHlAMS4xLjlAZDMtaGllcmFyY2h5L2Rpc3QvZDMtaGllcmFyY2h5LmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xuZnVuY3Rpb24gY29ubmVjdG9yKGRhdGEsIG9wdGlvbnMsIGRhdGFWaWV3KSB7XG4gICAgZGF0YVZpZXcuZGF0YVR5cGUgPSBkYXRhX3NldF8xLkRhdGFTZXQuQ09OU1RBTlRTLkhJRVJBUkNIWTtcbiAgICB2YXIgY2hpbGRyZW4gPSBvcHRpb25zICYmIG9wdGlvbnMuY2hpbGRyZW4gPyBvcHRpb25zLmNoaWxkcmVuIDogbnVsbDtcbiAgICBpZiAoY2hpbGRyZW4gJiYgIXV0aWxfMS5pc0Z1bmN0aW9uKGNoaWxkcmVuKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoaWxkcmVuOiBtdXN0IGJlIGEgZnVuY3Rpb24hJyk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5wdXJlRGF0YSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRhdGFWaWV3LnJvd3MgPSBkYXRhVmlldy5yb290ID0gZDNfaGllcmFyY2h5XzEuaGllcmFyY2h5KGRhdGEsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGFWaWV3LnJvd3MgPSBkYXRhVmlldy5yb290ID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IoJ2hpZXJhcmNoeScsIGNvbm5lY3Rvcik7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IoJ3RyZWUnLCBjb25uZWN0b3IpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2Nvbm5lY3Rvci90b3BvanNvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY29ubmVjdG9yL3RvcG9qc29uLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIHRvcG9qc29uX2NsaWVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdG9wb2pzb24tY2xpZW50ICovIFwiLi9ub2RlX21vZHVsZXMvX3RvcG9qc29uLWNsaWVudEAzLjEuMEB0b3BvanNvbi1jbGllbnQvZGlzdC90b3BvanNvbi1jbGllbnQuanNcIik7XG52YXIgZ2VvanNvbl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9nZW9qc29uICovIFwiLi9zcmMvY29ubmVjdG9yL2dlb2pzb24udHNcIikpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xuZnVuY3Rpb24gVG9wb0pTT05Db25uZWN0b3IoZGF0YSwgb3B0aW9ucywgZGF0YVZpZXcpIHtcbiAgICB2YXIgb2JqZWN0ID0gb3B0aW9ucy5vYmplY3Q7XG4gICAgaWYgKCF1dGlsXzEuaXNTdHJpbmcob2JqZWN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9iamVjdDogbXVzdCBiZSBhIHN0cmluZyEnKTtcbiAgICB9XG4gICAgdmFyIGdlb0RhdGEgPSB0b3BvanNvbl9jbGllbnRfMS5mZWF0dXJlKGRhdGEsIGRhdGEub2JqZWN0c1tvYmplY3RdKTtcbiAgICByZXR1cm4gZ2VvanNvbl8xLmRlZmF1bHQoZ2VvRGF0YSwgdW5kZWZpbmVkLCBkYXRhVmlldyk7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IoJ3RvcG9qc29uJywgVG9wb0pTT05Db25uZWN0b3IpO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyQ29ubmVjdG9yKCdUb3BvSlNPTicsIFRvcG9KU09OQ29ubmVjdG9yKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb25zdGFudHMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbnN0YW50cy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBISUVSQVJDSFk6ICdoaWVyYXJjaHknLFxuICAgIEdFTzogJ2dlbycsXG4gICAgSEVYOiAnaGV4JyxcbiAgICBHUkFQSDogJ2dyYXBoJyxcbiAgICBUQUJMRTogJ3RhYmxlJyxcbiAgICBHRU9fR1JBVElDVUxFOiAnZ2VvLWdyYXRpY3VsZScsXG4gICAgU1RBVElTVElDU19NRVRIT0RTOiBbXG4gICAgICAgICdtYXgnLFxuICAgICAgICAnbWVhbicsXG4gICAgICAgICdtZWRpYW4nLFxuICAgICAgICAnbWluJyxcbiAgICAgICAgJ21vZGUnLFxuICAgICAgICAncHJvZHVjdCcsXG4gICAgICAgICdzdGFuZGFyZERldmlhdGlvbicsXG4gICAgICAgICdzdW0nLFxuICAgICAgICAnc3VtU2ltcGxlJyxcbiAgICAgICAgJ3ZhcmlhbmNlJyxcbiAgICBdLFxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9kYXRhLXNldC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIHdvbGZ5ODdfZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB3b2xmeTg3LWV2ZW50ZW1pdHRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL193b2xmeTg3LWV2ZW50ZW1pdHRlckA1LjIuOUB3b2xmeTg3LWV2ZW50ZW1pdHRlci9FdmVudEVtaXR0ZXIuanNcIikpO1xudmFyIHZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdmlldyAqLyBcIi4vc3JjL3ZpZXcudHNcIik7XG52YXIgY29uc3RhbnRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnN0YW50cyAqLyBcIi4vc3JjL2NvbnN0YW50cy50c1wiKSk7XG4vKipcbiAqIOaVsOaNrumbhlxuICogQHB1YmxpY1xuICovXG52YXIgRGF0YVNldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXRhU2V0LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpbml0aWFsUHJvcHMgLSDliJ3lp4vnirbmgIFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRhU2V0KGluaXRpYWxQcm9wcykge1xuICAgICAgICBpZiAoaW5pdGlhbFByb3BzID09PSB2b2lkIDApIHsgaW5pdGlhbFByb3BzID0geyBzdGF0ZToge30gfTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICog5ZCm5pivIERhdGFTZXRcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmlzRGF0YVNldCA9IHRydWU7XG4gICAgICAgIF90aGlzLl9vbkNoYW5nZVRpbWVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIOaJgOacieaMguWcqOaVsOaNrumbhuS4iueahOaVsOaNruinhuWbvu+8iGtleS12YWx1ZSDlr7nvvIlcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnZpZXdzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlrZjlgqjmlbDmja7pm4bkuIrnmoTnirbmgIHph4/vvIhrZXktdmFsdWUg5a+577yJXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHt9O1xuICAgICAgICAvLyBhc3NpZ24obWUsIGluaXRpYWxQcm9wcyk7XG4gICAgICAgIF90aGlzLnN0YXRlID0gaW5pdGlhbFByb3BzLnN0YXRlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOazqOWGjOS4gOS4quaVsOaNrui/nuaOpeWHveaVsO+8jOazqOWGjOWQjuaJgOacieaVsOaNruinhuWbvumDveWPr+S7peS9v+eUqCBuYW1lIOadpeW8leeUqOi/meS4quaVsOaNrui/nuaOpeWHveaVsO+8jOS7juiAjOaOpeWFpeafkOenjeaVsOaNrua6kOOAglxuICAgICAqIEBwYXJhbSBuYW1lIC0g57G75Z6LXG4gICAgICogQHBhcmFtIGNvbm5lY3RvciAtIOino+aekOmAu+i+kVxuICAgICAqL1xuICAgIERhdGFTZXQucmVnaXN0ZXJDb25uZWN0b3IgPSBmdW5jdGlvbiAobmFtZSwgY29ubmVjdG9yKSB7XG4gICAgICAgIERhdGFTZXQuY29ubmVjdG9yc1tuYW1lXSA9IGNvbm5lY3RvcjtcbiAgICB9O1xuICAgIERhdGFTZXQuZ2V0Q29ubmVjdG9yID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIERhdGFTZXQuY29ubmVjdG9yc1tuYW1lXSB8fCBEYXRhU2V0LmNvbm5lY3RvcnMuZGVmYXVsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIOazqOWGjOS4gOS4quaVsOaNruWkhOeQhuWHveaVsO+8jOazqOWGjOWQjuaJgOacieaVsOaNruinhuWbvumDveWPr+S7peS9v+eUqCBuYW1lIOadpeW8leeUqOi/meS4quaVsOaNruWkhOeQhuWHveaVsO+8jOS7juiAjOi/m+ihjOafkOenjeaVsOaNruWkhOeQhlxuICAgICAqIEBwYXJhbSBuYW1lIC0gdHJhbnNmb3JtIOexu+Wei1xuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm0gLSB0cmFuc2Zvcm3pgLvovpFcbiAgICAgKi9cbiAgICBEYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gKG5hbWUsIHRyYW5zZm9ybSkge1xuICAgICAgICBEYXRhU2V0LnRyYW5zZm9ybXNbbmFtZV0gPSB0cmFuc2Zvcm07XG4gICAgfTtcbiAgICBEYXRhU2V0LmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBEYXRhU2V0LnRyYW5zZm9ybXNbbmFtZV0gfHwgRGF0YVNldC50cmFuc2Zvcm1zLmRlZmF1bHQ7XG4gICAgfTtcbiAgICBEYXRhU2V0LnByb3RvdHlwZS5fZ2V0VW5pcXVlVmlld05hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYW1lID0gdXRpbF8xLnVuaXF1ZUlkKCd2aWV3XycpO1xuICAgICAgICB3aGlsZSAodGhpcy52aWV3c1tuYW1lXSkge1xuICAgICAgICAgICAgbmFtZSA9IHV0aWxfMS51bmlxdWVJZCgndmlld18nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9O1xuICAgIERhdGFTZXQucHJvdG90eXBlLmNyZWF0ZVZpZXcgPSBmdW5jdGlvbiAobmFtZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAodXRpbF8xLmlzTmlsKG5hbWUpKSB7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5fZ2V0VW5pcXVlVmlld05hbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbF8xLmlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbmFtZTtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLl9nZXRVbmlxdWVWaWV3TmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZpZXdzW25hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIHZpZXcgZXhpc3RzOiBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IHZpZXdfMS5WaWV3KHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnZpZXdzW25hbWVdID0gdmlldztcbiAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDov5Tlm54gbmFtZSDlr7nlupTnmoTmlbDmja7op4blm77lrp7kvotcbiAgICAgKiBAcGFyYW0gbmFtZSAtIG5hbWVcbiAgICAgKi9cbiAgICBEYXRhU2V0LnByb3RvdHlwZS5nZXRWaWV3ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3NbbmFtZV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDorr7nva4gbmFtZSDlr7nlupTnmoTmlbDmja7op4blm77lrp7kvovkuLogZHZcbiAgICAgKiBAcGFyYW0gbmFtZSAtIOWQjeensFxuICAgICAqIEBwYXJhbSB2aWV3IC0gZGF0YSB2aWV3XG4gICAgICovXG4gICAgRGF0YVNldC5wcm90b3R5cGUuc2V0VmlldyA9IGZ1bmN0aW9uIChuYW1lLCB2aWV3KSB7XG4gICAgICAgIHRoaXMudmlld3NbbmFtZV0gPSB2aWV3O1xuICAgIH07XG4gICAgLyoqXG4gICAgICog6K6+572u54q25oCB6YePIG5hbWUg55qE5YC85Li6IHZhbHVlXG4gICAgICogQHBhcmFtIG5hbWUgLSDnirbmgIHlkI1cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSDlgLxcbiAgICAgKi9cbiAgICBEYXRhU2V0LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0YXRlW25hbWVdID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZVRpbWVyKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX29uQ2hhbmdlVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2VUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb25DaGFuZ2VUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ3N0YXRlY2hhbmdlJywgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9LCAxNik7IC8vIGV4ZWN1dGUgYWZ0ZXIgb25lIGZyYW1lXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDluLjph4/vvIzorazlpoIgRGF0YVNldC5DT05TVEFOVFMuSElFUkFSQ0hZIOaYr+agkeW9oue7k+aehOeahOWQjeensFxuICAgICAqL1xuICAgIERhdGFTZXQuQ09OU1RBTlRTID0gY29uc3RhbnRzXzEuZGVmYXVsdDtcbiAgICAvKipcbiAgICAgKiDms6jlhoznmoQgQ29ubmVjdG9y77yIa2V5LXZhbHVlIOWvue+8iVxuICAgICAqL1xuICAgIERhdGFTZXQuY29ubmVjdG9ycyA9IHt9O1xuICAgIC8qKlxuICAgICAqIOW3suazqOWGjOeahCBUcmFuc2Zvcm3vvIhrZXktdmFsdWUg5a+577yJXG4gICAgICovXG4gICAgRGF0YVNldC50cmFuc2Zvcm1zID0ge307XG4gICAgRGF0YVNldC5EYXRhU2V0ID0gRGF0YVNldDtcbiAgICBEYXRhU2V0LkRhdGFWaWV3ID0gdmlld18xLlZpZXc7IC8vIGFsaWFzXG4gICAgRGF0YVNldC5WaWV3ID0gdmlld18xLlZpZXc7XG4gICAgRGF0YVNldC52ZXJzaW9uID0gJ19fX19EQVRBU0VUX1ZFUlNJT05fX19fJztcbiAgICByZXR1cm4gRGF0YVNldDtcbn0od29sZnk4N19ldmVudGVtaXR0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLkRhdGFTZXQgPSBEYXRhU2V0O1xuLy8gQHRzLWlnbm9yZVxudXRpbF8xLmFzc2lnbihEYXRhU2V0LCBjb25zdGFudHNfMS5kZWZhdWx0KTtcbi8vIEB0cy1pZ25vcmVcbnV0aWxfMS5hc3NpZ24oRGF0YVNldC5wcm90b3R5cGUsIHtcbiAgICB2aWV3OiBEYXRhU2V0LnByb3RvdHlwZS5jcmVhdGVWaWV3LFxufSk7XG52aWV3XzEuVmlldy5EYXRhU2V0ID0gRGF0YVNldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gZXh0cmEgQVBJc1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hcGkvZ2VvICovIFwiLi9zcmMvYXBpL2dlby50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXBpL2hpZXJhcmNoeSAqLyBcIi4vc3JjL2FwaS9oaWVyYXJjaHkudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2FwaS9wYXJ0aXRpb24gKi8gXCIuL3NyYy9hcGkvcGFydGl0aW9uLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hcGkvc3RhdGlzdGljcyAqLyBcIi4vc3JjL2FwaS9zdGF0aXN0aWNzLnRzXCIpO1xuLy8gY29ubmVjdG9yc1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25uZWN0b3IvZGVmYXVsdCAqLyBcIi4vc3JjL2Nvbm5lY3Rvci9kZWZhdWx0LnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25uZWN0b3IvZHN2ICovIFwiLi9zcmMvY29ubmVjdG9yL2Rzdi50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29ubmVjdG9yL2dlby1ncmF0aWN1bGUgKi8gXCIuL3NyYy9jb25uZWN0b3IvZ2VvLWdyYXRpY3VsZS50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29ubmVjdG9yL2dlb2pzb24gKi8gXCIuL3NyYy9jb25uZWN0b3IvZ2VvanNvbi50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29ubmVjdG9yL2dyYXBoICovIFwiLi9zcmMvY29ubmVjdG9yL2dyYXBoLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25uZWN0b3IvaGV4anNvbiAqLyBcIi4vc3JjL2Nvbm5lY3Rvci9oZXhqc29uLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25uZWN0b3IvaGllcmFyY2h5ICovIFwiLi9zcmMvY29ubmVjdG9yL2hpZXJhcmNoeS50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29ubmVjdG9yL3RvcG9qc29uICovIFwiLi9zcmMvY29ubmVjdG9yL3RvcG9qc29uLnRzXCIpO1xuLy8gdHJhbnNmb3Jtc1xuLy8gc3RhdGljXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9kZWZhdWx0ICovIFwiLi9zcmMvdHJhbnNmb3JtL2RlZmF1bHQudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9maWx0ZXIgKi8gXCIuL3NyYy90cmFuc2Zvcm0vZmlsdGVyLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vZm9sZCAqLyBcIi4vc3JjL3RyYW5zZm9ybS9mb2xkLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vbWFwICovIFwiLi9zcmMvdHJhbnNmb3JtL21hcC50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL3BhcnRpdGlvbiAqLyBcIi4vc3JjL3RyYW5zZm9ybS9wYXJ0aXRpb24udHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9wZXJjZW50ICovIFwiLi9zcmMvdHJhbnNmb3JtL3BlcmNlbnQudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9waWNrICovIFwiLi9zcmMvdHJhbnNmb3JtL3BpY2sudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9wcm9wb3J0aW9uICovIFwiLi9zcmMvdHJhbnNmb3JtL3Byb3BvcnRpb24udHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9yZW5hbWUgKi8gXCIuL3NyYy90cmFuc2Zvcm0vcmVuYW1lLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vcmV2ZXJzZSAqLyBcIi4vc3JjL3RyYW5zZm9ybS9yZXZlcnNlLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vc29ydCAqLyBcIi4vc3JjL3RyYW5zZm9ybS9zb3J0LnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vc29ydC1ieSAqLyBcIi4vc3JjL3RyYW5zZm9ybS9zb3J0LWJ5LnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vc3Vic2V0ICovIFwiLi9zcmMvdHJhbnNmb3JtL3N1YnNldC50c1wiKTtcbi8vIGltcHV0YXRpb25cbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2ZpbGwtcm93cyAqLyBcIi4vc3JjL3RyYW5zZm9ybS9maWxsLXJvd3MudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9pbXB1dGUgKi8gXCIuL3NyYy90cmFuc2Zvcm0vaW1wdXRlLnRzXCIpO1xuLy8gc3RhdGlzdGljc1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vYWdncmVnYXRlICovIFwiLi9zcmMvdHJhbnNmb3JtL2FnZ3JlZ2F0ZS50c1wiKTtcbi8vIHJlZ3Jlc3Npb25cbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL3JlZ3Jlc3Npb24gKi8gXCIuL3NyYy90cmFuc2Zvcm0vcmVncmVzc2lvbi50c1wiKTtcbi8vIEtERVxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0va2RlICovIFwiLi9zcmMvdHJhbnNmb3JtL2tkZS50c1wiKTtcbi8vIGJpbm5pbmdcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2Jpbi9oZXhhZ29uICovIFwiLi9zcmMvdHJhbnNmb3JtL2Jpbi9oZXhhZ29uLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vYmluL2hpc3RvZ3JhbSAqLyBcIi4vc3JjL3RyYW5zZm9ybS9iaW4vaGlzdG9ncmFtLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vYmluL3F1YW50aWxlICovIFwiLi9zcmMvdHJhbnNmb3JtL2Jpbi9xdWFudGlsZS50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2Jpbi9yZWN0YW5nbGUgKi8gXCIuL3NyYy90cmFuc2Zvcm0vYmluL3JlY3RhbmdsZS50c1wiKTtcbi8vIGdlb1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vZ2VvL2NlbnRyb2lkICovIFwiLi9zcmMvdHJhbnNmb3JtL2dlby9jZW50cm9pZC50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2dlby9wcm9qZWN0aW9uICovIFwiLi9zcmMvdHJhbnNmb3JtL2dlby9wcm9qZWN0aW9uLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vZ2VvL3JlZ2lvbiAqLyBcIi4vc3JjL3RyYW5zZm9ybS9nZW8vcmVnaW9uLnRzXCIpO1xuLy8gZGlhZ3JhbVxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vZGlhZ3JhbS9hcmMgKi8gXCIuL3NyYy90cmFuc2Zvcm0vZGlhZ3JhbS9hcmMudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9kaWFncmFtL2RhZ3JlICovIFwiLi9zcmMvdHJhbnNmb3JtL2RpYWdyYW0vZGFncmUudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9kaWFncmFtL3NhbmtleSAqLyBcIi4vc3JjL3RyYW5zZm9ybS9kaWFncmFtL3NhbmtleS50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2RpYWdyYW0vdm9yb25vaSAqLyBcIi4vc3JjL3RyYW5zZm9ybS9kaWFncmFtL3Zvcm9ub2kudHNcIik7XG4vLyBoaWVyYXJjaHlcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2hpZXJhcmNoeS9jbHVzdGVyICovIFwiLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS9jbHVzdGVyLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vaGllcmFyY2h5L2NvbXBhY3QtYm94ICovIFwiLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS9jb21wYWN0LWJveC50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2hpZXJhcmNoeS9kZW5kcm9ncmFtICovIFwiLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS9kZW5kcm9ncmFtLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vaGllcmFyY2h5L2luZGVudGVkICovIFwiLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS9pbmRlbnRlZC50c1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2hpZXJhcmNoeS9wYWNrICovIFwiLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS9wYWNrLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vaGllcmFyY2h5L3BhcnRpdGlvbiAqLyBcIi4vc3JjL3RyYW5zZm9ybS9oaWVyYXJjaHkvcGFydGl0aW9uLnRzXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vaGllcmFyY2h5L3RyZWUgKi8gXCIuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L3RyZWUudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9oaWVyYXJjaHkvdHJlZW1hcCAqLyBcIi4vc3JjL3RyYW5zZm9ybS9oaWVyYXJjaHkvdHJlZW1hcC50c1wiKTtcbi8vIHRhZyBjbG91ZFxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vdGFnLWNsb3VkICovIFwiLi9zcmMvdHJhbnNmb3JtL3RhZy1jbG91ZC50c1wiKTtcbi8vIHdhZmZsZVxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90cmFuc2Zvcm0vd2FmZmxlICovIFwiLi9zcmMvdHJhbnNmb3JtL3dhZmZsZS50c1wiKTtcbi8vIGtlcm5lbCBzbW9vdGhpbmdcbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNmb3JtL2tlcm5lbC1zbW9vdGgvZGVuc2l0eSAqLyBcIi4vc3JjL3RyYW5zZm9ybS9rZXJuZWwtc21vb3RoL2RlbnNpdHkudHNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybS9rZXJuZWwtc21vb3RoL3JlZ3Jlc3Npb24gKi8gXCIuL3NyYy90cmFuc2Zvcm0va2VybmVsLXNtb290aC9yZWdyZXNzaW9uLnRzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGRhdGFfc2V0XzEuRGF0YVNldDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vYWdncmVnYXRlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2FnZ3JlZ2F0ZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgc2ltcGxlU3RhdGlzdGljcyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIHNpbXBsZS1zdGF0aXN0aWNzICovIFwiLi9ub2RlX21vZHVsZXMvX3NpbXBsZS1zdGF0aXN0aWNzQDYuMS4xQHNpbXBsZS1zdGF0aXN0aWNzL2Rpc3Qvc2ltcGxlLXN0YXRpc3RpY3MubWluLmpzXCIpKTtcbnZhciBwYXJ0aXRpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvcGFydGl0aW9uICovIFwiLi9zcmMvdXRpbC9wYXJ0aXRpb24udHNcIikpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIHJlZ2lzdGVyVHJhbnNmb3JtID0gZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgYXM6IFtdLFxuICAgIGZpZWxkczogW10sXG4gICAgZ3JvdXBCeTogW10sXG4gICAgb3BlcmF0aW9uczogW10sXG59O1xudmFyIERFRkFVTFRfT1BFUkFUSU9OID0gJ2NvdW50JztcbnZhciBhZ2dyZWdhdGVzID0ge1xuICAgIGNvdW50OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG4gICAgfSxcbiAgICBkaXN0aW5jdDogZnVuY3Rpb24gKGRhdGEsIGZpZWxkKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB1dGlsXzEudW5pcShkYXRhLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3dbZmllbGRdOyB9KSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXMubGVuZ3RoO1xuICAgIH0sXG59O1xuZGF0YV9zZXRfMS5EYXRhU2V0LkNPTlNUQU5UUy5TVEFUSVNUSUNTX01FVEhPRFMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgYWdncmVnYXRlc1ttZXRob2RdID0gZnVuY3Rpb24gKGRhdGEsIGZpZWxkKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBkYXRhLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3dbZmllbGRdOyB9KTtcbiAgICAgICAgaWYgKHV0aWxfMS5pc0FycmF5KHZhbHVlcykgJiYgdXRpbF8xLmlzQXJyYXkodmFsdWVzWzBdKSkge1xuICAgICAgICAgICAgdmFsdWVzID0gdXRpbF8xLmZsYXR0ZW5EZWVwKHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gc2ltcGxlU3RhdGlzdGljc1ttZXRob2RdKHZhbHVlcyk7XG4gICAgfTtcbn0pO1xuYWdncmVnYXRlcy5hdmVyYWdlID0gYWdncmVnYXRlcy5tZWFuO1xuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGZpZWxkcyA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZHMob3B0aW9ucyk7XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShmaWVsZHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZmllbGRzOiBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggb25lIG9yIG1vcmUgc3RyaW5ncyEnKTtcbiAgICB9XG4gICAgdmFyIG91dHB1dE5hbWVzID0gb3B0aW9ucy5hcyB8fCBbXTtcbiAgICBpZiAodXRpbF8xLmlzU3RyaW5nKG91dHB1dE5hbWVzKSkge1xuICAgICAgICBvdXRwdXROYW1lcyA9IFtvdXRwdXROYW1lc107XG4gICAgfVxuICAgIHZhciBvcGVyYXRpb25zID0gb3B0aW9ucy5vcGVyYXRpb25zO1xuICAgIGlmICh1dGlsXzEuaXNTdHJpbmcob3BlcmF0aW9ucykpIHtcbiAgICAgICAgb3BlcmF0aW9ucyA9IFtvcGVyYXRpb25zXTtcbiAgICB9XG4gICAgdmFyIERFRkFVTFRfT1BFUkFUSU9OUyA9IFtERUZBVUxUX09QRVJBVElPTl07XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShvcGVyYXRpb25zKSB8fCAhb3BlcmF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdvcGVyYXRpb25zIGlzIG5vdCBkZWZpbmVkLCB3aWxsIHVzZSBbIFwiY291bnRcIiBdIGRpcmVjdGx5LicpO1xuICAgICAgICBvcGVyYXRpb25zID0gREVGQVVMVF9PUEVSQVRJT05TO1xuICAgICAgICBvdXRwdXROYW1lcyA9IG9wZXJhdGlvbnM7XG4gICAgfVxuICAgIGlmICghKG9wZXJhdGlvbnMubGVuZ3RoID09PSAxICYmIG9wZXJhdGlvbnNbMF0gPT09IERFRkFVTFRfT1BFUkFUSU9OKSkge1xuICAgICAgICBpZiAob3BlcmF0aW9ucy5sZW5ndGggIT09IGZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIG9wZXJhdGlvbnM6IGl0J3MgbGVuZ3RoIG11c3QgYmUgdGhlIHNhbWUgYXMgZmllbGRzIVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3V0cHV0TmFtZXMubGVuZ3RoICE9PSBmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhczogaXQncyBsZW5ndGggbXVzdCBiZSB0aGUgc2FtZSBhcyBmaWVsZHMhXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBncm91cHMgPSBwYXJ0aXRpb25fMS5kZWZhdWx0KGRhdGFWaWV3LnJvd3MsIG9wdGlvbnMuZ3JvdXBCeSk7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB1dGlsXzEuZm9ySW4oZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGdyb3VwWzBdO1xuICAgICAgICBvcGVyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wZXJhdGlvbiwgaSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dE5hbWUgPSBvdXRwdXROYW1lc1tpXTtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdFtvdXRwdXROYW1lXSA9IGFnZ3JlZ2F0ZXNbb3BlcmF0aW9uXShncm91cCwgZmllbGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG4gICAgZGF0YVZpZXcucm93cyA9IHJlc3VsdHM7XG59XG5yZWdpc3RlclRyYW5zZm9ybSgnYWdncmVnYXRlJywgdHJhbnNmb3JtKTtcbnJlZ2lzdGVyVHJhbnNmb3JtKCdzdW1tYXJ5JywgdHJhbnNmb3JtKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBWQUxJRF9BR0dSRUdBVEVTOiB1dGlsXzEua2V5cyhhZ2dyZWdhdGVzKSxcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2Jpbi9oZXhhZ29uLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vYmluL2hleGFnb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgb3B0aW9uX3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBhczogWyd4JywgJ3knLCAnY291bnQnXSxcbiAgICBiaW5zOiBbMzAsIDMwXSxcbiAgICBvZmZzZXQ6IFswLCAwXSxcbiAgICBzaXplQnlDb3VudDogZmFsc2UsXG59O1xudmFyIFNRUlQzID0gTWF0aC5zcXJ0KDMpO1xudmFyIFRISVJEX1BJID0gTWF0aC5QSSAvIDM7XG52YXIgQU5HTEVTID0gWzAsIFRISVJEX1BJLCAyICogVEhJUkRfUEksIDMgKiBUSElSRF9QSSwgNCAqIFRISVJEX1BJLCA1ICogVEhJUkRfUEldO1xuZnVuY3Rpb24gZGlzdGFuY2UoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MCAtIHgxKSAqICh4MCAtIHgxKSArICh5MCAtIHkxKSAqICh5MCAtIHkxKSk7XG59XG5mdW5jdGlvbiBuZWFyZXN0Qmluc0NlbnRlcnModmFsdWUsIHNjYWxlLCBvZmZzZXQpIHtcbiAgICB2YXIgdGVtcCA9IHZhbHVlIC0gb2Zmc2V0O1xuICAgIHNjYWxlID0gc2NhbGUgLyAyO1xuICAgIHZhciBkaXYgPSBNYXRoLmZsb29yKHRlbXAgLyBzY2FsZSk7XG4gICAgdmFyIHJvdW5kZWQgPSBzY2FsZSAqIChkaXYgKyAoTWF0aC5hYnMoZGl2ICUgMikgPT09IDEgPyAxIDogMCkpO1xuICAgIHZhciByb3VuZGVkU2NhbGVkID0gc2NhbGUgKiAoZGl2ICsgKE1hdGguYWJzKGRpdiAlIDIpID09PSAxID8gMCA6IDEpKTtcbiAgICByZXR1cm4gW3JvdW5kZWQgKyBvZmZzZXQsIHJvdW5kZWRTY2FsZWQgKyBvZmZzZXRdO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVCaW5zKHBvaW50cywgYmluV2lkdGgsIG9mZnNldCkge1xuICAgIGlmIChiaW5XaWR0aCA9PT0gdm9pZCAwKSB7IGJpbldpZHRoID0gWzEsIDFdOyB9XG4gICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9IFswLCAwXTsgfVxuICAgIC8vIHByb2Nlc3NpbmcgYWxpZ25lZCBkYXRhXG4gICAgdmFyIGJpbnMgPSB7fTtcbiAgICB2YXIgX2EgPSB0c2xpYl8xLl9fcmVhZChiaW5XaWR0aCwgMiksIGJpbldpZHRoWCA9IF9hWzBdLCBiaW5XaWR0aFkgPSBfYVsxXTtcbiAgICB2YXIgX2IgPSB0c2xpYl8xLl9fcmVhZChvZmZzZXQsIDIpLCBvZmZzZXRYID0gX2JbMF0sIG9mZnNldFkgPSBfYlsxXTtcbiAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIF9jID0gdHNsaWJfMS5fX3JlYWQocG9pbnQsIDIpLCB4ID0gX2NbMF0sIHkgPSBfY1sxXTtcbiAgICAgICAgLy8gc3RlcDMuMTogbmVhcmVzdCB0d28gY2VudGVyc1xuICAgICAgICB2YXIgX2QgPSB0c2xpYl8xLl9fcmVhZChuZWFyZXN0Qmluc0NlbnRlcnMoeCwgYmluV2lkdGhYLCBvZmZzZXRYKSwgMiksIHhSb3VuZGVkID0gX2RbMF0sIHhSb3VuZGVkU2NhbGVkID0gX2RbMV07XG4gICAgICAgIHZhciBfZSA9IHRzbGliXzEuX19yZWFkKG5lYXJlc3RCaW5zQ2VudGVycyh5LCBiaW5XaWR0aFksIG9mZnNldFkpLCAyKSwgeVJvdW5kZWQgPSBfZVswXSwgeVJvdW5kZWRTY2FsZWQgPSBfZVsxXTtcbiAgICAgICAgLy8gc3RlcDMuMjogY29tcGFyZSBkaXN0YW5jZXNcbiAgICAgICAgdmFyIGQxID0gZGlzdGFuY2UoeCwgeSwgeFJvdW5kZWQsIHlSb3VuZGVkKTtcbiAgICAgICAgdmFyIGQyID0gZGlzdGFuY2UoeCwgeSwgeFJvdW5kZWRTY2FsZWQsIHlSb3VuZGVkU2NhbGVkKTtcbiAgICAgICAgdmFyIGJpbktleTtcbiAgICAgICAgdmFyIGJpblg7XG4gICAgICAgIHZhciBiaW5ZO1xuICAgICAgICBpZiAoZDEgPCBkMikge1xuICAgICAgICAgICAgYmluS2V5ID0gXCJ4XCIgKyB4Um91bmRlZCArIFwieVwiICsgeVJvdW5kZWQ7XG4gICAgICAgICAgICBfYSA9IHRzbGliXzEuX19yZWFkKFt4Um91bmRlZCwgeVJvdW5kZWRdLCAyKSwgYmluWCA9IF9hWzBdLCBiaW5ZID0gX2FbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiaW5LZXkgPSBcInhcIiArIHhSb3VuZGVkU2NhbGVkICsgXCJ5XCIgKyB5Um91bmRlZFNjYWxlZDtcbiAgICAgICAgICAgIF9iID0gdHNsaWJfMS5fX3JlYWQoW3hSb3VuZGVkU2NhbGVkLCB5Um91bmRlZFNjYWxlZF0sIDIpLCBiaW5YID0gX2JbMF0sIGJpblkgPSBfYlsxXTtcbiAgICAgICAgfVxuICAgICAgICBiaW5zW2JpbktleV0gPSBiaW5zW2JpbktleV0gfHwge1xuICAgICAgICAgICAgeDogYmluWCxcbiAgICAgICAgICAgIHk6IGJpblksXG4gICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgfTtcbiAgICAgICAgYmluc1tiaW5LZXldLmNvdW50Kys7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJpbnM7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICAvLyBzdGVwMTogZ2V0IGJpbldpZHRoLCBldGMuXG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGZpZWxkcyA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZHMob3B0aW9ucyk7XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShmaWVsZHMpIHx8IGZpZWxkcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBmaWVsZHM6IGl0IG11c3QgYmUgYW4gYXJyYXkgd2l0aCAyIHN0cmluZ3MhJyk7XG4gICAgfVxuICAgIHZhciBfYSA9IHRzbGliXzEuX19yZWFkKGZpZWxkcywgMiksIGZpZWxkWCA9IF9hWzBdLCBmaWVsZFkgPSBfYVsxXTtcbiAgICB2YXIgcmFuZ2VGaWVsZFggPSBkYXRhVmlldy5yYW5nZShmaWVsZFgpO1xuICAgIHZhciByYW5nZUZpZWxkWSA9IGRhdGFWaWV3LnJhbmdlKGZpZWxkWSk7XG4gICAgdmFyIHdpZHRoWCA9IHJhbmdlRmllbGRYWzFdIC0gcmFuZ2VGaWVsZFhbMF07XG4gICAgdmFyIHdpZHRoWSA9IHJhbmdlRmllbGRZWzFdIC0gcmFuZ2VGaWVsZFlbMF07XG4gICAgdmFyIGJpbldpZHRoID0gb3B0aW9ucy5iaW5XaWR0aCB8fCBbXTtcbiAgICBpZiAoYmluV2lkdGgubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHZhciBfYiA9IHRzbGliXzEuX19yZWFkKG9wdGlvbnMuYmlucywgMiksIGJpbnNYID0gX2JbMF0sIGJpbnNZID0gX2JbMV07XG4gICAgICAgIGlmIChiaW5zWCA8PSAwIHx8IGJpbnNZIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYmluczogbXVzdCBiZSBhbiBhcnJheSB3aXRoIHR3byBwb3NpdGl2ZSBudW1iZXJzIChlLmcuIFsgMzAsIDMwIF0pIScpO1xuICAgICAgICB9XG4gICAgICAgIGJpbldpZHRoID0gW3dpZHRoWCAvIGJpbnNYLCB3aWR0aFkgLyBiaW5zWV07XG4gICAgfVxuICAgIC8vIHN0ZXAyOiBhbGlnbiBzY2FsZSAoc3F1YXNoIFkpXG4gICAgLypcbiAgICAgKiBiaW5XaWR0aFggLyBiaW5XaWR0aFkgc2hvdWxkIGJlIE1hdGguc3FydDMgLyAxLjVcbiAgICAgKiAtOiBiaW5XaWR0aFggfDogYmluV2lkdGhZXG4gICAgICogICAgICAgICAgIDNcbiAgICAgKiAgICAgICAgICAgfFxuICAgICAqICAgNCAgICAgICB8ICAgICAgICAyXG4gICAgICogICAgICAgICAgIHxcbiAgICAgKiAgICAgICAgICAgfFxuICAgICAqICAgNS0tLS0tLS0tLS0tLS0tLS0xXG4gICAgICpcbiAgICAgKiAgICAgICAgICAgMFxuICAgICAqL1xuICAgIHZhciBfYyA9IHRzbGliXzEuX19yZWFkKG9wdGlvbnMub2Zmc2V0LCAyKSwgb2Zmc2V0WCA9IF9jWzBdLCBvZmZzZXRZID0gX2NbMV07XG4gICAgdmFyIHlTY2FsZSA9ICgzICogYmluV2lkdGhbMF0pIC8gKFNRUlQzICogYmluV2lkdGhbMV0pO1xuICAgIC8vIGNvbnN0IHlTY2FsZSA9IGJpbldpZHRoWzBdIC8gKFNRUlQzICogYmluV2lkdGhbMV0pO1xuICAgIHZhciBwb2ludHMgPSBkYXRhVmlldy5yb3dzLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiBbcm93W2ZpZWxkWF0sIHlTY2FsZSAqIHJvd1tmaWVsZFldXTsgfSk7XG4gICAgLy8gc3RlcDM6IGJpbm5pbmdcbiAgICB2YXIgYmlucyA9IGdlbmVyYXRlQmlucyhwb2ludHMsIFtiaW5XaWR0aFswXSwgeVNjYWxlICogYmluV2lkdGhbMV1dLCBbb2Zmc2V0WCwgeVNjYWxlICogb2Zmc2V0WV0pO1xuICAgIC8vIHN0ZXA0OiByZXN0b3JlIHNjYWxlIChmb3IgWSlcbiAgICB2YXIgX2QgPSB0c2xpYl8xLl9fcmVhZChvcHRpb25zLmFzLCAzKSwgYXNYID0gX2RbMF0sIGFzWSA9IF9kWzFdLCBhc0NvdW50ID0gX2RbMl07XG4gICAgaWYgKCFhc1ggfHwgIWFzWSB8fCAhYXNDb3VudCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFzOiBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggdGhyZWUgZWxlbWVudHMgKGUuZy4gWyBcInhcIiwgXCJ5XCIsIFwiY291bnRcIiBdKSEnKTtcbiAgICB9XG4gICAgdmFyIHJhZGl1cyA9IGJpbldpZHRoWzBdIC8gU1FSVDM7XG4gICAgdmFyIGhleGFnb25Qb2ludHMgPSBBTkdMRVMubWFwKGZ1bmN0aW9uIChhbmdsZSkgeyByZXR1cm4gW01hdGguc2luKGFuZ2xlKSAqIHJhZGl1cywgLU1hdGguY29zKGFuZ2xlKSAqIHJhZGl1c107IH0pO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgbWF4Q291bnQgPSAwO1xuICAgIGlmIChvcHRpb25zLnNpemVCeUNvdW50KSB7XG4gICAgICAgIHV0aWxfMS5mb3JJbihiaW5zLCBmdW5jdGlvbiAoYmluKSB7XG4gICAgICAgICAgICBpZiAoYmluLmNvdW50ID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBtYXhDb3VudCA9IGJpbi5jb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHV0aWxfMS5mb3JJbihiaW5zLCBmdW5jdGlvbiAoYmluKSB7XG4gICAgICAgIHZhciB4ID0gYmluLngsIHkgPSBiaW4ueSwgY291bnQgPSBiaW4uY291bnQ7XG4gICAgICAgIHZhciByb3cgPSB7fTtcbiAgICAgICAgcm93W2FzQ291bnRdID0gY291bnQ7XG4gICAgICAgIGlmIChvcHRpb25zLnNpemVCeUNvdW50KSB7XG4gICAgICAgICAgICByb3dbYXNYXSA9IGhleGFnb25Qb2ludHMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiB4ICsgKGJpbi5jb3VudCAvIG1heENvdW50KSAqIHBbMF07IH0pO1xuICAgICAgICAgICAgcm93W2FzWV0gPSBoZXhhZ29uUG9pbnRzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gKHkgKyAoYmluLmNvdW50IC8gbWF4Q291bnQpICogcFsxXSkgLyB5U2NhbGU7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcm93W2FzWF0gPSBoZXhhZ29uUG9pbnRzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4geCArIHBbMF07IH0pO1xuICAgICAgICAgICAgcm93W2FzWV0gPSBoZXhhZ29uUG9pbnRzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gKHkgKyBwWzFdKSAvIHlTY2FsZTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICB9KTtcbiAgICBkYXRhVmlldy5yb3dzID0gcmVzdWx0O1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdiaW4uaGV4YWdvbicsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2Jpbi5oZXgnLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdoZXhiaW4nLCB0cmFuc2Zvcm0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9iaW4vaGlzdG9ncmFtLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9iaW4vaGlzdG9ncmFtLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgcGFydGl0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL3BhcnRpdGlvbiAqLyBcIi4vc3JjL3V0aWwvcGFydGl0aW9uLnRzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGFzOiBbJ3gnLCAnY291bnQnXSxcbiAgICBiaW5zOiAzMCxcbiAgICBvZmZzZXQ6IDAsXG4gICAgZ3JvdXBCeTogW10sXG59O1xuZnVuY3Rpb24gbmVhcmVzdEJpbih2YWx1ZSwgc2NhbGUsIG9mZnNldCkge1xuICAgIHZhciB0ZW1wID0gdmFsdWUgLSBvZmZzZXQ7XG4gICAgdmFyIGRpdiA9IE1hdGguZmxvb3IodGVtcCAvIHNjYWxlKTtcbiAgICByZXR1cm4gW2RpdiAqIHNjYWxlICsgb2Zmc2V0LCAoZGl2ICsgMSkgKiBzY2FsZSArIG9mZnNldF07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgZmllbGQgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGQob3B0aW9ucyk7XG4gICAgaWYgKGRhdGFWaWV3LnJvd3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJhbmdlID0gZGF0YVZpZXcucmFuZ2UoZmllbGQpO1xuICAgIHZhciB3aWR0aCA9IHJhbmdlWzFdIC0gcmFuZ2VbMF07XG4gICAgdmFyIGJpbldpZHRoID0gb3B0aW9ucy5iaW5XaWR0aDtcbiAgICBpZiAoIWJpbldpZHRoKSB7XG4gICAgICAgIHZhciBiaW5zID0gb3B0aW9ucy5iaW5zO1xuICAgICAgICBpZiAoYmlucyA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGJpbnM6IGl0IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIhJyk7XG4gICAgICAgIH1cbiAgICAgICAgYmluV2lkdGggPSB3aWR0aCAvIGJpbnM7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSBvcHRpb25zLm9mZnNldCAlIGJpbldpZHRoO1xuICAgIC8vIGdyb3VwaW5nXG4gICAgdmFyIHJvd3MgPSBbXTtcbiAgICB2YXIgZ3JvdXBCeSA9IG9wdGlvbnMuZ3JvdXBCeTtcbiAgICB2YXIgZ3JvdXBzID0gcGFydGl0aW9uXzEuZGVmYXVsdChkYXRhVmlldy5yb3dzLCBncm91cEJ5KTtcbiAgICB1dGlsXzEuZm9ySW4oZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgdmFyIGJpbnMgPSB7fTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IGdyb3VwLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3dbZmllbGRdOyB9KTtcbiAgICAgICAgY29sdW1uLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0c2xpYl8xLl9fcmVhZChuZWFyZXN0QmluKHZhbHVlLCBiaW5XaWR0aCwgb2Zmc2V0KSwgMiksIHgwID0gX2FbMF0sIHgxID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgYmluS2V5ID0geDAgKyBcIi1cIiArIHgxO1xuICAgICAgICAgICAgYmluc1tiaW5LZXldID0gYmluc1tiaW5LZXldIHx8IHtcbiAgICAgICAgICAgICAgICB4MDogeDAsXG4gICAgICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJpbnNbYmluS2V5XS5jb3VudCsrO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9hID0gdHNsaWJfMS5fX3JlYWQob3B0aW9ucy5hcywgMiksIGFzWCA9IF9hWzBdLCBhc0NvdW50ID0gX2FbMV07XG4gICAgICAgIGlmICghYXNYIHx8ICFhc0NvdW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFzOiBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggMiBlbGVtZW50cyAoZS5nLiBbIFwieFwiLCBcImNvdW50XCIgXSkhJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldGEgPSB1dGlsXzEucGljayhncm91cFswXSwgZ3JvdXBCeSk7XG4gICAgICAgIHV0aWxfMS5mb3JJbihiaW5zLCBmdW5jdGlvbiAoYmluKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gdXRpbF8xLmFzc2lnbih7fSwgbWV0YSk7XG4gICAgICAgICAgICByb3dbYXNYXSA9IFtiaW4ueDAsIGJpbi54MV07XG4gICAgICAgICAgICByb3dbYXNDb3VudF0gPSBiaW4uY291bnQ7XG4gICAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgZGF0YVZpZXcucm93cyA9IHJvd3M7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2Jpbi5oaXN0b2dyYW0nLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdiaW4uZG90JywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vYmluL3F1YW50aWxlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2Jpbi9xdWFudGlsZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgc2ltcGxlX3N0YXRpc3RpY3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHNpbXBsZS1zdGF0aXN0aWNzICovIFwiLi9ub2RlX21vZHVsZXMvX3NpbXBsZS1zdGF0aXN0aWNzQDYuMS4xQHNpbXBsZS1zdGF0aXN0aWNzL2Rpc3Qvc2ltcGxlLXN0YXRpc3RpY3MubWluLmpzXCIpO1xudmFyIHBhcnRpdGlvbl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9wYXJ0aXRpb24gKi8gXCIuL3NyYy91dGlsL3BhcnRpdGlvbi50c1wiKSk7XG52YXIgcF9ieV9mcmFjdGlvbl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9wLWJ5LWZyYWN0aW9uICovIFwiLi9zcmMvdXRpbC9wLWJ5LWZyYWN0aW9uLnRzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciByZWdpc3RlclRyYW5zZm9ybSA9IGRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGFzOiAnX2JpbicsXG4gICAgZ3JvdXBCeTogW10sXG4gICAgZnJhY3Rpb246IDQsXG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGZpZWxkID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkKG9wdGlvbnMpO1xuICAgIHZhciBhcyA9IG9wdGlvbnMuYXM7XG4gICAgaWYgKCF1dGlsXzEuaXNTdHJpbmcoYXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXM6IGl0IG11c3QgYmUgYSBzdHJpbmcgKGUuZy4gXCJfYmluXCIpIScpO1xuICAgIH1cbiAgICB2YXIgcEFycmF5ID0gb3B0aW9ucy5wO1xuICAgIHZhciBmcmFjdGlvbiA9IG9wdGlvbnMuZnJhY3Rpb247XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShwQXJyYXkpIHx8IHBBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcEFycmF5ID0gcF9ieV9mcmFjdGlvbl8xLmRlZmF1bHQoZnJhY3Rpb24pO1xuICAgIH1cbiAgICB2YXIgcm93cyA9IGRhdGFWaWV3LnJvd3M7XG4gICAgdmFyIGdyb3VwQnkgPSBvcHRpb25zLmdyb3VwQnk7XG4gICAgdmFyIGdyb3VwcyA9IHBhcnRpdGlvbl8xLmRlZmF1bHQocm93cywgZ3JvdXBCeSk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHV0aWxfMS5mb3JJbihncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICAvLyBjb25zdCByZXN1bHRSb3cgPSBwaWNrKGdyb3VwWzBdLCBncm91cEJ5KTtcbiAgICAgICAgdmFyIHJlc3VsdFJvdyA9IGdyb3VwWzBdO1xuICAgICAgICB2YXIgYmlubmluZ0NvbHVtbiA9IGdyb3VwLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3dbZmllbGRdOyB9KTtcbiAgICAgICAgdmFyIHF1YW50aWxlcyA9IHBBcnJheS5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHNpbXBsZV9zdGF0aXN0aWNzXzEucXVhbnRpbGUoYmlubmluZ0NvbHVtbiwgcCk7IH0pO1xuICAgICAgICByZXN1bHRSb3dbYXNdID0gcXVhbnRpbGVzO1xuICAgICAgICByZXN1bHQucHVzaChyZXN1bHRSb3cpO1xuICAgIH0pO1xuICAgIGRhdGFWaWV3LnJvd3MgPSByZXN1bHQ7XG59XG5yZWdpc3RlclRyYW5zZm9ybSgnYmluLnF1YW50aWxlJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vYmluL3JlY3RhbmdsZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vYmluL3JlY3RhbmdsZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIHJlZ2lzdGVyVHJhbnNmb3JtID0gZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgYXM6IFsneCcsICd5JywgJ2NvdW50J10sXG4gICAgYmluczogWzMwLCAzMF0sXG4gICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgc2l6ZUJ5Q291bnQ6IGZhbHNlLFxufTtcbmZ1bmN0aW9uIG5lYXJlc3RCaW4odmFsdWUsIHNjYWxlLCBvZmZzZXQpIHtcbiAgICB2YXIgdGVtcCA9IHZhbHVlIC0gb2Zmc2V0O1xuICAgIHZhciBkaXYgPSBNYXRoLmZsb29yKHRlbXAgLyBzY2FsZSk7XG4gICAgcmV0dXJuIFtkaXYgKiBzY2FsZSArIG9mZnNldCwgKGRpdiArIDEpICogc2NhbGUgKyBvZmZzZXRdO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIF9hID0gdHNsaWJfMS5fX3JlYWQob3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkcyhvcHRpb25zKSwgMiksIGZpZWxkWCA9IF9hWzBdLCBmaWVsZFkgPSBfYVsxXTtcbiAgICBpZiAoIWZpZWxkWCB8fCAhZmllbGRZKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZmllbGRzOiBtdXN0IGJlIGFuIGFycmF5IHdpdGggMiBzdHJpbmdzIScpO1xuICAgIH1cbiAgICB2YXIgcmFuZ2VGaWVsZFggPSBkYXRhVmlldy5yYW5nZShmaWVsZFgpO1xuICAgIHZhciByYW5nZUZpZWxkWSA9IGRhdGFWaWV3LnJhbmdlKGZpZWxkWSk7XG4gICAgdmFyIHdpZHRoWCA9IHJhbmdlRmllbGRYWzFdIC0gcmFuZ2VGaWVsZFhbMF07XG4gICAgdmFyIHdpZHRoWSA9IHJhbmdlRmllbGRZWzFdIC0gcmFuZ2VGaWVsZFlbMF07XG4gICAgdmFyIGJpbldpZHRoID0gb3B0aW9ucy5iaW5XaWR0aCB8fCBbXTtcbiAgICBpZiAoYmluV2lkdGgubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHZhciBfYiA9IHRzbGliXzEuX19yZWFkKG9wdGlvbnMuYmlucywgMiksIGJpbnNYID0gX2JbMF0sIGJpbnNZID0gX2JbMV07XG4gICAgICAgIGlmIChiaW5zWCA8PSAwIHx8IGJpbnNZIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYmluczogbXVzdCBiZSBhbiBhcnJheSB3aXRoIDIgcG9zaXRpdmUgbnVtYmVycyAoZS5nLiBbIDMwLCAzMCBdKSEnKTtcbiAgICAgICAgfVxuICAgICAgICBiaW5XaWR0aCA9IFt3aWR0aFggLyBiaW5zWCwgd2lkdGhZIC8gYmluc1ldO1xuICAgIH1cbiAgICB2YXIgcG9pbnRzID0gZGF0YVZpZXcucm93cy5tYXAoZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gW3Jvd1tmaWVsZFhdLCByb3dbZmllbGRZXV07IH0pO1xuICAgIHZhciBiaW5zID0ge307XG4gICAgdmFyIF9jID0gdHNsaWJfMS5fX3JlYWQob3B0aW9ucy5vZmZzZXQsIDIpLCBvZmZzZXRYID0gX2NbMF0sIG9mZnNldFkgPSBfY1sxXTtcbiAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgdmFyIF9hID0gdHNsaWJfMS5fX3JlYWQobmVhcmVzdEJpbihwb2ludFswXSwgYmluV2lkdGhbMF0sIG9mZnNldFgpLCAyKSwgeDAgPSBfYVswXSwgeDEgPSBfYVsxXTtcbiAgICAgICAgdmFyIF9iID0gdHNsaWJfMS5fX3JlYWQobmVhcmVzdEJpbihwb2ludFsxXSwgYmluV2lkdGhbMV0sIG9mZnNldFkpLCAyKSwgeTAgPSBfYlswXSwgeTEgPSBfYlsxXTtcbiAgICAgICAgdmFyIGJpbktleSA9IHgwICsgXCItXCIgKyB4MSArIFwiLVwiICsgeTAgKyBcIi1cIiArIHkxO1xuICAgICAgICBiaW5zW2JpbktleV0gPSBiaW5zW2JpbktleV0gfHwge1xuICAgICAgICAgICAgeDA6IHgwLFxuICAgICAgICAgICAgeDE6IHgxLFxuICAgICAgICAgICAgeTA6IHkwLFxuICAgICAgICAgICAgeTE6IHkxLFxuICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGJpbnNbYmluS2V5XS5jb3VudCsrO1xuICAgIH0pO1xuICAgIHZhciByb3dzID0gW107XG4gICAgdmFyIF9kID0gdHNsaWJfMS5fX3JlYWQob3B0aW9ucy5hcywgMyksIGFzWCA9IF9kWzBdLCBhc1kgPSBfZFsxXSwgYXNDb3VudCA9IF9kWzJdO1xuICAgIGlmICghYXNYIHx8ICFhc1kgfHwgIWFzQ291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhczogaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIDMgc3RyaW5ncyAoZS5nLiBbIFwieFwiLCBcInlcIiwgXCJjb3VudFwiIF0pIScpO1xuICAgIH1cbiAgICAvKiBwb2ludHNcbiAgICAgKiAzLS0tMlxuICAgICAqIHwgICB8XG4gICAgICogMC0tLTFcbiAgICAgKi9cbiAgICBpZiAoIW9wdGlvbnMuc2l6ZUJ5Q291bnQpIHtcbiAgICAgICAgdXRpbF8xLmZvckluKGJpbnMsIGZ1bmN0aW9uIChiaW4pIHtcbiAgICAgICAgICAgIHZhciByb3cgPSB7fTtcbiAgICAgICAgICAgIHJvd1thc1hdID0gW2Jpbi54MCwgYmluLngxLCBiaW4ueDEsIGJpbi54MF07XG4gICAgICAgICAgICByb3dbYXNZXSA9IFtiaW4ueTAsIGJpbi55MCwgYmluLnkxLCBiaW4ueTFdO1xuICAgICAgICAgICAgcm93W2FzQ291bnRdID0gYmluLmNvdW50O1xuICAgICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG1heENvdW50XzEgPSAwO1xuICAgICAgICB1dGlsXzEuZm9ySW4oYmlucywgZnVuY3Rpb24gKGJpbikge1xuICAgICAgICAgICAgaWYgKGJpbi5jb3VudCA+IG1heENvdW50XzEpIHtcbiAgICAgICAgICAgICAgICBtYXhDb3VudF8xID0gYmluLmNvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdXRpbF8xLmZvckluKGJpbnMsIGZ1bmN0aW9uIChiaW4pIHtcbiAgICAgICAgICAgIHZhciB4MCA9IGJpbi54MCwgeDEgPSBiaW4ueDEsIHkwID0gYmluLnkwLCB5MSA9IGJpbi55MSwgY291bnQgPSBiaW4uY291bnQ7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBjb3VudCAvIG1heENvdW50XzE7XG4gICAgICAgICAgICB2YXIgX2EgPSB0c2xpYl8xLl9fcmVhZChbKHgwICsgeDEpIC8gMiwgKHkwICsgeTEpIC8gMl0sIDIpLCBjeCA9IF9hWzBdLCBjeSA9IF9hWzFdO1xuICAgICAgICAgICAgdmFyIHJ4ID0gKCh4MSAtIHgwKSAqIHNjYWxlKSAvIDI7XG4gICAgICAgICAgICB2YXIgcnkgPSAoKHkxIC0geTApICogc2NhbGUpIC8gMjtcbiAgICAgICAgICAgIHZhciB4MDEgPSBjeCAtIHJ4O1xuICAgICAgICAgICAgdmFyIHgxMSA9IGN4ICsgcng7XG4gICAgICAgICAgICB2YXIgeTAxID0gY3kgLSByeTtcbiAgICAgICAgICAgIHZhciB5MTEgPSBjeSArIHJ5O1xuICAgICAgICAgICAgdmFyIHJvdyA9IHt9O1xuICAgICAgICAgICAgcm93W2FzWF0gPSBbeDAxLCB4MTEsIHgxMSwgeDAxXTtcbiAgICAgICAgICAgIHJvd1thc1ldID0gW3kwMSwgeTAxLCB5MTEsIHkxMV07XG4gICAgICAgICAgICByb3dbYXNDb3VudF0gPSBjb3VudDtcbiAgICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGF0YVZpZXcucm93cyA9IHJvd3M7XG59XG5yZWdpc3RlclRyYW5zZm9ybSgnYmluLnJlY3RhbmdsZScsIHRyYW5zZm9ybSk7XG5yZWdpc3RlclRyYW5zZm9ybSgnYmluLnJlY3QnLCB0cmFuc2Zvcm0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9kZWZhdWx0LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9kZWZhdWx0LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2RlZmF1bHQnLCBmdW5jdGlvbiAoZGF0YVZpZXcpIHtcbiAgICByZXR1cm4gZGF0YVZpZXc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vZGlhZ3JhbS9hcmMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9kaWFncmFtL2FyYy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gKiBmb3IgQXJjIERpYWdyYW0gKGVkZ2VzIHdpdGhvdXQgd2VpZ2h0KSAvIENob3JkIERpYWdyYW0gKGVkZ2VzIHdpdGggc291cmNlIGFuZCB0YXJnZXQgd2VpZ2h0KVxuICogZ3JhcGggZGF0YSByZXF1aXJlZCAobm9kZXMsIGVkZ2VzKVxuICovXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICB5OiAwLFxuICAgIHRoaWNrbmVzczogMC4wNSxcbiAgICB3ZWlnaHQ6IGZhbHNlLFxuICAgIG1hcmdpblJhdGlvOiAwLjEsXG4gICAgaWQ6IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLmlkOyB9LFxuICAgIHNvdXJjZTogZnVuY3Rpb24gKGVkZ2UpIHsgcmV0dXJuIGVkZ2Uuc291cmNlOyB9LFxuICAgIHRhcmdldDogZnVuY3Rpb24gKGVkZ2UpIHsgcmV0dXJuIGVkZ2UudGFyZ2V0OyB9LFxuICAgIHNvdXJjZVdlaWdodDogZnVuY3Rpb24gKGVkZ2UpIHsgcmV0dXJuIGVkZ2UudmFsdWUgfHwgMTsgfSxcbiAgICB0YXJnZXRXZWlnaHQ6IGZ1bmN0aW9uIChlZGdlKSB7IHJldHVybiBlZGdlLnZhbHVlIHx8IDE7IH0sXG4gICAgc29ydEJ5OiBudWxsLFxufTtcbmZ1bmN0aW9uIF9ub2Rlc0Zyb21FZGdlcyhlZGdlcywgb3B0aW9ucywgbWFwKSB7XG4gICAgaWYgKG1hcCA9PT0gdm9pZCAwKSB7IG1hcCA9IHt9OyB9XG4gICAgZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICB2YXIgc0lkID0gb3B0aW9ucy5lZGdlU291cmNlKGVkZ2UpO1xuICAgICAgICB2YXIgdElkID0gb3B0aW9ucy5lZGdlVGFyZ2V0KGVkZ2UpO1xuICAgICAgICBpZiAoIW1hcFtzSWRdKSB7XG4gICAgICAgICAgICBtYXBbc0lkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogc0lkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1hcFt0SWRdKSB7XG4gICAgICAgICAgICBtYXBbdElkXSA9IHtcbiAgICAgICAgICAgICAgICBpZDogdElkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB1dGlsXzEudmFsdWVzKG1hcCk7XG59XG5mdW5jdGlvbiBfcHJvY2Vzc0dyYXBoKG5vZGVCeUlkLCBlZGdlcywgb3B0aW9ucykge1xuICAgIHV0aWxfMS5mb3JJbihub2RlQnlJZCwgZnVuY3Rpb24gKG5vZGUsIGlkKSB7XG4gICAgICAgIC8vIGluIGVkZ2VzLCBvdXQgZWRnZXNcbiAgICAgICAgbm9kZS5pbkVkZ2VzID0gZWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlZGdlKSB7IHJldHVybiBcIlwiICsgb3B0aW9ucy50YXJnZXQoZWRnZSkgPT09IFwiXCIgKyBpZDsgfSk7XG4gICAgICAgIG5vZGUub3V0RWRnZXMgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHsgcmV0dXJuIFwiXCIgKyBvcHRpb25zLnNvdXJjZShlZGdlKSA9PT0gXCJcIiArIGlkOyB9KTtcbiAgICAgICAgLy8gZnJlcXVlbmN5XG4gICAgICAgIG5vZGUuZWRnZXMgPSBub2RlLm91dEVkZ2VzLmNvbmNhdChub2RlLmluRWRnZXMpO1xuICAgICAgICBub2RlLmZyZXF1ZW5jeSA9IG5vZGUuZWRnZXMubGVuZ3RoO1xuICAgICAgICAvLyB3ZWlnaHRcbiAgICAgICAgbm9kZS52YWx1ZSA9IDA7XG4gICAgICAgIG5vZGUuaW5FZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlICs9IG9wdGlvbnMudGFyZ2V0V2VpZ2h0KGVkZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZS5vdXRFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICBub2RlLnZhbHVlICs9IG9wdGlvbnMuc291cmNlV2VpZ2h0KGVkZ2UpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9zb3J0Tm9kZXMobm9kZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgc29ydE1ldGhvZHMgPSB7XG4gICAgICAgIHdlaWdodDogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlOyB9LFxuICAgICAgICBmcmVxdWVuY3k6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLmZyZXF1ZW5jeSAtIGEuZnJlcXVlbmN5OyB9LFxuICAgICAgICBpZDogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChcIlwiICsgb3B0aW9ucy5pZChhKSkubG9jYWxlQ29tcGFyZShcIlwiICsgb3B0aW9ucy5pZChiKSk7IH0sXG4gICAgfTtcbiAgICB2YXIgbWV0aG9kID0gc29ydE1ldGhvZHNbb3B0aW9ucy5zb3J0QnldO1xuICAgIGlmICghbWV0aG9kICYmIHV0aWxfMS5pc0Z1bmN0aW9uKG9wdGlvbnMuc29ydEJ5KSkge1xuICAgICAgICBtZXRob2QgPSBvcHRpb25zLnNvcnRCeTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgICBub2Rlcy5zb3J0KG1ldGhvZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2xheW91dE5vZGVzKG5vZGVzLCBvcHRpb25zKSB7XG4gICAgdmFyIGxlbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBub2RlczogaXQncyBlbXB0eSFcIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndlaWdodCkge1xuICAgICAgICB2YXIgbWFyZ2luUmF0aW9fMSA9IG9wdGlvbnMubWFyZ2luUmF0aW87XG4gICAgICAgIGlmIChtYXJnaW5SYXRpb18xIDwgMCB8fCBtYXJnaW5SYXRpb18xID49IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWFyZ2luUmF0aW86IGl0IG11c3QgYmUgaW4gcmFuZ2UgWzAsIDEpIScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJnaW5fMSA9IG1hcmdpblJhdGlvXzEgLyAoMiAqIGxlbik7XG4gICAgICAgIHZhciB0aGlja25lc3NfMSA9IG9wdGlvbnMudGhpY2tuZXNzO1xuICAgICAgICBpZiAodGhpY2tuZXNzXzEgPD0gMCB8fCB0aGlja25lc3NfMSA+PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRoaWNrbmVzczogaXQgbXVzdCBiZSBpbiByYW5nZSAoMCwgMSkhJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdGFsVmFsdWVfMSA9IDA7XG4gICAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHRvdGFsVmFsdWVfMSArPSBub2RlLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZS53ZWlnaHQgPSBub2RlLnZhbHVlIC8gdG90YWxWYWx1ZV8xO1xuICAgICAgICAgICAgbm9kZS53aWR0aCA9IG5vZGUud2VpZ2h0ICogKDEgLSBtYXJnaW5SYXRpb18xKTtcbiAgICAgICAgICAgIG5vZGUuaGVpZ2h0ID0gdGhpY2tuZXNzXzE7XG4gICAgICAgIH0pO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpbmRleCkge1xuICAgICAgICAgICAgLy8geFxuICAgICAgICAgICAgdmFyIGRlbHRhWCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGRlbHRhWCArPSBub2Rlc1tpXS53aWR0aCArIDIgKiBtYXJnaW5fMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtaW5YID0gKG5vZGUubWluWCA9IG1hcmdpbl8xICsgZGVsdGFYKTtcbiAgICAgICAgICAgIHZhciBtYXhYID0gKG5vZGUubWF4WCA9IG5vZGUubWluWCArIG5vZGUud2lkdGgpO1xuICAgICAgICAgICAgdmFyIG1pblkgPSAobm9kZS5taW5ZID0gb3B0aW9ucy55IC0gdGhpY2tuZXNzXzEgLyAyKTtcbiAgICAgICAgICAgIHZhciBtYXhZID0gKG5vZGUubWF4WSA9IG1pblkgKyB0aGlja25lc3NfMSk7XG4gICAgICAgICAgICBub2RlLnggPSBbbWluWCwgbWF4WCwgbWF4WCwgbWluWF07XG4gICAgICAgICAgICBub2RlLnkgPSBbbWluWSwgbWluWSwgbWF4WSwgbWF4WV07XG4gICAgICAgICAgICAvKiBwb2ludHNcbiAgICAgICAgICAgICAqIDMtLS0yXG4gICAgICAgICAgICAgKiB8ICAgfFxuICAgICAgICAgICAgICogMC0tLTFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gbm9kZS54ID0gbWluWCArIDAuNSAqIG5vZGUud2lkdGg7XG4gICAgICAgICAgICAvLyBub2RlLnkgPSBvcHRpb25zLnk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGRlbHRhWF8xID0gMSAvIGxlbjtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIG5vZGUueCA9IChpbmRleCArIDAuNSkgKiBkZWx0YVhfMTtcbiAgICAgICAgICAgIG5vZGUueSA9IG9wdGlvbnMueTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2xvY2F0aW5nRWRnZXMobm9kZUJ5SWQsIGVkZ2VzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMud2VpZ2h0KSB7XG4gICAgICAgIHZhciB2YWx1ZUJ5SWRfMSA9IHt9O1xuICAgICAgICB1dGlsXzEuZm9ySW4obm9kZUJ5SWQsIGZ1bmN0aW9uIChub2RlLCBpZCkge1xuICAgICAgICAgICAgdmFsdWVCeUlkXzFbaWRdID0gbm9kZS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIHZhciBzSWQgPSBvcHRpb25zLnNvdXJjZShlZGdlKTtcbiAgICAgICAgICAgIHZhciB0SWQgPSBvcHRpb25zLnRhcmdldChlZGdlKTtcbiAgICAgICAgICAgIHZhciBzTm9kZSA9IG5vZGVCeUlkW3NJZF07XG4gICAgICAgICAgICB2YXIgdE5vZGUgPSBub2RlQnlJZFt0SWRdO1xuICAgICAgICAgICAgaWYgKHNOb2RlICYmIHROb2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNWYWx1ZSA9IHZhbHVlQnlJZF8xW3NJZF07XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTVmFsdWUgPSBvcHRpb25zLnNvdXJjZVdlaWdodChlZGdlKTtcbiAgICAgICAgICAgICAgICB2YXIgc1N0YXJ0ID0gc05vZGUubWluWCArICgoc05vZGUudmFsdWUgLSBzVmFsdWUpIC8gc05vZGUudmFsdWUpICogc05vZGUud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIHNFbmQgPSBzU3RhcnQgKyAoY3VycmVudFNWYWx1ZSAvIHNOb2RlLnZhbHVlKSAqIHNOb2RlLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhbHVlQnlJZF8xW3NJZF0gLT0gY3VycmVudFNWYWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgdFZhbHVlID0gdmFsdWVCeUlkXzFbdElkXTtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRWYWx1ZSA9IG9wdGlvbnMudGFyZ2V0V2VpZ2h0KGVkZ2UpO1xuICAgICAgICAgICAgICAgIHZhciB0U3RhcnQgPSB0Tm9kZS5taW5YICsgKCh0Tm9kZS52YWx1ZSAtIHRWYWx1ZSkgLyB0Tm9kZS52YWx1ZSkgKiB0Tm9kZS53aWR0aDtcbiAgICAgICAgICAgICAgICB2YXIgdEVuZCA9IHRTdGFydCArIChjdXJyZW50VFZhbHVlIC8gdE5vZGUudmFsdWUpICogdE5vZGUud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFsdWVCeUlkXzFbdElkXSAtPSBjdXJyZW50VFZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gb3B0aW9ucy55O1xuICAgICAgICAgICAgICAgIGVkZ2UueCA9IFtzU3RhcnQsIHNFbmQsIHRTdGFydCwgdEVuZF07XG4gICAgICAgICAgICAgICAgZWRnZS55ID0gW3ksIHksIHksIHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIHZhciBzTm9kZSA9IG5vZGVCeUlkW29wdGlvbnMuc291cmNlKGVkZ2UpXTtcbiAgICAgICAgICAgIHZhciB0Tm9kZSA9IG5vZGVCeUlkW29wdGlvbnMudGFyZ2V0KGVkZ2UpXTtcbiAgICAgICAgICAgIGlmIChzTm9kZSAmJiB0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGVkZ2UueCA9IFtzTm9kZS54LCB0Tm9kZS54XTtcbiAgICAgICAgICAgICAgICBlZGdlLnkgPSBbc05vZGUueSwgdE5vZGUueV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybShkdiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBub2RlQnlJZCA9IHt9O1xuICAgIHZhciBub2RlcyA9IGR2Lm5vZGVzO1xuICAgIHZhciBlZGdlcyA9IGR2LmVkZ2VzO1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkobm9kZXMpIHx8IG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBub2RlcyA9IF9ub2Rlc0Zyb21FZGdlcyhlZGdlcywgb3B0aW9ucywgbm9kZUJ5SWQpO1xuICAgIH1cbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBpZCA9IG9wdGlvbnMuaWQobm9kZSk7XG4gICAgICAgIG5vZGVCeUlkW2lkXSA9IG5vZGU7XG4gICAgfSk7XG4gICAgX3Byb2Nlc3NHcmFwaChub2RlQnlJZCwgZWRnZXMsIG9wdGlvbnMpO1xuICAgIF9zb3J0Tm9kZXMobm9kZXMsIG9wdGlvbnMpO1xuICAgIF9sYXlvdXROb2Rlcyhub2Rlcywgb3B0aW9ucyk7XG4gICAgX2xvY2F0aW5nRWRnZXMobm9kZUJ5SWQsIGVkZ2VzLCBvcHRpb25zKTtcbiAgICBkdi5ub2RlcyA9IG5vZGVzO1xuICAgIGR2LmVkZ2VzID0gZWRnZXM7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2RpYWdyYW0uYXJjJywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnYXJjJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vZGlhZ3JhbS9kYWdyZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vZGlhZ3JhbS9kYWdyZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG4vKlxuICogZm9yIERBR1xuICogZ3JhcGggZGF0YSByZXF1aXJlZCAobm9kZXMsIGVkZ2VzKVxuICovXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGRhZ3JlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkYWdyZSAqLyBcIi4vbm9kZV9tb2R1bGVzL19kYWdyZUAwLjguNUBkYWdyZS9pbmRleC5qc1wiKSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIC8vIG5vZGVJZDogbm9kZSA9PiBub2RlLmluZGV4LFxuICAgIHJhbmtkaXI6ICdUQicsXG4gICAgYWxpZ246ICdUQicsXG4gICAgbm9kZXNlcDogNTAsXG4gICAgZWRnZXNlcDogMTAsXG4gICAgcmFua3NlcDogNTAsXG4gICAgc291cmNlOiBmdW5jdGlvbiAoZWRnZSkgeyByZXR1cm4gZWRnZS5zb3VyY2U7IH0sXG4gICAgdGFyZ2V0OiBmdW5jdGlvbiAoZWRnZSkgeyByZXR1cm4gZWRnZS50YXJnZXQ7IH0sXG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtKGR2LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGcgPSBuZXcgZGFncmVfMS5kZWZhdWx0LmdyYXBobGliLkdyYXBoKCk7XG4gICAgLy8gU2V0IGFuIG9iamVjdCBmb3IgdGhlIGdyYXBoIGxhYmVsXG4gICAgZy5zZXRHcmFwaCh7fSk7XG4gICAgLy8gRGVmYXVsdCB0byBhc3NpZ25pbmcgYSBuZXcgb2JqZWN0IGFzIGEgbGFiZWwgZm9yIGVhY2ggbmV3IGVkZ2UuXG4gICAgZy5zZXREZWZhdWx0RWRnZUxhYmVsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0pO1xuICAgIGR2Lm5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IG9wdGlvbnMubm9kZUlkID8gb3B0aW9ucy5ub2RlSWQobm9kZSkgOiBub2RlLmlkO1xuICAgICAgICBpZiAoIW5vZGUuaGVpZ2h0ICYmICFub2RlLndpZHRoKSB7XG4gICAgICAgICAgICBub2RlLmhlaWdodCA9IG5vZGUud2lkdGggPSBvcHRpb25zLmVkZ2VzZXA7XG4gICAgICAgIH1cbiAgICAgICAgZy5zZXROb2RlKG5vZGVJZCwgbm9kZSk7XG4gICAgfSk7XG4gICAgZHYuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICBnLnNldEVkZ2Uob3B0aW9ucy5zb3VyY2UoZWRnZSksIG9wdGlvbnMudGFyZ2V0KGVkZ2UpKTtcbiAgICB9KTtcbiAgICBkYWdyZV8xLmRlZmF1bHQubGF5b3V0KGcpO1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBlZGdlcyA9IFtdO1xuICAgIGcubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBuID0gZy5ub2RlKG5vZGUpO1xuICAgICAgICB2YXIgeCA9IG4ueCwgeSA9IG4ueSwgaGVpZ2h0ID0gbi5oZWlnaHQsIHdpZHRoID0gbi53aWR0aDtcbiAgICAgICAgLyogcG9pbnRzXG4gICAgICAgICAqIDMtLS0yXG4gICAgICAgICAqIHwgICB8XG4gICAgICAgICAqIDAtLS0xXG4gICAgICAgICAqL1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIG4ueCA9IFt4IC0gd2lkdGggLyAyLCB4ICsgd2lkdGggLyAyLCB4ICsgd2lkdGggLyAyLCB4IC0gd2lkdGggLyAyXTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBuLnkgPSBbeSArIGhlaWdodCAvIDIsIHkgKyBoZWlnaHQgLyAyLCB5IC0gaGVpZ2h0IC8gMiwgeSAtIGhlaWdodCAvIDJdO1xuICAgICAgICBub2Rlcy5wdXNoKG4pO1xuICAgIH0pO1xuICAgIGcuZWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBnLmVkZ2UoZWRnZSkucG9pbnRzO1xuICAgICAgICB2YXIgZSA9IHt9O1xuICAgICAgICBlLnggPSBwb2ludHMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLng7IH0pO1xuICAgICAgICBlLnkgPSBwb2ludHMubWFwKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnk7IH0pO1xuICAgICAgICBlZGdlcy5wdXNoKGUpO1xuICAgIH0pO1xuICAgIGR2Lm5vZGVzID0gbm9kZXM7XG4gICAgZHYuZWRnZXMgPSBlZGdlcztcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnZGlhZ3JhbS5kYWdyZScsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2RhZ3JlJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vZGlhZ3JhbS9zYW5rZXkudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9kaWFncmFtL3NhbmtleS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gKiBmb3IgU2Fua2V5IERpYWdyYW1cbiAqIGdyYXBoIGRhdGEgcmVxdWlyZWQgKG5vZGVzLCBlZGdlcylcbiAqL1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkM19zYW5rZXlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLXNhbmtleSAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1zYW5rZXlAMC45LjFAZDMtc2Fua2V5L2Rpc3QvZDMtc2Fua2V5LmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIEFMSUdOX01FVEhPRCA9IHtcbiAgICBzYW5rZXlMZWZ0OiBkM19zYW5rZXlfMS5zYW5rZXlMZWZ0LFxuICAgIHNhbmtleVJpZ2h0OiBkM19zYW5rZXlfMS5zYW5rZXlSaWdodCxcbiAgICBzYW5rZXlDZW50ZXI6IGQzX3NhbmtleV8xLnNhbmtleUNlbnRlcixcbiAgICBzYW5rZXlKdXN0aWZ5OiBkM19zYW5rZXlfMS5zYW5rZXlKdXN0aWZ5LFxufTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgLy8gbm9kZUlkOiBub2RlID0+IG5vZGUuaW5kZXgsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnZhbHVlOyB9LFxuICAgIHNvdXJjZTogZnVuY3Rpb24gKGVkZ2UpIHsgcmV0dXJuIGVkZ2Uuc291cmNlOyB9LFxuICAgIHRhcmdldDogZnVuY3Rpb24gKGVkZ2UpIHsgcmV0dXJuIGVkZ2UudGFyZ2V0OyB9LFxuICAgIG5vZGVBbGlnbjogJ3NhbmtleUp1c3RpZnknLFxuICAgIG5vZGVXaWR0aDogMC4wMixcbiAgICBub2RlUGFkZGluZzogMC4wMixcbiAgICBzb3J0OiB1bmRlZmluZWQsXG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtKGR2LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIG5vZGVBbGlnbiA9IG51bGw7XG4gICAgaWYgKHV0aWxfMS5pc1N0cmluZyhvcHRpb25zLm5vZGVBbGlnbikpIHtcbiAgICAgICAgbm9kZUFsaWduID0gQUxJR05fTUVUSE9EW29wdGlvbnMubm9kZUFsaWduXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodXRpbF8xLmlzRnVuY3Rpb24ob3B0aW9ucy5ub2RlQWxpZ24pKSB7XG4gICAgICAgIG5vZGVBbGlnbiA9IG9wdGlvbnMubm9kZUFsaWduO1xuICAgIH1cbiAgICB2YXIgc2Fua2V5UHJvY2Vzc29yID0gZDNfc2Fua2V5XzEuc2Fua2V5KClcbiAgICAgICAgLm5vZGVTb3J0KG9wdGlvbnMuc29ydClcbiAgICAgICAgLmxpbmtzKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmVkZ2VzOyB9KVxuICAgICAgICAubm9kZVdpZHRoKG9wdGlvbnMubm9kZVdpZHRoKVxuICAgICAgICAubm9kZVBhZGRpbmcob3B0aW9ucy5ub2RlUGFkZGluZylcbiAgICAgICAgLmV4dGVudChbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzEsIDFdLFxuICAgIF0pO1xuICAgIGlmICh1dGlsXzEuaXNGdW5jdGlvbihvcHRpb25zLm5vZGVJZCkpIHtcbiAgICAgICAgc2Fua2V5UHJvY2Vzc29yLm5vZGVJZChvcHRpb25zLm5vZGVJZCk7XG4gICAgfVxuICAgIGlmIChub2RlQWxpZ24pIHtcbiAgICAgICAgc2Fua2V5UHJvY2Vzc29yLm5vZGVBbGlnbihub2RlQWxpZ24pO1xuICAgIH1cbiAgICAvLyBUT0RPOlxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBzYW5rZXlQcm9jZXNzb3IoZHYpO1xuICAgIC8vIHBvc3QgcHJvY2VzcyAoeCwgeSksIGV0Yy5cbiAgICBkdi5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciB4MCA9IG5vZGUueDAsIHgxID0gbm9kZS54MSwgeTAgPSBub2RlLnkwLCB5MSA9IG5vZGUueTE7XG4gICAgICAgIC8qIHBvaW50c1xuICAgICAgICAgKiAzLS0tMlxuICAgICAgICAgKiB8ICAgfFxuICAgICAgICAgKiAwLS0tMVxuICAgICAgICAgKi9cbiAgICAgICAgbm9kZS54ID0gW3gwLCB4MSwgeDEsIHgwXTtcbiAgICAgICAgbm9kZS55ID0gW3kwLCB5MCwgeTEsIHkxXTtcbiAgICB9KTtcbiAgICBkdi5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBlZGdlLnNvdXJjZSwgdGFyZ2V0ID0gZWRnZS50YXJnZXQ7XG4gICAgICAgIHZhciBzeCA9IHNvdXJjZS54MTtcbiAgICAgICAgdmFyIHR4ID0gdGFyZ2V0LngwO1xuICAgICAgICBlZGdlLnggPSBbc3gsIHN4LCB0eCwgdHhdO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gZWRnZS53aWR0aCAvIDI7XG4gICAgICAgIGVkZ2UueSA9IFtlZGdlLnkwICsgb2Zmc2V0LCBlZGdlLnkwIC0gb2Zmc2V0LCBlZGdlLnkxICsgb2Zmc2V0LCBlZGdlLnkxIC0gb2Zmc2V0XTtcbiAgICB9KTtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnZGlhZ3JhbS5zYW5rZXknLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdzYW5rZXknLCB0cmFuc2Zvcm0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9kaWFncmFtL3Zvcm9ub2kudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vZGlhZ3JhbS92b3Jvbm9pLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIGQzVm9yb25vaSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLXZvcm9ub2kgKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtdm9yb25vaUAxLjEuNEBkMy12b3Jvbm9pL2Rpc3QvZDMtdm9yb25vaS5qc1wiKSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIHJlZ2lzdGVyVHJhbnNmb3JtID0gZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgLy8gZmllbGRzOiBbICd4JywgJ3knIF0gLy8gZmllbGQgeCBhbmQgZmllbGQgeSwgcmVxdWlyZWRcbiAgICAvLyBleHRlbmQ6IFtbeDAsIHkwXSwgW3gxLCB5MV1dLCAvLyBvcHRpb25hbFxuICAgIC8vIHNpemU6IFt3aWR0aCwgaGVpZ2h0XSwgLy8gb3B0aW9uYWxcbiAgICBhczogWydfeCcsICdfeSddLFxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhVmlldywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBhcyA9IG9wdGlvbnMuYXM7XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShhcykgfHwgYXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYXM6IG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0d28gc3RyaW5ncyEnKTtcbiAgICB9XG4gICAgdmFyIHhGaWVsZCA9IGFzWzBdO1xuICAgIHZhciB5RmllbGQgPSBhc1sxXTtcbiAgICB2YXIgZmllbGRzID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkcyhvcHRpb25zKTtcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGZpZWxkcykgfHwgZmllbGRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGZpZWxkczogbXVzdCBiZSBhbiBhcnJheSB3aXRoIHR3byBzdHJpbmdzIScpO1xuICAgIH1cbiAgICB2YXIgeCA9IGZpZWxkc1swXTtcbiAgICB2YXIgeSA9IGZpZWxkc1sxXTtcbiAgICB2YXIgcm93cyA9IGRhdGFWaWV3LnJvd3M7XG4gICAgdmFyIGRhdGEgPSByb3dzLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiBbcm93W3hdLCByb3dbeV1dOyB9KTtcbiAgICB2YXIgdm9yb25vaSA9IGQzVm9yb25vaS52b3Jvbm9pKCk7XG4gICAgaWYgKG9wdGlvbnMuZXh0ZW5kKSB7XG4gICAgICAgIHZvcm9ub2kuZXh0ZW50KG9wdGlvbnMuZXh0ZW5kKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc2l6ZSkge1xuICAgICAgICB2b3Jvbm9pLnNpemUob3B0aW9ucy5zaXplKTtcbiAgICB9XG4gICAgdmFyIHBvbHlnb25zID0gdm9yb25vaShkYXRhKS5wb2x5Z29ucygpO1xuICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93LCBpKSB7XG4gICAgICAgIHZhciBwb2x5Z29uID0gcG9seWdvbnNbaV0uZmlsdGVyKGZ1bmN0aW9uIChwb2ludCkgeyByZXR1cm4gISFwb2ludDsgfSk7IC8vIHNvbWUgcG9pbnRzIGFyZSBudWxsXG4gICAgICAgIHJvd1t4RmllbGRdID0gcG9seWdvbi5tYXAoZnVuY3Rpb24gKHBvaW50KSB7IHJldHVybiBwb2ludFswXTsgfSk7XG4gICAgICAgIHJvd1t5RmllbGRdID0gcG9seWdvbi5tYXAoZnVuY3Rpb24gKHBvaW50KSB7IHJldHVybiBwb2ludFsxXTsgfSk7XG4gICAgfSk7XG59XG5yZWdpc3RlclRyYW5zZm9ybSgnZGlhZ3JhbS52b3Jvbm9pJywgdHJhbnNmb3JtKTtcbnJlZ2lzdGVyVHJhbnNmb3JtKCd2b3Jvbm9pJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vZmlsbC1yb3dzLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2ZpbGwtcm93cy50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgcGFydGl0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL3BhcnRpdGlvbiAqLyBcIi4vc3JjL3V0aWwvcGFydGl0aW9uLnRzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgZmlsbEJ5OiAnZ3JvdXAnLFxuICAgIGdyb3VwQnk6IFtdLFxuICAgIG9yZGVyQnk6IFtdLFxufTtcbmZ1bmN0aW9uIGFycmF5RGlmZmVyZW5jZShhcnIxLCBhcnIyKSB7XG4gICAgLy8gYXJyYXlEaWZmZXJlbmNlKFsxLCAxLCAxLCAyXSwgWzEsIDJdKSA9PiBbMSwgMV1cbiAgICB2YXIgc2hhZG93ID0gYXJyMS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW07IH0pOyAvLyBzaGFkb3cgY29weVxuICAgIGFycjIuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgaW5kZXggPSBzaGFkb3cuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHNoYWRvdy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNoYWRvdztcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhVmlldywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciByb3dzID0gZGF0YVZpZXcucm93cztcbiAgICB2YXIgZ3JvdXBCeSA9IG9wdGlvbnMuZ3JvdXBCeTtcbiAgICB2YXIgb3JkZXJCeSA9IG9wdGlvbnMub3JkZXJCeTtcbiAgICB2YXIgZ3JvdXBzID0gcGFydGl0aW9uXzEuZGVmYXVsdChyb3dzLCBncm91cEJ5LCBvcmRlckJ5KTtcbiAgICB2YXIgbWF4TGVuZ3RoID0gMDtcbiAgICB2YXIgcmVmZXJlbmNlR3JvdXAgPSBbXTtcbiAgICB1dGlsXzEuZm9ySW4oZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgaWYgKGdyb3VwLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgbWF4TGVuZ3RoID0gZ3JvdXAubGVuZ3RoO1xuICAgICAgICAgICAgcmVmZXJlbmNlR3JvdXAgPSBncm91cDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciByZWZlcmVuY2VPcmRlckJ5S2V5cyA9IFtdO1xuICAgIHZhciByZWZlcmVuY2VSb3dCeU9yZGVyQnlLZXkgPSB7fTtcbiAgICByZWZlcmVuY2VHcm91cC5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGtleSA9IG9yZGVyQnkubWFwKGZ1bmN0aW9uIChjb2wpIHsgcmV0dXJuIHJvd1tjb2xdOyB9KS5qb2luKCctJyk7XG4gICAgICAgIHJlZmVyZW5jZU9yZGVyQnlLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgcmVmZXJlbmNlUm93QnlPcmRlckJ5S2V5W2tleV0gPSByb3c7XG4gICAgfSk7XG4gICAgaWYgKG9wdGlvbnMuZmlsbEJ5ID09PSAnb3JkZXInKSB7XG4gICAgICAgIHZhciBmaXJzdF8xID0gcmVmZXJlbmNlR3JvdXBbMF07XG4gICAgICAgIHZhciBhbGxPcmRlckJ5S2V5c18xID0gW107XG4gICAgICAgIHZhciByb3dCeU9yZGVyQnlLZXlfMSA9IHt9O1xuICAgICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICAgICAgdmFyIGtleSA9IG9yZGVyQnkubWFwKGZ1bmN0aW9uIChjb2wpIHsgcmV0dXJuIHJvd1tjb2xdOyB9KS5qb2luKCctJyk7XG4gICAgICAgICAgICBpZiAoYWxsT3JkZXJCeUtleXNfMS5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYWxsT3JkZXJCeUtleXNfMS5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgcm93QnlPcmRlckJ5S2V5XzFba2V5XSA9IHJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfbWlzc2luZ09yZGVyQnlLZXlzID0gYXJyYXlEaWZmZXJlbmNlKGFsbE9yZGVyQnlLZXlzXzEsIHJlZmVyZW5jZU9yZGVyQnlLZXlzKTtcbiAgICAgICAgX21pc3NpbmdPcmRlckJ5S2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSB7fTtcbiAgICAgICAgICAgIGdyb3VwQnkuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgICAgICAgcm93W2NvbF0gPSBmaXJzdF8xW2NvbF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9yZGVyQnkuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgICAgICAgcm93W2NvbF0gPSByb3dCeU9yZGVyQnlLZXlfMVtrZXldW2NvbF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgICAgcmVmZXJlbmNlR3JvdXAucHVzaChyb3cpO1xuICAgICAgICAgICAgcmVmZXJlbmNlT3JkZXJCeUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgcmVmZXJlbmNlUm93QnlPcmRlckJ5S2V5W2tleV0gPSByb3c7XG4gICAgICAgIH0pO1xuICAgICAgICBtYXhMZW5ndGggPSByZWZlcmVuY2VHcm91cC5sZW5ndGg7XG4gICAgfVxuICAgIHV0aWxfMS5mb3JJbihncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICBpZiAoZ3JvdXAgIT09IHJlZmVyZW5jZUdyb3VwICYmIGdyb3VwLmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0XzIgPSBncm91cFswXTtcbiAgICAgICAgICAgIC8vIG1pc3Npbmcgb3JkZXJCeSBrZXlzXG4gICAgICAgICAgICB2YXIgb3JkZXJCeUtleXNfMSA9IFtdO1xuICAgICAgICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICAgICAgb3JkZXJCeUtleXNfMS5wdXNoKG9yZGVyQnkubWFwKGZ1bmN0aW9uIChjb2wpIHsgcmV0dXJuIHJvd1tjb2xdOyB9KS5qb2luKCctJykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWlzc2luZ09yZGVyQnlLZXlzID0gYXJyYXlEaWZmZXJlbmNlKHJlZmVyZW5jZU9yZGVyQnlLZXlzLCBvcmRlckJ5S2V5c18xKTtcbiAgICAgICAgICAgIG1pc3NpbmdPcmRlckJ5S2V5cy5zb21lKGZ1bmN0aW9uIChrZXksIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBtYXhMZW5ndGggLSBncm91cC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ3JvdXAgbGVuZ3RoIG92ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVmZXJlbmNlUm93ID0gcmVmZXJlbmNlUm93QnlPcmRlckJ5S2V5W2tleV07XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IHt9O1xuICAgICAgICAgICAgICAgIGdyb3VwQnkuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2xdID0gZmlyc3RfMltjb2xdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9yZGVyQnkuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tjb2xdID0gcmVmZXJlbmNlUm93W2NvbF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnZmlsbC1yb3dzJywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnZmlsbFJvd3MnLCB0cmFuc2Zvcm0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9maWx0ZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vZmlsdGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbmZ1bmN0aW9uIGRlZmF1bHRDYWxsYmFjayhyb3cpIHtcbiAgICByZXR1cm4gISFyb3c7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2ZpbHRlcicsIGZ1bmN0aW9uIChkYXRhVmlldywgb3B0aW9ucykge1xuICAgIGRhdGFWaWV3LnJvd3MgPSBkYXRhVmlldy5yb3dzLmZpbHRlcihvcHRpb25zLmNhbGxiYWNrIHx8IGRlZmF1bHRDYWxsYmFjayk7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vZm9sZC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vZm9sZC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGZpZWxkczogW10sXG4gICAga2V5OiAna2V5JyxcbiAgICByZXRhaW5zOiBbXSxcbiAgICB2YWx1ZTogJ3ZhbHVlJyxcbn07XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2ZvbGQnLCBmdW5jdGlvbiAoZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29sdW1ucyA9IGRhdGFWaWV3LmdldENvbHVtbk5hbWVzKCk7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGZpZWxkcyA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZHMob3B0aW9ucyk7XG4gICAgaWYgKGZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCd3YXJuaW5nOiBvcHRpb24gZmllbGRzIGlzIG5vdCBzcGVjaWZpZWQsIHdpbGwgZm9sZCBhbGwgY29sdW1ucy4nKTtcbiAgICAgICAgZmllbGRzID0gY29sdW1ucztcbiAgICB9XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIHJldGFpbnMgPSBvcHRpb25zLnJldGFpbnM7XG4gICAgaWYgKCFyZXRhaW5zIHx8IHJldGFpbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldGFpbnMgPSB1dGlsXzEuZGlmZmVyZW5jZShjb2x1bW5zLCBmaWVsZHMpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0Um93cyA9IFtdO1xuICAgIGRhdGFWaWV3LnJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdFJvdyA9IHV0aWxfMS5waWNrKHJvdywgcmV0YWlucyk7XG4gICAgICAgICAgICByZXN1bHRSb3dba2V5XSA9IGZpZWxkO1xuICAgICAgICAgICAgcmVzdWx0Um93W3ZhbHVlXSA9IHJvd1tmaWVsZF07XG4gICAgICAgICAgICByZXN1bHRSb3dzLnB1c2gocmVzdWx0Um93KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgZGF0YVZpZXcucm93cyA9IHJlc3VsdFJvd3M7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vZ2VvL2NlbnRyb2lkLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2dlby9jZW50cm9pZC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIHJlZ2lzdGVyVHJhbnNmb3JtID0gZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgLy8gZmllbGQ6ICduYW1lJywgLy8gcmVxdWlyZWRcbiAgICAvLyBnZW9WaWV3OiB2aWV3LCAvLyByZXF1aXJlZFxuICAgIC8vIGdlb0RhdGFWaWV3OiB2aWV3LCAvLyBhbGlhc1xuICAgIGFzOiBbJ19jZW50cm9pZF94JywgJ19jZW50cm9pZF95J10sXG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtKHZpZXcsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgZmllbGQgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGQob3B0aW9ucyk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhciBnZW9WaWV3ID0gb3B0aW9ucy5nZW9WaWV3IHx8IG9wdGlvbnMuZ2VvRGF0YVZpZXc7IC8vIGFsaWFzXG4gICAgaWYgKHV0aWxfMS5pc1N0cmluZyhnZW9WaWV3KSAmJiB2aWV3LmRhdGFTZXQpIHtcbiAgICAgICAgZ2VvVmlldyA9IHZpZXcuZGF0YVNldC5nZXRWaWV3KGdlb1ZpZXcpO1xuICAgIH1cbiAgICBpZiAoIWdlb1ZpZXcgfHwgZ2VvVmlldy5kYXRhVHlwZSAhPT0gJ2dlbycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBnZW9WaWV3OiBtdXN0IGJlIGEgRGF0YVZpZXcgb2YgR0VPIGRhdGFUeXBlIScpO1xuICAgIH1cbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzO1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoYXMpIHx8IGFzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFzOiBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggMiBzdHJpbmdzIChlLmcuIFsgXCJjWFwiLCBcImNZXCIgXSkhJyk7XG4gICAgfVxuICAgIHZhciBjZW50cm9pZFggPSBhc1swXTtcbiAgICB2YXIgY2VudHJvaWRZID0gYXNbMV07XG4gICAgdmlldy5yb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGdlb1ZpZXcuZ2VvRmVhdHVyZUJ5TmFtZShyb3dbZmllbGRdKTtcbiAgICAgICAgaWYgKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIGlmIChnZW9WaWV3Ll9wcm9qZWN0ZWRBcykge1xuICAgICAgICAgICAgICAgIHJvd1tjZW50cm9pZFhdID0gZmVhdHVyZVtnZW9WaWV3Ll9wcm9qZWN0ZWRBc1syXV07XG4gICAgICAgICAgICAgICAgcm93W2NlbnRyb2lkWV0gPSBmZWF0dXJlW2dlb1ZpZXcuX3Byb2plY3RlZEFzWzNdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvd1tjZW50cm9pZFhdID0gZmVhdHVyZS5jZW50cm9pZFg7XG4gICAgICAgICAgICAgICAgcm93W2NlbnRyb2lkWV0gPSBmZWF0dXJlLmNlbnRyb2lkWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxucmVnaXN0ZXJUcmFuc2Zvcm0oJ2dlby5jZW50cm9pZCcsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2dlby9wcm9qZWN0aW9uLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vZ2VvL3Byb2plY3Rpb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZDNfZ2VvXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1nZW8gKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtZ2VvQDEuNi40QGQzLWdlby9idWlsZC9kMy1nZW8uanNcIik7XG52YXIgcG9pbnRfYXRfbGVuZ3RoXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBwb2ludC1hdC1sZW5ndGggKi8gXCIuL25vZGVfbW9kdWxlcy9fcG9pbnQtYXQtbGVuZ3RoQDEuMS4wQHBvaW50LWF0LWxlbmd0aC9pbmRleC5qc1wiKSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgcmVnaXN0ZXJUcmFuc2Zvcm0gPSBkYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm07XG52YXIgZ2V0X2dlb19wcm9qZWN0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2dldC1nZW8tcHJvamVjdGlvbiAqLyBcIi4vc3JjL3V0aWwvZ2V0LWdlby1wcm9qZWN0aW9uLnRzXCIpKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgLy8gcHJvamVjdGlvbjogJycsIC8vIGRlZmF1bHQgdG8gbnVsbFxuICAgIGFzOiBbJ194JywgJ195JywgJ19jZW50cm9pZF94JywgJ19jZW50cm9pZF95J10sXG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgaWYgKGRhdGFWaWV3LmRhdGFUeXBlICE9PSAnZ2VvJyAmJiBkYXRhVmlldy5kYXRhVHlwZSAhPT0gJ2dlby1ncmF0aWN1bGUnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZGF0YVZpZXc6IHRoaXMgdHJhbnNmb3JtIGlzIGZvciBHZW8gZGF0YSBvbmx5IScpO1xuICAgIH1cbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgcHJvamVjdGlvbiA9IG9wdGlvbnMucHJvamVjdGlvbjtcbiAgICBpZiAoIXByb2plY3Rpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwcm9qZWN0aW9uIScpO1xuICAgIH1cbiAgICBwcm9qZWN0aW9uID0gZ2V0X2dlb19wcm9qZWN0aW9uXzEuZGVmYXVsdChwcm9qZWN0aW9uKTtcbiAgICAvLyBAdHMtaWdub3JlO1xuICAgIHZhciBnZW9QYXRoR2VuZXJhdG9yID0gZDNfZ2VvXzEuZ2VvUGF0aChwcm9qZWN0aW9uKTtcbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzO1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoYXMpIHx8IGFzLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFzOiBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggNCBzdHJpbmdzIChlLmcuIFsgXCJ4XCIsIFwieVwiLCBcImNYXCIsIFwiY1lcIiBdKSEnKTtcbiAgICB9XG4gICAgZGF0YVZpZXcuX3Byb2plY3RlZEFzID0gYXM7XG4gICAgdmFyIF9hID0gdHNsaWJfMS5fX3JlYWQoYXMsIDQpLCBsb25GaWVsZCA9IF9hWzBdLCBsYXRGaWVsZCA9IF9hWzFdLCBjZW50cm9pZFggPSBfYVsyXSwgY2VudHJvaWRZID0gX2FbM107XG4gICAgZGF0YVZpZXcucm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcm93W2xvbkZpZWxkXSA9IFtdO1xuICAgICAgICByb3dbbGF0RmllbGRdID0gW107XG4gICAgICAgIHZhciBwYXRoRGF0YSA9IGdlb1BhdGhHZW5lcmF0b3Iocm93KTtcbiAgICAgICAgaWYgKHBhdGhEYXRhKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHByb2plY3Rpb24gcmV0dXJucyBudWxsXG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gcG9pbnRfYXRfbGVuZ3RoXzEuZGVmYXVsdChwYXRoRGF0YSk7XG4gICAgICAgICAgICBwb2ludHMuX3BhdGguZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICByb3dbbG9uRmllbGRdLnB1c2gocG9pbnRbMV0pO1xuICAgICAgICAgICAgICAgIHJvd1tsYXRGaWVsZF0ucHVzaChwb2ludFsyXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBjZW50cm9pZCA9IGdlb1BhdGhHZW5lcmF0b3IuY2VudHJvaWQocm93KTtcbiAgICAgICAgICAgIHJvd1tjZW50cm9pZFhdID0gY2VudHJvaWRbMF07XG4gICAgICAgICAgICByb3dbY2VudHJvaWRZXSA9IGNlbnRyb2lkWzFdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZGF0YVZpZXcucm93cyA9IGRhdGFWaWV3LnJvd3MuZmlsdGVyKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHJvd1tsb25GaWVsZF0ubGVuZ3RoICE9PSAwOyB9KTtcbn1cbnJlZ2lzdGVyVHJhbnNmb3JtKCdnZW8ucHJvamVjdGlvbicsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2dlby9yZWdpb24udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2dlby9yZWdpb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgcmVnaXN0ZXJUcmFuc2Zvcm0gPSBkYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm07XG52YXIgb3B0aW9uX3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICAvLyBmaWVsZDogJ25hbWUnLCAvLyByZXF1aXJlZFxuICAgIC8vIGdlb1ZpZXc6IHZpZXcsIC8vIHJlcXVpcmVkXG4gICAgLy8gZ2VvRGF0YVZpZXc6IHZpZXcsIC8vIGFsaWFzXG4gICAgYXM6IFsnX3gnLCAnX3knXSxcbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm0odmlldywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBmaWVsZCA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZChvcHRpb25zKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFyIGdlb1ZpZXcgPSBvcHRpb25zLmdlb1ZpZXcgfHwgb3B0aW9ucy5nZW9EYXRhVmlldzsgLy8gYWxpYXNcbiAgICBpZiAodXRpbF8xLmlzU3RyaW5nKGdlb1ZpZXcpKSB7XG4gICAgICAgIGdlb1ZpZXcgPSB2aWV3LmRhdGFTZXQuZ2V0VmlldyhnZW9WaWV3KTtcbiAgICB9XG4gICAgaWYgKCFnZW9WaWV3IHx8IGdlb1ZpZXcuZGF0YVR5cGUgIT09ICdnZW8nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZ2VvVmlldzogbXVzdCBiZSBhIERhdGFWaWV3IG9mIEdFTyBkYXRhVHlwZSEnKTtcbiAgICB9XG4gICAgdmFyIGFzID0gb3B0aW9ucy5hcztcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGFzKSB8fCBhcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhczogaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIDIgc3RyaW5ncyAoZS5nLiBbIFwieFwiLCBcInlcIiBdKSEnKTtcbiAgICB9XG4gICAgdmFyIGxvbkZpZWxkID0gYXNbMF07XG4gICAgdmFyIGxhdEZpZWxkID0gYXNbMV07XG4gICAgdmlldy5yb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGdlb1ZpZXcuZ2VvRmVhdHVyZUJ5TmFtZShyb3dbZmllbGRdKTtcbiAgICAgICAgaWYgKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIGlmIChnZW9WaWV3Ll9wcm9qZWN0ZWRBcykge1xuICAgICAgICAgICAgICAgIHJvd1tsb25GaWVsZF0gPSBmZWF0dXJlW2dlb1ZpZXcuX3Byb2plY3RlZEFzWzBdXTtcbiAgICAgICAgICAgICAgICByb3dbbGF0RmllbGRdID0gZmVhdHVyZVtnZW9WaWV3Ll9wcm9qZWN0ZWRBc1sxXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb3dbbG9uRmllbGRdID0gZmVhdHVyZS5sb25naXR1ZGU7XG4gICAgICAgICAgICAgICAgcm93W2xhdEZpZWxkXSA9IGZlYXR1cmUubGF0aXR1ZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbnJlZ2lzdGVyVHJhbnNmb3JtKCdnZW8ucmVnaW9uJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L2NsdXN0ZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9oaWVyYXJjaHkvY2x1c3Rlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIGQzSGllcmFyY2h5ID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtaGllcmFyY2h5ICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWhpZXJhcmNoeUAxLjEuOUBkMy1oaWVyYXJjaHkvZGlzdC9kMy1oaWVyYXJjaHkuanNcIikpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGZpZWxkOiAndmFsdWUnLFxuICAgIHNpemU6IFsxLCAxXSxcbiAgICBub2RlU2l6ZTogbnVsbCxcbiAgICBzZXBhcmF0aW9uOiBudWxsLFxuICAgIGFzOiBbJ3gnLCAneSddLFxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhVmlldywgb3B0aW9ucykge1xuICAgIGlmIChkYXRhVmlldy5kYXRhVHlwZSAhPT0gZGF0YV9zZXRfMS5EYXRhU2V0LkNPTlNUQU5UUy5ISUVSQVJDSFkgfHwgIWRhdGFWaWV3LnJvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBEYXRhVmlldzogVGhpcyB0cmFuc2Zvcm0gaXMgZm9yIEhpZXJhcmNoeSBkYXRhIG9ubHkhJyk7XG4gICAgfVxuICAgIHZhciByb290ID0gZGF0YVZpZXcucm9vdDtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzO1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoYXMpIHx8IGFzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFzOiBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggMiBzdHJpbmdzIChlLmcuIFsgXCJ4XCIsIFwieVwiIF0pIScpO1xuICAgIH1cbiAgICB2YXIgZmllbGQgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgZmllbGQgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGQob3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlKTtcbiAgICB9XG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICAgIHJvb3Quc3VtKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkW2ZpZWxkXTsgfSk7XG4gICAgfVxuICAgIHZhciBjbHVzdGVyTGF5b3V0ID0gZDNIaWVyYXJjaHkuY2x1c3RlcigpO1xuICAgIGNsdXN0ZXJMYXlvdXQuc2l6ZShvcHRpb25zLnNpemUpO1xuICAgIGlmIChvcHRpb25zLm5vZGVTaXplKSB7XG4gICAgICAgIGNsdXN0ZXJMYXlvdXQubm9kZVNpemUob3B0aW9ucy5ub2RlU2l6ZSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnNlcGFyYXRpb24pIHtcbiAgICAgICAgY2x1c3RlckxheW91dC5zZXBhcmF0aW9uKG9wdGlvbnMuc2VwYXJhdGlvbik7XG4gICAgfVxuICAgIGNsdXN0ZXJMYXlvdXQocm9vdCk7XG4gICAgdmFyIHggPSBhc1swXTtcbiAgICB2YXIgeSA9IGFzWzFdO1xuICAgIHJvb3QuZWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlW3hdID0gbm9kZS54O1xuICAgICAgICBub2RlW3ldID0gbm9kZS55O1xuICAgIH0pO1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdoaWVyYXJjaHkuY2x1c3RlcicsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2RlbmRyb2dyYW0nLCB0cmFuc2Zvcm0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9oaWVyYXJjaHkvY29tcGFjdC1ib3gudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L2NvbXBhY3QtYm94LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIGhpZXJhcmNoeV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvaGllcmFyY2h5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X2hpZXJhcmNoeUAwLjYuMkBAYW50di9oaWVyYXJjaHkvYnVpbGQvaGllcmFyY2h5LmpzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7fTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhVmlldywgb3B0aW9ucykge1xuICAgIHZhciByb290ID0gZGF0YVZpZXcucm9vdDtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICBpZiAoZGF0YVZpZXcuZGF0YVR5cGUgIT09IGRhdGFfc2V0XzEuRGF0YVNldC5DT05TVEFOVFMuSElFUkFSQ0hZKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgRGF0YVZpZXc6IFRoaXMgdHJhbnNmb3JtIGlzIGZvciBIaWVyYXJjaHkgZGF0YSBvbmx5IScpO1xuICAgIH1cbiAgICBkYXRhVmlldy5yb290ID0gaGllcmFyY2h5XzEuZGVmYXVsdC5jb21wYWN0Qm94KHJvb3QsIG9wdGlvbnMpO1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdoaWVyYXJjaHkuY29tcGFjdC1ib3gnLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdjb21wYWN0LWJveC10cmVlJywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnbm9uLWxheWVyZWQtdGlkeS10cmVlJywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnbWluZG1hcC1sb2dpY2FsJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L2RlbmRyb2dyYW0udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9oaWVyYXJjaHkvZGVuZHJvZ3JhbS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIGhpZXJhcmNoeV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvaGllcmFyY2h5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X2hpZXJhcmNoeUAwLjYuMkBAYW50di9oaWVyYXJjaHkvYnVpbGQvaGllcmFyY2h5LmpzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7fTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhVmlldywgb3B0aW9ucykge1xuICAgIHZhciByb290ID0gZGF0YVZpZXcucm9vdDtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICBpZiAoZGF0YVZpZXcuZGF0YVR5cGUgIT09IGRhdGFfc2V0XzEuRGF0YVNldC5DT05TVEFOVFMuSElFUkFSQ0hZKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgRGF0YVZpZXc6IFRoaXMgdHJhbnNmb3JtIGlzIGZvciBIaWVyYXJjaHkgZGF0YSBvbmx5IScpO1xuICAgIH1cbiAgICBkYXRhVmlldy5yb290ID0gaGllcmFyY2h5XzEuZGVmYXVsdC5kZW5kcm9ncmFtKHJvb3QsIG9wdGlvbnMpO1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdoaWVyYXJjaHkuZGVuZHJvZ3JhbScsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2RlbmRyb2dyYW0nLCB0cmFuc2Zvcm0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS9oaWVyYXJjaHkvaW5kZW50ZWQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L2luZGVudGVkLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIGhpZXJhcmNoeV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvaGllcmFyY2h5ICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X2hpZXJhcmNoeUAwLjYuMkBAYW50di9oaWVyYXJjaHkvYnVpbGQvaGllcmFyY2h5LmpzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7fTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhVmlldywgb3B0aW9ucykge1xuICAgIHZhciByb290ID0gZGF0YVZpZXcucm9vdDtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICBpZiAoZGF0YVZpZXcuZGF0YVR5cGUgIT09IGRhdGFfc2V0XzEuRGF0YVNldC5DT05TVEFOVFMuSElFUkFSQ0hZKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgRGF0YVZpZXc6IFRoaXMgdHJhbnNmb3JtIGlzIGZvciBIaWVyYXJjaHkgZGF0YSBvbmx5IScpO1xuICAgIH1cbiAgICBkYXRhVmlldy5yb290ID0gaGllcmFyY2h5XzEuZGVmYXVsdC5pbmRlbnRlZChyb290LCBvcHRpb25zKTtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnaGllcmFyY2h5LmluZGVudGVkJywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnaW5kZW50ZWQtdHJlZScsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS9wYWNrLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L3BhY2sudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZDNIaWVyYXJjaHkgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1oaWVyYXJjaHkgKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtaGllcmFyY2h5QDEuMS45QGQzLWhpZXJhcmNoeS9kaXN0L2QzLWhpZXJhcmNoeS5qc1wiKSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgb3B0aW9uX3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBmaWVsZDogJ3ZhbHVlJyxcbiAgICBzaXplOiBbMSwgMV0sXG4gICAgcGFkZGluZzogMCxcbiAgICBhczogWyd4JywgJ3knLCAnciddLFxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhVmlldywgb3B0aW9ucykge1xuICAgIGlmIChkYXRhVmlldy5kYXRhVHlwZSAhPT0gZGF0YV9zZXRfMS5EYXRhU2V0LkNPTlNUQU5UUy5ISUVSQVJDSFkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBEYXRhVmlldzogVGhpcyB0cmFuc2Zvcm0gaXMgZm9yIEhpZXJhcmNoeSBkYXRhIG9ubHkhJyk7XG4gICAgfVxuICAgIHZhciByb290ID0gZGF0YVZpZXcucm9vdDtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzO1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoYXMpIHx8IGFzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFzOiBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggMyBzdHJpbmdzIChlLmcuIFsgXCJ4XCIsIFwieVwiLCBcInJcIiBdKSEnKTtcbiAgICB9XG4gICAgdmFyIGZpZWxkO1xuICAgIHRyeSB7XG4gICAgICAgIGZpZWxkID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgfVxuICAgIGlmIChmaWVsZCkge1xuICAgICAgICByb290LnN1bShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFtmaWVsZF07IH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGJbZmllbGRdIC0gYVtmaWVsZF07IH0pO1xuICAgIH1cbiAgICB2YXIgcGFja0xheW91dCA9IGQzSGllcmFyY2h5LnBhY2soKTtcbiAgICBwYWNrTGF5b3V0LnNpemUob3B0aW9ucy5zaXplKTtcbiAgICBpZiAob3B0aW9ucy5wYWRkaW5nKSB7XG4gICAgICAgIHBhY2tMYXlvdXQucGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICAgIH1cbiAgICBwYWNrTGF5b3V0KHJvb3QpO1xuICAgIHZhciB4ID0gYXNbMF07XG4gICAgdmFyIHkgPSBhc1sxXTtcbiAgICB2YXIgciA9IGFzWzJdO1xuICAgIHJvb3QuZWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlW3hdID0gbm9kZS54O1xuICAgICAgICBub2RlW3ldID0gbm9kZS55O1xuICAgICAgICBub2RlW3JdID0gbm9kZS5yO1xuICAgIH0pO1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdoaWVyYXJjaHkucGFjaycsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2hpZXJhcmNoeS5jaXJjbGUtcGFja2luZycsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2NpcmNsZS1wYWNraW5nJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L3BhcnRpdGlvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L3BhcnRpdGlvbi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgZDNIaWVyYXJjaHkgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1oaWVyYXJjaHkgKi8gXCIuL25vZGVfbW9kdWxlcy9fZDMtaGllcmFyY2h5QDEuMS45QGQzLWhpZXJhcmNoeS9kaXN0L2QzLWhpZXJhcmNoeS5qc1wiKSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgZmllbGQ6ICd2YWx1ZScsXG4gICAgc2l6ZTogWzEsIDFdLFxuICAgIHJvdW5kOiBmYWxzZSxcbiAgICAvLyByYXRpbzogMS42MTgwMzM5ODg3NDk4OTUsIC8vIGdvbGRlbiByYXRpb1xuICAgIHBhZGRpbmc6IDAsXG4gICAgc29ydDogdHJ1ZSxcbiAgICBhczogWyd4JywgJ3knXSxcbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBpZiAoZGF0YVZpZXcuZGF0YVR5cGUgIT09IGRhdGFfc2V0XzEuRGF0YVNldC5DT05TVEFOVFMuSElFUkFSQ0hZKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgRGF0YVZpZXc6IFRoaXMgdHJhbnNmb3JtIGlzIGZvciBIaWVyYXJjaHkgZGF0YSBvbmx5IScpO1xuICAgIH1cbiAgICB2YXIgcm9vdCA9IGRhdGFWaWV3LnJvb3Q7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGFzID0gb3B0aW9ucy5hcztcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGFzKSB8fCBhcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhczogaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIDIgc3RyaW5ncyAoZS5nLiBbIFwieFwiLCBcInlcIiBdKSEnKTtcbiAgICB9XG4gICAgdmFyIGZpZWxkO1xuICAgIHRyeSB7XG4gICAgICAgIGZpZWxkID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgfVxuICAgIGlmIChmaWVsZCkge1xuICAgICAgICByb290LnN1bShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFtmaWVsZF07IH0pO1xuICAgIH1cbiAgICB2YXIgcGFydGl0aW9uTGF5b3V0ID0gZDNIaWVyYXJjaHkucGFydGl0aW9uKCk7XG4gICAgcGFydGl0aW9uTGF5b3V0XG4gICAgICAgIC5zaXplKG9wdGlvbnMuc2l6ZSlcbiAgICAgICAgLnJvdW5kKG9wdGlvbnMucm91bmQpXG4gICAgICAgIC5wYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gICAgcGFydGl0aW9uTGF5b3V0KHJvb3QpO1xuICAgIC8qXG4gICAgICogcG9pbnRzOlxuICAgICAqICAgMyAgMlxuICAgICAqICAgMCAgMVxuICAgICAqL1xuICAgIHZhciB4ID0gYXNbMF07XG4gICAgdmFyIHkgPSBhc1sxXTtcbiAgICByb290LmVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZVt4XSA9IFtub2RlLngwLCBub2RlLngxLCBub2RlLngxLCBub2RlLngwXTtcbiAgICAgICAgbm9kZVt5XSA9IFtub2RlLnkxLCBub2RlLnkxLCBub2RlLnkwLCBub2RlLnkwXTtcbiAgICAgICAgWyd4MCcsICd4MScsICd5MCcsICd5MSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmIChhcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnaGllcmFyY2h5LnBhcnRpdGlvbicsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2FkamFjZW5jeScsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2hpZXJhcmNoeS90cmVlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L3RyZWUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciBkM0hpZXJhcmNoeSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIGQzLWhpZXJhcmNoeSAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1oaWVyYXJjaHlAMS4xLjlAZDMtaGllcmFyY2h5L2Rpc3QvZDMtaGllcmFyY2h5LmpzXCIpKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgb3B0aW9uX3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vdXRpbC9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBmaWVsZDogJ3ZhbHVlJyxcbiAgICBzaXplOiBbMSwgMV0sXG4gICAgbm9kZVNpemU6IG51bGwsXG4gICAgc2VwYXJhdGlvbjogbnVsbCxcbiAgICBhczogWyd4JywgJ3knXSxcbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBpZiAoZGF0YVZpZXcuZGF0YVR5cGUgIT09IGRhdGFfc2V0XzEuRGF0YVNldC5DT05TVEFOVFMuSElFUkFSQ0hZKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgRGF0YVZpZXc6IFRoaXMgdHJhbnNmb3JtIGlzIGZvciBIaWVyYXJjaHkgZGF0YSBvbmx5IScpO1xuICAgIH1cbiAgICB2YXIgcm9vdCA9IGRhdGFWaWV3LnJvb3Q7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGFzID0gb3B0aW9ucy5hcztcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGFzKSB8fCBhcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhczogaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIDIgc3RyaW5ncyAoZS5nLiBbIFwieFwiLCBcInlcIiBdKSEnKTtcbiAgICB9XG4gICAgdmFyIGZpZWxkO1xuICAgIHRyeSB7XG4gICAgICAgIGZpZWxkID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgfVxuICAgIGlmIChmaWVsZCkge1xuICAgICAgICByb290LnN1bShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFtmaWVsZF07IH0pO1xuICAgIH1cbiAgICB2YXIgdHJlZUxheW91dCA9IGQzSGllcmFyY2h5LnRyZWUoKTtcbiAgICB0cmVlTGF5b3V0LnNpemUob3B0aW9ucy5zaXplKTtcbiAgICBpZiAob3B0aW9ucy5ub2RlU2l6ZSkge1xuICAgICAgICB0cmVlTGF5b3V0Lm5vZGVTaXplKG9wdGlvbnMubm9kZVNpemUpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5zZXBhcmF0aW9uKSB7XG4gICAgICAgIHRyZWVMYXlvdXQuc2VwYXJhdGlvbihvcHRpb25zLnNlcGFyYXRpb24pO1xuICAgIH1cbiAgICB0cmVlTGF5b3V0KHJvb3QpO1xuICAgIHZhciB4ID0gYXNbMF07XG4gICAgdmFyIHkgPSBhc1sxXTtcbiAgICByb290LmVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZVt4XSA9IG5vZGUueDtcbiAgICAgICAgbm9kZVt5XSA9IG5vZGUueTtcbiAgICB9KTtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnaGllcmFyY2h5LnRyZWUnLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCd0cmVlJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vaGllcmFyY2h5L3RyZWVtYXAudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9oaWVyYXJjaHkvdHJlZW1hcC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIGQzSGllcmFyY2h5ID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtaGllcmFyY2h5ICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWhpZXJhcmNoeUAxLjEuOUBkMy1oaWVyYXJjaHkvZGlzdC9kMy1oaWVyYXJjaHkuanNcIikpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGZpZWxkOiAndmFsdWUnLFxuICAgIHRpbGU6ICd0cmVlbWFwU3F1YXJpZnknLFxuICAgIHNpemU6IFsxLCAxXSxcbiAgICByb3VuZDogZmFsc2UsXG4gICAgLy8gcmF0aW86IDEuNjE4MDMzOTg4NzQ5ODk1LCAvLyBnb2xkZW4gcmF0aW9cbiAgICBwYWRkaW5nOiAwLFxuICAgIHBhZGRpbmdJbm5lcjogMCxcbiAgICBwYWRkaW5nT3V0ZXI6IDAsXG4gICAgcGFkZGluZ1RvcDogMCxcbiAgICBwYWRkaW5nUmlnaHQ6IDAsXG4gICAgcGFkZGluZ0JvdHRvbTogMCxcbiAgICBwYWRkaW5nTGVmdDogMCxcbiAgICBhczogWyd4JywgJ3knXSxcbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBpZiAoZGF0YVZpZXcuZGF0YVR5cGUgIT09IGRhdGFfc2V0XzEuRGF0YVNldC5DT05TVEFOVFMuSElFUkFSQ0hZKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgRGF0YVZpZXc6IFRoaXMgdHJhbnNmb3JtIGlzIGZvciBIaWVyYXJjaHkgZGF0YSBvbmx5IScpO1xuICAgIH1cbiAgICB2YXIgcm9vdCA9IGRhdGFWaWV3LnJvb3Q7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGFzID0gb3B0aW9ucy5hcztcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGFzKSB8fCBhcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhczogaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIDIgc3RyaW5ncyAoZS5nLiBbIFwieFwiLCBcInlcIiBdKSEnKTtcbiAgICB9XG4gICAgdmFyIGZpZWxkO1xuICAgIHRyeSB7XG4gICAgICAgIGZpZWxkID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkKG9wdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oZSk7XG4gICAgfVxuICAgIGlmIChmaWVsZCkge1xuICAgICAgICByb290LnN1bShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZFtmaWVsZF07IH0pO1xuICAgIH1cbiAgICB2YXIgdHJlZW1hcExheW91dCA9IGQzSGllcmFyY2h5LnRyZWVtYXAoKTtcbiAgICB0cmVlbWFwTGF5b3V0XG4gICAgICAgIC50aWxlKGQzSGllcmFyY2h5W29wdGlvbnMudGlsZV0pXG4gICAgICAgIC5zaXplKG9wdGlvbnMuc2l6ZSlcbiAgICAgICAgLnJvdW5kKG9wdGlvbnMucm91bmQpXG4gICAgICAgIC5wYWRkaW5nKG9wdGlvbnMucGFkZGluZylcbiAgICAgICAgLnBhZGRpbmdJbm5lcihvcHRpb25zLnBhZGRpbmdJbm5lcilcbiAgICAgICAgLnBhZGRpbmdPdXRlcihvcHRpb25zLnBhZGRpbmdPdXRlcilcbiAgICAgICAgLnBhZGRpbmdUb3Aob3B0aW9ucy5wYWRkaW5nVG9wKVxuICAgICAgICAucGFkZGluZ1JpZ2h0KG9wdGlvbnMucGFkZGluZ1JpZ2h0KVxuICAgICAgICAucGFkZGluZ0JvdHRvbShvcHRpb25zLnBhZGRpbmdCb3R0b20pXG4gICAgICAgIC5wYWRkaW5nTGVmdChvcHRpb25zLnBhZGRpbmdMZWZ0KTtcbiAgICB0cmVlbWFwTGF5b3V0KHJvb3QpO1xuICAgIC8qXG4gICAgICogcG9pbnRzOlxuICAgICAqICAgMyAgMlxuICAgICAqICAgMCAgMVxuICAgICAqL1xuICAgIHZhciB4ID0gYXNbMF07XG4gICAgdmFyIHkgPSBhc1sxXTtcbiAgICByb290LmVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZVt4XSA9IFtub2RlLngwLCBub2RlLngxLCBub2RlLngxLCBub2RlLngwXTtcbiAgICAgICAgbm9kZVt5XSA9IFtub2RlLnkxLCBub2RlLnkxLCBub2RlLnkwLCBub2RlLnkwXTtcbiAgICAgICAgWyd4MCcsICd4MScsICd5MCcsICd5MSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmIChhcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnaGllcmFyY2h5LnRyZWVtYXAnLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCd0cmVlbWFwJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vaW1wdXRlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2ltcHV0ZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgc2ltcGxlU3RhdGlzdGljcyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oLyohIHNpbXBsZS1zdGF0aXN0aWNzICovIFwiLi9ub2RlX21vZHVsZXMvX3NpbXBsZS1zdGF0aXN0aWNzQDYuMS4xQHNpbXBsZS1zdGF0aXN0aWNzL2Rpc3Qvc2ltcGxlLXN0YXRpc3RpY3MubWluLmpzXCIpKTtcbnZhciBwYXJ0aXRpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvcGFydGl0aW9uICovIFwiLi9zcmMvdXRpbC9wYXJ0aXRpb24udHNcIikpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgLy8gZmllbGQ6ICcnLCAvLyByZXF1aXJlZFxuICAgIC8vIG1ldGhvZDogJ3ZhbHVlJywgLy8gcmVxdWlyZWRcbiAgICAvLyB2YWx1ZTogMTAsIC8vIHJlcXVpcmVkIGlmIChtZXRob2QgPT09ICd2YWx1ZScpXG4gICAgZ3JvdXBCeTogW10sXG59O1xuZnVuY3Rpb24gbm90VW5kZWZpbmVkVmFsdWVzKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gIXV0aWxfMS5pc1VuZGVmaW5lZCh2YWx1ZSk7IH0pO1xufVxudmFyIFNUQVRJU1RJQ1NfTUVUSE9EUyA9IFsnbWVhbicsICdtZWRpYW4nLCAnbWF4JywgJ21pbiddO1xudmFyIGltcHV0YXRpb25zID0ge307XG5TVEFUSVNUSUNTX01FVEhPRFMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGltcHV0YXRpb25zW21ldGhvZF0gPSBmdW5jdGlvbiAocm93LCB2YWx1ZXMpIHsgcmV0dXJuIHNpbXBsZVN0YXRpc3RpY3NbbWV0aG9kXSh2YWx1ZXMpOyB9O1xufSk7XG5pbXB1dGF0aW9ucy52YWx1ZSA9IGZ1bmN0aW9uIChfcm93LCBfdmFsdWVzLCB2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgZmllbGQgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGQob3B0aW9ucyk7XG4gICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kO1xuICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbWV0aG9kIScpO1xuICAgIH1cbiAgICBpZiAobWV0aG9kID09PSAndmFsdWUnICYmICF1dGlsXzEuaGFzKG9wdGlvbnMsICd2YWx1ZScpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgdmFsdWU6IGl0IGlzIG5pbC4nKTtcbiAgICB9XG4gICAgdmFyIGNvbHVtbiA9IG5vdFVuZGVmaW5lZFZhbHVlcyhkYXRhVmlldy5nZXRDb2x1bW4oZmllbGQpKTtcbiAgICB2YXIgZ3JvdXBzID0gcGFydGl0aW9uXzEuZGVmYXVsdChkYXRhVmlldy5yb3dzLCBvcHRpb25zLmdyb3VwQnkpO1xuICAgIHV0aWxfMS5mb3JJbihncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICB2YXIgZmllbGRWYWx1ZXMgPSBub3RVbmRlZmluZWRWYWx1ZXMoZ3JvdXAubWFwKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHJvd1tmaWVsZF07IH0pKTtcbiAgICAgICAgaWYgKGZpZWxkVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZmllbGRWYWx1ZXMgPSBjb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgICAgICBpZiAodXRpbF8xLmlzVW5kZWZpbmVkKHJvd1tmaWVsZF0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxfMS5pc0Z1bmN0aW9uKG1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93W2ZpZWxkXSA9IG1ldGhvZChyb3csIGZpZWxkVmFsdWVzLCBvcHRpb25zLnZhbHVlLCBncm91cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHV0aWxfMS5pc1N0cmluZyhtZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tmaWVsZF0gPSBpbXB1dGF0aW9uc1ttZXRob2RdKHJvdywgZmllbGRWYWx1ZXMsIG9wdGlvbnMudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgbWV0aG9kOiBtdXN0IGJlIGEgZnVuY3Rpb24gb3Igb25lIG9mIFwiICsgU1RBVElTVElDU19NRVRIT0RTLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2ltcHV0ZScsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL2tkZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9rZGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG4vKlxuICoga2VybmVsIGRlbnNpdHkgZXN0aW1hdGlvblxuICovXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGdldF9zZXJpZXNfdmFsdWVzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2dldC1zZXJpZXMtdmFsdWVzICovIFwiLi9zcmMvdXRpbC9nZXQtc2VyaWVzLXZhbHVlcy50c1wiKSk7XG52YXIga2VybmVsXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2tlcm5lbCAqLyBcIi4vc3JjL3V0aWwva2VybmVsLnRzXCIpKTtcbnZhciBiYW5kd2lkdGggPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2JhbmR3aWR0aCAqLyBcIi4vc3JjL3V0aWwvYmFuZHdpZHRoLnRzXCIpKTtcbnZhciBwYXJ0aXRpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvcGFydGl0aW9uICovIFwiLi9zcmMvdXRpbC9wYXJ0aXRpb24udHNcIikpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBzaW1wbGVfc3RhdGlzdGljc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgc2ltcGxlLXN0YXRpc3RpY3MgKi8gXCIuL25vZGVfbW9kdWxlcy9fc2ltcGxlLXN0YXRpc3RpY3NANi4xLjFAc2ltcGxlLXN0YXRpc3RpY3MvZGlzdC9zaW1wbGUtc3RhdGlzdGljcy5taW4uanNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIG1pblNpemU6IDAuMDEsXG4gICAgYXM6IFsna2V5JywgJ3knLCAnc2l6ZSddLFxuICAgIC8vIGZpZWxkczogWyAneTEnLCAneTInIF0sIC8vIHJlcXVpcmVkLCBvbmUgb3IgbW9yZSBmaWVsZHNcbiAgICBleHRlbnQ6IFtdLFxuICAgIG1ldGhvZDogJ2dhdXNzaWFuJyxcbiAgICBiYW5kd2lkdGg6ICducmQnLFxuICAgIHN0ZXA6IDAsXG4gICAgZ3JvdXBCeTogW10sXG59O1xudmFyIEtFUk5FTF9NRVRIT0RTID0gdXRpbF8xLmtleXMoa2VybmVsXzEuZGVmYXVsdCk7XG52YXIgQkFORFdJRFRIX01FVEhPRFMgPSB1dGlsXzEua2V5cyhiYW5kd2lkdGgpO1xuZnVuY3Rpb24gdHJhbnNmb3JtKGR2LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGZpZWxkcyA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZHMob3B0aW9ucyk7XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShmaWVsZHMpIHx8IGZpZWxkcy5sZW5ndGggPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZmllbGRzOiBtdXN0IGJlIGFuIGFycmF5IG9mIGF0IGxlYXN0IDEgc3RyaW5ncyEnKTtcbiAgICB9XG4gICAgdmFyIGFzID0gb3B0aW9ucy5hcztcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGFzKSB8fCBhcy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhczogbXVzdCBiZSBhbiBhcnJheSBvZiAzIHN0cmluZ3MhJyk7XG4gICAgfVxuICAgIHZhciBtZXRob2QgPSBvcHRpb25zLm1ldGhvZDtcbiAgICBpZiAodXRpbF8xLmlzU3RyaW5nKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKEtFUk5FTF9NRVRIT0RTLmluZGV4T2YobWV0aG9kKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIG1ldGhvZDogXCIgKyBtZXRob2QgKyBcIi4gTXVzdCBiZSBvbmUgb2YgXCIgKyBLRVJORUxfTUVUSE9EUy5qb2luKCcsICcpKTtcbiAgICAgICAgfVxuICAgICAgICBtZXRob2QgPSBrZXJuZWxfMS5kZWZhdWx0W21ldGhvZF07XG4gICAgfVxuICAgIGlmICghdXRpbF8xLmlzRnVuY3Rpb24obWV0aG9kKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIG1ldGhvZDoga2VybmVsIG1ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24hJyk7XG4gICAgfVxuICAgIHZhciBleHRlbnQgPSBvcHRpb25zLmV4dGVudDtcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGV4dGVudCkgfHwgZXh0ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgcmFuZ2VBcnJfMSA9IFtdO1xuICAgICAgICB1dGlsXzEuZWFjaChmaWVsZHMsIGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZHYucmFuZ2UoZmllbGQpO1xuICAgICAgICAgICAgcmFuZ2VBcnJfMSA9IHJhbmdlQXJyXzEuY29uY2F0KHJhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4dGVudCA9IFtNYXRoLm1pbi5hcHBseShNYXRoLCB0c2xpYl8xLl9fc3ByZWFkKHJhbmdlQXJyXzEpKSwgTWF0aC5tYXguYXBwbHkoTWF0aCwgdHNsaWJfMS5fX3NwcmVhZChyYW5nZUFycl8xKSldO1xuICAgIH1cbiAgICB2YXIgYncgPSBvcHRpb25zLmJhbmR3aWR0aDtcbiAgICBpZiAodXRpbF8xLmlzU3RyaW5nKGJ3KSAmJiBiYW5kd2lkdGhbYnddKSB7XG4gICAgICAgIGJ3ID0gYmFuZHdpZHRoW2J3XShkdi5nZXRDb2x1bW4oZmllbGRzWzBdKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxfMS5pc0Z1bmN0aW9uKGJ3KSkge1xuICAgICAgICBidyA9IGJ3KGR2LmdldENvbHVtbihmaWVsZHNbMF0pKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXV0aWxfMS5pc051bWJlcihidykgfHwgYncgPD0gMCkge1xuICAgICAgICBidyA9IGJhbmR3aWR0aC5ucmQoZHYuZ2V0Q29sdW1uKGZpZWxkc1swXSkpO1xuICAgIH1cbiAgICB2YXIgc2VyaWVzVmFsdWVzID0gZ2V0X3Nlcmllc192YWx1ZXNfMS5kZWZhdWx0KGV4dGVudCwgb3B0aW9ucy5zdGVwID8gb3B0aW9ucy5zdGVwIDogYncpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgZ3JvdXBCeSA9IG9wdGlvbnMuZ3JvdXBCeTtcbiAgICB2YXIgZ3JvdXBzID0gcGFydGl0aW9uXzEuZGVmYXVsdChkdi5yb3dzLCBncm91cEJ5KTtcbiAgICB1dGlsXzEuZm9ySW4oZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgdmFyIHByb2JhbGl0eURlbnNpdHlGdW5jdGlvbkJ5RmllbGQgPSB7fTtcbiAgICAgICAgdXRpbF8xLmVhY2goZmllbGRzLCBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSB1dGlsXzEucGljayhncm91cFswXSwgZ3JvdXBCeSk7XG4gICAgICAgICAgICBwcm9iYWxpdHlEZW5zaXR5RnVuY3Rpb25CeUZpZWxkW2ZpZWxkXSA9IHNpbXBsZV9zdGF0aXN0aWNzXzEua2VybmVsRGVuc2l0eUVzdGltYXRpb24oZ3JvdXAubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtW2ZpZWxkXTsgfSksIG1ldGhvZCwgYncpO1xuICAgICAgICAgICAgdmFyIF9hID0gdHNsaWJfMS5fX3JlYWQoYXMsIDMpLCBrZXkgPSBfYVswXSwgeSA9IF9hWzFdLCBzaXplID0gX2FbMl07XG4gICAgICAgICAgICByb3dba2V5XSA9IGZpZWxkO1xuICAgICAgICAgICAgcm93W3ldID0gW107XG4gICAgICAgICAgICByb3dbc2l6ZV0gPSBbXTtcbiAgICAgICAgICAgIHV0aWxfMS5lYWNoKHNlcmllc1ZhbHVlcywgZnVuY3Rpb24gKHlWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBzaXplVmFsdWUgPSBwcm9iYWxpdHlEZW5zaXR5RnVuY3Rpb25CeUZpZWxkW2ZpZWxkXSh5VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplVmFsdWUgPj0gb3B0aW9ucy5taW5TaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd1t5XS5wdXNoKHlWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJvd1tzaXplXS5wdXNoKHNpemVWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChyb3cpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBkdi5yb3dzID0gcmVzdWx0O1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdrZXJuZWwtZGVuc2l0eS1lc3RpbWF0aW9uJywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgna2RlJywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnS0RFJywgdHJhbnNmb3JtKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBLRVJORUxfTUVUSE9EUzogS0VSTkVMX01FVEhPRFMsXG4gICAgQkFORFdJRFRIX01FVEhPRFM6IEJBTkRXSURUSF9NRVRIT0RTLFxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0va2VybmVsLXNtb290aC9kZW5zaXR5LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2tlcm5lbC1zbW9vdGgvZGVuc2l0eS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbi8qXG4gKiBAcmVmZXJlbmNlOiBodHRwczovL2dpdGh1Yi5jb20vUGxhbmVzaGlmdGVyL2tlcm5lbC1zbW9vdGgvYmxvYi9tYXN0ZXIvbGliL2luZGV4LmpzXG4gKi9cbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZ2V0X3Nlcmllc192YWx1ZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvZ2V0LXNlcmllcy12YWx1ZXMgKi8gXCIuL3NyYy91dGlsL2dldC1zZXJpZXMtdmFsdWVzLnRzXCIpKTtcbnZhciBrZXJuZWxfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwva2VybmVsICovIFwiLi9zcmMvdXRpbC9rZXJuZWwudHNcIikpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBiYW5kd2lkdGhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvYmFuZHdpZHRoICovIFwiLi9zcmMvdXRpbC9iYW5kd2lkdGgudHNcIik7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIGFzOiBbJ3gnLCAneScsICd6J10sXG4gICAgLy8gZmllbGRzOiBbICd4JywgJ3knIF0sIC8vIHJlcXVpcmVkLCBvbmUgb3IgdHdvIGZpZWxkc1xuICAgIG1ldGhvZDogJ2dhdXNzaWFuJyxcbn07XG52YXIgS0VSTkVMX01FVEhPRFMgPSB1dGlsXzEua2V5cyhrZXJuZWxfMS5kZWZhdWx0KTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkdiwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGZpZWxkcyA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZHMob3B0aW9ucyk7XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShmaWVsZHMpIHx8IGZpZWxkcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBmaWVsZHM6IG11c3QgYmUgYW4gYXJyYXkgb2YgMiBzdHJpbmdzIScpO1xuICAgIH1cbiAgICB2YXIgX2MgPSB0c2xpYl8xLl9fcmVhZChvcHRpb25zLmFzLCAzKSwgYXNYID0gX2NbMF0sIGFzWSA9IF9jWzFdLCBhc1ogPSBfY1syXTtcbiAgICBpZiAoIXV0aWxfMS5pc1N0cmluZyhhc1gpIHx8ICF1dGlsXzEuaXNTdHJpbmcoYXNZKSB8fCAhdXRpbF8xLmlzU3RyaW5nKGFzWikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBhczogbXVzdCBiZSBhbiBhcnJheSBvZiAzIHN0cmluZ3MhJyk7XG4gICAgfVxuICAgIHZhciBtZXRob2Q7XG4gICAgaWYgKHV0aWxfMS5pc1N0cmluZyhvcHRpb25zLm1ldGhvZCkpIHtcbiAgICAgICAgaWYgKEtFUk5FTF9NRVRIT0RTLmluZGV4T2Yob3B0aW9ucy5tZXRob2QpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgbWV0aG9kOiBcIiArIG9wdGlvbnMubWV0aG9kICsgXCIuIE11c3QgYmUgb25lIG9mIFwiICsgS0VSTkVMX01FVEhPRFMuam9pbignLCAnKSk7XG4gICAgICAgIH1cbiAgICAgICAgbWV0aG9kID0ga2VybmVsXzEuZGVmYXVsdFtvcHRpb25zLm1ldGhvZF07XG4gICAgfVxuICAgIHZhciBfZCA9IHRzbGliXzEuX19yZWFkKGZpZWxkcywgMiksIHhGaWVsZCA9IF9kWzBdLCB5RmllbGQgPSBfZFsxXTtcbiAgICB2YXIgZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQsIGJhbmR3aWR0aCA9IG9wdGlvbnMuYmFuZHdpZHRoO1xuICAgIHZhciBleHRlbnRYO1xuICAgIHZhciBleHRlbnRZO1xuICAgIGlmIChleHRlbnQgJiYgQXJyYXkuaXNBcnJheShleHRlbnQpICYmIEFycmF5LmlzQXJyYXkoZXh0ZW50WzBdKSAmJiBBcnJheS5pc0FycmF5KGV4dGVudFsxXSkpIHtcbiAgICAgICAgX2EgPSB0c2xpYl8xLl9fcmVhZChleHRlbnQsIDIpLCBleHRlbnRYID0gX2FbMF0sIGV4dGVudFkgPSBfYVsxXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4dGVudFggPSBkdi5yYW5nZSh4RmllbGQpO1xuICAgICAgICBleHRlbnRZID0gZHYucmFuZ2UoeUZpZWxkKTtcbiAgICB9XG4gICAgdmFyIGJ3WCwgYndZO1xuICAgIGlmIChiYW5kd2lkdGggJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheShiYW5kd2lkdGgpICYmXG4gICAgICAgIGJhbmR3aWR0aC5zbGljZSgwLCAyKS5ldmVyeSh1dGlsXzEuaXNOdW1iZXIpICYmXG4gICAgICAgIGJhbmR3aWR0aC5zbGljZSgwLCAyKS5ldmVyeShmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbSA+IDA7IH0pKSB7XG4gICAgICAgIF9iID0gdHNsaWJfMS5fX3JlYWQoYmFuZHdpZHRoLCAyKSwgYndYID0gX2JbMF0sIGJ3WSA9IF9iWzFdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYndYID0gYmFuZHdpZHRoXzEuc2lsdmVybWFuKGR2LmdldENvbHVtbih4RmllbGQpKTtcbiAgICAgICAgYndZID0gYmFuZHdpZHRoXzEuc2lsdmVybWFuKGR2LmdldENvbHVtbih5RmllbGQpKTtcbiAgICB9XG4gICAgdmFyIHNlcmllc1ZhbHVlc1ggPSBnZXRfc2VyaWVzX3ZhbHVlc18xLmRlZmF1bHQoZXh0ZW50WCwgYndYKTtcbiAgICB2YXIgc2VyaWVzVmFsdWVzWSA9IGdldF9zZXJpZXNfdmFsdWVzXzEuZGVmYXVsdChleHRlbnRZLCBid1kpO1xuICAgIHZhciBjb3VudCA9IGR2LnJvd3MubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmllc1ZhbHVlc1gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXJpZXNWYWx1ZXNZLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIHZhciB4ID0gc2VyaWVzVmFsdWVzWFtpXTtcbiAgICAgICAgICAgIHZhciB5ID0gc2VyaWVzVmFsdWVzWVtqXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgY291bnQ7IGsrKykge1xuICAgICAgICAgICAgICAgIHN1bSArPSBtZXRob2QoKHggLSBkdi5yb3dzW2tdW3hGaWVsZF0pIC8gYndYKSAqIG1ldGhvZCgoeSAtIGR2LnJvd3Nba11beUZpZWxkXSkgLyBid1kpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHogPSAoMSAvIChjb3VudCAqIGJ3WCAqIGJ3WSkpICogc3VtO1xuICAgICAgICAgICAgdmFyIHJvdyA9IHt9O1xuICAgICAgICAgICAgcm93W2FzWF0gPSB4O1xuICAgICAgICAgICAgcm93W2FzWV0gPSB5O1xuICAgICAgICAgICAgcm93W2FzWl0gPSB6O1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkdi5yb3dzID0gcmVzdWx0O1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdrZXJuZWwtc21vb3RoLmRlbnNpdHknLCB0cmFuc2Zvcm0pO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdrZXJuZWwuZGVuc2l0eScsIHRyYW5zZm9ybSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgS0VSTkVMX01FVEhPRFM6IEtFUk5FTF9NRVRIT0RTLFxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0va2VybmVsLXNtb290aC9yZWdyZXNzaW9uLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL2tlcm5lbC1zbW9vdGgvcmVncmVzc2lvbi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbi8qXG4gKiBAcmVmZXJlbmNlOiBodHRwczovL2dpdGh1Yi5jb20vUGxhbmVzaGlmdGVyL2tlcm5lbC1zbW9vdGgvYmxvYi9tYXN0ZXIvbGliL2luZGV4LmpzXG4gKi9cbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZ2V0X3Nlcmllc192YWx1ZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwvZ2V0LXNlcmllcy12YWx1ZXMgKi8gXCIuL3NyYy91dGlsL2dldC1zZXJpZXMtdmFsdWVzLnRzXCIpKTtcbnZhciBrZXJuZWxfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uLy4uL3V0aWwva2VybmVsICovIFwiLi9zcmMvdXRpbC9rZXJuZWwudHNcIikpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIHNpbXBsZV9zdGF0aXN0aWNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzaW1wbGUtc3RhdGlzdGljcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19zaW1wbGUtc3RhdGlzdGljc0A2LjEuMUBzaW1wbGUtc3RhdGlzdGljcy9kaXN0L3NpbXBsZS1zdGF0aXN0aWNzLm1pbi5qc1wiKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgYmFuZHdpZHRoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi8uLi91dGlsL2JhbmR3aWR0aCAqLyBcIi4vc3JjL3V0aWwvYmFuZHdpZHRoLnRzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBhczogWyd4JywgJ3knXSxcbiAgICAvLyBmaWVsZHM6IFsgJ3gnLCAneScgXSwgLy8gcmVxdWlyZWQsIG9uZSBvciB0d28gZmllbGRzXG4gICAgbWV0aG9kOiAnZ2F1c3NpYW4nLFxufTtcbnZhciBLRVJORUxfTUVUSE9EUyA9IHV0aWxfMS5rZXlzKGtlcm5lbF8xLmRlZmF1bHQpO1xuLy8gY2FsY3VsYXRlcyB3ZWlnaHQgZm9yIGktdGggb2JzXG5mdW5jdGlvbiB3ZWlnaHQoa2VybmVsLCBiYW5kd2lkdGgsIHhfMCwgeF9pKSB7XG4gICAgdmFyIGFyZyA9ICh4X2kgLSB4XzApIC8gYmFuZHdpZHRoO1xuICAgIHJldHVybiBrZXJuZWwoYXJnKTtcbn1cbi8vIGNhbGN1bGF0ZXMgd2VpZ2h0IGZvciBpLXRoIG9icyB3aGVuIHAgPiAxXG4vLyBmdW5jdGlvbiB3ZWlnaHRfdmVjdG9ycyhrZXJuZWwsIGJhbmR3aWR0aCwgeF8wLCB4X2kpIHtcbi8vICAgY29uc3QgYXJnID0gZW5jbGlkZWFuRGlzdGFuY2UoeF9pLCB4XzApIC8gYmFuZHdpZHRoO1xuLy8gICByZXR1cm4ga2VybmVsKGFyZyk7XG4vLyB9XG5mdW5jdGlvbiB2ZWN0b3JpemUoZnVuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICghdXRpbF8xLmlzQXJyYXkoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW4oeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHgubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuKHgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtKGR2LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGZpZWxkcyA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZHMob3B0aW9ucyk7XG4gICAgaWYgKCF1dGlsXzEuaXNBcnJheShmaWVsZHMpIHx8ICEoZmllbGRzLmxlbmd0aCA9PT0gMSB8fCBmaWVsZHMubGVuZ3RoID09PSAyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGZpZWxkczogbXVzdCBiZSBhbiBhcnJheSBvZiAxIG9yIDIgc3RyaW5ncyEnKTtcbiAgICB9XG4gICAgdmFyIF9hID0gdHNsaWJfMS5fX3JlYWQob3B0aW9ucy5hcywgMiksIGFzWCA9IF9hWzBdLCBhc1kgPSBfYVsxXTtcbiAgICBpZiAoIXV0aWxfMS5pc1N0cmluZyhhc1gpIHx8ICF1dGlsXzEuaXNTdHJpbmcoYXNZKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGFzOiBtdXN0IGJlIGFuIGFycmF5IG9mIDIgc3RyaW5ncyEnKTtcbiAgICB9XG4gICAgdmFyIGZ1bmM7XG4gICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kO1xuICAgIGlmICh1dGlsXzEuaXNTdHJpbmcobWV0aG9kKSkge1xuICAgICAgICBpZiAoS0VSTkVMX01FVEhPRFMuaW5kZXhPZihtZXRob2QpID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgbWV0aG9kOiBcIiArIG1ldGhvZCArIFwiLiBNdXN0IGJlIG9uZSBvZiBcIiArIEtFUk5FTF9NRVRIT0RTLmpvaW4oJywgJykpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmMgPSBrZXJuZWxfMS5kZWZhdWx0W21ldGhvZF07XG4gICAgfVxuICAgIHZhciBfYiA9IHRzbGliXzEuX19yZWFkKGZpZWxkcywgMiksIHhGaWVsZCA9IF9iWzBdLCB5RmllbGQgPSBfYlsxXTtcbiAgICB2YXIgeHMgPSBkdi5nZXRDb2x1bW4oeEZpZWxkKTtcbiAgICB2YXIgZXh0ZW50ID0gb3B0aW9ucy5leHRlbnQ7XG4gICAgaWYgKGV4dGVudCB8fCAhdXRpbF8xLmlzQXJyYXkoZXh0ZW50KSkge1xuICAgICAgICBleHRlbnQgPSBkdi5yYW5nZSh4RmllbGQpO1xuICAgIH1cbiAgICB2YXIgYmFuZHdpZHRoID0gb3B0aW9ucy5iYW5kd2lkdGg7XG4gICAgaWYgKCFiYW5kd2lkdGggfHwgIXV0aWxfMS5pc051bWJlcihiYW5kd2lkdGgpIHx8IGJhbmR3aWR0aCA8PSAwKSB7XG4gICAgICAgIGJhbmR3aWR0aCA9IGJhbmR3aWR0aF8xLnNpbHZlcm1hbih4cyk7XG4gICAgfVxuICAgIHZhciBzZXJpZXNWYWx1ZXMgPSBnZXRfc2VyaWVzX3ZhbHVlc18xLmRlZmF1bHQoZXh0ZW50LCBiYW5kd2lkdGgpO1xuICAgIHZhciB4Q291bnQgPSB4cy5sZW5ndGg7XG4gICAgdmFyIHdlaWdodEZ1bmMgPSB3ZWlnaHQuYmluZChudWxsLCBmdW5jLCBiYW5kd2lkdGgpO1xuICAgIHZhciBrZXJuZWxTbW9vdGhlcjtcbiAgICBpZiAodXRpbF8xLmlzTmlsKHlGaWVsZCkpIHtcbiAgICAgICAgLy8gS0RFXG4gICAgICAgIGtlcm5lbFNtb290aGVyID0gdmVjdG9yaXplKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICB2YXIgd2VpZ2h0cyA9IHhzLm1hcChmdW5jdGlvbiAoeF9pKSB7IHJldHVybiB3ZWlnaHRGdW5jKHgsIHhfaSk7IH0pO1xuICAgICAgICAgICAgdmFyIG51bSA9IHNpbXBsZV9zdGF0aXN0aWNzXzEuc3VtKHdlaWdodHMpO1xuICAgICAgICAgICAgdmFyIGRlbm9tID0geENvdW50ICogYmFuZHdpZHRoO1xuICAgICAgICAgICAgaWYgKCFudW0gfHwgIWRlbm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgcmV0dXJuIG51bSAvIGRlbm9tO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGtlcm5lbCByZWdyZXNzaW9uIHNtb290aGluZ1xuICAgICAgICB2YXIgeXNfMSA9IGR2LmdldENvbHVtbih5RmllbGQpO1xuICAgICAgICBrZXJuZWxTbW9vdGhlciA9IHZlY3Rvcml6ZShmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgdmFyIHdlaWdodHMgPSB4cy5tYXAoZnVuY3Rpb24gKHhfaSkgeyByZXR1cm4gd2VpZ2h0RnVuYyh4LCB4X2kpOyB9KTtcbiAgICAgICAgICAgIHZhciBudW0gPSBzaW1wbGVfc3RhdGlzdGljc18xLnN1bSh3ZWlnaHRzLm1hcChmdW5jdGlvbiAodywgaSkgeyByZXR1cm4gdyAqIHlzXzFbaV07IH0pKTtcbiAgICAgICAgICAgIHZhciBkZW5vbSA9IHNpbXBsZV9zdGF0aXN0aWNzXzEuc3VtKHdlaWdodHMpO1xuICAgICAgICAgICAgaWYgKCFudW0gfHwgIWRlbm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgcmV0dXJuIG51bSAvIGRlbm9tO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHNlcmllc1ZhbHVlcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJvdyA9IHt9O1xuICAgICAgICByb3dbYXNYXSA9IHg7XG4gICAgICAgIHJvd1thc1ldID0ga2VybmVsU21vb3RoZXIoeCk7XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgfSk7XG4gICAgZHYucm93cyA9IHJlc3VsdDtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgna2VybmVsLXNtb290aC5yZWdyZXNzaW9uJywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgna2VybmVsLnJlZ3Jlc3Npb24nLCB0cmFuc2Zvcm0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIEtFUk5FTF9NRVRIT0RTOiBLRVJORUxfTUVUSE9EUyxcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL21hcC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS9tYXAudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xuZnVuY3Rpb24gZGVmYXVsdENhbGxiYWNrKHJvdykge1xuICAgIHJldHVybiByb3c7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ21hcCcsIGZ1bmN0aW9uIChkYXRhVmlldywgb3B0aW9ucykge1xuICAgIGRhdGFWaWV3LnJvd3MgPSBkYXRhVmlldy5yb3dzLm1hcChvcHRpb25zLmNhbGxiYWNrIHx8IGRlZmF1bHRDYWxsYmFjayk7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vcGFydGl0aW9uLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL3BhcnRpdGlvbi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgcGFydGl0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL3BhcnRpdGlvbiAqLyBcIi4vc3JjL3V0aWwvcGFydGl0aW9uLnRzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgZ3JvdXBCeTogW10sXG4gICAgb3JkZXJCeTogW10sXG59O1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdwYXJ0aXRpb24nLCBmdW5jdGlvbiAoZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICAvLyBUT0RPOiByb3dzIOaYr+WQpumDveWPquiDveaYr+aVsOe7hFxuICAgIC8vIEB0cy1pZ25vcmU7XG4gICAgZGF0YVZpZXcucm93cyA9IHBhcnRpdGlvbl8xLmRlZmF1bHQoZGF0YVZpZXcucm93cywgb3B0aW9ucy5ncm91cEJ5LCBvcHRpb25zLm9yZGVyQnkpO1xufSk7XG5mdW5jdGlvbiBncm91cChkYXRhVmlldywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIGRhdGFWaWV3LnJvd3MgPSB1dGlsXzEudmFsdWVzKHBhcnRpdGlvbl8xLmRlZmF1bHQoZGF0YVZpZXcucm93cywgb3B0aW9ucy5ncm91cEJ5LCBvcHRpb25zLm9yZGVyQnkpKTtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnZ3JvdXAnLCBncm91cCk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ2dyb3VwcycsIGdyb3VwKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vcGVyY2VudC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vcGVyY2VudC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIHNpbXBsZV9zdGF0aXN0aWNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzaW1wbGUtc3RhdGlzdGljcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19zaW1wbGUtc3RhdGlzdGljc0A2LjEuMUBzaW1wbGUtc3RhdGlzdGljcy9kaXN0L3NpbXBsZS1zdGF0aXN0aWNzLm1pbi5qc1wiKTtcbnZhciBwYXJ0aXRpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvcGFydGl0aW9uICovIFwiLi9zcmMvdXRpbC9wYXJ0aXRpb24udHNcIikpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgLy8gZmllbGQ6ICd5JywgLy8gcmVxdWlyZWRcbiAgICAvLyBkaW1lbnNpb246ICd4JywgLy8gcmVxdWlyZWRcbiAgICBncm91cEJ5OiBbXSxcbiAgICBhczogJ19wZXJjZW50Jyxcbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgZmllbGQgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGQob3B0aW9ucyk7XG4gICAgdmFyIGRpbWVuc2lvbiA9IG9wdGlvbnMuZGltZW5zaW9uLCBncm91cEJ5ID0gb3B0aW9ucy5ncm91cEJ5O1xuICAgIHZhciBhcyA9IG9wdGlvbnMuYXM7XG4gICAgaWYgKCF1dGlsXzEuaXNTdHJpbmcoZGltZW5zaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGRpbWVuc2lvbjogbXVzdCBiZSBhIHN0cmluZyEnKTtcbiAgICB9XG4gICAgaWYgKHV0aWxfMS5pc0FycmF5KGFzKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgYXM6IG11c3QgYmUgYSBzdHJpbmcsIHdpbGwgdXNlIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBhcnJheSBzcGVjaWZpZWQuJyk7XG4gICAgICAgIGFzID0gYXNbMF07XG4gICAgfVxuICAgIGlmICghdXRpbF8xLmlzU3RyaW5nKGFzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFzOiBtdXN0IGJlIGEgc3RyaW5nIScpO1xuICAgIH1cbiAgICB2YXIgcm93cyA9IGRhdGFWaWV3LnJvd3M7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBncm91cHMgPSBwYXJ0aXRpb25fMS5kZWZhdWx0KHJvd3MsIGdyb3VwQnkpO1xuICAgIHV0aWxfMS5mb3JJbihncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICB2YXIgdG90YWxTdW0gPSBzaW1wbGVfc3RhdGlzdGljc18xLnN1bShncm91cC5tYXAoZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gcm93W2ZpZWxkXTsgfSkpO1xuICAgICAgICBpZiAodG90YWxTdW0gPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgZGF0YTogdG90YWwgc3VtIG9mIGZpZWxkIFwiICsgZmllbGQgKyBcIiBpcyAwIVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5uZXJHcm91cHMgPSBwYXJ0aXRpb25fMS5kZWZhdWx0KGdyb3VwLCBbZGltZW5zaW9uXSk7XG4gICAgICAgIHV0aWxfMS5mb3JJbihpbm5lckdyb3VwcywgZnVuY3Rpb24gKGlubmVyR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBpbm5lclN1bSA9IHNpbXBsZV9zdGF0aXN0aWNzXzEuc3VtKGlubmVyR3JvdXAubWFwKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHJvd1tmaWVsZF07IH0pKTtcbiAgICAgICAgICAgIC8vIGNvbnN0IHJlc3VsdFJvdyA9IHBpY2soaW5uZXJHcm91cFswXSwgdW5pb24oZ3JvdXBCeSwgWyBkaW1lbnNpb24gXSkpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdFJvdyA9IGlubmVyR3JvdXBbMF07XG4gICAgICAgICAgICAvLyBGSVhNRSBpbiBjYXNlIGRpbWVuc2lvbiBhbmQgZmllbGQgaXMgdGhlIHNhbWVcbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25WYWx1ZSA9IHJlc3VsdFJvd1tkaW1lbnNpb25dO1xuICAgICAgICAgICAgcmVzdWx0Um93W2ZpZWxkXSA9IGlubmVyU3VtO1xuICAgICAgICAgICAgcmVzdWx0Um93W2RpbWVuc2lvbl0gPSBkaW1lbnNpb25WYWx1ZTtcbiAgICAgICAgICAgIGlmICh0b3RhbFN1bSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFJvd1thc10gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Um93W2FzXSA9IGlubmVyU3VtIC8gdG90YWxTdW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChyZXN1bHRSb3cpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBkYXRhVmlldy5yb3dzID0gcmVzdWx0O1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdwZXJjZW50JywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vcGljay50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vcGljay50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ3BpY2snLCBmdW5jdGlvbiAoZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29sdW1ucyA9IG9wdGlvbl9wYXJzZXJfMS5nZXRGaWVsZHMob3B0aW9ucywgZGF0YVZpZXcuZ2V0Q29sdW1uTmFtZXMoKSk7XG4gICAgZGF0YVZpZXcucm93cyA9IGRhdGFWaWV3LnJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHV0aWxfMS5waWNrKHJvdywgY29sdW1ucyk7IH0pO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL3Byb3BvcnRpb24udHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL3Byb3BvcnRpb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBwYXJ0aXRpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvcGFydGl0aW9uICovIFwiLi9zcmMvdXRpbC9wYXJ0aXRpb24udHNcIikpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgLy8gZmllbGQ6ICd5JywgLy8gcmVxdWlyZWRcbiAgICAvLyBkaW1lbnNpb246ICd4JywgLy8gcmVxdWlyZWRcbiAgICBncm91cEJ5OiBbXSxcbiAgICBhczogJ19wcm9wb3J0aW9uJyxcbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgZmllbGQgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGQob3B0aW9ucyk7XG4gICAgdmFyIGRpbWVuc2lvbiA9IG9wdGlvbnMuZGltZW5zaW9uO1xuICAgIHZhciBncm91cEJ5ID0gb3B0aW9ucy5ncm91cEJ5O1xuICAgIHZhciBhcyA9IG9wdGlvbnMuYXM7XG4gICAgaWYgKCF1dGlsXzEuaXNTdHJpbmcoZGltZW5zaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGRpbWVuc2lvbjogbXVzdCBiZSBhIHN0cmluZyEnKTtcbiAgICB9XG4gICAgaWYgKHV0aWxfMS5pc0FycmF5KGFzKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgYXM6IG11c3QgYmUgYSBzdHJpbmcsIHdpbGwgdXNlIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBhcnJheSBzcGVjaWZpZWQuJyk7XG4gICAgICAgIGFzID0gYXNbMF07XG4gICAgfVxuICAgIGlmICghdXRpbF8xLmlzU3RyaW5nKGFzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFzOiBtdXN0IGJlIGEgc3RyaW5nIScpO1xuICAgIH1cbiAgICB2YXIgcm93cyA9IGRhdGFWaWV3LnJvd3M7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBncm91cHMgPSBwYXJ0aXRpb25fMS5kZWZhdWx0KHJvd3MsIGdyb3VwQnkpO1xuICAgIHV0aWxfMS5mb3JJbihncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICB2YXIgdG90YWxDb3VudCA9IGdyb3VwLmxlbmd0aDtcbiAgICAgICAgdmFyIGlubmVyR3JvdXBzID0gcGFydGl0aW9uXzEuZGVmYXVsdChncm91cCwgW2RpbWVuc2lvbl0pO1xuICAgICAgICB1dGlsXzEuZm9ySW4oaW5uZXJHcm91cHMsIGZ1bmN0aW9uIChpbm5lckdyb3VwKSB7XG4gICAgICAgICAgICB2YXIgaW5uZXJDb3VudCA9IGlubmVyR3JvdXAubGVuZ3RoO1xuICAgICAgICAgICAgLy8gY29uc3QgcmVzdWx0Um93ID0gcGljayhpbm5lckdyb3VwWzBdLCB1bmlvbihncm91cEJ5LCBbIGRpbWVuc2lvbiBdKSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0Um93ID0gaW5uZXJHcm91cFswXTtcbiAgICAgICAgICAgIC8vIEZJWE1FIGluIGNhc2UgZGltZW5zaW9uIGFuZCBmaWVsZCBpcyB0aGUgc2FtZVxuICAgICAgICAgICAgdmFyIGRpbWVuc2lvblZhbHVlID0gcmVzdWx0Um93W2RpbWVuc2lvbl07XG4gICAgICAgICAgICByZXN1bHRSb3dbZmllbGRdID0gaW5uZXJDb3VudDtcbiAgICAgICAgICAgIHJlc3VsdFJvd1tkaW1lbnNpb25dID0gZGltZW5zaW9uVmFsdWU7XG4gICAgICAgICAgICByZXN1bHRSb3dbYXNdID0gaW5uZXJDb3VudCAvIHRvdGFsQ291bnQ7XG4gICAgICAgICAgICByZXN1bHQucHVzaChyZXN1bHRSb3cpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBkYXRhVmlldy5yb3dzID0gcmVzdWx0O1xufVxuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdwcm9wb3J0aW9uJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vcmVncmVzc2lvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vcmVncmVzc2lvbi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgcmVncmVzc2lvbl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVncmVzc2lvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19yZWdyZXNzaW9uQDIuMC4xQHJlZ3Jlc3Npb24vZGlzdC9yZWdyZXNzaW9uLmpzXCIpKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZ2V0X3Nlcmllc192YWx1ZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvZ2V0LXNlcmllcy12YWx1ZXMgKi8gXCIuL3NyYy91dGlsL2dldC1zZXJpZXMtdmFsdWVzLnRzXCIpKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciBvcHRpb25fcGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL29wdGlvbi1wYXJzZXIgKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIik7XG52YXIgYmFuZHdpZHRoXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlsL2JhbmR3aWR0aCAqLyBcIi4vc3JjL3V0aWwvYmFuZHdpZHRoLnRzXCIpO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBhczogWyd4JywgJ3knXSxcbiAgICAvLyBmaWVsZHM6IFsgJ3gnLCAneScgXSwgLy8gcmVxdWlyZWQgdHdvIGZpZWxkc1xuICAgIG1ldGhvZDogJ2xpbmVhcicsXG4gICAgLy8gZXh0ZW50OiBbXSwgLy8gZXh0ZW50IHRvIGV4ZWN1dGUgcmVncmVzc2lvbiBmdW5jdGlvbiwgZGVmYXVsdDogWyBtaW4oeCksIG1heCh4KSBdXG4gICAgLy8gYmFuZHdpZHRoOiAxLCAvLyBiYW5kV2lkdGggdG8gZXhlY3V0ZSByZWdyZXNzaW9uIGZ1bmN0aW9uXG4gICAgb3JkZXI6IDIsXG4gICAgcHJlY2lzaW9uOiAyLFxufTtcbnZhciBSRUdSRVNTSU9OX01FVEhPRFMgPSBbJ2xpbmVhcicsICdleHBvbmVudGlhbCcsICdsb2dhcml0aG1pYycsICdwb3dlcicsICdwb2x5bm9taWFsJ107XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbF8xLmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcbiAgICB2YXIgZmllbGRzID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkcyhvcHRpb25zKTtcbiAgICBpZiAoIXV0aWxfMS5pc0FycmF5KGZpZWxkcykgfHwgZmllbGRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGZpZWxkczogbXVzdCBiZSBhbiBhcnJheSBvZiAyIHN0cmluZ3MuJyk7XG4gICAgfVxuICAgIHZhciBfYSA9IHRzbGliXzEuX19yZWFkKGZpZWxkcywgMiksIHhGaWVsZCA9IF9hWzBdLCB5RmllbGQgPSBfYVsxXTtcbiAgICB2YXIgbWV0aG9kID0gb3B0aW9ucy5tZXRob2Q7XG4gICAgaWYgKFJFR1JFU1NJT05fTUVUSE9EUy5pbmRleE9mKG1ldGhvZCkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIG1ldGhvZDogXCIgKyBtZXRob2QgKyBcIi4gTXVzdCBiZSBvbmUgb2YgXCIgKyBSRUdSRVNTSU9OX01FVEhPRFMuam9pbignLCAnKSk7XG4gICAgfVxuICAgIHZhciBwb2ludHMgPSBkYXRhVmlldy5yb3dzLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiBbcm93W3hGaWVsZF0sIHJvd1t5RmllbGRdXTsgfSk7XG4gICAgdmFyIHJlZ3Jlc3Npb25SZXN1bHQgPSByZWdyZXNzaW9uXzEuZGVmYXVsdFttZXRob2RdKHBvaW50cywgb3B0aW9ucyk7XG4gICAgdmFyIGV4dGVudCA9IG9wdGlvbnMuZXh0ZW50O1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoZXh0ZW50KSB8fCBleHRlbnQubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGV4dGVudCA9IGRhdGFWaWV3LnJhbmdlKHhGaWVsZCk7XG4gICAgfVxuICAgIHZhciBiYW5kd2lkdGggPSBvcHRpb25zLmJhbmR3aWR0aDtcbiAgICBpZiAoIXV0aWxfMS5pc051bWJlcihiYW5kd2lkdGgpIHx8IGJhbmR3aWR0aCA8PSAwKSB7XG4gICAgICAgIGJhbmR3aWR0aCA9IGJhbmR3aWR0aF8xLnNpbHZlcm1hbihkYXRhVmlldy5nZXRDb2x1bW4oeEZpZWxkKSk7XG4gICAgfVxuICAgIHZhciB2YWx1ZXNUb1ByZWRpY3QgPSBnZXRfc2VyaWVzX3ZhbHVlc18xLmRlZmF1bHQoZXh0ZW50LCBiYW5kd2lkdGgpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgX2IgPSB0c2xpYl8xLl9fcmVhZChvcHRpb25zLmFzLCAyKSwgYXNYID0gX2JbMF0sIGFzWSA9IF9iWzFdO1xuICAgIHZhbHVlc1RvUHJlZGljdC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcm93ID0ge307XG4gICAgICAgIHZhciBfYSA9IHRzbGliXzEuX19yZWFkKHJlZ3Jlc3Npb25SZXN1bHQucHJlZGljdCh2YWx1ZSksIDIpLCB4ID0gX2FbMF0sIHkgPSBfYVsxXTtcbiAgICAgICAgcm93W2FzWF0gPSB4O1xuICAgICAgICByb3dbYXNZXSA9IHk7XG4gICAgICAgIGlmIChpc0Zpbml0ZSh5KSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGRhdGFWaWV3LnJvd3MgPSByZXN1bHQ7XG59XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ3JlZ3Jlc3Npb24nLCB0cmFuc2Zvcm0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIFJFR1JFU1NJT05fTUVUSE9EUzogUkVHUkVTU0lPTl9NRVRIT0RTLFxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vcmVuYW1lLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL3JlbmFtZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgdmFyIG1hcCA9IG9wdGlvbnMubWFwIHx8IHt9O1xuICAgIHZhciBjbGVhbk1hcCA9IHt9O1xuICAgIGlmICh1dGlsXzEuaXNQbGFpbk9iamVjdChtYXApKSB7XG4gICAgICAgIHV0aWxfMS5mb3JJbihtYXAsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBpZiAodXRpbF8xLmlzU3RyaW5nKHZhbHVlKSAmJiB1dGlsXzEuaXNTdHJpbmcoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNsZWFuTWFwW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGFWaWV3LnJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHV0aWxfMS5mb3JJbihjbGVhbk1hcCwgZnVuY3Rpb24gKG5ld0tleSwga2V5KSB7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IHJvd1trZXldO1xuICAgICAgICAgICAgZGVsZXRlIHJvd1trZXldO1xuICAgICAgICAgICAgcm93W25ld0tleV0gPSB0ZW1wO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgncmVuYW1lJywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgncmVuYW1lLWZpZWxkcycsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL3JldmVyc2UudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL3JldmVyc2UudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgncmV2ZXJzZScsIGZ1bmN0aW9uIChkYXRhVmlldykge1xuICAgIGRhdGFWaWV3LnJvd3MucmV2ZXJzZSgpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL3NvcnQtYnkudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL3NvcnQtYnkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgb3B0aW9uX3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCIpO1xuLypcbiAqIG9wdGlvbnM6IHtcbiAqICAgdHlwZTogJ3NvcnQtYnknLFxuICogICBmaWVsZHM6IFtdLFxuICogICBvcmRlcjogJ0FTQycgLy8gJ0RFU0MnXG4gKiB9XG4gKi9cbnZhciBWQUxJRF9PUkRFUlMgPSBbJ0FTQycsICdERVNDJ107XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICB2YXIgZmllbGRzID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkcyhvcHRpb25zLCBbZGF0YVZpZXcuZ2V0Q29sdW1uTmFtZSgwKV0pO1xuICAgIGlmICghdXRpbF8xLmlzQXJyYXkoZmllbGRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGZpZWxkczogbXVzdCBiZSBhbiBhcnJheSB3aXRoIHN0cmluZ3MhJyk7XG4gICAgfVxuICAgIGRhdGFWaWV3LnJvd3MgPSB1dGlsXzEuc29ydEJ5KGRhdGFWaWV3LnJvd3MsIGZpZWxkcyk7XG4gICAgdmFyIG9yZGVyID0gb3B0aW9ucy5vcmRlcjtcbiAgICBpZiAob3JkZXIgJiYgVkFMSURfT1JERVJTLmluZGV4T2Yob3JkZXIpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBvcmRlcjogXCIgKyBvcmRlciArIFwiIG11c3QgYmUgb25lIG9mIFwiICsgVkFMSURfT1JERVJTLmpvaW4oJywgJykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcmRlciA9PT0gJ0RFU0MnKSB7XG4gICAgICAgIGRhdGFWaWV3LnJvd3MucmV2ZXJzZSgpO1xuICAgIH1cbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnc29ydC1ieScsIHRyYW5zZm9ybSk7XG5kYXRhX3NldF8xLkRhdGFTZXQucmVnaXN0ZXJUcmFuc2Zvcm0oJ3NvcnRCeScsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL3NvcnQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL3NvcnQudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnc29ydCcsIGZ1bmN0aW9uIChkYXRhVmlldywgb3B0aW9ucykge1xuICAgIHZhciBjb2x1bW5OYW1lID0gZGF0YVZpZXcuZ2V0Q29sdW1uTmFtZSgwKTtcbiAgICBkYXRhVmlldy5yb3dzLnNvcnQob3B0aW9ucy5jYWxsYmFjayB8fCAoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbY29sdW1uTmFtZV0gLSBiW2NvbHVtbk5hbWVdOyB9KSk7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90cmFuc2Zvcm0vc3Vic2V0LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdHJhbnNmb3JtL3N1YnNldC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGF0YV9zZXRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RhdGEtc2V0ICovIFwiLi9zcmMvZGF0YS1zZXQudHNcIik7XG52YXIgb3B0aW9uX3BhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbC9vcHRpb24tcGFyc2VyICovIFwiLi9zcmMvdXRpbC9vcHRpb24tcGFyc2VyLnRzXCIpO1xuZGF0YV9zZXRfMS5EYXRhU2V0LnJlZ2lzdGVyVHJhbnNmb3JtKCdzdWJzZXQnLCBmdW5jdGlvbiAoZGF0YVZpZXcsIG9wdGlvbnMpIHtcbiAgICB2YXIgc3RhcnRJbmRleCA9IG9wdGlvbnMuc3RhcnRSb3dJbmRleCB8fCAwO1xuICAgIHZhciBlbmRJbmRleCA9IG9wdGlvbnMuZW5kUm93SW5kZXggfHwgZGF0YVZpZXcucm93cy5sZW5ndGggLSAxO1xuICAgIHZhciBjb2x1bW5zID0gb3B0aW9uX3BhcnNlcl8xLmdldEZpZWxkcyhvcHRpb25zLCBkYXRhVmlldy5nZXRDb2x1bW5OYW1lcygpKTtcbiAgICBkYXRhVmlldy5yb3dzID0gZGF0YVZpZXcuZ2V0U3Vic2V0KHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBjb2x1bW5zKTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3RyYW5zZm9ybS90YWctY2xvdWQudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy90cmFuc2Zvcm0vdGFnLWNsb3VkLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbnZhciBkYXRhX3NldF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGF0YS1zZXQgKi8gXCIuL3NyYy9kYXRhLXNldC50c1wiKTtcbnZhciB0YWdfY2xvdWRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvdGFnLWNsb3VkICovIFwiLi9zcmMvdXRpbC90YWctY2xvdWQudHNcIikpO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgZmllbGRzOiBbJ3RleHQnLCAndmFsdWUnXSxcbiAgICBmb250OiBmdW5jdGlvbiAoKSB7IHJldHVybiAnc2VyaWYnOyB9LFxuICAgIHBhZGRpbmc6IDEsXG4gICAgc2l6ZTogWzUwMCwgNTAwXSxcbiAgICBzcGlyYWw6ICdhcmNoaW1lZGVhbicsXG4gICAgLy8gdGltZUludGVydmFsOiBJbmZpbml0eSAvLyBtYXggZXhlY3V0ZSB0aW1lXG4gICAgdGltZUludGVydmFsOiA1MDAsXG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtKGRhdGFWaWV3LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWxfMS5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdmFyIGxheW91dCA9IHRhZ19jbG91ZF8xLmRlZmF1bHQoKTtcbiAgICBbJ2ZvbnQnLCAnZm9udFNpemUnLCAncGFkZGluZycsICdyb3RhdGUnLCAnc2l6ZScsICdzcGlyYWwnLCAndGltZUludGVydmFsJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKG9wdGlvbnNba2V5XSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbGF5b3V0W2tleV0ob3B0aW9uc1trZXldKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBmaWVsZHMgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGRzKG9wdGlvbnMpO1xuICAgIHZhciBfYSA9IHRzbGliXzEuX19yZWFkKGZpZWxkcywgMiksIHRleHQgPSBfYVswXSwgdmFsdWUgPSBfYVsxXTtcbiAgICBpZiAoIXV0aWxfMS5pc1N0cmluZyh0ZXh0KSB8fCAhdXRpbF8xLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGZpZWxkczogbXVzdCBiZSBhbiBhcnJheSB3aXRoIDIgc3RyaW5ncyAoZS5nLiBbIFwidGV4dFwiLCBcInZhbHVlXCIgXSkhJyk7XG4gICAgfVxuICAgIHZhciB3b3JkcyA9IGRhdGFWaWV3LnJvd3MubWFwKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgcm93LnRleHQgPSByb3dbdGV4dF07XG4gICAgICAgIHJvdy52YWx1ZSA9IHJvd1t2YWx1ZV07XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgfSk7XG4gICAgbGF5b3V0LndvcmRzKHdvcmRzKTtcbiAgICBpZiAob3B0aW9ucy5pbWFnZU1hc2spIHtcbiAgICAgICAgbGF5b3V0LmNyZWF0ZU1hc2sob3B0aW9ucy5pbWFnZU1hc2spO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gbGF5b3V0LnN0YXJ0KCk7XG4gICAgdmFyIHRhZ3MgPSByZXN1bHQuX3RhZ3M7XG4gICAgdmFyIGJvdW5kcyA9IHJlc3VsdC5fYm91bmRzO1xuICAgIHRhZ3MuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIHRhZy54ICs9IG9wdGlvbnMuc2l6ZVswXSAvIDI7XG4gICAgICAgIHRhZy55ICs9IG9wdGlvbnMuc2l6ZVsxXSAvIDI7XG4gICAgfSk7XG4gICAgdmFyIF9iID0gdHNsaWJfMS5fX3JlYWQob3B0aW9ucy5zaXplLCAyKSwgdyA9IF9iWzBdLCBoID0gX2JbMV07XG4gICAgdmFyIGhhc0ltYWdlID0gcmVzdWx0Lmhhc0ltYWdlO1xuICAgIHRhZ3MucHVzaCh7XG4gICAgICAgIHRleHQ6ICcnLFxuICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgeDogaGFzSW1hZ2UgPyAwIDogYm91bmRzWzBdLngsXG4gICAgICAgIHk6IGhhc0ltYWdlID8gMCA6IGJvdW5kc1swXS55LFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgIH0pO1xuICAgIHRhZ3MucHVzaCh7XG4gICAgICAgIHRleHQ6ICcnLFxuICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgeDogaGFzSW1hZ2UgPyB3IDogYm91bmRzWzFdLngsXG4gICAgICAgIHk6IGhhc0ltYWdlID8gaCA6IGJvdW5kc1sxXS55LFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgIH0pO1xuICAgIGRhdGFWaWV3LnJvd3MgPSB0YWdzO1xuICAgIGRhdGFWaWV3Ll90YWdDbG91ZCA9IHJlc3VsdDtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgndGFnLWNsb3VkJywgdHJhbnNmb3JtKTtcbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnd29yZC1jbG91ZCcsIHRyYW5zZm9ybSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdHJhbnNmb3JtL3dhZmZsZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3RyYW5zZm9ybS93YWZmbGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIHNpbXBsZV9zdGF0aXN0aWNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzaW1wbGUtc3RhdGlzdGljcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19zaW1wbGUtc3RhdGlzdGljc0A2LjEuMUBzaW1wbGUtc3RhdGlzdGljcy9kaXN0L3NpbXBsZS1zdGF0aXN0aWNzLm1pbi5qc1wiKTtcbnZhciBwYXJ0aXRpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvcGFydGl0aW9uICovIFwiLi9zcmMvdXRpbC9wYXJ0aXRpb24udHNcIikpO1xudmFyIGRhdGFfc2V0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9kYXRhLXNldCAqLyBcIi4vc3JjL2RhdGEtc2V0LnRzXCIpO1xudmFyIG9wdGlvbl9wYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWwvb3B0aW9uLXBhcnNlciAqLyBcIi4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50c1wiKTtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gICAgZmllbGRzOiBbJ25hbWUnLCAndmFsdWUnXSxcbiAgICByb3dzOiA1LFxuICAgIHNpemU6IFsxLCAxXSxcbiAgICBzY2FsZTogMSxcbiAgICBncm91cEJ5OiBbXSxcbiAgICBtYXhDb3VudDogMTAwMCxcbiAgICBnYXBSYXRpbzogMC4xLFxuICAgIGFzOiBbJ3gnLCAneSddLFxufTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShkYXRhVmlldywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB1dGlsXzEuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHZhciBmaWVsZHMgPSBvcHRpb25fcGFyc2VyXzEuZ2V0RmllbGRzKG9wdGlvbnMpO1xuICAgIHZhciBfYSA9IHRzbGliXzEuX19yZWFkKGZpZWxkcywgMiksIG5hbWVGaWVsZCA9IF9hWzBdLCB2YWx1ZUZpZWxkID0gX2FbMV07XG4gICAgdmFyIF9iID0gdHNsaWJfMS5fX3JlYWQob3B0aW9ucy5hcywgMiksIGFzWCA9IF9iWzBdLCBhc1kgPSBfYlsxXTtcbiAgICB2YXIgZ3JvdXBCeSA9IG9wdGlvbnMuZ3JvdXBCeTtcbiAgICB2YXIgZ3JvdXBzID0gcGFydGl0aW9uXzEuZGVmYXVsdChkYXRhVmlldy5yb3dzLCBncm91cEJ5KTtcbiAgICB2YXIgZ3JvdXBLZXlzID0gdXRpbF8xLmtleXMoZ3JvdXBzKTtcbiAgICB2YXIgX2MgPSB0c2xpYl8xLl9fcmVhZChvcHRpb25zLnNpemUsIDIpLCB3aWR0aCA9IF9jWzBdLCBoZWlnaHQgPSBfY1sxXTtcbiAgICB2YXIgbWF4Q291bnQgPSBvcHRpb25zLm1heENvdW50O1xuICAgIHZhciBncm91cENvdW50ID0gZ3JvdXBLZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFydEhlaWdodCA9IGhlaWdodCAvIGdyb3VwQ291bnQ7XG4gICAgdmFyIHJvd3MgPSBvcHRpb25zLnJvd3M7XG4gICAgdmFyIGdhcFJhdGlvID0gb3B0aW9ucy5nYXBSYXRpbztcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcbiAgICB2YXIgY3VycmVudEdyb3VwSW5kZXggPSAwO1xuICAgIHZhciB3U3RlcCA9IDA7XG4gICAgLy8gZ2V0dGluZyBzdWl0YWJsZSBzY2FsZSBhbmQgd2lkdGggc3RlcFxuICAgIHV0aWxfMS5mb3JJbihncm91cHMsIGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgICB2YXIgdG90YWxWYWx1ZSA9IHNpbXBsZV9zdGF0aXN0aWNzXzEuc3VtKHV0aWxfMS5tYXAoZ3JvdXAsIGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIHJvd1t2YWx1ZUZpZWxkXTsgfSkpO1xuICAgICAgICB2YXIgY29scyA9IE1hdGguY2VpbCgodG90YWxWYWx1ZSAqIHNjYWxlKSAvIHJvd3MpO1xuICAgICAgICBpZiAodG90YWxWYWx1ZSAqIHNjYWxlID4gbWF4Q291bnQpIHtcbiAgICAgICAgICAgIHNjYWxlID0gbWF4Q291bnQgLyB0b3RhbFZhbHVlO1xuICAgICAgICAgICAgY29scyA9IE1hdGguY2VpbCgodG90YWxWYWx1ZSAqIHNjYWxlKSAvIHJvd3MpO1xuICAgICAgICB9XG4gICAgICAgIHdTdGVwID0gd2lkdGggLyBjb2xzO1xuICAgIH0pO1xuICAgIC8vIGRpc3RyaWJ1dGluZyB2YWx1ZXMgaW50byBncmlkXG4gICAgdXRpbF8xLmZvckluKGdyb3VwcywgZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgIHZhciBoZWlnaHRSYW5nZSA9IFtjdXJyZW50R3JvdXBJbmRleCAqIHBhcnRIZWlnaHQsIChjdXJyZW50R3JvdXBJbmRleCArIDEpICogcGFydEhlaWdodF07XG4gICAgICAgIHZhciBoID0gaGVpZ2h0UmFuZ2VbMV0gLSBoZWlnaHRSYW5nZVswXTtcbiAgICAgICAgdmFyIGhTdGVwID0gKGggKiAoMSAtIGdhcFJhdGlvKSkgLyByb3dzO1xuICAgICAgICB2YXIgY3VycmVudENvbCA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50Um93ID0gMDtcbiAgICAgICAgdXRpbF8xLmVhY2goZ3JvdXAsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJvd1t2YWx1ZUZpZWxkXTtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IE1hdGgucm91bmQodmFsdWUgKiBzY2FsZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFJvdyA9PT0gcm93cykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Um93ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0Um93ID0gdXRpbF8xLnBpY2socm93LCBbbmFtZUZpZWxkLCB2YWx1ZUZpZWxkXS5jb25jYXQoZ3JvdXBCeSkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFJvd1thc1hdID0gY3VycmVudENvbCAqIHdTdGVwICsgd1N0ZXAgLyAyO1xuICAgICAgICAgICAgICAgIHJlc3VsdFJvd1thc1ldID0gY3VycmVudFJvdyAqIGhTdGVwICsgaFN0ZXAgLyAyICsgaGVpZ2h0UmFuZ2VbMF07XG4gICAgICAgICAgICAgICAgcmVzdWx0Um93Ll93U3RlcCA9IHdTdGVwO1xuICAgICAgICAgICAgICAgIHJlc3VsdFJvdy5faFN0ZXAgPSBoU3RlcDtcbiAgICAgICAgICAgICAgICBjdXJyZW50Um93Kys7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocmVzdWx0Um93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGN1cnJlbnRHcm91cEluZGV4ICs9IDE7XG4gICAgfSk7XG4gICAgZGF0YVZpZXcucm93cyA9IHJlc3VsdDtcbn1cbmRhdGFfc2V0XzEuRGF0YVNldC5yZWdpc3RlclRyYW5zZm9ybSgnd2FmZmxlJywgdHJhbnNmb3JtKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL2JhbmR3aWR0aC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL2JhbmR3aWR0aC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNpbXBsZV9zdGF0aXN0aWNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzaW1wbGUtc3RhdGlzdGljcyAqLyBcIi4vbm9kZV9tb2R1bGVzL19zaW1wbGUtc3RhdGlzdGljc0A2LjEuMUBzaW1wbGUtc3RhdGlzdGljcy9kaXN0L3NpbXBsZS1zdGF0aXN0aWNzLm1pbi5qc1wiKTtcbmZ1bmN0aW9uIHNpbHZlcm1hbihhcnIpIHtcbiAgICB2YXIgc3RkZXYgPSBzaW1wbGVfc3RhdGlzdGljc18xLnN0YW5kYXJkRGV2aWF0aW9uKGFycik7XG4gICAgdmFyIG51bSA9IDQgKiBNYXRoLnBvdyhzdGRldiwgNSk7XG4gICAgdmFyIGRlbm9tID0gMyAqIGFyci5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGgucG93KG51bSAvIGRlbm9tLCAwLjIpO1xufVxuZXhwb3J0cy5zaWx2ZXJtYW4gPSBzaWx2ZXJtYW47XG5mdW5jdGlvbiBucmQoYXJyKSB7XG4gICAgdmFyIHMgPSBzaW1wbGVfc3RhdGlzdGljc18xLnN0YW5kYXJkRGV2aWF0aW9uKGFycik7XG4gICAgdmFyIGlxciA9IHNpbXBsZV9zdGF0aXN0aWNzXzEuaW50ZXJxdWFydGlsZVJhbmdlKGFycik7XG4gICAgaWYgKHR5cGVvZiBpcXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHMgPSBNYXRoLm1pbihzLCBpcXIgLyAxLjM0KTtcbiAgICB9XG4gICAgcmV0dXJuIDEuMDYgKiBzICogTWF0aC5wb3coYXJyLmxlbmd0aCwgLTAuMik7XG59XG5leHBvcnRzLm5yZCA9IG5yZDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL2dldC1nZW8tcHJvamVjdGlvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL2dldC1nZW8tcHJvamVjdGlvbi50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB0c2xpYiAqLyBcIi4vbm9kZV9tb2R1bGVzL190c2xpYkAxLjExLjFAdHNsaWIvdHNsaWIuanNcIik7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xudmFyIGQzR2VvID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtZ2VvICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWdlb0AxLjYuNEBkMy1nZW8vYnVpbGQvZDMtZ2VvLmpzXCIpKTtcbnZhciBkM0dlb1Byb2plY3Rpb24gPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkMy1nZW8tcHJvamVjdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL19kMy1nZW8tcHJvamVjdGlvbkAyLjEuMkBkMy1nZW8tcHJvamVjdGlvbi9idWlsZC9kMy1nZW8tcHJvamVjdGlvbi5qc1wiKSk7XG52YXIgZDNDb21wb3NpdGVQcm9qZWN0aW9uID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZDMtY29tcG9zaXRlLXByb2plY3Rpb25zICovIFwiLi9ub2RlX21vZHVsZXMvX2QzLWNvbXBvc2l0ZS1wcm9qZWN0aW9uc0AxLjMuMkBkMy1jb21wb3NpdGUtcHJvamVjdGlvbnMvZDMtY29tcG9zaXRlLXByb2plY3Rpb25zLmpzXCIpKTtcbi8qXG4gKiBnZXRHZW9Qcm9qZWN0aW9uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IHByb2plY3Rpb24gIHByb2plY3Rpb24gbmFtZSBvciBwcm9qZWN0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtleHBvcnRSYXcgPSBmYWxzZV0gLSB3aGV0aGVyIHJldHVybiB0aGUgcmF3IHByb2plY3Rpb24gb3Igbm90XG4gKiAqL1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChwcm9qZWN0aW9uLCBleHBvcnRSYXcpIHtcbiAgICBpZiAoZXhwb3J0UmF3ID09PSB2b2lkIDApIHsgZXhwb3J0UmF3ID0gZmFsc2U7IH1cbiAgICBpZiAodXRpbF8xLmlzRnVuY3Rpb24ocHJvamVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydFJhdyA/IHByb2plY3Rpb24gOiBwcm9qZWN0aW9uKCk7XG4gICAgfVxuICAgIGlmICh1dGlsXzEuaXNTdHJpbmcocHJvamVjdGlvbikpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZDNHZW9bcHJvamVjdGlvbl0pIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRSYXcgPyBkM0dlb1twcm9qZWN0aW9uXSA6IGQzR2VvW3Byb2plY3Rpb25dKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQzR2VvUHJvamVjdGlvbltwcm9qZWN0aW9uXSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydFJhdyA/IGQzR2VvUHJvamVjdGlvbltwcm9qZWN0aW9uXSA6IGQzR2VvUHJvamVjdGlvbltwcm9qZWN0aW9uXSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkM0NvbXBvc2l0ZVByb2plY3Rpb25bcHJvamVjdGlvbl0pIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRSYXcgPyBkM0NvbXBvc2l0ZVByb2plY3Rpb25bcHJvamVjdGlvbl0gOiBkM0NvbXBvc2l0ZVByb2plY3Rpb25bcHJvamVjdGlvbl0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvZ2V0LXNlcmllcy12YWx1ZXMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL2dldC1zZXJpZXMtdmFsdWVzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0gKGZ1bmN0aW9uIChleHRlbnQsIGJ3KSB7XG4gICAgdmFyIGJhbmR3aWR0aCA9IGJ3IHx8IDE7XG4gICAgdmFyIF9hID0gdHNsaWJfMS5fX3JlYWQoZXh0ZW50LCAyKSwgbWluID0gX2FbMF0sIG1heCA9IF9hWzFdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICB2YXIgdG1wID0gbWluO1xuICAgIHdoaWxlICh0bXAgPCBtYXgpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godG1wKTtcbiAgICAgICAgdG1wICs9IGJhbmR3aWR0aDtcbiAgICB9XG4gICAgdmFsdWVzLnB1c2gobWF4KTtcbiAgICByZXR1cm4gdmFsdWVzO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9rZXJuZWwudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9rZXJuZWwudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gKiBAcmVmZXJlbmNlOiBodHRwczovL2dpdGh1Yi5jb20vamFzb25kYXZpZXMvc2NpZW5jZS5qcy9ibG9iL21hc3Rlci9zcmMvc3RhdHMva2VybmVsLmpzXG4gKiBAcmVmZXJlbmNlOiBodHRwczovL2dpdGh1Yi5jb20vUGxhbmVzaGlmdGVyL2tlcm5lbC1zbW9vdGgvYmxvYi9tYXN0ZXIvbGliL2luZGV4LmpzI0wxNlxuICovXG5mdW5jdGlvbiB1bmlmb3JtKHUpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModSkgPD0gMSA/IDAuNSA6IDA7XG59XG5mdW5jdGlvbiB0cmljdWJlZCh1KSB7XG4gICAgdmFyIGFicyA9IDEgLSBNYXRoLnBvdyhNYXRoLmFicyh1KSwgMyk7XG4gICAgcmV0dXJuIE1hdGgucG93KGFicywgMyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgYm94Y2FyOiB1bmlmb3JtLFxuICAgIGNvc2luZTogZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHUpIDw9IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAoTWF0aC5QSSAvIDQpICogTWF0aC5jb3MoKE1hdGguUEkgLyAyKSAqIHUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgZXBhbmVjaG5pa292OiBmdW5jdGlvbiAodSkge1xuICAgICAgICByZXR1cm4gTWF0aC5hYnModSkgPCAxID8gMC43NSAqICgxIC0gdSAqIHUpIDogMDtcbiAgICB9LFxuICAgIGdhdXNzaWFuOiBmdW5jdGlvbiAodSkge1xuICAgICAgICAvLyByZXR1cm4gMSAvIE1hdGguc3FydCgyICogTWF0aC5QSSkgKiBNYXRoLmV4cCgtMC41ICogdSAqIHUpO1xuICAgICAgICByZXR1cm4gMC4zOTg5NDIyODA0ICogTWF0aC5leHAoLTAuNSAqIHUgKiB1KTtcbiAgICB9LFxuICAgIHF1YXJ0aWM6IGZ1bmN0aW9uICh1KSB7XG4gICAgICAgIGlmIChNYXRoLmFicyh1KSA8IDEpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSAxIC0gdSAqIHU7XG4gICAgICAgICAgICByZXR1cm4gKDE1IC8gMTYpICogdG1wICogdG1wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgdHJpYW5ndWxhcjogZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzKHUpO1xuICAgICAgICByZXR1cm4gYWJzIDwgMSA/IDEgLSBhYnMgOiAwO1xuICAgIH0sXG4gICAgdHJpY3ViZTogZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHUpIDwgMSA/ICg3MCAvIDgxKSAqIHRyaWN1YmVkKHUpIDogMDtcbiAgICB9LFxuICAgIHRyaXdlaWdodDogZnVuY3Rpb24gKHUpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHUpIDwgMSkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IDEgLSB1ICogdTtcbiAgICAgICAgICAgIHJldHVybiAoMzUgLyAzMikgKiB0bXAgKiB0bXAgKiB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICB1bmlmb3JtOiB1bmlmb3JtLFxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL29wdGlvbi1wYXJzZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvb3B0aW9uLXBhcnNlci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgSU5WQUxJRF9GSUVMRF9FUlJfTVNHID0gJ0ludmFsaWQgZmllbGQ6IGl0IG11c3QgYmUgYSBzdHJpbmchJztcbnZhciBJTlZBTElEX0ZJRUxEU19FUlJfTVNHID0gJ0ludmFsaWQgZmllbGRzOiBpdCBtdXN0IGJlIGFuIGFycmF5ISc7XG5mdW5jdGlvbiBnZXRGaWVsZChvcHRpb25zLCBkZWZhdWx0RmllbGQpIHtcbiAgICB2YXIgZmllbGQgPSBvcHRpb25zLmZpZWxkLCBmaWVsZHMgPSBvcHRpb25zLmZpZWxkcztcbiAgICBpZiAodXRpbF8xLmlzU3RyaW5nKGZpZWxkKSkge1xuICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgfVxuICAgIGlmICh1dGlsXzEuaXNBcnJheShmaWVsZCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKElOVkFMSURfRklFTERfRVJSX01TRyk7XG4gICAgICAgIHJldHVybiBmaWVsZFswXTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKElOVkFMSURfRklFTERfRVJSX01TRyArIFwiIHdpbGwgdHJ5IHRvIGdldCBmaWVsZHMgaW5zdGVhZC5cIik7XG4gICAgaWYgKHV0aWxfMS5pc1N0cmluZyhmaWVsZHMpKSB7XG4gICAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfVxuICAgIGlmICh1dGlsXzEuaXNBcnJheShmaWVsZHMpICYmIGZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkc1swXTtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRGaWVsZCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEZpZWxkO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKElOVkFMSURfRklFTERfRVJSX01TRyk7XG59XG5leHBvcnRzLmdldEZpZWxkID0gZ2V0RmllbGQ7XG5mdW5jdGlvbiBnZXRGaWVsZHMob3B0aW9ucywgZGVmYXVsdEZpZWxkcykge1xuICAgIHZhciBmaWVsZCA9IG9wdGlvbnMuZmllbGQsIGZpZWxkcyA9IG9wdGlvbnMuZmllbGRzO1xuICAgIGlmICh1dGlsXzEuaXNBcnJheShmaWVsZHMpKSB7XG4gICAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfVxuICAgIGlmICh1dGlsXzEuaXNTdHJpbmcoZmllbGRzKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oSU5WQUxJRF9GSUVMRFNfRVJSX01TRyk7XG4gICAgICAgIHJldHVybiBbZmllbGRzXTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKElOVkFMSURfRklFTERTX0VSUl9NU0cgKyBcIiB3aWxsIHRyeSB0byBnZXQgZmllbGQgaW5zdGVhZC5cIik7XG4gICAgaWYgKHV0aWxfMS5pc1N0cmluZyhmaWVsZCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKElOVkFMSURfRklFTERTX0VSUl9NU0cpO1xuICAgICAgICByZXR1cm4gW2ZpZWxkXTtcbiAgICB9XG4gICAgaWYgKHV0aWxfMS5pc0FycmF5KGZpZWxkKSAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKElOVkFMSURfRklFTERTX0VSUl9NU0cpO1xuICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0RmllbGRzKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RmllbGRzO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKElOVkFMSURfRklFTERTX0VSUl9NU0cpO1xufVxuZXhwb3J0cy5nZXRGaWVsZHMgPSBnZXRGaWVsZHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbC9wLWJ5LWZyYWN0aW9uLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL3AtYnktZnJhY3Rpb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSAoZnVuY3Rpb24gKGZyYWN0aW9uKSB7XG4gICAgdmFyIHN0ZXAgPSAxIC8gZnJhY3Rpb247XG4gICAgdmFyIHBBcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAxOyBpID0gaSArIHN0ZXApIHtcbiAgICAgICAgcEFyci5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcEFycjtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3V0aWwvcGFydGl0aW9uLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3V0aWwvcGFydGl0aW9uLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHRzbGliICovIFwiLi9ub2RlX21vZHVsZXMvX3RzbGliQDEuMTEuMUB0c2xpYi90c2xpYi5qc1wiKTtcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBAYW50di91dGlsICovIFwiLi9ub2RlX21vZHVsZXMvX0BhbnR2X3V0aWxAMi4wLjdAQGFudHYvdXRpbC9saWIvaW5kZXguanNcIik7XG52YXIgc2ltcGxlX3NvcnRfYnlfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2ltcGxlLXNvcnQtYnkgKi8gXCIuL3NyYy91dGlsL3NpbXBsZS1zb3J0LWJ5LnRzXCIpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAocm93cywgZ3JvdXBfYnksIG9yZGVyX2J5KSB7XG4gICAgaWYgKG9yZGVyX2J5ID09PSB2b2lkIDApIHsgb3JkZXJfYnkgPSBbXTsgfVxuICAgIHZhciBuZXdSb3dzID0gcm93cztcbiAgICBpZiAob3JkZXJfYnkgJiYgb3JkZXJfYnkubGVuZ3RoKSB7XG4gICAgICAgIG5ld1Jvd3MgPSBzaW1wbGVfc29ydF9ieV8xLmRlZmF1bHQocm93cywgb3JkZXJfYnkpO1xuICAgIH1cbiAgICB2YXIgZ3JvdXBpbmdGbjtcbiAgICBpZiAodXRpbF8xLmlzRnVuY3Rpb24oZ3JvdXBfYnkpKSB7XG4gICAgICAgIGdyb3VwaW5nRm4gPSBncm91cF9ieTtcbiAgICB9XG4gICAgZWxzZSBpZiAodXRpbF8xLmlzQXJyYXkoZ3JvdXBfYnkpKSB7XG4gICAgICAgIGdyb3VwaW5nRm4gPSBmdW5jdGlvbiAocm93KSB7IHJldHVybiBcIl9cIiArIGdyb3VwX2J5Lm1hcChmdW5jdGlvbiAoY29sKSB7IHJldHVybiByb3dbY29sXTsgfSkuam9pbignLScpOyB9O1xuICAgICAgICAvLyBOT1RFOiBPYmplY3Qua2V5cyh7J2InOiAnYicsICcyJzogJzInLCAnMSc6ICcxJywgJ2EnOiAnYSd9KSA9PiBbICcxJywgJzInLCAnYicsICdhJyBdXG4gICAgICAgIC8vIHRoYXQgaXMgd2h5IHdlIGhhdmUgdG8gYWRkIGEgcHJlZml4XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxfMS5pc1N0cmluZyhncm91cF9ieSkpIHtcbiAgICAgICAgZ3JvdXBpbmdGbiA9IGZ1bmN0aW9uIChyb3cpIHsgcmV0dXJuIFwiX1wiICsgcm93W2dyb3VwX2J5XTsgfTtcbiAgICB9XG4gICAgdmFyIGdyb3VwcyA9IHV0aWxfMS5ncm91cEJ5KG5ld1Jvd3MsIGdyb3VwaW5nRm4pO1xuICAgIHJldHVybiBncm91cHM7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL3NpbXBsZS1zb3J0LWJ5LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbC9zaW1wbGUtc29ydC1ieS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgQGFudHYvdXRpbCAqLyBcIi4vbm9kZV9tb2R1bGVzL19AYW50dl91dGlsQDIuMC43QEBhbnR2L3V0aWwvbGliL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gc29ydEJ5KGFyciwga2V5cykge1xuICAgIGlmIChrZXlzID09PSB2b2lkIDApIHsga2V5cyA9IFtdOyB9XG4gICAgdmFyIGNvbXBhcmVyID0gdW5kZWZpbmVkO1xuICAgIGlmICh1dGlsXzEuaXNGdW5jdGlvbihrZXlzKSkge1xuICAgICAgICBjb21wYXJlciA9IGtleXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHV0aWxfMS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgIGNvbXBhcmVyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChhW2tleV0gPCBiW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYVtrZXldID4gYltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh1dGlsXzEuaXNTdHJpbmcoa2V5cykpIHtcbiAgICAgICAgY29tcGFyZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgaWYgKGFba2V5c10gPCBiW2tleXNdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFba2V5c10gPiBiW2tleXNdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGFyci5zb3J0KGNvbXBhcmVyKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHNvcnRCeTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy91dGlsL3RhZy1jbG91ZC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsL3RhZy1jbG91ZC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuLypcbiAqIFN5bmNocm9ub3VzIHZlcnNpb24gb2YgZDMtY2xvdWRcbiAqL1xuLy8gV29yZCBjbG91ZCBsYXlvdXQgYnkgSmFzb24gRGF2aWVzLCBodHRwczovL3d3dy5qYXNvbmRhdmllcy5jb20vd29yZGNsb3VkL1xuLy8gQWxnb3JpdGhtIGR1ZSB0byBKb25hdGhhbiBGZWluYmVyZywgaHR0cDovL3N0YXRpYy5tcmZlaW5iZXJnLmNvbS9idl9jaDAzLnBkZlxuLyogZXNsaW50LWRpc2FibGUgbm8tcmV0dXJuLWFzc2lnbiwgbm8tY29uZC1hc3NpZ24gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIGNsb3VkUmFkaWFucyA9IE1hdGguUEkgLyAxODAsIGN3ID0gKDEgPDwgMTEpID4+IDUsIGNoID0gMSA8PCAxMTtcbmZ1bmN0aW9uIGNsb3VkVGV4dChkKSB7XG4gICAgcmV0dXJuIGQudGV4dDtcbn1cbmZ1bmN0aW9uIGNsb3VkRm9udCgpIHtcbiAgICByZXR1cm4gJ3NlcmlmJztcbn1cbmZ1bmN0aW9uIGNsb3VkRm9udE5vcm1hbCgpIHtcbiAgICByZXR1cm4gJ25vcm1hbCc7XG59XG5mdW5jdGlvbiBjbG91ZEZvbnRTaXplKGQpIHtcbiAgICByZXR1cm4gZC52YWx1ZTtcbn1cbmZ1bmN0aW9uIGNsb3VkUm90YXRlKCkge1xuICAgIHJldHVybiB+fihNYXRoLnJhbmRvbSgpICogMikgKiA5MDtcbn1cbmZ1bmN0aW9uIGNsb3VkUGFkZGluZygpIHtcbiAgICByZXR1cm4gMTtcbn1cbi8vIEZldGNoZXMgYSBtb25vY2hyb21lIHNwcml0ZSBiaXRtYXAgZm9yIHRoZSBzcGVjaWZpZWQgdGV4dC5cbi8vIExvYWQgaW4gYmF0Y2hlcyBmb3Igc3BlZWQuXG5mdW5jdGlvbiBjbG91ZFNwcml0ZShjb250ZXh0QW5kUmF0aW8sIGQsIGRhdGEsIGRpKSB7XG4gICAgaWYgKGQuc3ByaXRlKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIGMgPSBjb250ZXh0QW5kUmF0aW8uY29udGV4dCwgcmF0aW8gPSBjb250ZXh0QW5kUmF0aW8ucmF0aW87XG4gICAgYy5jbGVhclJlY3QoMCwgMCwgKGN3IDw8IDUpIC8gcmF0aW8sIGNoIC8gcmF0aW8pO1xuICAgIHZhciB4ID0gMCwgeSA9IDAsIG1heGggPSAwO1xuICAgIHZhciBuID0gZGF0YS5sZW5ndGg7XG4gICAgLS1kaTtcbiAgICB3aGlsZSAoKytkaSA8IG4pIHtcbiAgICAgICAgZCA9IGRhdGFbZGldO1xuICAgICAgICBjLnNhdmUoKTtcbiAgICAgICAgYy5mb250ID0gZC5zdHlsZSArICcgJyArIGQud2VpZ2h0ICsgJyAnICsgfn4oKGQuc2l6ZSArIDEpIC8gcmF0aW8pICsgJ3B4ICcgKyBkLmZvbnQ7XG4gICAgICAgIHZhciB3ID0gYy5tZWFzdXJlVGV4dChkLnRleHQgKyAnbScpLndpZHRoICogcmF0aW8sIGggPSBkLnNpemUgPDwgMTtcbiAgICAgICAgaWYgKGQucm90YXRlKSB7XG4gICAgICAgICAgICB2YXIgc3IgPSBNYXRoLnNpbihkLnJvdGF0ZSAqIGNsb3VkUmFkaWFucyksIGNyID0gTWF0aC5jb3MoZC5yb3RhdGUgKiBjbG91ZFJhZGlhbnMpLCB3Y3IgPSB3ICogY3IsIHdzciA9IHcgKiBzciwgaGNyID0gaCAqIGNyLCBoc3IgPSBoICogc3I7XG4gICAgICAgICAgICB3ID0gKChNYXRoLm1heChNYXRoLmFicyh3Y3IgKyBoc3IpLCBNYXRoLmFicyh3Y3IgLSBoc3IpKSArIDB4MWYpID4+IDUpIDw8IDU7XG4gICAgICAgICAgICBoID0gfn5NYXRoLm1heChNYXRoLmFicyh3c3IgKyBoY3IpLCBNYXRoLmFicyh3c3IgLSBoY3IpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHcgPSAoKHcgKyAweDFmKSA+PiA1KSA8PCA1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoID4gbWF4aClcbiAgICAgICAgICAgIG1heGggPSBoO1xuICAgICAgICBpZiAoeCArIHcgPj0gY3cgPDwgNSkge1xuICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgICAgICB5ICs9IG1heGg7XG4gICAgICAgICAgICBtYXhoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSArIGggPj0gY2gpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgYy50cmFuc2xhdGUoKHggKyAodyA+PiAxKSkgLyByYXRpbywgKHkgKyAoaCA+PiAxKSkgLyByYXRpbyk7XG4gICAgICAgIGlmIChkLnJvdGF0ZSlcbiAgICAgICAgICAgIGMucm90YXRlKGQucm90YXRlICogY2xvdWRSYWRpYW5zKTtcbiAgICAgICAgYy5maWxsVGV4dChkLnRleHQsIDAsIDApO1xuICAgICAgICBpZiAoZC5wYWRkaW5nKSB7XG4gICAgICAgICAgICBjLmxpbmVXaWR0aCA9IDIgKiBkLnBhZGRpbmc7XG4gICAgICAgICAgICBjLnN0cm9rZVRleHQoZC50ZXh0LCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjLnJlc3RvcmUoKTtcbiAgICAgICAgZC53aWR0aCA9IHc7XG4gICAgICAgIGQuaGVpZ2h0ID0gaDtcbiAgICAgICAgZC54b2ZmID0geDtcbiAgICAgICAgZC55b2ZmID0geTtcbiAgICAgICAgZC54MSA9IHcgPj4gMTtcbiAgICAgICAgZC55MSA9IGggPj4gMTtcbiAgICAgICAgZC54MCA9IC1kLngxO1xuICAgICAgICBkLnkwID0gLWQueTE7XG4gICAgICAgIGQuaGFzVGV4dCA9IHRydWU7XG4gICAgICAgIHggKz0gdztcbiAgICB9XG4gICAgdmFyIHBpeGVscyA9IGMuZ2V0SW1hZ2VEYXRhKDAsIDAsIChjdyA8PCA1KSAvIHJhdGlvLCBjaCAvIHJhdGlvKS5kYXRhLCBzcHJpdGUgPSBbXTtcbiAgICB3aGlsZSAoLS1kaSA+PSAwKSB7XG4gICAgICAgIGQgPSBkYXRhW2RpXTtcbiAgICAgICAgaWYgKCFkLmhhc1RleHQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdmFyIHcgPSBkLndpZHRoLCB3MzIgPSB3ID4+IDU7XG4gICAgICAgIHZhciBoID0gZC55MSAtIGQueTA7XG4gICAgICAgIC8vIFplcm8gdGhlIGJ1ZmZlclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGggKiB3MzI7IGkrKylcbiAgICAgICAgICAgIHNwcml0ZVtpXSA9IDA7XG4gICAgICAgIHggPSBkLnhvZmY7XG4gICAgICAgIGlmICh4ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHkgPSBkLnlvZmY7XG4gICAgICAgIHZhciBzZWVuID0gMCwgc2VlblJvdyA9IC0xO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGg7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IHczMiAqIGogKyAoaSA+PiA1KSwgbSA9IHBpeGVsc1soKHkgKyBqKSAqIChjdyA8PCA1KSArICh4ICsgaSkpIDw8IDJdID8gMSA8PCAoMzEgLSAoaSAlIDMyKSkgOiAwO1xuICAgICAgICAgICAgICAgIHNwcml0ZVtrXSB8PSBtO1xuICAgICAgICAgICAgICAgIHNlZW4gfD0gbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWVuKVxuICAgICAgICAgICAgICAgIHNlZW5Sb3cgPSBqO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZC55MCsrO1xuICAgICAgICAgICAgICAgIGgtLTtcbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgeSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGQueTEgPSBkLnkwICsgc2VlblJvdztcbiAgICAgICAgZC5zcHJpdGUgPSBzcHJpdGUuc2xpY2UoMCwgKGQueTEgLSBkLnkwKSAqIHczMik7XG4gICAgfVxufVxuLy8gVXNlIG1hc2stYmFzZWQgY29sbGlzaW9uIGRldGVjdGlvbi5cbmZ1bmN0aW9uIGNsb3VkQ29sbGlkZSh0YWcsIGJvYXJkLCBzdykge1xuICAgIHN3ID4+PSA1O1xuICAgIHZhciBzcHJpdGUgPSB0YWcuc3ByaXRlLCB3ID0gdGFnLndpZHRoID4+IDUsIGx4ID0gdGFnLnggLSAodyA8PCA0KSwgc3ggPSBseCAmIDB4N2YsIG1zeCA9IDMyIC0gc3gsIGggPSB0YWcueTEgLSB0YWcueTA7XG4gICAgdmFyIHggPSAodGFnLnkgKyB0YWcueTApICogc3cgKyAobHggPj4gNSksIGxhc3Q7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBoOyBqKyspIHtcbiAgICAgICAgbGFzdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHc7IGkrKykge1xuICAgICAgICAgICAgaWYgKCgobGFzdCA8PCBtc3gpIHwgKGkgPCB3ID8gKGxhc3QgPSBzcHJpdGVbaiAqIHcgKyBpXSkgPj4+IHN4IDogMCkpICYgYm9hcmRbeCArIGldKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHggKz0gc3c7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNsb3VkQm91bmRzKGJvdW5kcywgZCkge1xuICAgIHZhciBiMCA9IGJvdW5kc1swXSwgYjEgPSBib3VuZHNbMV07XG4gICAgaWYgKGQueCArIGQueDAgPCBiMC54KVxuICAgICAgICBiMC54ID0gZC54ICsgZC54MDtcbiAgICBpZiAoZC55ICsgZC55MCA8IGIwLnkpXG4gICAgICAgIGIwLnkgPSBkLnkgKyBkLnkwO1xuICAgIGlmIChkLnggKyBkLngxID4gYjEueClcbiAgICAgICAgYjEueCA9IGQueCArIGQueDE7XG4gICAgaWYgKGQueSArIGQueTEgPiBiMS55KVxuICAgICAgICBiMS55ID0gZC55ICsgZC55MTtcbn1cbmZ1bmN0aW9uIGNvbGxpZGVSZWN0cyhhLCBiKSB7XG4gICAgcmV0dXJuIGEueCArIGEueDEgPiBiWzBdLnggJiYgYS54ICsgYS54MCA8IGJbMV0ueCAmJiBhLnkgKyBhLnkxID4gYlswXS55ICYmIGEueSArIGEueTAgPCBiWzFdLnk7XG59XG5mdW5jdGlvbiBhcmNoaW1lZGVhblNwaXJhbChzaXplKSB7XG4gICAgdmFyIGUgPSBzaXplWzBdIC8gc2l6ZVsxXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIFtlICogKHQgKj0gMC4xKSAqIE1hdGguY29zKHQpLCB0ICogTWF0aC5zaW4odCldO1xuICAgIH07XG59XG5mdW5jdGlvbiByZWN0YW5ndWxhclNwaXJhbChzaXplKSB7XG4gICAgdmFyIGR5ID0gNCwgZHggPSAoZHkgKiBzaXplWzBdKSAvIHNpemVbMV07XG4gICAgdmFyIHggPSAwLCB5ID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgdmFyIHNpZ24gPSB0IDwgMCA/IC0xIDogMTtcbiAgICAgICAgLy8gU2VlIHRyaWFuZ3VsYXIgbnVtYmVyczogVF9uID0gbiAqIChuICsgMSkgLyAyLlxuICAgICAgICBzd2l0Y2ggKChNYXRoLnNxcnQoMSArIDQgKiBzaWduICogdCkgLSBzaWduKSAmIDMpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB4ICs9IGR4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHkgKz0gZHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgeCAtPSBkeDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgeSAtPSBkeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH07XG59XG4vLyBUT0RPIHJldXNlIGFycmF5cz9cbmZ1bmN0aW9uIHplcm9BcnJheShuKSB7XG4gICAgdmFyIGEgPSBbXTtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPCBuKVxuICAgICAgICBhW2ldID0gMDtcbiAgICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIGNsb3VkQ2FudmFzKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbn1cbmZ1bmN0aW9uIGZ1bmN0b3IoZCkge1xuICAgIHJldHVybiB0eXBlb2YgZCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGRcbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfTtcbn1cbnZhciBzcGlyYWxzID0ge1xuICAgIGFyY2hpbWVkZWFuOiBhcmNoaW1lZGVhblNwaXJhbCxcbiAgICByZWN0YW5ndWxhcjogcmVjdGFuZ3VsYXJTcGlyYWwsXG59O1xuZnVuY3Rpb24gZGVmYXVsdF8xKCkge1xuICAgIHZhciBzaXplID0gWzI1NiwgMjU2XSwgdGV4dCA9IGNsb3VkVGV4dCwgZm9udCA9IGNsb3VkRm9udCwgZm9udFNpemUgPSBjbG91ZEZvbnRTaXplLCBmb250U3R5bGUgPSBjbG91ZEZvbnROb3JtYWwsIGZvbnRXZWlnaHQgPSBjbG91ZEZvbnROb3JtYWwsIHJvdGF0ZSA9IGNsb3VkUm90YXRlLCBwYWRkaW5nID0gY2xvdWRQYWRkaW5nLCBzcGlyYWwgPSBhcmNoaW1lZGVhblNwaXJhbCwgd29yZHMgPSBbXSwgdGltZUludGVydmFsID0gSW5maW5pdHksIHJhbmRvbSA9IE1hdGgucmFuZG9tLCBjYW52YXMgPSBjbG91ZENhbnZhcztcbiAgICB2YXIgY2xvdWQgPSB7fTtcbiAgICBjbG91ZC5jYW52YXMgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoY2FudmFzID0gZnVuY3RvcihfKSksIGNsb3VkKSA6IGNhbnZhcztcbiAgICB9O1xuICAgIGNsb3VkLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0c2xpYl8xLl9fcmVhZChzaXplLCAyKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgICAgIHZhciBjb250ZXh0QW5kUmF0aW8gPSBnZXRDb250ZXh0KGNhbnZhcygpKSwgYm9hcmQgPSBjbG91ZC5ib2FyZCA/IGNsb3VkLmJvYXJkIDogemVyb0FycmF5KChzaXplWzBdID4+IDUpICogc2l6ZVsxXSksIG4gPSB3b3Jkcy5sZW5ndGgsIHRhZ3MgPSBbXSwgZGF0YSA9IHdvcmRzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICBkLnRleHQgPSB0ZXh0LmNhbGwodGhpcywgZCwgaSk7XG4gICAgICAgICAgICBkLmZvbnQgPSBmb250LmNhbGwodGhpcywgZCwgaSk7XG4gICAgICAgICAgICBkLnN0eWxlID0gZm9udFN0eWxlLmNhbGwodGhpcywgZCwgaSk7XG4gICAgICAgICAgICBkLndlaWdodCA9IGZvbnRXZWlnaHQuY2FsbCh0aGlzLCBkLCBpKTtcbiAgICAgICAgICAgIGQucm90YXRlID0gcm90YXRlLmNhbGwodGhpcywgZCwgaSk7XG4gICAgICAgICAgICBkLnNpemUgPSB+fmZvbnRTaXplLmNhbGwodGhpcywgZCwgaSk7XG4gICAgICAgICAgICBkLnBhZGRpbmcgPSBwYWRkaW5nLmNhbGwodGhpcywgZCwgaSk7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5zaXplIC0gYS5zaXplO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGkgPSAtMSwgYm91bmRzID0gIWNsb3VkLmJvYXJkXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgeDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGhlaWdodCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgc3RlcCgpO1xuICAgICAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnQgPCB0aW1lSW50ZXJ2YWwgJiYgKytpIDwgbikge1xuICAgICAgICAgICAgICAgIHZhciBkID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICBkLnggPSAod2lkdGggKiAocmFuZG9tKCkgKyAwLjUpKSA+PiAxO1xuICAgICAgICAgICAgICAgIGQueSA9IChoZWlnaHQgKiAocmFuZG9tKCkgKyAwLjUpKSA+PiAxO1xuICAgICAgICAgICAgICAgIGNsb3VkU3ByaXRlKGNvbnRleHRBbmRSYXRpbywgZCwgZGF0YSwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKGQuaGFzVGV4dCAmJiBwbGFjZShib2FyZCwgZCwgYm91bmRzKSkge1xuICAgICAgICAgICAgICAgICAgICB0YWdzLnB1c2goZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChib3VuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2xvdWQuaGFzSW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgYm91bmRzIGlmIGltYWdlIG1hc2sgbm90IHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3VkQm91bmRzKGJvdW5kcywgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3VuZHMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB4OiBkLnggKyBkLngwLCB5OiBkLnkgKyBkLnkwIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB4OiBkLnggKyBkLngxLCB5OiBkLnkgKyBkLnkxIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRlbXBvcmFyeSBoYWNrXG4gICAgICAgICAgICAgICAgICAgIGQueCAtPSBzaXplWzBdID4+IDE7XG4gICAgICAgICAgICAgICAgICAgIGQueSAtPSBzaXplWzFdID4+IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xvdWQuX3RhZ3MgPSB0YWdzO1xuICAgICAgICAgICAgY2xvdWQuX2JvdW5kcyA9IGJvdW5kcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBnZXRDb250ZXh0KGNhbnZhcykge1xuICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICAgICAgdmFyIHJhdGlvID0gTWF0aC5zcXJ0KGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhLmxlbmd0aCA+PiAyKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gKGN3IDw8IDUpIC8gcmF0aW87XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjaCAvIHJhdGlvO1xuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgcmV0dXJuIHsgY29udGV4dDogY29udGV4dCwgcmF0aW86IHJhdGlvIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBsYWNlKGJvYXJkLCB0YWcsIGJvdW5kcykge1xuICAgICAgICAvLyBjb25zdCBwZXJpbWV0ZXIgPSBbeyB4OiAwLCB5OiAwIH0sIHsgeDogc2l6ZVswXSwgeTogc2l6ZVsxXSB9XSxcbiAgICAgICAgdmFyIHN0YXJ0WCA9IHRhZy54LCBzdGFydFkgPSB0YWcueSwgbWF4RGVsdGEgPSBNYXRoLnNxcnQoc2l6ZVswXSAqIHNpemVbMF0gKyBzaXplWzFdICogc2l6ZVsxXSksIHMgPSBzcGlyYWwoc2l6ZSksIGR0ID0gcmFuZG9tKCkgPCAwLjUgPyAxIDogLTE7XG4gICAgICAgIHZhciBkeGR5LCB0ID0gLWR0LCBkeCwgZHk7XG4gICAgICAgIHdoaWxlICgoZHhkeSA9IHMoKHQgKz0gZHQpKSkpIHtcbiAgICAgICAgICAgIGR4ID0gfn5keGR5WzBdO1xuICAgICAgICAgICAgZHkgPSB+fmR4ZHlbMV07XG4gICAgICAgICAgICBpZiAoTWF0aC5taW4oTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeSkpID49IG1heERlbHRhKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdGFnLnggPSBzdGFydFggKyBkeDtcbiAgICAgICAgICAgIHRhZy55ID0gc3RhcnRZICsgZHk7XG4gICAgICAgICAgICBpZiAodGFnLnggKyB0YWcueDAgPCAwIHx8IHRhZy55ICsgdGFnLnkwIDwgMCB8fCB0YWcueCArIHRhZy54MSA+IHNpemVbMF0gfHwgdGFnLnkgKyB0YWcueTEgPiBzaXplWzFdKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gVE9ETyBvbmx5IGNoZWNrIGZvciBjb2xsaXNpb25zIHdpdGhpbiBjdXJyZW50IGJvdW5kcy5cbiAgICAgICAgICAgIGlmICghYm91bmRzIHx8ICFjbG91ZENvbGxpZGUodGFnLCBib2FyZCwgc2l6ZVswXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJvdW5kcyB8fCBjb2xsaWRlUmVjdHModGFnLCBib3VuZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSB0YWcuc3ByaXRlLCB3ID0gdGFnLndpZHRoID4+IDUsIHN3ID0gc2l6ZVswXSA+PiA1LCBseCA9IHRhZy54IC0gKHcgPDwgNCksIHN4ID0gbHggJiAweDdmLCBtc3ggPSAzMiAtIHN4LCBoID0gdGFnLnkxIC0gdGFnLnkwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHZvaWQgMCwgeCA9ICh0YWcueSArIHRhZy55MCkgKiBzdyArIChseCA+PiA1KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9hcmRbeCArIGldIHw9IChsYXN0IDw8IG1zeCkgfCAoaSA8IHcgPyAobGFzdCA9IHNwcml0ZVtqICogdyArIGldKSA+Pj4gc3ggOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3c7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRhZy5zcHJpdGU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNsb3VkLmNyZWF0ZU1hc2sgPSBmdW5jdGlvbiAoaW1nKSB7XG4gICAgICAgIHZhciBjYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdmFyIF9hID0gdHNsaWJfMS5fX3JlYWQoc2l6ZSwgMiksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgICAgICB2YXIgdzMyID0gd2lkdGggPj4gNTtcbiAgICAgICAgdmFyIGJvYXJkID0gemVyb0FycmF5KCh3aWR0aCA+PiA1KSAqIGhlaWdodCk7XG4gICAgICAgIGNhbi53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW4uaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB2YXIgY3h0ID0gY2FuLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB2YXIgaW1hZ2VEYXRhID0gY3h0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGhlaWdodDsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IHczMiAqIGogKyAoaSA+PiA1KTtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gKGogKiB3aWR0aCArIGkpIDw8IDI7XG4gICAgICAgICAgICAgICAgdmFyIGZsYWcgPSBpbWFnZURhdGFbdG1wXSA+PSAyNTAgJiYgaW1hZ2VEYXRhW3RtcCArIDFdID49IDI1MCAmJiBpbWFnZURhdGFbdG1wICsgMl0gPj0gMjUwO1xuICAgICAgICAgICAgICAgIHZhciBtID0gZmxhZyA/IDEgPDwgKDMxIC0gKGkgJSAzMikpIDogMDtcbiAgICAgICAgICAgICAgICBib2FyZFtrXSB8PSBtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNsb3VkLmJvYXJkID0gYm9hcmQ7XG4gICAgICAgIGNsb3VkLmhhc0ltYWdlID0gdHJ1ZTtcbiAgICB9O1xuICAgIGNsb3VkLnRpbWVJbnRlcnZhbCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKCh0aW1lSW50ZXJ2YWwgPSBfID09IG51bGwgPyBJbmZpbml0eSA6IF8pLCBjbG91ZCkgOiB0aW1lSW50ZXJ2YWw7XG4gICAgfTtcbiAgICBjbG91ZC53b3JkcyA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKCh3b3JkcyA9IF8pLCBjbG91ZCkgOiB3b3JkcztcbiAgICB9O1xuICAgIGNsb3VkLnNpemUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoc2l6ZSA9IFsrX1swXSwgK19bMV1dKSwgY2xvdWQpIDogc2l6ZTtcbiAgICB9O1xuICAgIGNsb3VkLmZvbnQgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoZm9udCA9IGZ1bmN0b3IoXykpLCBjbG91ZCkgOiBmb250O1xuICAgIH07XG4gICAgY2xvdWQuZm9udFN0eWxlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGZvbnRTdHlsZSA9IGZ1bmN0b3IoXykpLCBjbG91ZCkgOiBmb250U3R5bGU7XG4gICAgfTtcbiAgICBjbG91ZC5mb250V2VpZ2h0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGZvbnRXZWlnaHQgPSBmdW5jdG9yKF8pKSwgY2xvdWQpIDogZm9udFdlaWdodDtcbiAgICB9O1xuICAgIGNsb3VkLnJvdGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChyb3RhdGUgPSBmdW5jdG9yKF8pKSwgY2xvdWQpIDogcm90YXRlO1xuICAgIH07XG4gICAgY2xvdWQudGV4dCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKCh0ZXh0ID0gZnVuY3RvcihfKSksIGNsb3VkKSA6IHRleHQ7XG4gICAgfTtcbiAgICBjbG91ZC5zcGlyYWwgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoc3BpcmFsID0gc3BpcmFsc1tfXSB8fCBfKSwgY2xvdWQpIDogc3BpcmFsO1xuICAgIH07XG4gICAgY2xvdWQuZm9udFNpemUgPSBmdW5jdGlvbiAoXykge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoZm9udFNpemUgPSBmdW5jdG9yKF8pKSwgY2xvdWQpIDogZm9udFNpemU7XG4gICAgfTtcbiAgICBjbG91ZC5wYWRkaW5nID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKHBhZGRpbmcgPSBmdW5jdG9yKF8pKSwgY2xvdWQpIDogcGFkZGluZztcbiAgICB9O1xuICAgIGNsb3VkLnJhbmRvbSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChyYW5kb20gPSBfKSwgY2xvdWQpIDogcmFuZG9tO1xuICAgIH07XG4gICAgcmV0dXJuIGNsb3VkO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGVmYXVsdF8xO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3ZpZXcudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy92aWV3LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdHNsaWIgKi8gXCIuL25vZGVfbW9kdWxlcy9fdHNsaWJAMS4xMS4xQHRzbGliL3RzbGliLmpzXCIpO1xudmFyIHdvbGZ5ODdfZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISB3b2xmeTg3LWV2ZW50ZW1pdHRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL193b2xmeTg3LWV2ZW50ZW1pdHRlckA1LjIuOUB3b2xmeTg3LWV2ZW50ZW1pdHRlci9FdmVudEVtaXR0ZXIuanNcIikpO1xudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIEBhbnR2L3V0aWwgKi8gXCIuL25vZGVfbW9kdWxlcy9fQGFudHZfdXRpbEAyLjAuN0BAYW50di91dGlsL2xpYi9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIGNsb25lT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHV0aWxfMS5mb3JJbihvcHRpb25zLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBpZiAodXRpbF8xLmlzT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5pc1ZpZXcpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXRpbF8xLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlLmNvbmNhdChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXRpbF8xLmlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHV0aWxfMS5jbG9uZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICog5pWw5o2u6KeG5Zu+XG4gKiBAcHVibGljXG4gKi9cbnZhciBWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlldyhkYXRhU2V0LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDmmK/lkKbmmK9WaWV3XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5pc1ZpZXcgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICog5piv5ZCm5pivVmlld1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaXNEYXRhVmlldyA9IHRydWU7IC8vIGFsaWFzXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMud2F0Y2hpbmdTdGF0ZXMgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICog5pWw5o2u6KeG5Zu+57G75Z6LXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5kYXRhVHlwZSA9ICd0YWJsZSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDlt7LlupTnlKjnmoQgdHJhbnNmb3JtXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy50cmFuc2Zvcm1zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiDljp/lp4vmlbDmja5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLm9yaWdpbiA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICog5a2Y5YKo5aSE55CG5ZCO55qE5pWw5o2uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5yb3dzID0gW107XG4gICAgICAgIGlmIChkYXRhU2V0ICYmIGRhdGFTZXQuaXNEYXRhU2V0KSB7XG4gICAgICAgICAgICBfdGhpcy5kYXRhU2V0ID0gZGF0YVNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmRhdGFTZXQgPSBudWxsO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGRhdGFTZXQ7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMubG9vc2UgPSAhX3RoaXMuZGF0YVNldDtcbiAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgLy8gYXNzaWduKG1lLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIF90aGlzLndhdGNoaW5nU3RhdGVzID0gb3B0aW9ucy53YXRjaGluZ1N0YXRlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV90aGlzLmxvb3NlKSB7XG4gICAgICAgICAgICB2YXIgd2F0Y2hpbmdTdGF0ZXNfMSA9IF90aGlzLndhdGNoaW5nU3RhdGVzO1xuICAgICAgICAgICAgZGF0YVNldC5vbignc3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsXzEuaXNBcnJheSh3YXRjaGluZ1N0YXRlc18xKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2F0Y2hpbmdTdGF0ZXNfMS5pbmRleE9mKG5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZUV4ZWN1dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlRXhlY3V0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVmlldy5wcm90b3R5cGUuX3BhcnNlU3RhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgdmFyIGRhdGFTZXQgPSB0aGlzLmRhdGFTZXQ7XG4gICAgICAgIGlmIChkYXRhU2V0ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSAvXlxcJHN0YXRlXFwuKFxcdyspLy5leGVjKGV4cHIpO1xuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFTZXQuc3RhdGVbbWF0Y2hlZFsxXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfTtcbiAgICBWaWV3LnByb3RvdHlwZS5fcHJlcGFyc2VPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9wdGlvbnNDbG9uZWQgPSBjbG9uZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmxvb3NlKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uc0Nsb25lZDtcbiAgICAgICAgfVxuICAgICAgICB1dGlsXzEuZm9ySW4ob3B0aW9uc0Nsb25lZCwgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIGlmICh1dGlsXzEuaXNTdHJpbmcodmFsdWUpICYmIC9eXFwkc3RhdGVcXC4vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc0Nsb25lZFtrZXldID0gX3RoaXMuX3BhcnNlU3RhdGVFeHByZXNzaW9uKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zQ2xvbmVkO1xuICAgIH07XG4gICAgLy8gY29ubmVjdG9yc1xuICAgIFZpZXcucHJvdG90eXBlLl9wcmVwYXJlU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICAvLyB3YXJuaW5nIG1lLm9yaWdpbiBpcyBwcm90ZWN0ZWRcbiAgICAgICAgdGhpcy5fc291cmNlID0geyBzb3VyY2U6IHNvdXJjZSwgb3B0aW9uczogb3B0aW9ucyB9O1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBWaWV3IHx8IHV0aWxfMS5pc1N0cmluZyhzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSBWaWV3LkRhdGFTZXQuZ2V0Q29ubmVjdG9yKCdkZWZhdWx0Jykoc291cmNlLCB0aGlzLmRhdGFTZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXRpbF8xLmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gYnJhbmNoOiBpZiBzb3VyY2UgaXMgbGlrZSBbJ2RhdGF2aWV3MScsICdkYXRhdmlldzInXVxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luID0gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodXRpbF8xLmlzT2JqZWN0KHNvdXJjZSkgJiYgc291cmNlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMuX3ByZXBhcnNlT3B0aW9ucyhzb3VyY2UpOyAvLyBjb25uZWN0b3Igd2l0aG91dCBzb3VyY2VcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbiA9IFZpZXcuRGF0YVNldC5nZXRDb25uZWN0b3Iob3B0cy50eXBlKShvcHRzLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgc291cmNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMuX3ByZXBhcnNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luID0gVmlldy5EYXRhU2V0LmdldENvbm5lY3RvcihvcHRzLnR5cGUpKHNvdXJjZSwgb3B0cywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3dzID0gdXRpbF8xLmRlZXBNaXgoW10sIHRoaXMub3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBWaWV3LnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3ByZXBhcmVTb3VyY2Uoc291cmNlLCBvcHRpb25zKS5fcmVFeGVjdXRlVHJhbnNmb3JtcygpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiAg5omn6KGM5pWw5o2u5aSE55CG5pWw5o2u44CC5omn6KGM5a6M6L+Z5Liq5Ye95pWw5ZCO77yMdHJhbnNmb3JtIOS8muiiq+WtmOWCqFxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0g5p+Q56eN57G75Z6L55qEdHJhbnNmb3JtXG4gICAgICovXG4gICAgVmlldy5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybXMucHVzaChvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGVUcmFuc2Zvcm0ob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBWaWV3LnByb3RvdHlwZS5fZXhlY3V0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wcmVwYXJzZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBWaWV3LkRhdGFTZXQuZ2V0VHJhbnNmb3JtKG9wdGlvbnMudHlwZSk7XG4gICAgICAgIHRyYW5zZm9ybSh0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFZpZXcucHJvdG90eXBlLl9yZUV4ZWN1dGVUcmFuc2Zvcm1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMuZm9yRWFjaChmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgX3RoaXMuX2V4ZWN1dGVUcmFuc2Zvcm0ob3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVmlldy5wcm90b3R5cGUuYWRkUm93ID0gZnVuY3Rpb24gKHJvdykge1xuICAgICAgICB0aGlzLnJvd3MucHVzaChyb3cpO1xuICAgIH07XG4gICAgVmlldy5wcm90b3R5cGUucmVtb3ZlUm93ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHRoaXMucm93cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH07XG4gICAgVmlldy5wcm90b3R5cGUudXBkYXRlUm93ID0gZnVuY3Rpb24gKGluZGV4LCBuZXdSb3cpIHtcbiAgICAgICAgdXRpbF8xLmFzc2lnbih0aGlzLnJvd3NbaW5kZXhdLCBuZXdSb3cpO1xuICAgIH07XG4gICAgVmlldy5wcm90b3R5cGUuZmluZFJvd3MgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93cy5maWx0ZXIoZnVuY3Rpb24gKHJvdykgeyByZXR1cm4gdXRpbF8xLmlzTWF0Y2gocm93LCBxdWVyeSk7IH0pO1xuICAgIH07XG4gICAgVmlldy5wcm90b3R5cGUuZmluZFJvdyA9IGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICByZXR1cm4gdXRpbF8xLmZpbmQodGhpcy5yb3dzLCBxdWVyeSk7XG4gICAgfTtcbiAgICAvLyBjb2x1bW5zXG4gICAgVmlldy5wcm90b3R5cGUuZ2V0Q29sdW1uTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaXJzdFJvdyA9IHRoaXMucm93c1swXTtcbiAgICAgICAgaWYgKGZpcnN0Um93KSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbF8xLmtleXMoZmlyc3RSb3cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIFZpZXcucHJvdG90eXBlLmdldENvbHVtbk5hbWUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sdW1uTmFtZXMoKVtpbmRleF07XG4gICAgfTtcbiAgICBWaWV3LnByb3RvdHlwZS5nZXRDb2x1bW5JbmRleCA9IGZ1bmN0aW9uIChjb2x1bW5OYW1lKSB7XG4gICAgICAgIHZhciBjb2x1bW5OYW1lcyA9IHRoaXMuZ2V0Q29sdW1uTmFtZXMoKTtcbiAgICAgICAgcmV0dXJuIGNvbHVtbk5hbWVzLmluZGV4T2YoY29sdW1uTmFtZSk7XG4gICAgfTtcbiAgICBWaWV3LnByb3RvdHlwZS5nZXRDb2x1bW4gPSBmdW5jdGlvbiAoY29sdW1uTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dzLm1hcChmdW5jdGlvbiAocm93KSB7IHJldHVybiByb3dbY29sdW1uTmFtZV07IH0pO1xuICAgIH07XG4gICAgVmlldy5wcm90b3R5cGUuZ2V0Q29sdW1uRGF0YSA9IGZ1bmN0aW9uIChjb2x1bW5OYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbihjb2x1bW5OYW1lKTtcbiAgICB9O1xuICAgIC8vIGRhdGEgcHJvY2Vzc1xuICAgIFZpZXcucHJvdG90eXBlLmdldFN1YnNldCA9IGZ1bmN0aW9uIChzdGFydFJvd0luZGV4LCBlbmRSb3dJbmRleCwgY29sdW1uTmFtZXMpIHtcbiAgICAgICAgdmFyIHN1YnNldCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRSb3dJbmRleDsgaSA8PSBlbmRSb3dJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBzdWJzZXQucHVzaCh1dGlsXzEucGljayh0aGlzLnJvd3NbaV0sIGNvbHVtbk5hbWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNldDtcbiAgICB9O1xuICAgIFZpZXcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHByZXR0eVByaW50KSB7XG4gICAgICAgIGlmIChwcmV0dHlQcmludCA9PT0gdm9pZCAwKSB7IHByZXR0eVByaW50ID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHByZXR0eVByaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5yb3dzLCBudWxsLCAyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5yb3dzKTtcbiAgICB9O1xuICAgIFZpZXcucHJvdG90eXBlLl9yZUV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuX3NvdXJjZSwgc291cmNlID0gX2Euc291cmNlLCBvcHRpb25zID0gX2Eub3B0aW9ucztcbiAgICAgICAgdGhpcy5fcHJlcGFyZVNvdXJjZShzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9yZUV4ZWN1dGVUcmFuc2Zvcm1zKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgW10pO1xuICAgIH07XG4gICAgcmV0dXJuIFZpZXc7XG59KHdvbGZ5ODdfZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5WaWV3ID0gVmlldztcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YS1zZXQuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@antv/data-set/build/data-set.js\n");

/***/ }),

/***/ "./node_modules/@vue/babel-helper-vue-jsx-merge-props/dist/helper.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@vue/babel-helper-vue-jsx-merge-props/dist/helper.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("function _extends(){return _extends=Object.assign||function(a){for(var b,c=1;c<arguments.length;c++)for(var d in b=arguments[c],b)Object.prototype.hasOwnProperty.call(b,d)&&(a[d]=b[d]);return a},_extends.apply(this,arguments)}var normalMerge=[\"attrs\",\"props\",\"domProps\"],toArrayMerge=[\"class\",\"style\",\"directives\"],functionalMerge=[\"on\",\"nativeOn\"],mergeJsxProps=function(a){return a.reduce(function(c,a){for(var b in a)if(!c[b])c[b]=a[b];else if(-1!==normalMerge.indexOf(b))c[b]=_extends({},c[b],a[b]);else if(-1!==toArrayMerge.indexOf(b)){var d=c[b]instanceof Array?c[b]:[c[b]],e=a[b]instanceof Array?a[b]:[a[b]];c[b]=d.concat(e)}else if(-1!==functionalMerge.indexOf(b)){for(var f in a[b])if(c[b][f]){var g=c[b][f]instanceof Array?c[b][f]:[c[b][f]],h=a[b][f]instanceof Array?a[b][f]:[a[b][f]];c[b][f]=g.concat(h)}else c[b][f]=a[b][f];}else if(\"hook\"==b)for(var i in a[b])c[b][i]=c[b][i]?mergeFn(c[b][i],a[b][i]):a[b][i];else c[b]=a[b];return c},{})},mergeFn=function(a,b){return function(){a&&a.apply(this,arguments),b&&b.apply(this,arguments)}};module.exports=mergeJsxProps;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHZ1ZS9iYWJlbC1oZWxwZXItdnVlLWpzeC1tZXJnZS1wcm9wcy9kaXN0L2hlbHBlci5qcz8yNjM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhLG9CQUFvQiwyQ0FBMkMsY0FBYyxtQkFBbUIseUZBQXlGLFNBQVMsZ0NBQWdDLHFKQUFxSiw4QkFBOEIsa0NBQWtDLG9EQUFvRCxZQUFZLHNDQUFzQywwRUFBMEUsaUJBQWlCLHlDQUF5Qyw4QkFBOEIsNEZBQTRGLG9CQUFvQixzQkFBc0IscUZBQXFGLGVBQWUsU0FBUyxHQUFHLEVBQUUsdUJBQXVCLGtCQUFrQix3REFBd0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHZ1ZS9iYWJlbC1oZWxwZXItdnVlLWpzeC1tZXJnZS1wcm9wcy9kaXN0L2hlbHBlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO2Z1bmN0aW9uIF9leHRlbmRzKCl7cmV0dXJuIF9leHRlbmRzPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGEpe2Zvcih2YXIgYixjPTE7Yzxhcmd1bWVudHMubGVuZ3RoO2MrKylmb3IodmFyIGQgaW4gYj1hcmd1bWVudHNbY10sYilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYixkKSYmKGFbZF09YltkXSk7cmV0dXJuIGF9LF9leHRlbmRzLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgbm9ybWFsTWVyZ2U9W1wiYXR0cnNcIixcInByb3BzXCIsXCJkb21Qcm9wc1wiXSx0b0FycmF5TWVyZ2U9W1wiY2xhc3NcIixcInN0eWxlXCIsXCJkaXJlY3RpdmVzXCJdLGZ1bmN0aW9uYWxNZXJnZT1bXCJvblwiLFwibmF0aXZlT25cIl0sbWVyZ2VKc3hQcm9wcz1mdW5jdGlvbihhKXtyZXR1cm4gYS5yZWR1Y2UoZnVuY3Rpb24oYyxhKXtmb3IodmFyIGIgaW4gYSlpZighY1tiXSljW2JdPWFbYl07ZWxzZSBpZigtMSE9PW5vcm1hbE1lcmdlLmluZGV4T2YoYikpY1tiXT1fZXh0ZW5kcyh7fSxjW2JdLGFbYl0pO2Vsc2UgaWYoLTEhPT10b0FycmF5TWVyZ2UuaW5kZXhPZihiKSl7dmFyIGQ9Y1tiXWluc3RhbmNlb2YgQXJyYXk/Y1tiXTpbY1tiXV0sZT1hW2JdaW5zdGFuY2VvZiBBcnJheT9hW2JdOlthW2JdXTtjW2JdPWQuY29uY2F0KGUpfWVsc2UgaWYoLTEhPT1mdW5jdGlvbmFsTWVyZ2UuaW5kZXhPZihiKSl7Zm9yKHZhciBmIGluIGFbYl0paWYoY1tiXVtmXSl7dmFyIGc9Y1tiXVtmXWluc3RhbmNlb2YgQXJyYXk/Y1tiXVtmXTpbY1tiXVtmXV0saD1hW2JdW2ZdaW5zdGFuY2VvZiBBcnJheT9hW2JdW2ZdOlthW2JdW2ZdXTtjW2JdW2ZdPWcuY29uY2F0KGgpfWVsc2UgY1tiXVtmXT1hW2JdW2ZdO31lbHNlIGlmKFwiaG9va1wiPT1iKWZvcih2YXIgaSBpbiBhW2JdKWNbYl1baV09Y1tiXVtpXT9tZXJnZUZuKGNbYl1baV0sYVtiXVtpXSk6YVtiXVtpXTtlbHNlIGNbYl09YVtiXTtyZXR1cm4gY30se30pfSxtZXJnZUZuPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGZ1bmN0aW9uKCl7YSYmYS5hcHBseSh0aGlzLGFyZ3VtZW50cyksYiYmYi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fTttb2R1bGUuZXhwb3J0cz1tZXJnZUpzeFByb3BzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@vue/babel-helper-vue-jsx-merge-props/dist/helper.js\n");

/***/ }),

/***/ "./node_modules/lodash.get/index.js":
/*!******************************************!*\
  !*** ./node_modules/lodash.get/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLmdldC9pbmRleC5qcz9jODMyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xC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QUFDZjtBQUNBO0FBQ0EsaUJBQWlCLFFBQVEsT0FBTyxTQUFTLEVBQUU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9sb2Rhc2guZ2V0L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgcmVMZWFkaW5nRG90ID0gL15cXC4vLFxuICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSG9zdE9iamVjdCh2YWx1ZSkge1xuICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9ICEhKHZhbHVlICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGlzS2V5KHBhdGgsIG9iamVjdCkgPyBbcGF0aF0gOiBjYXN0UGF0aChwYXRoKTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogc3RyaW5nVG9QYXRoKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplKGZ1bmN0aW9uKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBBc3NpZ24gY2FjaGUgdG8gYF8ubWVtb2l6ZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lodash.get/index.js\n");

/***/ })

}]);